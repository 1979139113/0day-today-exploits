# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
# auxiliary/scanner/smb/smb_ms_17_010
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Auxiliary
 
  include Msf::Exploit::Remote::SMB::Client
  include Msf::Exploit::Remote::SMB::Client::Authenticated
 
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;MS17-010 SMB RCE Detection&#039;,
      &#039;Description&#039;    => %q{
        Uses information disclosure to determine if MS17-010 has been patched or not.
        Specifically, it connects to the IPC$ tree and attempts a transaction on FID 0.
        If the status returned is "STATUS_INSUFF_SERVER_RESOURCES", the machine does
        not have the MS17-010 patch.
 
        This module does not require valid SMB credentials in default server
        configurations. It can log on as the user "\" and connect to IPC$.
      },
      &#039;Author&#039;         => [ &#039;Sean Dillon <sean.dillon@risksense.com>&#039; ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2017-0143&#039;],
          [ &#039;CVE&#039;, &#039;2017-0144&#039;],
          [ &#039;CVE&#039;, &#039;2017-0145&#039;],
          [ &#039;CVE&#039;, &#039;2017-0146&#039;],
          [ &#039;CVE&#039;, &#039;2017-0147&#039;],
          [ &#039;CVE&#039;, &#039;2017-0148&#039;],
          [ &#039;MSB&#039;, &#039;MS17-010&#039;],
          [ &#039;URL&#039;, &#039;https://technet.microsoft.com/en-us/library/security/ms17-010.aspx&#039;]
        ],
      &#039;License&#039;        => MSF_LICENSE
    ))
  end
 
  def run_host(ip)
    begin
      status = do_smb_probe(ip)
 
      if status == "STATUS_INSUFF_SERVER_RESOURCES"
        print_warning("Host is likely VULNERABLE to MS17-010!")
        report_vuln(
          host: ip,
          name: self.name,
          refs: self.references,
          info: &#039;STATUS_INSUFF_SERVER_RESOURCES for FID 0 against IPC$&#039;
        )
      elsif status == "STATUS_ACCESS_DENIED" or status == "STATUS_INVALID_HANDLE"
        # STATUS_ACCESS_DENIED (Windows 10) and STATUS_INVALID_HANDLE (others)
        print_good("Host does NOT appear vulnerable.")
      else
        print_bad("Unable to properly detect if host is vulnerable.")
      end
 
    rescue ::Interrupt
      print_status("Exiting on interrupt.")
      raise $!
    rescue ::Rex::Proto::SMB::Exceptions::LoginError
      print_error("An SMB Login Error occurred while connecting to the IPC$ tree.")
    rescue ::Exception => e
      vprint_error("#{e.class}: #{e.message}")
    ensure
      disconnect
    end
  end
 
  def do_smb_probe(ip)
    connect
 
    # logon as user \
    simple.login(datastore[&#039;SMBName&#039;], datastore[&#039;SMBUser&#039;], datastore[&#039;SMBPass&#039;], datastore[&#039;SMBDomain&#039;])
 
    # connect to IPC$
    ipc_share = "\\\\#{ip}\\IPC$"
    simple.connect(ipc_share)
    tree_id = simple.shares[ipc_share]
 
    print_status("Connected to #{ipc_share} with TID = #{tree_id}")
 
    # request transaction with fid = 0
    pkt = make_smb_trans_ms17_010(tree_id)
    sock.put(pkt)
    bytes = sock.get_once
 
    # convert packet to response struct
    pkt = Rex::Proto::SMB::Constants::SMB_TRANS_RES_HDR_PKT.make_struct
    pkt.from_s(bytes[4..-1])
 
    # convert error code to string
    code = pkt[&#039;SMB&#039;].v[&#039;ErrorClass&#039;]
    smberr = Rex::Proto::SMB::Exceptions::ErrorCode.new
    status = smberr.get_error(code)
 
    print_status("Received #{status} with FID = 0")
    status
  end
 
  def make_smb_trans_ms17_010(tree_id)
    # make a raw transaction packet
    pkt = Rex::Proto::SMB::Constants::SMB_TRANS_PKT.make_struct
    simple.client.smb_defaults(pkt[&#039;Payload&#039;][&#039;SMB&#039;])
 
    # opcode 0x23 = PeekNamedPipe, fid = 0
    setup = "\x23\x00\x00\x00"
    setup_count = 2             # 2 words
    trans = "\\PIPE\\\x00"
 
    # calculate offsets to the SetupData payload
    base_offset = pkt.to_s.length + (setup.length) - 4
    param_offset = base_offset + trans.length
    data_offset = param_offset # + 0
 
    # packet baselines
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = Rex::Proto::SMB::Constants::SMB_COM_TRANSACTION
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x18
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0x2801 # 0xc803 would unicode
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;TreeID&#039;] = tree_id
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 14 + setup_count
    pkt[&#039;Payload&#039;].v[&#039;ParamCountMax&#039;] = 0xffff
    pkt[&#039;Payload&#039;].v[&#039;DataCountMax&#039;] = 0xffff
    pkt[&#039;Payload&#039;].v[&#039;ParamOffset&#039;] = param_offset
    pkt[&#039;Payload&#039;].v[&#039;DataOffset&#039;] = data_offset
 
    # actual magic: PeekNamedPipe FID=0, \PIPE\
    pkt[&#039;Payload&#039;].v[&#039;SetupCount&#039;] = setup_count
    pkt[&#039;Payload&#039;].v[&#039;SetupData&#039;] = setup
    pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] = trans
 
    pkt.to_s
  end
end

