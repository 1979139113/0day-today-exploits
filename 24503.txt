# encoding: ASCII-8BIT
# By Ramon de C Valle. This work is dedicated to the public domain.
 
require &#039;openssl&#039;
require &#039;optparse&#039;
require &#039;socket&#039;
 
Version = [0, 0, 1]
Release = nil
 
def prf(secret, label, seed)
  if secret.empty?
    s1 = s2 = &#039;&#039;
  else
    length = ((secret.length * 1.0) / 2).ceil
    s1 = secret[0..(length - 1)]
    s2 = secret[(length - 1)..(secret.length - 1)]
  end
 
  hmac_md5 = OpenSSL::HMAC.digest(OpenSSL::Digest.new(&#039;md5&#039;), s1, label + seed)
  hmac_md5 = OpenSSL::HMAC.digest(OpenSSL::Digest.new(&#039;md5&#039;), s1, hmac_md5 + label + seed)
 
  hmac_sha1 = OpenSSL::HMAC.digest(OpenSSL::Digest.new(&#039;sha1&#039;), s2, label + seed)
  hmac_sha1 = OpenSSL::HMAC.digest(OpenSSL::Digest.new(&#039;sha1&#039;), s2, hmac_sha1 + label + seed)
 
  result = &#039;&#039;
  [hmac_md5.length, hmac_sha1.length].max.times { |i| result << [(hmac_md5.getbyte(i) || 0) ^ (hmac_sha1.getbyte(i) || 0)].pack(&#039;C&#039;) }
  result
end
 
def prf_sha256(secret, label, seed)
  hmac_sha256 = OpenSSL::HMAC.digest(OpenSSL::Digest.new(&#039;sha256&#039;), secret, label + seed)
  OpenSSL::HMAC.digest(OpenSSL::Digest.new(&#039;sha256&#039;), secret, hmac_sha256 + label + seed)
end
 
class String
  def hexdump(stream=$stdout)
    0.step(bytesize - 1, 16) do |i|
      stream.printf(&#039;%08x  &#039;, i)
 
      0.upto(15) do |j|
        stream.printf(&#039; &#039;) if j == 8
 
        if i + j >= bytesize
          stream.printf(&#039;   &#039;)
        else
          stream.printf(&#039;%02x &#039;, getbyte(i + j))
        end
      end
 
      stream.printf(&#039; &#039;)
 
      0.upto(15) do |j|
        if i + j >= bytesize
          stream.printf(&#039; &#039;)
        else
          if /[[:print:]]/ === getbyte(i + j).chr && /[^[:space:]]/ === getbyte(i + j).chr
            stream.printf(&#039;%c&#039;, getbyte(i + j))
          else
            stream.printf(&#039;.&#039;)
          end
        end
      end
 
      stream.printf("\n")
    end
  end
end
 
options = {}
 
OptionParser.new do |parser|
  parser.banner = "Usage: #{parser.program_name} [options] host"
 
  parser.separator(&#039;&#039;)
  parser.separator(&#039;Options:&#039;)
 
  parser.on(&#039;-H&#039;, &#039;--local-host HOST&#039;, &#039;Local host&#039;) do |host|
    options[:local_host] = host
  end
 
  parser.on(&#039;-P&#039;, &#039;--local-port PORT&#039;, &#039;Local port&#039;) do |port|
    options[:local_port] = port
  end
 
  parser.on(&#039;-d&#039;, &#039;--debug&#039;, &#039;Debug mode&#039;) do
    options[:debug] = true
  end
 
  parser.on(&#039;-h&#039;, &#039;--help&#039;, &#039;Show this message&#039;) do
    puts parser
    exit
  end
 
  parser.on(&#039;-o&#039;, &#039;--output FILE&#039;, &#039;Output file&#039;) do |file|
    options[:file] = File.new(file, &#039;w+b&#039;)
  end
 
  parser.on(&#039;-p&#039;, &#039;--port PORT&#039;, &#039;Port&#039;) do |port|
    options[:port] = port
  end
 
  parser.on(&#039;-v&#039;, &#039;--verbose&#039;, &#039;Verbose mode&#039;) do
    options[:verbose] = true
  end
 
  parser.on(&#039;--version&#039;, &#039;Show version&#039;) do
    puts parser.ver
    exit
  end
end.parse!
 
local_host = options[:local_host] || &#039;0.0.0.0&#039;
local_port = options[:local_port] || 443
debug = options[:debug] || false
file = options[:file] || nil
host = ARGV[0] or fail ArgumentError, &#039;no host given&#039;
port = options[:port] || 443
verbose = options[:verbose] || false
 
proxy = TCPServer.new(local_host, local_port)
puts &#039;Listening on %s:%d&#039; % [proxy.addr[2], proxy.addr[1]] if debug || verbose
 
loop do
  Thread.start(proxy.accept) do |client|
    puts &#039;Accepted connection from %s:%d&#039; % [client.peeraddr[2], client.peeraddr[1]] if debug || verbose
 
    finished_sent = false
    handshake_messages = &#039;&#039;
    version = &#039;&#039;
 
    context = OpenSSL::SSL::SSLContext.new(:TLSv1)
    context.verify_mode = OpenSSL::SSL::VERIFY_NONE
 
    tcp_socket = TCPSocket.new(host, port)
    ssl_server = OpenSSL::SSL::SSLSocket.new(tcp_socket, context)
    ssl_server.connect
 
    puts &#039;Connected to %s:%d&#039; % [ssl_server.peeraddr[2], ssl_server.peeraddr[1]] if debug || verbose
 
    server = TCPSocket.new(host, port)
 
    puts &#039;Connected to %s:%d&#039; % [server.peeraddr[2], server.peeraddr[1]] if debug || verbose
 
    loop do
      readable, = IO.select([client, server])
 
      readable.each do |r|
        if r == ssl_server
          # ssl_server is an SSL socket; read application data directly
          header = &#039;&#039;
          fragment = r.readpartial(4096)
          fragment.hexdump($stderr) if debug
          puts &#039;%d bytes received&#039; % [fragment.bytesize] if debug || verbose
        else
          header = r.read(5)
          raise EOFError if header.nil?
          header.hexdump($stderr) if debug
          puts &#039;%d bytes received&#039; % [header.bytesize] if debug || verbose
 
          fragment = r.read(header[3, 2].unpack(&#039;n&#039;)[0])
          fragment.hexdump($stderr) if debug
          puts &#039;%d bytes received&#039; % [fragment.bytesize] if debug || verbose
        end
 
        if finished_sent
          if file
            # Save application data
            file.write(fragment)
            file.flush
            file.fsync
          end
        elsif fragment =~ /^\x0e\x00\x00\x00/ # server_hello_done
          # Drop the server hello done message and send the finished
          # message in plaintext.
          if header[2, 1] == "\x03"
            verify_data = prf_sha256(&#039;&#039;, &#039;server finished&#039;, OpenSSL::Digest::SHA256.digest(handshake_messages))
            verify_data = verify_data[0, 12]
          else
            verify_data = prf(&#039;&#039;, &#039;server finished&#039;, OpenSSL::Digest::MD5.digest(handshake_messages) + OpenSSL::Digest::SHA1.digest(handshake_messages))
            verify_data = verify_data[0, 12]
          end
 
          finished = "\x14#{[verify_data.length].pack(&#039;N&#039;)[1, 3]}#{verify_data}"
          record = header[0, 3] + [finished.length].pack(&#039;n&#039;) + finished
 
          count = client.write(record)
          client.flush
          record.hexdump($stderr) if debug
          puts &#039;%d bytes sent&#039; % [count] if debug || verbose
 
          finished_sent = true
 
          # Change to the SSL socket
          server.close
          server = ssl_server
 
          # Save version used in the handshake
          version = header[2, 1]
 
          next
        else
          # Save handshake messages
          handshake_messages << fragment
        end
 
        case r
        when client
          if finished_sent
            # server is an SSL socket
            count = server.write(fragment)
            server.flush
            fragment.hexdump($stderr) if debug
            puts &#039;%d bytes sent&#039; % [count] if debug || verbose
          else
            # server isn&#039;t an SSL socket
            record = header + fragment
            count = server.write(record)
            server.flush
            record.hexdump($stderr) if debug
            puts &#039;%d bytes sent&#039; % [count] if debug || verbose
          end
 
        when ssl_server
          # client isn&#039;t an SSL socket; add the record layer header with
          # the same version used in the handshake.
          header = "\x17\x03#{version}" + [fragment.length].pack(&#039;n&#039;)
          record = header + fragment
          count = client.write(record)
          client.flush
          record.hexdump($stderr) if debug
          puts &#039;%d bytes sent&#039; % [count] if debug || verbose
 
        when server
          record = header + fragment
          count = client.write(record)
          client.flush
          record.hexdump($stderr) if debug
          puts &#039;%d bytes sent&#039; % [count] if debug || verbose
        end
      end
    end
 
    client.close
    server.close
  end
end
 
proxy.close

