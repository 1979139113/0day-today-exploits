

neverallow system_server self:process execmem;
neverallow system_server ashmem_device:chr_file execute;
neverallow system_server system_server_tmpfs:file execute;

However, as system_server is extremely privileged, there are a few vectors through which it may still load arbitrary code, thus bypassing the mitigation mentioned above.

1. The system user has read-write access to /data/app/*/oat/*. However, this directory and all files created within it have the SELinux context:

u:object_r:dalvikcache_data_file:s0

(see http://androidxref.com/7.0.0_r1/xref/system/sepolicy/file_contexts#252)

Since system_server is required to execute dalvik-cache files, its SELinux policy explicitly allows this by adding the rule:

allow system_server dalvikcache_data_file:file execute;

This means that system_server may create a file under the aforementioned path and mmap it with PROT_EXEC in order to load arbitrary code.

2. Much in the same way, system_server has read-write access to /data/app, including /data/app/vmdl*.tmp/*/oat/*. However, this directory and all files created within it have the SELinux context:

u:object_r:dalvikcache_data_file:s0

(see http://androidxref.com/7.0.0_r1/xref/system/sepolicy/file_contexts#254)

This allows the attacker to follow the same steps as in (1.) in order to map in arbitrary code.


Note that removing RW access to the oat directories is not always sufficient to fix this issue. For example, an attacker can also choose to store his code within the his application (i.e., in a large byte[] within the source code). This in turn will be compiled into the ODEX file under the "oat" directory, and can then be used to map in arbitrary code once more into system_server.

This bug is subject to a 90 day disclosure deadline. If 90 days elapse without a broadly available patch, then the bug report will automatically become visible to the public.



Found by: laginimaineb

